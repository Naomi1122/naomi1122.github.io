import {
  dist_exports,
  init_dist,
  init_register_all_chained_ops,
  register_all_chained_ops_exports
} from "./chunk-MK6PJKKX.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/.pnpm/fast-json-patch@3.1.1/node_modules/fast-json-patch/module/helpers.mjs
function hasOwnProperty(obj, key3) {
  return _hasOwnProperty.call(obj, key3);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys_1 = new Array(obj.length);
    for (var k4 = 0; k4 < keys_1.length; k4++) {
      keys_1[k4] = "" + k4;
    }
    return keys_1;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys5 = [];
  for (var i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys5.push(i);
    }
  }
  return keys5;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str) {
  var i = 0;
  var len = str.length;
  var charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path5) {
  if (path5.indexOf("/") === -1 && path5.indexOf("~") === -1)
    return path5;
  return path5.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path5) {
  return path5.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
        if (hasUndefined(obj[i_1])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key3 in args) {
    var value4 = typeof args[key3] === "object" ? JSON.stringify(args[key3], null, 2) : args[key3];
    if (typeof value4 !== "undefined") {
      messageParts.push(key3 + ": " + value4);
    }
  }
  return messageParts.join("\n");
}
var __extends, _hasOwnProperty, PatchError;
var init_helpers = __esm({
  "node_modules/.pnpm/fast-json-patch@3.1.1/node_modules/fast-json-patch/module/helpers.mjs"() {
    __extends = function() {
      var extendStatics = function(d, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
          d2.__proto__ = b4;
        } || function(d2, b4) {
          for (var p in b4)
            if (b4.hasOwnProperty(p))
              d2[p] = b4[p];
        };
        return extendStatics(d, b3);
      };
      return function(d, b3) {
        extendStatics(d, b3);
        function __() {
          this.constructor = d;
        }
        d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    _hasOwnProperty = Object.prototype.hasOwnProperty;
    PatchError = function(_super) {
      __extends(PatchError2, _super);
      function PatchError2(message, name4, index8, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name4, index: index8, operation, tree })) || this;
        _this.name = name4;
        _this.index = index8;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        _this.message = patchErrorMessageFormatter(message, { name: name4, index: index8, operation, tree });
        return _this;
      }
      return PatchError2;
    }(Error);
  }
});

// node_modules/.pnpm/fast-json-patch@3.1.1/node_modules/fast-json-patch/module/core.mjs
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate,
  validator: () => validator
});
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index8) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index8 === void 0) {
    index8 = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index8, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index8, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    var path5 = operation.path || "";
    var keys5 = path5.split("/");
    var obj = document2;
    var t = 1;
    var len = keys5.length;
    var existingPathFragment = void 0;
    var key3 = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key3 = keys5[t];
      if (key3 && key3.indexOf("~") != -1) {
        key3 = unescapePathComponent(key3);
      }
      if (banPrototypeModifications && (key3 == "__proto__" || key3 == "prototype" && t > 0 && keys5[t - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key3] === void 0) {
            existingPathFragment = keys5.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key3 === "-") {
          key3 = obj.length;
        } else {
          if (validateOperation && !isInteger(key3)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index8, operation, document2);
          } else if (isInteger(key3)) {
            key3 = ~~key3;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key3 > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index8, operation, document2);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key3, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index8, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (t >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key3, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index8, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key3];
      if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index8, operation, document2);
      }
    }
  }
}
function applyPatch(document2, patch2, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch2)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  var results = new Array(patch2.length);
  for (var i = 0, length_1 = patch2.length; i < length_1; i++) {
    results[i] = applyOperation(document2, patch2[i], validateOperation, true, banPrototypeModifications, i);
    document2 = results[i].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index8) {
  var operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index8, operation, document2);
  }
  return operationResult.newDocument;
}
function validator(operation, index8, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index8, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index8, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index8, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index8, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index8, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index8, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index8, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index8, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index8, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = { op: "_get", path: operation.from, value: void 0 };
      var error3 = validate([existingValue], document2);
      if (error3 && error3.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index8, operation, document2);
      }
    }
  }
}
function validate(sequence3, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence3)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence3), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence3.length; i++) {
        externalValidator(sequence3[i], i, document2, void 0);
      }
    }
  } catch (e3) {
    if (e3 instanceof JsonPatchError) {
      return e3;
    } else {
      throw e3;
    }
  }
}
function _areEquals(a4, b3) {
  if (a4 === b3)
    return true;
  if (a4 && b3 && typeof a4 == "object" && typeof b3 == "object") {
    var arrA = Array.isArray(a4), arrB = Array.isArray(b3), i, length4, key3;
    if (arrA && arrB) {
      length4 = a4.length;
      if (length4 != b3.length)
        return false;
      for (i = length4; i-- !== 0; )
        if (!_areEquals(a4[i], b3[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys5 = Object.keys(a4);
    length4 = keys5.length;
    if (length4 !== Object.keys(b3).length)
      return false;
    for (i = length4; i-- !== 0; )
      if (!b3.hasOwnProperty(keys5[i]))
        return false;
    for (i = length4; i-- !== 0; ) {
      key3 = keys5[i];
      if (!_areEquals(a4[key3], b3[key3]))
        return false;
    }
    return true;
  }
  return a4 !== a4 && b3 !== b3;
}
var JsonPatchError, deepClone, objOps, arrOps;
var init_core = __esm({
  "node_modules/.pnpm/fast-json-patch@3.1.1/node_modules/fast-json-patch/module/core.mjs"() {
    init_helpers();
    JsonPatchError = PatchError;
    deepClone = _deepClone;
    objOps = {
      add: function(obj, key3, document2) {
        obj[key3] = this.value;
        return { newDocument: document2 };
      },
      remove: function(obj, key3, document2) {
        var removed = obj[key3];
        delete obj[key3];
        return { newDocument: document2, removed };
      },
      replace: function(obj, key3, document2) {
        var removed = obj[key3];
        obj[key3] = this.value;
        return { newDocument: document2, removed };
      },
      move: function(obj, key3, document2) {
        var removed = getValueByPointer(document2, this.path);
        if (removed) {
          removed = _deepClone(removed);
        }
        var originalValue = applyOperation(document2, { op: "remove", path: this.from }).removed;
        applyOperation(document2, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document2, removed };
      },
      copy: function(obj, key3, document2) {
        var valueToCopy = getValueByPointer(document2, this.from);
        applyOperation(document2, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
        return { newDocument: document2 };
      },
      test: function(obj, key3, document2) {
        return { newDocument: document2, test: _areEquals(obj[key3], this.value) };
      },
      _get: function(obj, key3, document2) {
        this.value = obj[key3];
        return { newDocument: document2 };
      }
    };
    arrOps = {
      add: function(arr, i, document2) {
        if (isInteger(i)) {
          arr.splice(i, 0, this.value);
        } else {
          arr[i] = this.value;
        }
        return { newDocument: document2, index: i };
      },
      remove: function(arr, i, document2) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document2, removed: removedList[0] };
      },
      replace: function(arr, i, document2) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document2, removed };
      },
      move: objOps.move,
      copy: objOps.copy,
      test: objOps.test,
      _get: objOps._get
    };
  }
});

// node_modules/.pnpm/fast-json-patch@3.1.1/node_modules/fast-json-patch/module/duplex.mjs
var duplex_exports = {};
__export(duplex_exports, {
  compare: () => compare,
  generate: () => generate,
  observe: () => observe,
  unobserve: () => unobserve
});
function getMirror(obj) {
  return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
function unobserve(root2, observer) {
  observer.unobserve();
}
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = function() {
      generate(observer);
    };
    var fastCheck = function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    };
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
function generate(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp3 = observer.patches;
  if (temp3.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp3);
    }
  }
  return temp3;
}
function _generate(mirror, obj, patches, path5, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var changed = false;
  var deleted = false;
  for (var t = oldKeys.length - 1; t >= 0; t--) {
    var key3 = oldKeys[t];
    var oldVal = mirror[key3];
    if (hasOwnProperty(obj, key3) && !(obj[key3] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key3];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path5 + "/" + escapePathComponent(key3), invertible);
      } else {
        if (oldVal !== newVal) {
          changed = true;
          if (invertible) {
            patches.push({ op: "test", path: path5 + "/" + escapePathComponent(key3), value: _deepClone(oldVal) });
          }
          patches.push({ op: "replace", path: path5 + "/" + escapePathComponent(key3), value: _deepClone(newVal) });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({ op: "test", path: path5 + "/" + escapePathComponent(key3), value: _deepClone(oldVal) });
      }
      patches.push({ op: "remove", path: path5 + "/" + escapePathComponent(key3) });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path: path5, value: mirror });
      }
      patches.push({ op: "replace", path: path5, value: obj });
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t = 0; t < newKeys.length; t++) {
    var key3 = newKeys[t];
    if (!hasOwnProperty(mirror, key3) && obj[key3] !== void 0) {
      patches.push({ op: "add", path: path5 + "/" + escapePathComponent(key3), value: _deepClone(obj[key3]) });
    }
  }
}
function compare(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}
var beforeDict, Mirror, ObserverInfo;
var init_duplex = __esm({
  "node_modules/.pnpm/fast-json-patch@3.1.1/node_modules/fast-json-patch/module/duplex.mjs"() {
    init_helpers();
    init_core();
    beforeDict = /* @__PURE__ */ new WeakMap();
    Mirror = function() {
      function Mirror2(obj) {
        this.observers = /* @__PURE__ */ new Map();
        this.obj = obj;
      }
      return Mirror2;
    }();
    ObserverInfo = function() {
      function ObserverInfo2(callback, observer) {
        this.callback = callback;
        this.observer = observer;
      }
      return ObserverInfo2;
    }();
  }
});

// node_modules/.pnpm/fast-json-patch@3.1.1/node_modules/fast-json-patch/index.mjs
var fast_json_patch_default;
var init_fast_json_patch = __esm({
  "node_modules/.pnpm/fast-json-patch@3.1.1/node_modules/fast-json-patch/index.mjs"() {
    init_core();
    init_duplex();
    init_helpers();
    init_core();
    init_duplex();
    init_helpers();
    fast_json_patch_default = Object.assign({}, core_exports, duplex_exports, {
      JsonPatchError: PatchError,
      deepClone: _deepClone,
      escapePathComponent,
      unescapePathComponent
    });
  }
});

// node_modules/.pnpm/json-stringify-pretty-compact@3.0.0/node_modules/json-stringify-pretty-compact/index.js
var require_json_stringify_pretty_compact = __commonJS({
  "node_modules/.pnpm/json-stringify-pretty-compact@3.0.0/node_modules/json-stringify-pretty-compact/index.js"(exports, module4) {
    "use strict";
    var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;
    module4.exports = function stringify5(passedObj, options2) {
      var indent, maxLength, replacer2;
      options2 = options2 || {};
      indent = JSON.stringify(
        [1],
        void 0,
        options2.indent === void 0 ? 2 : options2.indent
      ).slice(2, -3);
      maxLength = indent === "" ? Infinity : options2.maxLength === void 0 ? 80 : options2.maxLength;
      replacer2 = options2.replacer;
      return function _stringify(obj, currentIndent, reserved) {
        var end, index8, items2, key3, keyPart, keys5, length4, nextIndent, prettified, start, string, value4;
        if (obj && typeof obj.toJSON === "function") {
          obj = obj.toJSON();
        }
        string = JSON.stringify(obj, replacer2);
        if (string === void 0) {
          return string;
        }
        length4 = maxLength - currentIndent.length - reserved;
        if (string.length <= length4) {
          prettified = string.replace(
            stringOrChar,
            function(match4, stringLiteral) {
              return stringLiteral || match4 + " ";
            }
          );
          if (prettified.length <= length4) {
            return prettified;
          }
        }
        if (replacer2 != null) {
          obj = JSON.parse(string);
          replacer2 = void 0;
        }
        if (typeof obj === "object" && obj !== null) {
          nextIndent = currentIndent + indent;
          items2 = [];
          index8 = 0;
          if (Array.isArray(obj)) {
            start = "[";
            end = "]";
            length4 = obj.length;
            for (; index8 < length4; index8++) {
              items2.push(
                _stringify(obj[index8], nextIndent, index8 === length4 - 1 ? 0 : 1) || "null"
              );
            }
          } else {
            start = "{";
            end = "}";
            keys5 = Object.keys(obj);
            length4 = keys5.length;
            for (; index8 < length4; index8++) {
              key3 = keys5[index8];
              keyPart = JSON.stringify(key3) + ": ";
              value4 = _stringify(
                obj[key3],
                nextIndent,
                keyPart.length + (index8 === length4 - 1 ? 0 : 1)
              );
              if (value4 !== void 0) {
                items2.push(keyPart + value4);
              }
            }
          }
          if (items2.length > 0) {
            return [start, indent + items2.join(",\n" + nextIndent), end].join(
              "\n" + currentIndent
            );
          }
        }
        return string;
      }(passedObj, "", 0);
    };
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/constants.js"(exports, module4) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module4.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/debug.js"(exports, module4) {
    var debug3 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module4.exports = debug3;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/re.js"(exports, module4) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug3 = require_debug();
    exports = module4.exports = {};
    var re4 = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value4) => {
      for (const [token, max8] of safeRegexReplacements) {
        value4 = value4.split(`${token}*`).join(`${token}{0,${max8}}`).split(`${token}+`).join(`${token}{1,${max8}}`);
      }
      return value4;
    };
    var createToken = (name4, value4, isGlobal) => {
      const safe = makeSafeRegex(value4);
      const index8 = R++;
      debug3(name4, index8, value4);
      t[name4] = index8;
      src[index8] = value4;
      re4[index8] = new RegExp(value4, isGlobal ? "g" : void 0);
      safeRe[index8] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/parse-options.js"(exports, module4) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options2) => {
      if (!options2) {
        return emptyOpts;
      }
      if (typeof options2 !== "object") {
        return looseOption;
      }
      return options2;
    };
    module4.exports = parseOptions;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/internal/identifiers.js"(exports, module4) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a4, b3) => {
      const anum = numeric.test(a4);
      const bnum = numeric.test(b3);
      if (anum && bnum) {
        a4 = +a4;
        b3 = +b3;
      }
      return a4 === b3 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a4 < b3 ? -1 : 1;
    };
    var rcompareIdentifiers = (a4, b3) => compareIdentifiers(b3, a4);
    module4.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/semver.js"(exports, module4) {
    var debug3 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re4, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version5, options2) {
        options2 = parseOptions(options2);
        if (version5 instanceof SemVer) {
          if (version5.loose === !!options2.loose && version5.includePrerelease === !!options2.includePrerelease) {
            return version5;
          } else {
            version5 = version5.version;
          }
        } else if (typeof version5 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version5}".`);
        }
        if (version5.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug3("SemVer", version5, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        const m2 = version5.trim().match(options2.loose ? re4[t.LOOSE] : re4[t.FULL]);
        if (!m2) {
          throw new TypeError(`Invalid Version: ${version5}`);
        }
        this.raw = version5;
        this.major = +m2[1];
        this.minor = +m2[2];
        this.patch = +m2[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m2[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m2[4].split(".").map((id4) => {
            if (/^[0-9]+$/.test(id4)) {
              const num = +id4;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id4;
          });
        }
        this.build = m2[5] ? m2[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug3("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a4 = this.prerelease[i];
          const b3 = other.prerelease[i];
          debug3("prerelease compare", i, a4, b3);
          if (a4 === void 0 && b3 === void 0) {
            return 0;
          } else if (b3 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b3) {
            continue;
          } else {
            return compareIdentifiers(a4, b3);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a4 = this.build[i];
          const b3 = other.build[i];
          debug3("prerelease compare", i, a4, b3);
          if (a4 === void 0 && b3 === void 0) {
            return 0;
          } else if (b3 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b3) {
            continue;
          } else {
            return compareIdentifiers(a4, b3);
          }
        } while (++i);
      }
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base3 = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base3];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base3);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base3];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module4.exports = SemVer;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/parse.js"(exports, module4) {
    var SemVer = require_semver();
    var parse8 = (version5, options2, throwErrors = false) => {
      if (version5 instanceof SemVer) {
        return version5;
      }
      try {
        return new SemVer(version5, options2);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module4.exports = parse8;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/valid.js"(exports, module4) {
    var parse8 = require_parse();
    var valid = (version5, options2) => {
      const v = parse8(version5, options2);
      return v ? v.version : null;
    };
    module4.exports = valid;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/clean.js"(exports, module4) {
    var parse8 = require_parse();
    var clean = (version5, options2) => {
      const s3 = parse8(version5.trim().replace(/^[=v]+/, ""), options2);
      return s3 ? s3.version : null;
    };
    module4.exports = clean;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/inc.js"(exports, module4) {
    var SemVer = require_semver();
    var inc = (version5, release, options2, identifier, identifierBase) => {
      if (typeof options2 === "string") {
        identifierBase = identifier;
        identifier = options2;
        options2 = void 0;
      }
      try {
        return new SemVer(
          version5 instanceof SemVer ? version5.version : version5,
          options2
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module4.exports = inc;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/diff.js"(exports, module4) {
    var parse8 = require_parse();
    var diff2 = (version1, version22) => {
      const v1 = parse8(version1, null, true);
      const v2 = parse8(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module4.exports = diff2;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/major.js"(exports, module4) {
    var SemVer = require_semver();
    var major = (a4, loose) => new SemVer(a4, loose).major;
    module4.exports = major;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/minor.js"(exports, module4) {
    var SemVer = require_semver();
    var minor = (a4, loose) => new SemVer(a4, loose).minor;
    module4.exports = minor;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/patch.js"(exports, module4) {
    var SemVer = require_semver();
    var patch2 = (a4, loose) => new SemVer(a4, loose).patch;
    module4.exports = patch2;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/prerelease.js"(exports, module4) {
    var parse8 = require_parse();
    var prerelease = (version5, options2) => {
      const parsed = parse8(version5, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module4.exports = prerelease;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare.js"(exports, module4) {
    var SemVer = require_semver();
    var compare6 = (a4, b3, loose) => new SemVer(a4, loose).compare(new SemVer(b3, loose));
    module4.exports = compare6;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/rcompare.js"(exports, module4) {
    var compare6 = require_compare();
    var rcompare = (a4, b3, loose) => compare6(b3, a4, loose);
    module4.exports = rcompare;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-loose.js"(exports, module4) {
    var compare6 = require_compare();
    var compareLoose = (a4, b3) => compare6(a4, b3, true);
    module4.exports = compareLoose;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/compare-build.js"(exports, module4) {
    var SemVer = require_semver();
    var compareBuild = (a4, b3, loose) => {
      const versionA = new SemVer(a4, loose);
      const versionB = new SemVer(b3, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module4.exports = compareBuild;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/sort.js"(exports, module4) {
    var compareBuild = require_compare_build();
    var sort5 = (list, loose) => list.sort((a4, b3) => compareBuild(a4, b3, loose));
    module4.exports = sort5;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/rsort.js"(exports, module4) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a4, b3) => compareBuild(b3, a4, loose));
    module4.exports = rsort;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gt.js"(exports, module4) {
    var compare6 = require_compare();
    var gt = (a4, b3, loose) => compare6(a4, b3, loose) > 0;
    module4.exports = gt;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lt.js"(exports, module4) {
    var compare6 = require_compare();
    var lt = (a4, b3, loose) => compare6(a4, b3, loose) < 0;
    module4.exports = lt;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/eq.js"(exports, module4) {
    var compare6 = require_compare();
    var eq = (a4, b3, loose) => compare6(a4, b3, loose) === 0;
    module4.exports = eq;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/neq.js"(exports, module4) {
    var compare6 = require_compare();
    var neq = (a4, b3, loose) => compare6(a4, b3, loose) !== 0;
    module4.exports = neq;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/gte.js"(exports, module4) {
    var compare6 = require_compare();
    var gte = (a4, b3, loose) => compare6(a4, b3, loose) >= 0;
    module4.exports = gte;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/lte.js"(exports, module4) {
    var compare6 = require_compare();
    var lte = (a4, b3, loose) => compare6(a4, b3, loose) <= 0;
    module4.exports = lte;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/cmp.js"(exports, module4) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a4, op, b3, loose) => {
      switch (op) {
        case "===":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b3 === "object") {
            b3 = b3.version;
          }
          return a4 === b3;
        case "!==":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b3 === "object") {
            b3 = b3.version;
          }
          return a4 !== b3;
        case "":
        case "=":
        case "==":
          return eq(a4, b3, loose);
        case "!=":
          return neq(a4, b3, loose);
        case ">":
          return gt(a4, b3, loose);
        case ">=":
          return gte(a4, b3, loose);
        case "<":
          return lt(a4, b3, loose);
        case "<=":
          return lte(a4, b3, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module4.exports = cmp;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/coerce.js"(exports, module4) {
    var SemVer = require_semver();
    var parse8 = require_parse();
    var { safeRe: re4, t } = require_re();
    var coerce = (version5, options2) => {
      if (version5 instanceof SemVer) {
        return version5;
      }
      if (typeof version5 === "number") {
        version5 = String(version5);
      }
      if (typeof version5 !== "string") {
        return null;
      }
      options2 = options2 || {};
      let match4 = null;
      if (!options2.rtl) {
        match4 = version5.match(re4[t.COERCE]);
      } else {
        let next;
        while ((next = re4[t.COERCERTL].exec(version5)) && (!match4 || match4.index + match4[0].length !== version5.length)) {
          if (!match4 || next.index + next[0].length !== match4.index + match4[0].length) {
            match4 = next;
          }
          re4[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re4[t.COERCERTL].lastIndex = -1;
      }
      if (match4 === null) {
        return null;
      }
      return parse8(`${match4[2]}.${match4[3] || "0"}.${match4[4] || "0"}`, options2);
    };
    module4.exports = coerce;
  }
});

// node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js"(exports, module4) {
    "use strict";
    module4.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"(exports, module4) {
    "use strict";
    module4.exports = Yallist;
    Yallist.Node = Node3;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (!(self instanceof Yallist)) {
        self = new Yallist();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert2(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert2(self, node, value4) {
      var inserted = node === self.head ? new Node3(value4, null, node, self) : new Node3(value4, node, node.next, self);
      if (inserted.next === null) {
        self.tail = inserted;
      }
      if (inserted.prev === null) {
        self.head = inserted;
      }
      self.length++;
      return inserted;
    }
    function push(self, item) {
      self.tail = new Node3(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node3(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node3(value4, prev, next, list) {
      if (!(this instanceof Node3)) {
        return new Node3(value4, prev, next, list);
      }
      this.list = list;
      this.value = value4;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"(exports, module4) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE2 = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options2) {
        if (typeof options2 === "number")
          options2 = { max: options2 };
        if (!options2)
          options2 = {};
        if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max8 = this[MAX] = options2.max || Infinity;
        const lc = options2.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options2.stale || false;
        if (options2.maxAge && typeof options2.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options2.maxAge || 0;
        this[DISPOSE] = options2.dispose;
        this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit3) => {
            hit3.length = this[LENGTH_CALCULATOR](hit3.value, hit3.key);
            this[LENGTH] += hit3.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k4) => k4.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k4) => k4.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit3) => this[DISPOSE](hit3.key, hit3.value));
        }
        this[CACHE2] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit3) => isStale(this, hit3) ? false : {
          k: hit3.key,
          v: hit3.value,
          e: hit3.now + (hit3.maxAge || 0)
        }).toArray().filter((h4) => h4);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key3, value4, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now2 = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value4, key3);
        if (this[CACHE2].has(key3)) {
          if (len > this[MAX]) {
            del(this, this[CACHE2].get(key3));
            return false;
          }
          const node = this[CACHE2].get(key3);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key3, item.value);
          }
          item.now = now2;
          item.maxAge = maxAge;
          item.value = value4;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key3);
          trim(this);
          return true;
        }
        const hit3 = new Entry2(key3, value4, len, now2, maxAge);
        if (hit3.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key3, value4);
          return false;
        }
        this[LENGTH] += hit3.length;
        this[LRU_LIST].unshift(hit3);
        this[CACHE2].set(key3, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key3) {
        if (!this[CACHE2].has(key3))
          return false;
        const hit3 = this[CACHE2].get(key3).value;
        return !isStale(this, hit3);
      }
      get(key3) {
        return get8(this, key3, true);
      }
      peek(key3) {
        return get8(this, key3, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key3) {
        del(this, this[CACHE2].get(key3));
      }
      load(arr) {
        this.reset();
        const now2 = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit3 = arr[l];
          const expiresAt = hit3.e || 0;
          if (expiresAt === 0)
            this.set(hit3.k, hit3.v);
          else {
            const maxAge = expiresAt - now2;
            if (maxAge > 0) {
              this.set(hit3.k, hit3.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE2].forEach((value4, key3) => get8(this, key3, false));
      }
    };
    var get8 = (self, key3, doUse) => {
      const node = self[CACHE2].get(key3);
      if (node) {
        const hit3 = node.value;
        if (isStale(self, hit3)) {
          del(self, node);
          if (!self[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self[LRU_LIST].unshiftNode(node);
          }
        }
        return hit3.value;
      }
    };
    var isStale = (self, hit3) => {
      if (!hit3 || !hit3.maxAge && !self[MAX_AGE])
        return false;
      const diff2 = Date.now() - hit3.now;
      return hit3.maxAge ? diff2 > hit3.maxAge : self[MAX_AGE] && diff2 > self[MAX_AGE];
    };
    var trim = (self) => {
      if (self[LENGTH] > self[MAX]) {
        for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self, walker);
          walker = prev;
        }
      }
    };
    var del = (self, node) => {
      if (node) {
        const hit3 = node.value;
        if (self[DISPOSE])
          self[DISPOSE](hit3.key, hit3.value);
        self[LENGTH] -= hit3.length;
        self[CACHE2].delete(hit3.key);
        self[LRU_LIST].removeNode(node);
      }
    };
    var Entry2 = class {
      constructor(key3, value4, length4, now2, maxAge) {
        this.key = key3;
        this.value = value4;
        this.length = length4;
        this.now = now2;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self, fn, node, thisp) => {
      let hit3 = node.value;
      if (isStale(self, hit3)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          hit3 = void 0;
      }
      if (hit3)
        fn.call(thisp, hit3.value, hit3.key, self);
    };
    module4.exports = LRUCache;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/range.js"(exports, module4) {
    var Range = class {
      constructor(range7, options2) {
        options2 = parseOptions(options2);
        if (range7 instanceof Range) {
          if (range7.loose === !!options2.loose && range7.includePrerelease === !!options2.includePrerelease) {
            return range7;
          } else {
            return new Range(range7.raw, options2);
          }
        }
        if (range7 instanceof Comparator) {
          this.raw = range7.value;
          this.set = [[range7]];
          this.format();
          return this;
        }
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        this.raw = range7.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c2) => c2.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c2) => !isNullSet(c2[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c2 of this.set) {
              if (c2.length === 1 && isAny(c2[0])) {
                this.set = [c2];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range7) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range7;
        const cached = cache3.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re4[t.HYPHENRANGELOOSE] : re4[t.HYPHENRANGE];
        range7 = range7.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug3("hyphen replace", range7);
        range7 = range7.replace(re4[t.COMPARATORTRIM], comparatorTrimReplace);
        debug3("comparator trim", range7);
        range7 = range7.replace(re4[t.TILDETRIM], tildeTrimReplace);
        debug3("tilde trim", range7);
        range7 = range7.replace(re4[t.CARETTRIM], caretTrimReplace);
        debug3("caret trim", range7);
        let rangeList = range7.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug3("loose invalid filter", comp, this.options);
            return !!comp.match(re4[t.COMPARATORLOOSE]);
          });
        }
        debug3("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache3.set(memoKey, result);
        return result;
      }
      intersects(range7, options2) {
        if (!(range7 instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options2) && range7.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options2);
              });
            });
          });
        });
      }
      test(version5) {
        if (!version5) {
          return false;
        }
        if (typeof version5 === "string") {
          try {
            version5 = new SemVer(version5, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version5, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module4.exports = Range;
    var LRU = require_lru_cache();
    var cache3 = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug3 = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re4,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c2) => c2.value === "<0.0.0-0";
    var isAny = (c2) => c2.value === "";
    var isSatisfiable = (comparators, options2) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options2) => {
      debug3("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug3("caret", comp);
      comp = replaceTildes(comp, options2);
      debug3("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug3("xrange", comp);
      comp = replaceStars(comp, options2);
      debug3("stars", comp);
      return comp;
    };
    var isX2 = (id4) => !id4 || id4.toLowerCase() === "x" || id4 === "*";
    var replaceTildes = (comp, options2) => {
      return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options2)).join(" ");
    };
    var replaceTilde = (comp, options2) => {
      const r2 = options2.loose ? re4[t.TILDELOOSE] : re4[t.TILDE];
      return comp.replace(r2, (_, M2, m2, p, pr) => {
        debug3("tilde", comp, _, M2, m2, p, pr);
        let ret;
        if (isX2(M2)) {
          ret = "";
        } else if (isX2(m2)) {
          ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
        } else if (isX2(p)) {
          ret = `>=${M2}.${m2}.0 <${M2}.${+m2 + 1}.0-0`;
        } else if (pr) {
          debug3("replaceTilde pr", pr);
          ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m2}.${p} <${M2}.${+m2 + 1}.0-0`;
        }
        debug3("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options2) => {
      return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options2)).join(" ");
    };
    var replaceCaret = (comp, options2) => {
      debug3("caret", comp, options2);
      const r2 = options2.loose ? re4[t.CARETLOOSE] : re4[t.CARET];
      const z = options2.includePrerelease ? "-0" : "";
      return comp.replace(r2, (_, M2, m2, p, pr) => {
        debug3("caret", comp, _, M2, m2, p, pr);
        let ret;
        if (isX2(M2)) {
          ret = "";
        } else if (isX2(m2)) {
          ret = `>=${M2}.0.0${z} <${+M2 + 1}.0.0-0`;
        } else if (isX2(p)) {
          if (M2 === "0") {
            ret = `>=${M2}.${m2}.0${z} <${M2}.${+m2 + 1}.0-0`;
          } else {
            ret = `>=${M2}.${m2}.0${z} <${+M2 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug3("replaceCaret pr", pr);
          if (M2 === "0") {
            if (m2 === "0") {
              ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${m2}.${+p + 1}-0`;
            } else {
              ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M2}.${m2}.${p}-${pr} <${+M2 + 1}.0.0-0`;
          }
        } else {
          debug3("no pr");
          if (M2 === "0") {
            if (m2 === "0") {
              ret = `>=${M2}.${m2}.${p}${z} <${M2}.${m2}.${+p + 1}-0`;
            } else {
              ret = `>=${M2}.${m2}.${p}${z} <${M2}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M2}.${m2}.${p} <${+M2 + 1}.0.0-0`;
          }
        }
        debug3("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options2) => {
      debug3("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map((c2) => replaceXRange(c2, options2)).join(" ");
    };
    var replaceXRange = (comp, options2) => {
      comp = comp.trim();
      const r2 = options2.loose ? re4[t.XRANGELOOSE] : re4[t.XRANGE];
      return comp.replace(r2, (ret, gtlt, M2, m2, p, pr) => {
        debug3("xRange", comp, ret, gtlt, M2, m2, p, pr);
        const xM = isX2(M2);
        const xm = xM || isX2(m2);
        const xp = xm || isX2(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M2 = +M2 + 1;
              m2 = 0;
              p = 0;
            } else {
              m2 = +m2 + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M2 = +M2 + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M2}.${m2}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M2}.${m2}.0${pr} <${M2}.${+m2 + 1}.0-0`;
        }
        debug3("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options2) => {
      debug3("replaceStars", comp, options2);
      return comp.trim().replace(re4[t.STAR], "");
    };
    var replaceGTE0 = (comp, options2) => {
      debug3("replaceGTE0", comp, options2);
      return comp.trim().replace(re4[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX2(fM)) {
        from = "";
      } else if (isX2(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX2(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX2(tM)) {
        to = "";
      } else if (isX2(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX2(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set8, version5, options2) => {
      for (let i = 0; i < set8.length; i++) {
        if (!set8[i].test(version5)) {
          return false;
        }
      }
      if (version5.prerelease.length && !options2.includePrerelease) {
        for (let i = 0; i < set8.length; i++) {
          debug3(set8[i].semver);
          if (set8[i].semver === Comparator.ANY) {
            continue;
          }
          if (set8[i].semver.prerelease.length > 0) {
            const allowed = set8[i].semver;
            if (allowed.major === version5.major && allowed.minor === version5.minor && allowed.patch === version5.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/classes/comparator.js"(exports, module4) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options2) {
        options2 = parseOptions(options2);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options2.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug3("comparator", comp, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug3("comp", this);
      }
      parse(comp) {
        const r2 = this.options.loose ? re4[t.COMPARATORLOOSE] : re4[t.COMPARATOR];
        const m2 = comp.match(r2);
        if (!m2) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m2[1] !== void 0 ? m2[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m2[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m2[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version5) {
        debug3("Comparator.test", version5, this.options.loose);
        if (this.semver === ANY || version5 === ANY) {
          return true;
        }
        if (typeof version5 === "string") {
          try {
            version5 = new SemVer(version5, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version5, this.operator, this.semver, this.options);
      }
      intersects(comp, options2) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options2).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options2).test(comp.semver);
        }
        options2 = parseOptions(options2);
        if (options2.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options2.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options2) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options2) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module4.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re4, t } = require_re();
    var cmp = require_cmp();
    var debug3 = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/functions/satisfies.js"(exports, module4) {
    var Range = require_range();
    var satisfies2 = (version5, range7, options2) => {
      try {
        range7 = new Range(range7, options2);
      } catch (er) {
        return false;
      }
      return range7.test(version5);
    };
    module4.exports = satisfies2;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/to-comparators.js"(exports, module4) {
    var Range = require_range();
    var toComparators = (range7, options2) => new Range(range7, options2).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
    module4.exports = toComparators;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/max-satisfying.js"(exports, module4) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range7, options2) => {
      let max8 = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range7, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max8 || maxSV.compare(v) === -1) {
            max8 = v;
            maxSV = new SemVer(max8, options2);
          }
        }
      });
      return max8;
    };
    module4.exports = maxSatisfying;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/min-satisfying.js"(exports, module4) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range7, options2) => {
      let min8 = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range7, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min8 || minSV.compare(v) === 1) {
            min8 = v;
            minSV = new SemVer(min8, options2);
          }
        }
      });
      return min8;
    };
    module4.exports = minSatisfying;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/min-version.js"(exports, module4) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range7, loose) => {
      range7 = new Range(range7, loose);
      let minver = new SemVer("0.0.0");
      if (range7.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range7.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range7.set.length; ++i) {
        const comparators = range7.set[i];
        let setMin = null;
        comparators.forEach((comparator3) => {
          const compver = new SemVer(comparator3.semver.version);
          switch (comparator3.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator3.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range7.test(minver)) {
        return minver;
      }
      return null;
    };
    module4.exports = minVersion;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/valid.js"(exports, module4) {
    var Range = require_range();
    var validRange = (range7, options2) => {
      try {
        return new Range(range7, options2).range || "*";
      } catch (er) {
        return null;
      }
    };
    module4.exports = validRange;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/outside.js"(exports, module4) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version5, range7, hilo, options2) => {
      version5 = new SemVer(version5, options2);
      range7 = new Range(range7, options2);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies2(version5, range7, options2)) {
        return false;
      }
      for (let i = 0; i < range7.set.length; ++i) {
        const comparators = range7.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator3) => {
          if (comparator3.semver === ANY) {
            comparator3 = new Comparator(">=0.0.0");
          }
          high = high || comparator3;
          low = low || comparator3;
          if (gtfn(comparator3.semver, high.semver, options2)) {
            high = comparator3;
          } else if (ltfn(comparator3.semver, low.semver, options2)) {
            low = comparator3;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version5, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version5, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module4.exports = outside;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/gtr.js"(exports, module4) {
    var outside = require_outside();
    var gtr = (version5, range7, options2) => outside(version5, range7, ">", options2);
    module4.exports = gtr;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/ltr.js"(exports, module4) {
    var outside = require_outside();
    var ltr = (version5, range7, options2) => outside(version5, range7, "<", options2);
    module4.exports = ltr;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/intersects.js"(exports, module4) {
    var Range = require_range();
    var intersects2 = (r1, r2, options2) => {
      r1 = new Range(r1, options2);
      r2 = new Range(r2, options2);
      return r1.intersects(r2, options2);
    };
    module4.exports = intersects2;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/simplify.js"(exports, module4) {
    var satisfies2 = require_satisfies();
    var compare6 = require_compare();
    module4.exports = (versions, range7, options2) => {
      const set8 = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a4, b3) => compare6(a4, b3, options2));
      for (const version5 of v) {
        const included = satisfies2(version5, range7, options2);
        if (included) {
          prev = version5;
          if (!first) {
            first = version5;
          }
        } else {
          if (prev) {
            set8.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set8.push([first, null]);
      }
      const ranges2 = [];
      for (const [min8, max8] of set8) {
        if (min8 === max8) {
          ranges2.push(min8);
        } else if (!max8 && min8 === v[0]) {
          ranges2.push("*");
        } else if (!max8) {
          ranges2.push(`>=${min8}`);
        } else if (min8 === v[0]) {
          ranges2.push(`<=${max8}`);
        } else {
          ranges2.push(`${min8} - ${max8}`);
        }
      }
      const simplified = ranges2.join(" || ");
      const original = typeof range7.raw === "string" ? range7.raw : String(range7);
      return simplified.length < original.length ? simplified : range7;
    };
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/ranges/subset.js"(exports, module4) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies2 = require_satisfies();
    var compare6 = require_compare();
    var subset4 = (sub, dom, options2 = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options2);
      dom = new Range(dom, options2);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options2);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options2) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options2.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options2.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c2 of sub) {
        if (c2.operator === ">" || c2.operator === ">=") {
          gt = higherGT(gt, c2, options2);
        } else if (c2.operator === "<" || c2.operator === "<=") {
          lt = lowerLT(lt, c2, options2);
        } else {
          eqSet.add(c2.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare6(gt.semver, lt.semver, options2);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies2(eq, String(gt), options2)) {
          return null;
        }
        if (lt && !satisfies2(eq, String(lt), options2)) {
          return null;
        }
        for (const c2 of dom) {
          if (!satisfies2(eq, String(c2), options2)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower2;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options2.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options2.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c2 of dom) {
        hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
        hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c2.operator === ">" || c2.operator === ">=") {
            higher = higherGT(gt, c2, options2);
            if (higher === c2 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies2(gt.semver, String(c2), options2)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c2.operator === "<" || c2.operator === "<=") {
            lower2 = lowerLT(lt, c2, options2);
            if (lower2 === c2 && lower2 !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies2(lt.semver, String(c2), options2)) {
            return false;
          }
        }
        if (!c2.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a4, b3, options2) => {
      if (!a4) {
        return b3;
      }
      const comp = compare6(a4.semver, b3.semver, options2);
      return comp > 0 ? a4 : comp < 0 ? b3 : b3.operator === ">" && a4.operator === ">=" ? b3 : a4;
    };
    var lowerLT = (a4, b3, options2) => {
      if (!a4) {
        return b3;
      }
      const comp = compare6(a4.semver, b3.semver, options2);
      return comp < 0 ? a4 : comp > 0 ? b3 : b3.operator === "<" && a4.operator === "<=" ? b3 : a4;
    };
    module4.exports = subset4;
  }
});

// node_modules/.pnpm/semver@7.5.4/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/.pnpm/semver@7.5.4/node_modules/semver/index.js"(exports, module4) {
    var internalRe = require_re();
    var constants3 = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse8 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff2 = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch2 = require_patch();
    var prerelease = require_prerelease();
    var compare6 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort5 = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies2 = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects2 = require_intersects();
    var simplifyRange = require_simplify();
    var subset4 = require_subset();
    module4.exports = {
      parse: parse8,
      valid,
      clean,
      inc,
      diff: diff2,
      major,
      minor,
      patch: patch2,
      prerelease,
      compare: compare6,
      rcompare,
      compareLoose,
      compareBuild,
      sort: sort5,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies: satisfies2,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects: intersects2,
      simplifyRange,
      subset: subset4,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants3.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants3.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/vega-util@1.16.1/node_modules/vega-util/build/vega-util.module.js
function accessor(fn, fields, name4) {
  fn.fields = fields || [];
  fn.fname = name4;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}
function getter(path5) {
  return path5.length === 1 ? get1(path5[0]) : getN(path5);
}
function error(message) {
  throw Error(message);
}
function splitAccessPath(p) {
  const path5 = [], n = p.length;
  let q = null, b3 = 0, s3 = "", i, j, c2;
  p = p + "";
  function push() {
    path5.push(s3 + p.substring(i, j));
    s3 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c2 = p[j];
    if (c2 === "\\") {
      s3 += p.substring(i, j);
      s3 += p.substring(++j, ++j);
      i = j;
    } else if (c2 === q) {
      push();
      q = null;
      b3 = -1;
    } else if (q) {
      continue;
    } else if (i === b3 && c2 === '"') {
      i = j + 1;
      q = c2;
    } else if (i === b3 && c2 === "'") {
      i = j + 1;
      q = c2;
    } else if (c2 === "." && !b3) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c2 === "[") {
      if (j > i)
        push();
      b3 = i = j + 1;
    } else if (c2 === "]") {
      if (!b3)
        error("Access path missing open bracket: " + p);
      if (b3 > 0)
        push();
      b3 = 0;
      i = j + 1;
    }
  }
  if (b3)
    error("Access path missing closing bracket: " + p);
  if (q)
    error("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path5;
}
function field(field4, name4, opt) {
  const path5 = splitAccessPath(field4);
  field4 = path5.length === 1 ? path5[0] : field4;
  return accessor((opt && opt.get || getter)(path5), [field4], name4 || field4);
}
function log$1(method3, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method3].apply(console, args);
}
function logger(_, method3) {
  let level = _ || None;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$1)
        log$1(method3 || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn)
        log$1(method3 || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info)
        log$1(method3 || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug)
        log$1(method3 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
function isObject(_) {
  return _ === Object(_);
}
function mergeConfig(...configs) {
  return configs.reduce((out, source5) => {
    for (const key3 in source5) {
      if (key3 === "signals") {
        out.signals = mergeNamed(out.signals, source5.signals);
      } else {
        const r2 = key3 === "legend" ? {
          layout: 1
        } : key3 === "style" ? true : null;
        writeConfig(out, key3, source5[key3], r2);
      }
    }
    return out;
  }, {});
}
function writeConfig(output3, key3, value4, recurse3) {
  if (!isLegalKey(key3))
    return;
  let k4, o;
  if (isObject(value4) && !isArray(value4)) {
    o = isObject(output3[key3]) ? output3[key3] : output3[key3] = {};
    for (k4 in value4) {
      if (recurse3 && (recurse3 === true || recurse3[k4])) {
        writeConfig(o, k4, value4[k4]);
      } else if (isLegalKey(k4)) {
        o[k4] = value4[k4];
      }
    }
  } else {
    output3[key3] = value4;
  }
}
function mergeNamed(a4, b3) {
  if (a4 == null)
    return b3;
  const map11 = {}, out = [];
  function add7(_) {
    if (!map11[_.name]) {
      map11[_.name] = 1;
      out.push(_);
    }
  }
  b3.forEach(add7);
  a4.forEach(add7);
  return out;
}
function peek(array9) {
  return array9[array9.length - 1];
}
function toNumber(_) {
  return _ == null || _ === "" ? null : +_;
}
function pan(domain4, delta, lift, ground) {
  const d0 = lift(domain4[0]), d1 = lift(peek(domain4)), dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear(domain4, delta) {
  return pan(domain4, delta, toNumber, identity);
}
function panLog(domain4, delta) {
  var sign5 = Math.sign(domain4[0]);
  return pan(domain4, delta, log(sign5), exp(sign5));
}
function panPow(domain4, delta, exponent) {
  return pan(domain4, delta, pow(exponent), pow(1 / exponent));
}
function panSymlog(domain4, delta, constant5) {
  return pan(domain4, delta, symlog(constant5), symexp(constant5));
}
function zoom(domain4, anchor, scale8, lift, ground) {
  const d0 = lift(domain4[0]), d1 = lift(peek(domain4)), da = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da + (d0 - da) * scale8), ground(da + (d1 - da) * scale8)];
}
function zoomLinear(domain4, anchor, scale8) {
  return zoom(domain4, anchor, scale8, toNumber, identity);
}
function zoomLog(domain4, anchor, scale8) {
  const sign5 = Math.sign(domain4[0]);
  return zoom(domain4, anchor, scale8, log(sign5), exp(sign5));
}
function zoomPow(domain4, anchor, scale8, exponent) {
  return zoom(domain4, anchor, scale8, pow(exponent), pow(1 / exponent));
}
function zoomSymlog(domain4, anchor, scale8, constant5) {
  return zoom(domain4, anchor, scale8, symlog(constant5), symexp(constant5));
}
function quarter(date3) {
  return 1 + ~~(new Date(date3).getMonth() / 3);
}
function utcquarter(date3) {
  return 1 + ~~(new Date(date3).getUTCMonth() / 3);
}
function array(_) {
  return _ != null ? isArray(_) ? _ : [_] : [];
}
function clampRange(range7, min8, max8) {
  let lo = range7[0], hi = range7[1], span3;
  if (hi < lo) {
    span3 = hi;
    hi = lo;
    lo = span3;
  }
  span3 = hi - lo;
  return span3 >= max8 - min8 ? [min8, max8] : [lo = Math.min(Math.max(lo, min8), max8 - span3), lo + span3];
}
function isFunction(_) {
  return typeof _ === "function";
}
function compare2(fields, orders, opt) {
  opt = opt || {};
  orders = array(orders) || [];
  const ord = [], get8 = [], fmap = {}, gen = opt.comparator || comparator;
  array(fields).forEach((f, i) => {
    if (f == null)
      return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get8.push(f = isFunction(f) ? f : field(f, null, opt));
    (accessorFields(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get8.length === 0 ? null : accessor(gen(get8, ord), Object.keys(fmap));
}
function constant(_) {
  return isFunction(_) ? _ : () => _;
}
function debounce(delay, handler) {
  let tid;
  return (e3) => {
    if (tid)
      clearTimeout(tid);
    tid = setTimeout(() => (handler(e3), tid = null), delay);
  };
}
function extend(_) {
  for (let x7, k4, i = 1, len = arguments.length; i < len; ++i) {
    x7 = arguments[i];
    for (k4 in x7) {
      _[k4] = x7[k4];
    }
  }
  return _;
}
function extent(array9, f) {
  let i = 0, n, v, min8, max8;
  if (array9 && (n = array9.length)) {
    if (f == null) {
      for (v = array9[i]; i < n && (v == null || v !== v); v = array9[++i])
        ;
      min8 = max8 = v;
      for (; i < n; ++i) {
        v = array9[i];
        if (v != null) {
          if (v < min8)
            min8 = v;
          if (v > max8)
            max8 = v;
        }
      }
    } else {
      for (v = f(array9[i]); i < n && (v == null || v !== v); v = f(array9[++i]))
        ;
      min8 = max8 = v;
      for (; i < n; ++i) {
        v = f(array9[i]);
        if (v != null) {
          if (v < min8)
            min8 = v;
          if (v > max8)
            max8 = v;
        }
      }
    }
  }
  return [min8, max8];
}
function extentIndex(array9, f) {
  const n = array9.length;
  let i = -1, a4, b3, c2, u, v;
  if (f == null) {
    while (++i < n) {
      b3 = array9[i];
      if (b3 != null && b3 >= b3) {
        a4 = c2 = b3;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u = v = i;
    while (++i < n) {
      b3 = array9[i];
      if (b3 != null) {
        if (a4 > b3) {
          a4 = b3;
          u = i;
        }
        if (c2 < b3) {
          c2 = b3;
          v = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b3 = f(array9[i], i, array9);
      if (b3 != null && b3 >= b3) {
        a4 = c2 = b3;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u = v = i;
    while (++i < n) {
      b3 = f(array9[i], i, array9);
      if (b3 != null) {
        if (a4 > b3) {
          a4 = b3;
          u = i;
        }
        if (c2 < b3) {
          c2 = b3;
          v = i;
        }
      }
    }
  }
  return [u, v];
}
function has(object2, property2) {
  return hop.call(object2, property2);
}
function fastmap(input) {
  let obj = {}, test2;
  function has$1(key3) {
    return has(obj, key3) && obj[key3] !== NULL;
  }
  const map11 = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key3) {
      return has$1(key3) ? obj[key3] : void 0;
    },
    set(key3, value4) {
      if (!has$1(key3)) {
        ++map11.size;
        if (obj[key3] === NULL)
          --map11.empty;
      }
      obj[key3] = value4;
      return this;
    },
    delete(key3) {
      if (has$1(key3)) {
        --map11.size;
        ++map11.empty;
        obj[key3] = NULL;
      }
      return this;
    },
    clear() {
      map11.size = map11.empty = 0;
      map11.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test2 = _;
        return map11;
      } else {
        return test2;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key3 in obj) {
        const value4 = obj[key3];
        if (value4 !== NULL && (!test2 || !test2(value4))) {
          next[key3] = value4;
          ++size;
        }
      }
      map11.size = size;
      map11.empty = 0;
      map11.object = obj = next;
    }
  };
  if (input)
    Object.keys(input).forEach((key3) => {
      map11.set(key3, input[key3]);
    });
  return map11;
}
function flush(range7, value4, threshold3, left, right, center) {
  if (!threshold3 && threshold3 !== 0)
    return center;
  const t = +threshold3;
  let a4 = range7[0], b3 = peek(range7), l;
  if (b3 < a4) {
    l = a4;
    a4 = b3;
    b3 = l;
  }
  l = Math.abs(value4 - a4);
  const r2 = Math.abs(b3 - value4);
  return l < r2 && l <= t ? left : r2 <= t ? right : center;
}
function inherits(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend(proto, members);
}
function inrange(value4, range7, left, right) {
  let r0 = range7[0], r1 = range7[range7.length - 1], t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value4 : r0 < value4) && (right ? value4 <= r1 : value4 < r1);
}
function isBoolean(_) {
  return typeof _ === "boolean";
}
function isDate(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable(_) {
  return _ && isFunction(_[Symbol.iterator]);
}
function isNumber(_) {
  return typeof _ === "number";
}
function isRegExp(_) {
  return Object.prototype.toString.call(_) === "[object RegExp]";
}
function isString(_) {
  return typeof _ === "string";
}
function key(fields, flat, opt) {
  if (fields) {
    fields = flat ? array(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter, map11 = (f) => gen(flat ? [f] : splitAccessPath(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get8 = map11(fields[0]);
    fn = function(_) {
      return "" + get8(_);
    };
  } else {
    const get8 = fields.map(map11);
    fn = function(_) {
      let s3 = "" + get8[0](_), i = 0;
      while (++i < len)
        s3 += "|" + get8[i](_);
      return s3;
    };
  }
  return accessor(fn, fields, "key");
}
function lerp(array9, frac) {
  const lo = array9[0], hi = peek(array9), f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}
function lruCache(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev, size;
  const clear2 = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key3, value4) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key3] = value4;
  };
  clear2();
  return {
    clear: clear2,
    has: (key3) => has(curr, key3) || has(prev, key3),
    get: (key3) => has(curr, key3) ? curr[key3] : has(prev, key3) ? update3(key3, prev[key3]) : void 0,
    set: (key3, value4) => has(curr, key3) ? curr[key3] = value4 : update3(key3, value4)
  };
}
function merge(compare6, array0, array1, output3) {
  const n0 = array0.length, n1 = array1.length;
  if (!n1)
    return array0;
  if (!n0)
    return array1;
  const merged = output3 || new array0.constructor(n0 + n1);
  let i0 = 0, i1 = 0, i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare6(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}
function repeat(str, reps) {
  let s3 = "";
  while (--reps >= 0)
    s3 += str;
  return s3;
}
function pad(str, length4, padchar, align2) {
  const c2 = padchar || " ", s3 = str + "", n = length4 - s3.length;
  return n <= 0 ? s3 : align2 === "left" ? repeat(c2, n) + s3 : align2 === "center" ? repeat(c2, ~~(n / 2)) + s3 + repeat(c2, Math.ceil(n / 2)) : s3 + repeat(c2, n);
}
function span(array9) {
  return array9 && peek(array9) - array9[0] || 0;
}
function $(x7) {
  return isArray(x7) ? "[" + x7.map($) + "]" : isObject(x7) || isString(x7) ? JSON.stringify(x7).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : x7;
}
function toBoolean(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
function toDate(_, parser4) {
  parser4 = parser4 || defaultParser;
  return _ == null || _ === "" ? null : parser4(_);
}
function toString(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet(_) {
  const s3 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s3[_[i]] = true;
  return s3;
}
function truncate(str, length4, align2, ellipsis) {
  const e3 = ellipsis != null ? ellipsis : "", s3 = str + "", n = s3.length, l = Math.max(0, length4 - e3.length);
  return n <= length4 ? s3 : align2 === "left" ? e3 + s3.slice(n - l) : align2 === "center" ? s3.slice(0, Math.ceil(l / 2)) + e3 + s3.slice(n - ~~(l / 2)) : s3.slice(0, l) + e3;
}
function visitArray(array9, filter6, visitor) {
  if (array9) {
    if (filter6) {
      const n = array9.length;
      for (let i = 0; i < n; ++i) {
        const t = filter6(array9[i]);
        if (t)
          visitor(t, i, array9);
      }
    } else {
      array9.forEach(visitor);
    }
  }
}
var get1, getN, id, identity, zero, one, truthy, falsy, None, Error$1, Warn, Info, Debug, isArray, isLegalKey, exp, log, symlog, symexp, pow, DESCENDING, ascending, comparator, compare1, compareN, hop, NULL, DEFAULT_MAX_SIZE, defaultParser;
var init_vega_util_module = __esm({
  "node_modules/.pnpm/vega-util@1.16.1/node_modules/vega-util/build/vega-util.module.js"() {
    get1 = (field4) => function(obj) {
      return obj[field4];
    };
    getN = (path5) => {
      const len = path5.length;
      return function(obj) {
        for (let i = 0; i < len; ++i) {
          obj = obj[path5[i]];
        }
        return obj;
      };
    };
    id = field("id");
    identity = accessor((_) => _, [], "identity");
    zero = accessor(() => 0, [], "zero");
    one = accessor(() => 1, [], "one");
    truthy = accessor(() => true, [], "true");
    falsy = accessor(() => false, [], "false");
    None = 0;
    Error$1 = 1;
    Warn = 2;
    Info = 3;
    Debug = 4;
    isArray = Array.isArray;
    isLegalKey = (key3) => key3 !== "__proto__";
    exp = (sign5) => (x7) => sign5 * Math.exp(x7);
    log = (sign5) => (x7) => Math.log(sign5 * x7);
    symlog = (c2) => (x7) => Math.sign(x7) * Math.log1p(Math.abs(x7 / c2));
    symexp = (c2) => (x7) => Math.sign(x7) * Math.expm1(Math.abs(x7)) * c2;
    pow = (exponent) => (x7) => x7 < 0 ? -Math.pow(-x7, exponent) : Math.pow(x7, exponent);
    DESCENDING = "descending";
    ascending = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;
    comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
    compare1 = (field4, order) => function(a4, b3) {
      return ascending(field4(a4), field4(b3)) * order;
    };
    compareN = (fields, orders, n) => {
      orders.push(0);
      return function(a4, b3) {
        let f, c2 = 0, i = -1;
        while (c2 === 0 && ++i < n) {
          f = fields[i];
          c2 = ascending(f(a4), f(b3));
        }
        return c2 * orders[i];
      };
    };
    hop = Object.prototype.hasOwnProperty;
    NULL = {};
    DEFAULT_MAX_SIZE = 1e4;
    defaultParser = (_) => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);
  }
});

// node_modules/.pnpm/vega-util@1.17.2/node_modules/vega-util/build/vega-util.module.js
function accessor2(fn, fields, name4) {
  fn.fields = fields || [];
  fn.fname = name4;
  return fn;
}
function accessorFields2(fn) {
  return fn == null ? null : fn.fields;
}
function getter2(path5) {
  return path5.length === 1 ? get12(path5[0]) : getN2(path5);
}
function error2(message) {
  throw Error(message);
}
function splitAccessPath2(p) {
  const path5 = [], n = p.length;
  let q = null, b3 = 0, s3 = "", i, j, c2;
  p = p + "";
  function push() {
    path5.push(s3 + p.substring(i, j));
    s3 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c2 = p[j];
    if (c2 === "\\") {
      s3 += p.substring(i, j++);
      i = j;
    } else if (c2 === q) {
      push();
      q = null;
      b3 = -1;
    } else if (q) {
      continue;
    } else if (i === b3 && c2 === '"') {
      i = j + 1;
      q = c2;
    } else if (i === b3 && c2 === "'") {
      i = j + 1;
      q = c2;
    } else if (c2 === "." && !b3) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c2 === "[") {
      if (j > i)
        push();
      b3 = i = j + 1;
    } else if (c2 === "]") {
      if (!b3)
        error2("Access path missing open bracket: " + p);
      if (b3 > 0)
        push();
      b3 = 0;
      i = j + 1;
    }
  }
  if (b3)
    error2("Access path missing closing bracket: " + p);
  if (q)
    error2("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path5;
}
function field2(field4, name4, opt) {
  const path5 = splitAccessPath2(field4);
  field4 = path5.length === 1 ? path5[0] : field4;
  return accessor2((opt && opt.get || getter2)(path5), [field4], name4 || field4);
}
function log$12(method3, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method3].apply(console, args);
}
function logger2(_, method3) {
  let handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : log$12;
  let level = _ || None2;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$12)
        handler(method3 || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn2)
        handler(method3 || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info2)
        handler(method3 || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug2)
        handler(method3 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
function isObject2(_) {
  return _ === Object(_);
}
function peek2(array9) {
  return array9[array9.length - 1];
}
function toNumber2(_) {
  return _ == null || _ === "" ? null : +_;
}
function array2(_) {
  return _ != null ? isArray2(_) ? _ : [_] : [];
}
function isFunction2(_) {
  return typeof _ === "function";
}
function compare3(fields, orders, opt) {
  opt = opt || {};
  orders = array2(orders) || [];
  const ord = [], get8 = [], fmap = {}, gen = opt.comparator || comparator2;
  array2(fields).forEach((f, i) => {
    if (f == null)
      return;
    ord.push(orders[i] === DESCENDING2 ? -1 : 1);
    get8.push(f = isFunction2(f) ? f : field2(f, null, opt));
    (accessorFields2(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get8.length === 0 ? null : accessor2(gen(get8, ord), Object.keys(fmap));
}
function constant2(_) {
  return isFunction2(_) ? _ : () => _;
}
function debounce2(delay, handler) {
  let tid;
  return (e3) => {
    if (tid)
      clearTimeout(tid);
    tid = setTimeout(() => (handler(e3), tid = null), delay);
  };
}
function extend2(_) {
  for (let x7, k4, i = 1, len = arguments.length; i < len; ++i) {
    x7 = arguments[i];
    for (k4 in x7) {
      _[k4] = x7[k4];
    }
  }
  return _;
}
function extent2(array9, f) {
  let i = 0, n, v, min8, max8;
  if (array9 && (n = array9.length)) {
    if (f == null) {
      for (v = array9[i]; i < n && (v == null || v !== v); v = array9[++i])
        ;
      min8 = max8 = v;
      for (; i < n; ++i) {
        v = array9[i];
        if (v != null) {
          if (v < min8)
            min8 = v;
          if (v > max8)
            max8 = v;
        }
      }
    } else {
      for (v = f(array9[i]); i < n && (v == null || v !== v); v = f(array9[++i]))
        ;
      min8 = max8 = v;
      for (; i < n; ++i) {
        v = f(array9[i]);
        if (v != null) {
          if (v < min8)
            min8 = v;
          if (v > max8)
            max8 = v;
        }
      }
    }
  }
  return [min8, max8];
}
function has2(object2, property2) {
  return hop2.call(object2, property2);
}
function inherits2(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend2(proto, members);
}
function inrange2(value4, range7, left, right) {
  let r0 = range7[0], r1 = range7[range7.length - 1], t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value4 : r0 < value4) && (right ? value4 <= r1 : value4 < r1);
}
function isDate2(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable2(_) {
  return _ && isFunction2(_[Symbol.iterator]);
}
function isNumber2(_) {
  return typeof _ === "number";
}
function isString2(_) {
  return typeof _ === "string";
}
function key2(fields, flat, opt) {
  if (fields) {
    fields = flat ? array2(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array2(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter2, map11 = (f) => gen(flat ? [f] : splitAccessPath2(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get8 = map11(fields[0]);
    fn = function(_) {
      return "" + get8(_);
    };
  } else {
    const get8 = fields.map(map11);
    fn = function(_) {
      let s3 = "" + get8[0](_), i = 0;
      while (++i < len)
        s3 += "|" + get8[i](_);
      return s3;
    };
  }
  return accessor2(fn, fields, "key");
}
function lruCache2(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE2;
  let curr, prev, size;
  const clear2 = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key3, value4) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key3] = value4;
  };
  clear2();
  return {
    clear: clear2,
    has: (key3) => has2(curr, key3) || has2(prev, key3),
    get: (key3) => has2(curr, key3) ? curr[key3] : has2(prev, key3) ? update3(key3, prev[key3]) : void 0,
    set: (key3, value4) => has2(curr, key3) ? curr[key3] = value4 : update3(key3, value4)
  };
}
function $2(x7) {
  return isArray2(x7) ? "[" + x7.map($2) + "]" : isObject2(x7) || isString2(x7) ? JSON.stringify(x7).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : x7;
}
function toBoolean2(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
function toDate2(_, parser4) {
  parser4 = parser4 || defaultParser2;
  return _ == null || _ === "" ? null : parser4(_);
}
function toString2(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet2(_) {
  const s3 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s3[_[i]] = true;
  return s3;
}
function visitArray2(array9, filter6, visitor) {
  if (array9) {
    if (filter6) {
      const n = array9.length;
      for (let i = 0; i < n; ++i) {
        const t = filter6(array9[i]);
        if (t)
          visitor(t, i, array9);
      }
    } else {
      array9.forEach(visitor);
    }
  }
}
var get12, getN2, id2, identity2, zero2, one2, truthy2, falsy2, None2, Error$12, Warn2, Info2, Debug2, isArray2, DESCENDING2, ascending2, comparator2, compare12, compareN2, hop2, DEFAULT_MAX_SIZE2, defaultParser2;
var init_vega_util_module2 = __esm({
  "node_modules/.pnpm/vega-util@1.17.2/node_modules/vega-util/build/vega-util.module.js"() {
    get12 = (field4) => function(obj) {
      return obj[field4];
    };
    getN2 = (path5) => {
      const len = path5.length;
      return function(obj) {
        for (let i = 0; i < len; ++i) {
          obj = obj[path5[i]];
        }
        return obj;
      };
    };
    id2 = field2("id");
    identity2 = accessor2((_) => _, [], "identity");
    zero2 = accessor2(() => 0, [], "zero");
    one2 = accessor2(() => 1, [], "one");
    truthy2 = accessor2(() => true, [], "true");
    falsy2 = accessor2(() => false, [], "false");
    None2 = 0;
    Error$12 = 1;
    Warn2 = 2;
    Info2 = 3;
    Debug2 = 4;
    isArray2 = Array.isArray;
    DESCENDING2 = "descending";
    ascending2 = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;
    comparator2 = (fields, orders) => fields.length === 1 ? compare12(fields[0], orders[0]) : compareN2(fields, orders, fields.length);
    compare12 = (field4, order) => function(a4, b3) {
      return ascending2(field4(a4), field4(b3)) * order;
    };
    compareN2 = (fields, orders, n) => {
      orders.push(0);
      return function(a4, b3) {
        let f, c2 = 0, i = -1;
        while (c2 === 0 && ++i < n) {
          f = fields[i];
          c2 = ascending2(f(a4), f(b3));
        }
        return c2 * orders[i];
      };
    };
    hop2 = Object.prototype.hasOwnProperty;
    DEFAULT_MAX_SIZE2 = 1e4;
    defaultParser2 = (_) => isNumber2(_) ? _ : isDate2(_) ? _ : Date.parse(_);
  }
});

// node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/dsv.js
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name4, i) {
    return JSON.stringify(name4) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object2 = objectConverter(columns);
  return function(row, i) {
    return f(object2(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad2(value4, width2) {
  var s3 = value4 + "", length4 = s3.length;
  return length4 < width2 ? new Array(width2 - length4 + 1).join(0) + s3 : s3;
}
function formatYear(year2) {
  return year2 < 0 ? "-" + pad2(-year2, 6) : year2 > 9999 ? "+" + pad2(year2, 6) : pad2(year2, 4);
}
function formatDate(date3) {
  var hours2 = date3.getUTCHours(), minutes2 = date3.getUTCMinutes(), seconds3 = date3.getUTCSeconds(), milliseconds3 = date3.getUTCMilliseconds();
  return isNaN(date3) ? "Invalid Date" : formatYear(date3.getUTCFullYear(), 4) + "-" + pad2(date3.getUTCMonth() + 1, 2) + "-" + pad2(date3.getUTCDate(), 2) + (milliseconds3 ? "T" + pad2(hours2, 2) + ":" + pad2(minutes2, 2) + ":" + pad2(seconds3, 2) + "." + pad2(milliseconds3, 3) + "Z" : seconds3 ? "T" + pad2(hours2, 2) + ":" + pad2(minutes2, 2) + ":" + pad2(seconds3, 2) + "Z" : minutes2 || hours2 ? "T" + pad2(hours2, 2) + ":" + pad2(minutes2, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse8(text5, f) {
    var convert, columns, rows = parseRows(text5, function(row, i) {
      if (convert)
        return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text5, f) {
    var rows = [], N = text5.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text5.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text5.charCodeAt(N - 1) === RETURN)
      --N;
    function token() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c2;
      if (text5.charCodeAt(j) === QUOTE) {
        while (I++ < N && text5.charCodeAt(I) !== QUOTE || text5.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c2 = text5.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text5.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text5.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c2 = text5.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text5.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c2 !== DELIMITER)
          continue;
        return text5.slice(j, i);
      }
      return eof = true, text5.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF)
        row.push(t), t = token();
      if (f && (row = f(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue5(row[column]);
      }).join(delimiter);
    });
  }
  function format9(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue5).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue5).join(delimiter);
  }
  function formatValue5(value4) {
    return value4 == null ? "" : value4 instanceof Date ? formatDate(value4) : reFormat.test(value4 += "") ? '"' + value4.replace(/"/g, '""') + '"' : value4;
  }
  return {
    parse: parse8,
    parseRows,
    format: format9,
    formatBody,
    formatRows,
    formatRow,
    formatValue: formatValue5
  };
}
var EOL, EOF, QUOTE, NEWLINE, RETURN;
var init_dsv = __esm({
  "node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/dsv.js"() {
    EOL = {};
    EOF = {};
    QUOTE = 34;
    NEWLINE = 10;
    RETURN = 13;
  }
});

// node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/csv.js
var csv, csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows, csvFormatRow, csvFormatValue;
var init_csv = __esm({
  "node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/csv.js"() {
    init_dsv();
    csv = dsv_default(",");
    csvParse = csv.parse;
    csvParseRows = csv.parseRows;
    csvFormat = csv.format;
    csvFormatBody = csv.formatBody;
    csvFormatRows = csv.formatRows;
    csvFormatRow = csv.formatRow;
    csvFormatValue = csv.formatValue;
  }
});

// node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/tsv.js
var tsv, tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows, tsvFormatRow, tsvFormatValue;
var init_tsv = __esm({
  "node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/tsv.js"() {
    init_dsv();
    tsv = dsv_default("	");
    tsvParse = tsv.parse;
    tsvParseRows = tsv.parseRows;
    tsvFormat = tsv.format;
    tsvFormatBody = tsv.formatBody;
    tsvFormatRows = tsv.formatRows;
    tsvFormatRow = tsv.formatRow;
    tsvFormatValue = tsv.formatValue;
  }
});

// node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/autoType.js
var fixtz;
var init_autoType = __esm({
  "node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/autoType.js"() {
    fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
  }
});

// node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/index.js
var init_src = __esm({
  "node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/index.js"() {
    init_dsv();
    init_csv();
    init_tsv();
    init_autoType();
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/identity.js
function identity_default(x7) {
  return x7;
}
var init_identity = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/identity.js"() {
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/transform.js
function transform_default(transform4) {
  if (transform4 == null)
    return identity_default;
  var x07, y07, kx4 = transform4.scale[0], ky3 = transform4.scale[1], dx = transform4.translate[0], dy = transform4.translate[1];
  return function(input, i) {
    if (!i)
      x07 = y07 = 0;
    var j = 2, n = input.length, output3 = new Array(n);
    output3[0] = (x07 += input[0]) * kx4 + dx;
    output3[1] = (y07 += input[1]) * ky3 + dy;
    while (j < n)
      output3[j] = input[j], ++j;
    return output3;
  };
}
var init_transform = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/transform.js"() {
    init_identity();
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/bbox.js
var init_bbox = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/bbox.js"() {
    init_transform();
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/reverse.js
function reverse_default(array9, n) {
  var t, j = array9.length, i = j - n;
  while (i < --j)
    t = array9[i], array9[i++] = array9[j], array9[j] = t;
}
var init_reverse = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/reverse.js"() {
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/feature.js
function feature_default(topology, o) {
  if (typeof o === "string")
    o = topology.objects[o];
  return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
    return feature(topology, o2);
  }) } : feature(topology, o);
}
function feature(topology, o) {
  var id4 = o.id, bbox = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
  return id4 == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id: id4, properties, geometry } : { type: "Feature", id: id4, bbox, properties, geometry };
}
function object(topology, o) {
  var transformPoint = transform_default(topology.transform), arcs = topology.arcs;
  function arc5(i, points2) {
    if (points2.length)
      points2.pop();
    for (var a4 = arcs[i < 0 ? ~i : i], k4 = 0, n = a4.length; k4 < n; ++k4) {
      points2.push(transformPoint(a4[k4], k4));
    }
    if (i < 0)
      reverse_default(points2, n);
  }
  function point16(p) {
    return transformPoint(p);
  }
  function line5(arcs2) {
    var points2 = [];
    for (var i = 0, n = arcs2.length; i < n; ++i)
      arc5(arcs2[i], points2);
    if (points2.length < 2)
      points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line5(arcs2);
    while (points2.length < 4)
      points2.push(points2[0]);
    return points2;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o2) {
    var type4 = o2.type, coordinates;
    switch (type4) {
      case "GeometryCollection":
        return { type: type4, geometries: o2.geometries.map(geometry) };
      case "Point":
        coordinates = point16(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point16);
        break;
      case "LineString":
        coordinates = line5(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line5);
        break;
      case "Polygon":
        coordinates = polygon(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return { type: type4, coordinates };
  }
  return geometry(o);
}
var init_feature = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/feature.js"() {
    init_reverse();
    init_transform();
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc5 = topology.arcs[i < 0 ? ~i : i], t;
    if (arc5.length < 3 && !arc5[1][0] && !arc5[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function(i) {
    var e3 = ends(i), start = e3[0], end = e3[1], f, g;
    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });
  function ends(i) {
    var arc5 = topology.arcs[i < 0 ? ~i : i], p02 = arc5[0], p1;
    if (topology.transform)
      p1 = [0, 0], arc5.forEach(function(dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });
    else
      p1 = arc5[arc5.length - 1];
    return i < 0 ? [p1, p02] : [p02, p1];
  }
  function flush2(fragmentByEnd2, fragmentByStart2) {
    for (var k4 in fragmentByEnd2) {
      var f = fragmentByEnd2[k4];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush2(fragmentByEnd, fragmentByStart);
  flush2(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i])
      fragments.push([i]);
  });
  return fragments;
}
var init_stitch = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/stitch.js"() {
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/mesh.js
function mesh_default(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object2, filter6) {
  var arcs, i, n;
  if (arguments.length > 1)
    arcs = extractArcs(topology, object2, filter6);
  else
    for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i)
      arcs[i] = i;
  return { type: "MultiLineString", arcs: stitch_default(topology, arcs) };
}
function extractArcs(topology, object2, filter6) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o.arcs);
        break;
      case "MultiPolygon":
        extract3(o.arcs);
        break;
    }
  }
  geometry(object2);
  geomsByArc.forEach(filter6 == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter6(geoms[0].g, geoms[geoms.length - 1].g))
      arcs.push(geoms[0].i);
  });
  return arcs;
}
var init_mesh = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/mesh.js"() {
    init_feature();
    init_stitch();
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/merge.js
var init_merge = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/merge.js"() {
    init_feature();
    init_stitch();
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/bisect.js
var init_bisect = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/bisect.js"() {
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/neighbors.js
var init_neighbors = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/neighbors.js"() {
    init_bisect();
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/untransform.js
var init_untransform = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/untransform.js"() {
    init_identity();
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/quantize.js
var init_quantize = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/quantize.js"() {
    init_bbox();
    init_untransform();
  }
});

// node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/index.js
var init_src2 = __esm({
  "node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/index.js"() {
    init_bbox();
    init_feature();
    init_mesh();
    init_merge();
    init_neighbors();
    init_quantize();
    init_transform();
    init_untransform();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ascending.js
function ascending3(a4, b3) {
  return a4 == null || b3 == null ? NaN : a4 < b3 ? -1 : a4 > b3 ? 1 : a4 >= b3 ? 0 : NaN;
}
var init_ascending = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ascending.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/descending.js
function descending(a4, b3) {
  return a4 == null || b3 == null ? NaN : b3 < a4 ? -1 : b3 > a4 ? 1 : b3 >= a4 ? 0 : NaN;
}
var init_descending = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/descending.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare13, compare22, delta;
  if (f.length !== 2) {
    compare13 = ascending3;
    compare22 = (d, x7) => ascending3(f(d), x7);
    delta = (d, x7) => f(d) - x7;
  } else {
    compare13 = f === ascending3 || f === descending ? f : zero3;
    compare22 = f;
    delta = f;
  }
  function left(a4, x7, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare13(x7, x7) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare22(a4[mid], x7) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a4, x7, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare13(x7, x7) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare22(a4[mid], x7) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a4, x7, lo = 0, hi = a4.length) {
    const i = left(a4, x7, lo, hi - 1);
    return i > lo && delta(a4[i - 1], x7) > -delta(a4[i], x7) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero3() {
  return 0;
}
var init_bisector = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bisector.js"() {
    init_ascending();
    init_descending();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/number.js
function number(x7) {
  return x7 === null ? NaN : +x7;
}
var init_number = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/number.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bisect.js
var ascendingBisect, bisectRight, bisectLeft, bisectCenter, bisect_default2;
var init_bisect2 = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bisect.js"() {
    init_ascending();
    init_bisector();
    init_number();
    ascendingBisect = bisector(ascending3);
    bisectRight = ascendingBisect.right;
    bisectLeft = ascendingBisect.left;
    bisectCenter = bisector(number).center;
    bisect_default2 = bisectRight;
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/blur.js
function Blur2(blur4) {
  return function(data3, rx, ry = rx) {
    if (!((rx = +rx) >= 0))
      throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0))
      throw new RangeError("invalid ry");
    let { data: values5, width: width2, height: height2 } = data3;
    if (!((width2 = Math.floor(width2)) >= 0))
      throw new RangeError("invalid width");
    if (!((height2 = Math.floor(height2 !== void 0 ? height2 : values5.length / width2)) >= 0))
      throw new RangeError("invalid height");
    if (!width2 || !height2 || !rx && !ry)
      return data3;
    const blurx = rx && blur4(rx);
    const blury = ry && blur4(ry);
    const temp3 = values5.slice();
    if (blurx && blury) {
      blurh(blurx, temp3, values5, width2, height2);
      blurh(blurx, values5, temp3, width2, height2);
      blurh(blurx, temp3, values5, width2, height2);
      blurv(blury, values5, temp3, width2, height2);
      blurv(blury, temp3, values5, width2, height2);
      blurv(blury, values5, temp3, width2, height2);
    } else if (blurx) {
      blurh(blurx, values5, temp3, width2, height2);
      blurh(blurx, temp3, values5, width2, height2);
      blurh(blurx, values5, temp3, width2, height2);
    } else if (blury) {
      blurv(blury, values5, temp3, width2, height2);
      blurv(blury, temp3, values5, width2, height2);
      blurv(blury, values5, temp3, width2, height2);
    }
    return data3;
  };
}
function blurh(blur4, T, S, w5, h4) {
  for (let y7 = 0, n = w5 * h4; y7 < n; ) {
    blur4(T, S, y7, y7 += w5, 1);
  }
}
function blurv(blur4, T, S, w5, h4) {
  for (let x7 = 0, n = w5 * h4; x7 < w5; ++x7) {
    blur4(T, S, x7, x7 + n, w5);
  }
}
function blurfImage(radius2) {
  const blur4 = blurf(radius2);
  return (T, S, start, stop2, step) => {
    start <<= 2, stop2 <<= 2, step <<= 2;
    blur4(T, S, start + 0, stop2 + 0, step);
    blur4(T, S, start + 1, stop2 + 1, step);
    blur4(T, S, start + 2, stop2 + 2, step);
    blur4(T, S, start + 3, stop2 + 3, step);
  };
}
function blurf(radius2) {
  const radius0 = Math.floor(radius2);
  if (radius0 === radius2)
    return bluri(radius2);
  const t = radius2 - radius0;
  const w5 = 2 * radius2 + 1;
  return (T, S, start, stop2, step) => {
    if (!((stop2 -= step) >= start))
      return;
    let sum6 = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum6 += S[Math.min(stop2, i)];
    }
    for (let i = start, j = stop2; i <= j; i += step) {
      sum6 += S[Math.min(stop2, i + s0)];
      T[i] = (sum6 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop2, i + s1)])) / w5;
      sum6 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius2) {
  const w5 = 2 * radius2 + 1;
  return (T, S, start, stop2, step) => {
    if (!((stop2 -= step) >= start))
      return;
    let sum6 = radius2 * S[start];
    const s3 = step * radius2;
    for (let i = start, j = start + s3; i < j; i += step) {
      sum6 += S[Math.min(stop2, i)];
    }
    for (let i = start, j = stop2; i <= j; i += step) {
      sum6 += S[Math.min(stop2, i + s3)];
      T[i] = sum6 / w5;
      sum6 -= S[Math.max(start, i - s3)];
    }
  };
}
var blur2, blurImage;
var init_blur = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/blur.js"() {
    blur2 = Blur2(blurf);
    blurImage = Blur2(blurfImage);
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/count.js
var init_count = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/count.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/cross.js
var init_cross = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/cross.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/cumsum.js
var init_cumsum = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/cumsum.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/variance.js
var init_variance = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/variance.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/deviation.js
var init_deviation = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/deviation.js"() {
    init_variance();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/extent.js
var init_extent = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/extent.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/fsum.js
var init_fsum = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/fsum.js"() {
  }
});

// node_modules/.pnpm/internmap@2.0.3/node_modules/internmap/src/index.js
function intern_get({ _intern, _key }, value4) {
  const key3 = _key(value4);
  return _intern.has(key3) ? _intern.get(key3) : value4;
}
function intern_set({ _intern, _key }, value4) {
  const key3 = _key(value4);
  if (_intern.has(key3))
    return _intern.get(key3);
  _intern.set(key3, value4);
  return value4;
}
function intern_delete({ _intern, _key }, value4) {
  const key3 = _key(value4);
  if (_intern.has(key3)) {
    value4 = _intern.get(key3);
    _intern.delete(key3);
  }
  return value4;
}
function keyof(value4) {
  return value4 !== null && typeof value4 === "object" ? value4.valueOf() : value4;
}
var InternMap, InternSet;
var init_src3 = __esm({
  "node_modules/.pnpm/internmap@2.0.3/node_modules/internmap/src/index.js"() {
    InternMap = class extends Map {
      constructor(entries3, key3 = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key3 } });
        if (entries3 != null)
          for (const [key4, value4] of entries3)
            this.set(key4, value4);
      }
      get(key3) {
        return super.get(intern_get(this, key3));
      }
      has(key3) {
        return super.has(intern_get(this, key3));
      }
      set(key3, value4) {
        return super.set(intern_set(this, key3), value4);
      }
      delete(key3) {
        return super.delete(intern_delete(this, key3));
      }
    };
    InternSet = class extends Set {
      constructor(values5, key3 = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key3 } });
        if (values5 != null)
          for (const value4 of values5)
            this.add(value4);
      }
      has(value4) {
        return super.has(intern_get(this, value4));
      }
      add(value4) {
        return super.add(intern_set(this, value4));
      }
      delete(value4) {
        return super.delete(intern_delete(this, value4));
      }
    };
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/identity.js
var init_identity2 = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/identity.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/group.js
var init_group = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/group.js"() {
    init_src3();
    init_identity2();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/permute.js
var init_permute = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/permute.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/sort.js
var init_sort = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/sort.js"() {
    init_ascending();
    init_permute();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/groupSort.js
var init_groupSort = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/groupSort.js"() {
    init_ascending();
    init_group();
    init_sort();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/array.js
var array3, slice, map;
var init_array = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/array.js"() {
    array3 = Array.prototype;
    slice = array3.slice;
    map = array3.map;
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/constant.js
var init_constant = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ticks.js
function tickSpec(start, stop2, count5) {
  const step = (stop2 - start) / Math.max(0, count5), power = Math.floor(Math.log10(step)), error3 = step / Math.pow(10, power), factor = error3 >= e10 ? 10 : error3 >= e5 ? 5 : error3 >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop2 * inc);
    if (i1 / inc < start)
      ++i1;
    if (i2 / inc > stop2)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop2 / inc);
    if (i1 * inc < start)
      ++i1;
    if (i2 * inc > stop2)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count5 && count5 < 2)
    return tickSpec(start, stop2, count5 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop2, count5) {
  stop2 = +stop2, start = +start, count5 = +count5;
  if (!(count5 > 0))
    return [];
  if (start === stop2)
    return [start];
  const reverse6 = stop2 < start, [i1, i2, inc] = reverse6 ? tickSpec(stop2, start, count5) : tickSpec(start, stop2, count5);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks3 = new Array(n);
  if (reverse6) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks3[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks3[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks3[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks3[i] = (i1 + i) * inc;
  }
  return ticks3;
}
function tickIncrement(start, stop2, count5) {
  stop2 = +stop2, start = +start, count5 = +count5;
  return tickSpec(start, stop2, count5)[2];
}
function tickStep(start, stop2, count5) {
  stop2 = +stop2, start = +start, count5 = +count5;
  const reverse6 = stop2 < start, inc = reverse6 ? tickIncrement(stop2, start, count5) : tickIncrement(start, stop2, count5);
  return (reverse6 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
var e10, e5, e2;
var init_ticks = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ticks.js"() {
    e10 = Math.sqrt(50);
    e5 = Math.sqrt(10);
    e2 = Math.sqrt(2);
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/nice.js
var init_nice = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/nice.js"() {
    init_ticks();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/threshold/sturges.js
var init_sturges = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/threshold/sturges.js"() {
    init_count();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bin.js
var init_bin = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bin.js"() {
    init_array();
    init_bisect2();
    init_constant();
    init_extent();
    init_identity2();
    init_nice();
    init_ticks();
    init_sturges();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/max.js
var init_max = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/max.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/maxIndex.js
var init_maxIndex = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/maxIndex.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/min.js
var init_min = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/min.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/minIndex.js
var init_minIndex = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/minIndex.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/quickselect.js
var init_quickselect = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/quickselect.js"() {
    init_sort();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/greatest.js
var init_greatest = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/greatest.js"() {
    init_ascending();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/quantile.js
function quantileSorted(values5, p, valueof = number) {
  if (!(n = values5.length) || isNaN(p = +p))
    return;
  if (p <= 0 || n < 2)
    return +valueof(values5[0], 0, values5);
  if (p >= 1)
    return +valueof(values5[n - 1], n - 1, values5);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values5[i0], i0, values5), value1 = +valueof(values5[i0 + 1], i0 + 1, values5);
  return value0 + (value1 - value0) * (i - i0);
}
var init_quantile = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/quantile.js"() {
    init_max();
    init_maxIndex();
    init_min();
    init_minIndex();
    init_quickselect();
    init_number();
    init_sort();
    init_greatest();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/threshold/freedmanDiaconis.js
var init_freedmanDiaconis = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/threshold/freedmanDiaconis.js"() {
    init_count();
    init_quantile();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/threshold/scott.js
var init_scott = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/threshold/scott.js"() {
    init_count();
    init_deviation();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/mean.js
var init_mean = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/mean.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/median.js
var init_median = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/median.js"() {
    init_quantile();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/merge.js
var init_merge2 = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/merge.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/mode.js
var init_mode = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/mode.js"() {
    init_src3();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/pairs.js
var init_pairs = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/pairs.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/range.js
function range(start, stop2, step) {
  start = +start, stop2 = +stop2, step = (n = arguments.length) < 2 ? (stop2 = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop2 - start) / step)) | 0, range7 = new Array(n);
  while (++i < n) {
    range7[i] = start + i * step;
  }
  return range7;
}
var init_range = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/range.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/rank.js
var init_rank = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/rank.js"() {
    init_ascending();
    init_sort();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/least.js
var init_least = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/least.js"() {
    init_ascending();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/leastIndex.js
var init_leastIndex = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/leastIndex.js"() {
    init_ascending();
    init_minIndex();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/greatestIndex.js
var init_greatestIndex = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/greatestIndex.js"() {
    init_ascending();
    init_maxIndex();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/scan.js
var init_scan = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/scan.js"() {
    init_leastIndex();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/shuffle.js
function shuffler(random3) {
  return function shuffle2(array9, i0 = 0, i1 = array9.length) {
    let m2 = i1 - (i0 = +i0);
    while (m2) {
      const i = random3() * m2-- | 0, t = array9[m2 + i0];
      array9[m2 + i0] = array9[i + i0];
      array9[i + i0] = t;
    }
    return array9;
  };
}
var shuffle_default;
var init_shuffle = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/shuffle.js"() {
    shuffle_default = shuffler(Math.random);
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/sum.js
var init_sum = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/sum.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/transpose.js
var init_transpose = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/transpose.js"() {
    init_min();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/zip.js
var init_zip = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/zip.js"() {
    init_transpose();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/every.js
var init_every = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/every.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/some.js
var init_some = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/some.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/filter.js
var init_filter = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/filter.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/map.js
var init_map = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/map.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/reduce.js
var init_reduce = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/reduce.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/reverse.js
var init_reverse2 = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/reverse.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/difference.js
var init_difference = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/difference.js"() {
    init_src3();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/disjoint.js
var init_disjoint = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/disjoint.js"() {
    init_src3();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/intersection.js
var init_intersection = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/intersection.js"() {
    init_src3();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/superset.js
var init_superset = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/superset.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/subset.js
var init_subset = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/subset.js"() {
    init_superset();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/union.js
var init_union = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/union.js"() {
    init_src3();
  }
});

// node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/index.js
var init_src4 = __esm({
  "node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/index.js"() {
    init_bisect2();
    init_ascending();
    init_bisector();
    init_blur();
    init_count();
    init_cross();
    init_cumsum();
    init_descending();
    init_deviation();
    init_extent();
    init_fsum();
    init_group();
    init_groupSort();
    init_bin();
    init_freedmanDiaconis();
    init_scott();
    init_sturges();
    init_max();
    init_maxIndex();
    init_mean();
    init_median();
    init_merge2();
    init_min();
    init_minIndex();
    init_mode();
    init_nice();
    init_pairs();
    init_permute();
    init_quantile();
    init_quickselect();
    init_range();
    init_rank();
    init_least();
    init_leastIndex();
    init_greatest();
    init_greatestIndex();
    init_scan();
    init_shuffle();
    init_sum();
    init_ticks();
    init_transpose();
    init_variance();
    init_zip();
    init_every();
    init_some();
    init_filter();
    init_map();
    init_reduce();
    init_reverse2();
    init_sort();
    init_difference();
    init_disjoint();
    init_intersection();
    init_subset();
    init_superset();
    init_union();
    init_src3();
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x7) {
  return Math.abs(x7 = Math.round(x7)) >= 1e21 ? x7.toLocaleString("en").replace(/,/g, "") : x7.toString(10);
}
function formatDecimalParts(x7, p) {
  if ((i = (x7 = p ? x7.toExponential(p - 1) : x7.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x7.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x7.slice(i + 1)
  ];
}
var init_formatDecimal = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatDecimal.js"() {
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/exponent.js
function exponent_default(x7) {
  return x7 = formatDecimalParts(Math.abs(x7)), x7 ? x7[1] : NaN;
}
var init_exponent = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/exponent.js"() {
    init_formatDecimal();
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value4, width2) {
    var i = value4.length, t = [], j = 0, g = grouping[0], length4 = 0;
    while (i > 0 && g > 0) {
      if (length4 + g + 1 > width2)
        g = Math.max(1, width2 - length4);
      t.push(value4.substring(i -= g, i + g));
      if ((length4 += g + 1) > width2)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
var init_formatGroup = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatGroup.js"() {
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value4) {
    return value4.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var init_formatNumerals = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatNumerals.js"() {
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatSpecifier.js
function formatSpecifier(specifier) {
  if (!(match4 = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match4;
  return new FormatSpecifier({
    fill: match4[1],
    align: match4[2],
    sign: match4[3],
    symbol: match4[4],
    zero: match4[5],
    width: match4[6],
    comma: match4[7],
    precision: match4[8] && match4[8].slice(1),
    trim: match4[9],
    type: match4[10]
  });
}
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
var re;
var init_formatSpecifier = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatSpecifier.js"() {
    re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    formatSpecifier.prototype = FormatSpecifier.prototype;
    FormatSpecifier.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s3) {
  out:
    for (var n = s3.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s3[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s3[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
}
var init_formatTrim = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatTrim.js"() {
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatPrefixAuto.js
function formatPrefixAuto_default(x7, p) {
  var d = formatDecimalParts(x7, p);
  if (!d)
    return x7 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x7, Math.max(0, p + i - 1))[0];
}
var prefixExponent;
var init_formatPrefixAuto = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatPrefixAuto.js"() {
    init_formatDecimal();
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x7, p) {
  var d = formatDecimalParts(x7, p);
  if (!d)
    return x7 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
var init_formatRounded = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatRounded.js"() {
    init_formatDecimal();
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatTypes.js
var formatTypes_default;
var init_formatTypes = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatTypes.js"() {
    init_formatDecimal();
    init_formatPrefixAuto();
    init_formatRounded();
    formatTypes_default = {
      "%": (x7, p) => (x7 * 100).toFixed(p),
      "b": (x7) => Math.round(x7).toString(2),
      "c": (x7) => x7 + "",
      "d": formatDecimal_default,
      "e": (x7, p) => x7.toExponential(p),
      "f": (x7, p) => x7.toFixed(p),
      "g": (x7, p) => x7.toPrecision(p),
      "o": (x7) => Math.round(x7).toString(8),
      "p": (x7, p) => formatRounded_default(x7 * 100, p),
      "r": formatRounded_default,
      "s": formatPrefixAuto_default,
      "X": (x7) => Math.round(x7).toString(16).toUpperCase(),
      "x": (x7) => Math.round(x7).toString(16)
    };
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/identity.js
function identity_default2(x7) {
  return x7;
}
var init_identity3 = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/identity.js"() {
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/locale.js
function locale_default(locale7) {
  var group6 = locale7.grouping === void 0 || locale7.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale7.grouping, Number), locale7.thousands + ""), currencyPrefix = locale7.currency === void 0 ? "" : locale7.currency[0] + "", currencySuffix = locale7.currency === void 0 ? "" : locale7.currency[1] + "", decimal = locale7.decimal === void 0 ? "." : locale7.decimal + "", numerals = locale7.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale7.numerals, String)), percent = locale7.percent === void 0 ? "%" : locale7.percent + "", minus = locale7.minus === void 0 ? "" : locale7.minus + "", nan = locale7.nan === void 0 ? "NaN" : locale7.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill3 = specifier.fill, align2 = specifier.align, sign5 = specifier.sign, symbol3 = specifier.symbol, zero10 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type4 = specifier.type;
    if (type4 === "n")
      comma = true, type4 = "g";
    else if (!formatTypes_default[type4])
      precision === void 0 && (precision = 12), trim = true, type4 = "g";
    if (zero10 || fill3 === "0" && align2 === "=")
      zero10 = true, fill3 = "0", align2 = "=";
    var prefix = symbol3 === "$" ? currencyPrefix : symbol3 === "#" && /[boxX]/.test(type4) ? "0" + type4.toLowerCase() : "", suffix = symbol3 === "$" ? currencySuffix : /[%p]/.test(type4) ? percent : "";
    var formatType = formatTypes_default[type4], maybeSuffix = /[defgprs%]/.test(type4);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type4) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format9(value4) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
      if (type4 === "c") {
        valueSuffix = formatType(value4) + valueSuffix;
        value4 = "";
      } else {
        value4 = +value4;
        var valueNegative = value4 < 0 || 1 / value4 < 0;
        value4 = isNaN(value4) ? nan : formatType(Math.abs(value4), precision);
        if (trim)
          value4 = formatTrim_default(value4);
        if (valueNegative && +value4 === 0 && sign5 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign5 === "(" ? sign5 : minus : sign5 === "-" || sign5 === "(" ? "" : sign5) + valuePrefix;
        valueSuffix = (type4 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign5 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value4.length;
          while (++i < n) {
            if (c2 = value4.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value4.slice(i + 1) : value4.slice(i)) + valueSuffix;
              value4 = value4.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero10)
        value4 = group6(value4, Infinity);
      var length4 = valuePrefix.length + value4.length + valueSuffix.length, padding3 = length4 < width2 ? new Array(width2 - length4 + 1).join(fill3) : "";
      if (comma && zero10)
        value4 = group6(padding3 + value4, padding3.length ? width2 - valueSuffix.length : Infinity), padding3 = "";
      switch (align2) {
        case "<":
          value4 = valuePrefix + value4 + valueSuffix + padding3;
          break;
        case "=":
          value4 = valuePrefix + padding3 + value4 + valueSuffix;
          break;
        case "^":
          value4 = padding3.slice(0, length4 = padding3.length >> 1) + valuePrefix + value4 + valueSuffix + padding3.slice(length4);
          break;
        default:
          value4 = padding3 + valuePrefix + value4 + valueSuffix;
          break;
      }
      return numerals(value4);
    }
    format9.toString = function() {
      return specifier + "";
    };
    return format9;
  }
  function formatPrefix4(specifier, value4) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value4) / 3))) * 3, k4 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value5) {
      return f(k4 * value5) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix4
  };
}
var map3, prefixes;
var init_locale = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/locale.js"() {
    init_exponent();
    init_formatGroup();
    init_formatNumerals();
    init_formatSpecifier();
    init_formatTrim();
    init_formatTypes();
    init_formatPrefixAuto();
    init_identity3();
    map3 = Array.prototype.map;
    prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/defaultLocale.js
function defaultLocale(definition3) {
  locale = locale_default(definition3);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
var locale, format, formatPrefix;
var init_defaultLocale = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/defaultLocale.js"() {
    init_locale();
    defaultLocale({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}
var init_precisionFixed = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/precisionFixed.js"() {
    init_exponent();
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value4) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value4) / 3))) * 3 - exponent_default(Math.abs(step)));
}
var init_precisionPrefix = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/precisionPrefix.js"() {
    init_exponent();
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max8) {
  step = Math.abs(step), max8 = Math.abs(max8) - step;
  return Math.max(0, exponent_default(max8) - exponent_default(step)) + 1;
}
var init_precisionRound = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/precisionRound.js"() {
    init_exponent();
  }
});

// node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/index.js
var init_src5 = __esm({
  "node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/index.js"() {
    init_defaultLocale();
    init_locale();
    init_formatSpecifier();
    init_precisionFixed();
    init_precisionPrefix();
    init_precisionRound();
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/interval.js
function timeInterval(floori, offseti, count5, field4) {
  function interval3(date3) {
    return floori(date3 = arguments.length === 0 ? new Date() : new Date(+date3)), date3;
  }
  interval3.floor = (date3) => {
    return floori(date3 = new Date(+date3)), date3;
  };
  interval3.ceil = (date3) => {
    return floori(date3 = new Date(date3 - 1)), offseti(date3, 1), floori(date3), date3;
  };
  interval3.round = (date3) => {
    const d0 = interval3(date3), d1 = interval3.ceil(date3);
    return date3 - d0 < d1 - date3 ? d0 : d1;
  };
  interval3.offset = (date3, step) => {
    return offseti(date3 = new Date(+date3), step == null ? 1 : Math.floor(step)), date3;
  };
  interval3.range = (start, stop2, step) => {
    const range7 = [];
    start = interval3.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop2) || !(step > 0))
      return range7;
    let previous;
    do
      range7.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop2);
    return range7;
  };
  interval3.filter = (test2) => {
    return timeInterval((date3) => {
      if (date3 >= date3)
        while (floori(date3), !test2(date3))
          date3.setTime(date3 - 1);
    }, (date3, step) => {
      if (date3 >= date3) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date3, -1), !test2(date3)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date3, 1), !test2(date3)) {
            }
          }
      }
    });
  };
  if (count5) {
    interval3.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count5(t0, t1));
    };
    interval3.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval3 : interval3.filter(field4 ? (d) => field4(d) % step === 0 : (d) => interval3.count(0, d) % step === 0);
    };
  }
  return interval3;
}
var t0, t1;
var init_interval = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/interval.js"() {
    t0 = new Date();
    t1 = new Date();
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/millisecond.js
var millisecond, milliseconds;
var init_millisecond = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/millisecond.js"() {
    init_interval();
    millisecond = timeInterval(() => {
    }, (date3, step) => {
      date3.setTime(+date3 + step);
    }, (start, end) => {
      return end - start;
    });
    millisecond.every = (k4) => {
      k4 = Math.floor(k4);
      if (!isFinite(k4) || !(k4 > 0))
        return null;
      if (!(k4 > 1))
        return millisecond;
      return timeInterval((date3) => {
        date3.setTime(Math.floor(date3 / k4) * k4);
      }, (date3, step) => {
        date3.setTime(+date3 + step * k4);
      }, (start, end) => {
        return (end - start) / k4;
      });
    };
    milliseconds = millisecond.range;
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/duration.js
var durationSecond, durationMinute, durationHour, durationDay, durationWeek, durationMonth, durationYear;
var init_duration = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/duration.js"() {
    durationSecond = 1e3;
    durationMinute = durationSecond * 60;
    durationHour = durationMinute * 60;
    durationDay = durationHour * 24;
    durationWeek = durationDay * 7;
    durationMonth = durationDay * 30;
    durationYear = durationDay * 365;
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/second.js
var second, seconds;
var init_second = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/second.js"() {
    init_interval();
    init_duration();
    second = timeInterval((date3) => {
      date3.setTime(date3 - date3.getMilliseconds());
    }, (date3, step) => {
      date3.setTime(+date3 + step * durationSecond);
    }, (start, end) => {
      return (end - start) / durationSecond;
    }, (date3) => {
      return date3.getUTCSeconds();
    });
    seconds = second.range;
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/minute.js
var timeMinute, timeMinutes, utcMinute, utcMinutes;
var init_minute = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/minute.js"() {
    init_interval();
    init_duration();
    timeMinute = timeInterval((date3) => {
      date3.setTime(date3 - date3.getMilliseconds() - date3.getSeconds() * durationSecond);
    }, (date3, step) => {
      date3.setTime(+date3 + step * durationMinute);
    }, (start, end) => {
      return (end - start) / durationMinute;
    }, (date3) => {
      return date3.getMinutes();
    });
    timeMinutes = timeMinute.range;
    utcMinute = timeInterval((date3) => {
      date3.setUTCSeconds(0, 0);
    }, (date3, step) => {
      date3.setTime(+date3 + step * durationMinute);
    }, (start, end) => {
      return (end - start) / durationMinute;
    }, (date3) => {
      return date3.getUTCMinutes();
    });
    utcMinutes = utcMinute.range;
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/hour.js
var timeHour, timeHours, utcHour, utcHours;
var init_hour = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/hour.js"() {
    init_interval();
    init_duration();
    timeHour = timeInterval((date3) => {
      date3.setTime(date3 - date3.getMilliseconds() - date3.getSeconds() * durationSecond - date3.getMinutes() * durationMinute);
    }, (date3, step) => {
      date3.setTime(+date3 + step * durationHour);
    }, (start, end) => {
      return (end - start) / durationHour;
    }, (date3) => {
      return date3.getHours();
    });
    timeHours = timeHour.range;
    utcHour = timeInterval((date3) => {
      date3.setUTCMinutes(0, 0, 0);
    }, (date3, step) => {
      date3.setTime(+date3 + step * durationHour);
    }, (start, end) => {
      return (end - start) / durationHour;
    }, (date3) => {
      return date3.getUTCHours();
    });
    utcHours = utcHour.range;
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/day.js
var timeDay, timeDays, utcDay, utcDays, unixDay, unixDays;
var init_day = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/day.js"() {
    init_interval();
    init_duration();
    timeDay = timeInterval(
      (date3) => date3.setHours(0, 0, 0, 0),
      (date3, step) => date3.setDate(date3.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
      (date3) => date3.getDate() - 1
    );
    timeDays = timeDay.range;
    utcDay = timeInterval((date3) => {
      date3.setUTCHours(0, 0, 0, 0);
    }, (date3, step) => {
      date3.setUTCDate(date3.getUTCDate() + step);
    }, (start, end) => {
      return (end - start) / durationDay;
    }, (date3) => {
      return date3.getUTCDate() - 1;
    });
    utcDays = utcDay.range;
    unixDay = timeInterval((date3) => {
      date3.setUTCHours(0, 0, 0, 0);
    }, (date3, step) => {
      date3.setUTCDate(date3.getUTCDate() + step);
    }, (start, end) => {
      return (end - start) / durationDay;
    }, (date3) => {
      return Math.floor(date3 / durationDay);
    });
    unixDays = unixDay.range;
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date3) => {
    date3.setDate(date3.getDate() - (date3.getDay() + 7 - i) % 7);
    date3.setHours(0, 0, 0, 0);
  }, (date3, step) => {
    date3.setDate(date3.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
function utcWeekday(i) {
  return timeInterval((date3) => {
    date3.setUTCDate(date3.getUTCDate() - (date3.getUTCDay() + 7 - i) % 7);
    date3.setUTCHours(0, 0, 0, 0);
  }, (date3, step) => {
    date3.setUTCDate(date3.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
var timeSunday, timeMonday, timeTuesday, timeWednesday, timeThursday, timeFriday, timeSaturday, timeSundays, timeMondays, timeTuesdays, timeWednesdays, timeThursdays, timeFridays, timeSaturdays, utcSunday, utcMonday, utcTuesday, utcWednesday, utcThursday, utcFriday, utcSaturday, utcSundays, utcMondays, utcTuesdays, utcWednesdays, utcThursdays, utcFridays, utcSaturdays;
var init_week = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/week.js"() {
    init_interval();
    init_duration();
    timeSunday = timeWeekday(0);
    timeMonday = timeWeekday(1);
    timeTuesday = timeWeekday(2);
    timeWednesday = timeWeekday(3);
    timeThursday = timeWeekday(4);
    timeFriday = timeWeekday(5);
    timeSaturday = timeWeekday(6);
    timeSundays = timeSunday.range;
    timeMondays = timeMonday.range;
    timeTuesdays = timeTuesday.range;
    timeWednesdays = timeWednesday.range;
    timeThursdays = timeThursday.range;
    timeFridays = timeFriday.range;
    timeSaturdays = timeSaturday.range;
    utcSunday = utcWeekday(0);
    utcMonday = utcWeekday(1);
    utcTuesday = utcWeekday(2);
    utcWednesday = utcWeekday(3);
    utcThursday = utcWeekday(4);
    utcFriday = utcWeekday(5);
    utcSaturday = utcWeekday(6);
    utcSundays = utcSunday.range;
    utcMondays = utcMonday.range;
    utcTuesdays = utcTuesday.range;
    utcWednesdays = utcWednesday.range;
    utcThursdays = utcThursday.range;
    utcFridays = utcFriday.range;
    utcSaturdays = utcSaturday.range;
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/month.js
var timeMonth, timeMonths, utcMonth, utcMonths;
var init_month = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/month.js"() {
    init_interval();
    timeMonth = timeInterval((date3) => {
      date3.setDate(1);
      date3.setHours(0, 0, 0, 0);
    }, (date3, step) => {
      date3.setMonth(date3.getMonth() + step);
    }, (start, end) => {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, (date3) => {
      return date3.getMonth();
    });
    timeMonths = timeMonth.range;
    utcMonth = timeInterval((date3) => {
      date3.setUTCDate(1);
      date3.setUTCHours(0, 0, 0, 0);
    }, (date3, step) => {
      date3.setUTCMonth(date3.getUTCMonth() + step);
    }, (start, end) => {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, (date3) => {
      return date3.getUTCMonth();
    });
    utcMonths = utcMonth.range;
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/year.js
var timeYear, timeYears, utcYear, utcYears;
var init_year = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/year.js"() {
    init_interval();
    timeYear = timeInterval((date3) => {
      date3.setMonth(0, 1);
      date3.setHours(0, 0, 0, 0);
    }, (date3, step) => {
      date3.setFullYear(date3.getFullYear() + step);
    }, (start, end) => {
      return end.getFullYear() - start.getFullYear();
    }, (date3) => {
      return date3.getFullYear();
    });
    timeYear.every = (k4) => {
      return !isFinite(k4 = Math.floor(k4)) || !(k4 > 0) ? null : timeInterval((date3) => {
        date3.setFullYear(Math.floor(date3.getFullYear() / k4) * k4);
        date3.setMonth(0, 1);
        date3.setHours(0, 0, 0, 0);
      }, (date3, step) => {
        date3.setFullYear(date3.getFullYear() + step * k4);
      });
    };
    timeYears = timeYear.range;
    utcYear = timeInterval((date3) => {
      date3.setUTCMonth(0, 1);
      date3.setUTCHours(0, 0, 0, 0);
    }, (date3, step) => {
      date3.setUTCFullYear(date3.getUTCFullYear() + step);
    }, (start, end) => {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, (date3) => {
      return date3.getUTCFullYear();
    });
    utcYear.every = (k4) => {
      return !isFinite(k4 = Math.floor(k4)) || !(k4 > 0) ? null : timeInterval((date3) => {
        date3.setUTCFullYear(Math.floor(date3.getUTCFullYear() / k4) * k4);
        date3.setUTCMonth(0, 1);
        date3.setUTCHours(0, 0, 0, 0);
      }, (date3, step) => {
        date3.setUTCFullYear(date3.getUTCFullYear() + step * k4);
      });
    };
    utcYears = utcYear.range;
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/ticks.js
function ticker(year2, month2, week2, day2, hour2, minute2) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week2, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function ticks3(start, stop2, count5) {
    const reverse6 = stop2 < start;
    if (reverse6)
      [start, stop2] = [stop2, start];
    const interval3 = count5 && typeof count5.range === "function" ? count5 : tickInterval(start, stop2, count5);
    const ticks4 = interval3 ? interval3.range(start, +stop2 + 1) : [];
    return reverse6 ? ticks4.reverse() : ticks4;
  }
  function tickInterval(start, stop2, count5) {
    const target2 = Math.abs(stop2 - start) / count5;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target2);
    if (i === tickIntervals.length)
      return year2.every(tickStep(start / durationYear, stop2 / durationYear, count5));
    if (i === 0)
      return millisecond.every(Math.max(tickStep(start, stop2, count5), 1));
    const [t, step] = tickIntervals[target2 / tickIntervals[i - 1][2] < tickIntervals[i][2] / target2 ? i - 1 : i];
    return t.every(step);
  }
  return [ticks3, tickInterval];
}
var utcTicks, utcTickInterval, timeTicks, timeTickInterval;
var init_ticks2 = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/ticks.js"() {
    init_src4();
    init_duration();
    init_millisecond();
    init_second();
    init_minute();
    init_hour();
    init_day();
    init_week();
    init_month();
    init_year();
    [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
    [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
  }
});

// node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/index.js
var init_src6 = __esm({
  "node_modules/.pnpm/d3-time@3.1.0/node_modules/d3-time/src/index.js"() {
    init_interval();
    init_millisecond();
    init_second();
    init_minute();
    init_hour();
    init_day();
    init_week();
    init_month();
    init_year();
    init_ticks2();
  }
});

// node_modules/.pnpm/vega-time@2.1.1/node_modules/vega-time/build/vega-time.module.js
function localYear(y7) {
  t02.setFullYear(y7);
  t02.setMonth(0);
  t02.setDate(1);
  t02.setHours(0, 0, 0, 0);
  return t02;
}
function localDayOfYear(d) {
  return timeDay.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return timeSunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y7) {
  return localYear(y7).getDay();
}
function utcDayOfYear(d) {
  const y7 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y7 - 1, d);
}
function utcWeekNum(d) {
  const y7 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y7 - 1, d);
}
function utcFirst(y7) {
  t02.setTime(Date.UTC(y7, 0, 1));
  return t02.getUTCDay();
}
function weekday(week2, day2, firstDay) {
  return day2 + week2 * 7 - (firstDay + 6) % 7;
}
function timeInterval2(unit3) {
  return timeIntervals[unit3];
}
function utcInterval(unit3) {
  return utcIntervals[unit3];
}
var YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS, TIME_UNITS, UNITS, defaultSpecifiers, t02, localGet, localInv, utcGet, utcInv, timeIntervals, utcIntervals, durationSecond2, durationMinute2, durationHour2, durationDay2, durationWeek2, durationMonth2, durationYear2, Milli, Seconds, Minutes, Hours, Day, Week, Month, Year, intervals;
var init_vega_time_module = __esm({
  "node_modules/.pnpm/vega-time@2.1.1/node_modules/vega-time/build/vega-time.module.js"() {
    init_vega_util_module2();
    init_src6();
    init_src4();
    YEAR = "year";
    QUARTER = "quarter";
    MONTH = "month";
    WEEK = "week";
    DATE = "date";
    DAY = "day";
    DAYOFYEAR = "dayofyear";
    HOURS = "hours";
    MINUTES = "minutes";
    SECONDS = "seconds";
    MILLISECONDS = "milliseconds";
    TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
    UNITS = TIME_UNITS.reduce((o, u, i) => (o[u] = 1 + i, o), {});
    defaultSpecifiers = {
      [YEAR]: "%Y ",
      [QUARTER]: "Q%q ",
      [MONTH]: "%b ",
      [DATE]: "%d ",
      [WEEK]: "W%U ",
      [DAY]: "%a ",
      [DAYOFYEAR]: "%j ",
      [HOURS]: "%H:00",
      [MINUTES]: "00:%M",
      [SECONDS]: ":%S",
      [MILLISECONDS]: ".%L",
      [`${YEAR}-${MONTH}`]: "%Y-%m ",
      [`${YEAR}-${MONTH}-${DATE}`]: "%Y-%m-%d ",
      [`${HOURS}-${MINUTES}`]: "%H:%M"
    };
    t02 = new Date();
    localGet = {
      [YEAR]: (d) => d.getFullYear(),
      [QUARTER]: (d) => Math.floor(d.getMonth() / 3),
      [MONTH]: (d) => d.getMonth(),
      [DATE]: (d) => d.getDate(),
      [HOURS]: (d) => d.getHours(),
      [MINUTES]: (d) => d.getMinutes(),
      [SECONDS]: (d) => d.getSeconds(),
      [MILLISECONDS]: (d) => d.getMilliseconds(),
      [DAYOFYEAR]: (d) => localDayOfYear(d),
      [WEEK]: (d) => localWeekNum(d),
      [WEEK + DAY]: (d, y7) => weekday(localWeekNum(d), d.getDay(), localFirst(y7)),
      [DAY]: (d, y7) => weekday(1, d.getDay(), localFirst(y7))
    };
    localInv = {
      [QUARTER]: (q) => 3 * q,
      [WEEK]: (w5, y7) => weekday(w5, 0, localFirst(y7))
    };
    utcGet = {
      [YEAR]: (d) => d.getUTCFullYear(),
      [QUARTER]: (d) => Math.floor(d.getUTCMonth() / 3),
      [MONTH]: (d) => d.getUTCMonth(),
      [DATE]: (d) => d.getUTCDate(),
      [HOURS]: (d) => d.getUTCHours(),
      [MINUTES]: (d) => d.getUTCMinutes(),
      [SECONDS]: (d) => d.getUTCSeconds(),
      [MILLISECONDS]: (d) => d.getUTCMilliseconds(),
      [DAYOFYEAR]: (d) => utcDayOfYear(d),
      [WEEK]: (d) => utcWeekNum(d),
      [DAY]: (d, y7) => weekday(1, d.getUTCDay(), utcFirst(y7)),
      [WEEK + DAY]: (d, y7) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y7))
    };
    utcInv = {
      [QUARTER]: (q) => 3 * q,
      [WEEK]: (w5, y7) => weekday(w5, 0, utcFirst(y7))
    };
    timeIntervals = {
      [YEAR]: timeYear,
      [QUARTER]: timeMonth.every(3),
      [MONTH]: timeMonth,
      [WEEK]: timeSunday,
      [DATE]: timeDay,
      [DAY]: timeDay,
      [DAYOFYEAR]: timeDay,
      [HOURS]: timeHour,
      [MINUTES]: timeMinute,
      [SECONDS]: second,
      [MILLISECONDS]: millisecond
    };
    utcIntervals = {
      [YEAR]: utcYear,
      [QUARTER]: utcMonth.every(3),
      [MONTH]: utcMonth,
      [WEEK]: utcSunday,
      [DATE]: utcDay,
      [DAY]: utcDay,
      [DAYOFYEAR]: utcDay,
      [HOURS]: utcHour,
      [MINUTES]: utcMinute,
      [SECONDS]: second,
      [MILLISECONDS]: millisecond
    };
    durationSecond2 = 1e3;
    durationMinute2 = durationSecond2 * 60;
    durationHour2 = durationMinute2 * 60;
    durationDay2 = durationHour2 * 24;
    durationWeek2 = durationDay2 * 7;
    durationMonth2 = durationDay2 * 30;
    durationYear2 = durationDay2 * 365;
    Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS];
    Seconds = Milli.slice(0, -1);
    Minutes = Seconds.slice(0, -1);
    Hours = Minutes.slice(0, -1);
    Day = Hours.slice(0, -1);
    Week = [YEAR, WEEK];
    Month = [YEAR, MONTH];
    Year = [YEAR];
    intervals = [[Seconds, 1, durationSecond2], [Seconds, 5, 5 * durationSecond2], [Seconds, 15, 15 * durationSecond2], [Seconds, 30, 30 * durationSecond2], [Minutes, 1, durationMinute2], [Minutes, 5, 5 * durationMinute2], [Minutes, 15, 15 * durationMinute2], [Minutes, 30, 30 * durationMinute2], [Hours, 1, durationHour2], [Hours, 3, 3 * durationHour2], [Hours, 6, 6 * durationHour2], [Hours, 12, 12 * durationHour2], [Day, 1, durationDay2], [Week, 1, durationWeek2], [Month, 1, durationMonth2], [Month, 3, 3 * durationMonth2], [Year, 1, durationYear2]];
  }
});

// node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date3 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date3.setFullYear(d.y);
    return date3;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date3 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date3.setUTCFullYear(d.y);
    return date3;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y7, m2, d) {
  return { y: y7, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale7) {
  var locale_dateTime = locale7.dateTime, locale_date = locale7.date, locale_time = locale7.time, locale_periods = locale7.periods, locale_weekdays = locale7.days, locale_shortWeekdays = locale7.shortDays, locale_months = locale7.months, locale_shortMonths = locale7.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats5 = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear2,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats5.x = newFormat(locale_date, formats5);
  formats5.X = newFormat(locale_time, formats5);
  formats5.c = newFormat(locale_dateTime, formats5);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats6) {
    return function(date3) {
      var string = [], i = -1, j = 0, n = specifier.length, c2, pad6, format9;
      if (!(date3 instanceof Date))
        date3 = new Date(+date3);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad6 = pads[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad6 = c2 === "e" ? " " : "0";
          if (format9 = formats6[c2])
            c2 = format9(date3, pad6);
          string.push(c2);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week2, day2;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week2 = utcDate(newDate(d.y, 0, 1)), day2 = week2.getUTCDay();
          week2 = day2 > 4 || day2 === 0 ? utcMonday.ceil(week2) : utcMonday(week2);
          week2 = utcDay.offset(week2, (d.V - 1) * 7);
          d.y = week2.getUTCFullYear();
          d.m = week2.getUTCMonth();
          d.d = week2.getUTCDate() + (d.w + 6) % 7;
        } else {
          week2 = localDate(newDate(d.y, 0, 1)), day2 = week2.getDay();
          week2 = day2 > 4 || day2 === 0 ? timeMonday.ceil(week2) : timeMonday(week2);
          week2 = timeDay.offset(week2, (d.V - 1) * 7);
          d.y = week2.getFullYear();
          d.m = week2.getMonth();
          d.d = week2.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m2 = string.length, c2, parse8;
    while (i < n) {
      if (j >= m2)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse8 = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse8 || (j = parse8(d, string, j)) < 0)
          return -1;
      } else if (c2 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats5);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
function pad3(value4, fill3, width2) {
  var sign5 = value4 < 0 ? "-" : "", string = (sign5 ? -value4 : value4) + "", length4 = string.length;
  return sign5 + (length4 < width2 ? new Array(width2 - length4 + 1).join(fill3) + string : string);
}
function requote(s3) {
  return s3.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name4, i) => [name4.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad3(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad3(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad3(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad3(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad3(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad3(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad3(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad3(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad3(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad3(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad3(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear2(d, p) {
  return pad3(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad3(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad3(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad3(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad3(z / 60 | 0, "0", 2) + pad3(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad3(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad3(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad3(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad3(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad3(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad3(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad3(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad3(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad3(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad3(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad3(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad3(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad3(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad3(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad3(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}
var pads, numberRe, percentRe, requoteRe;
var init_locale2 = __esm({
  "node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/locale.js"() {
    init_src6();
    pads = { "-": "", "_": " ", "0": "0" };
    numberRe = /^\s*\d+/;
    percentRe = /^%/;
    requoteRe = /[\\^$*+?|[\]().{}]/g;
  }
});

// node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/defaultLocale.js
function defaultLocale2(definition3) {
  locale2 = formatLocale(definition3);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}
var locale2, timeFormat, timeParse, utcFormat, utcParse;
var init_defaultLocale2 = __esm({
  "node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/defaultLocale.js"() {
    init_locale2();
    defaultLocale2({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
  }
});

// node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/isoFormat.js
function formatIsoNative(date3) {
  return date3.toISOString();
}
var isoSpecifier, formatIso;
var init_isoFormat = __esm({
  "node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/isoFormat.js"() {
    init_defaultLocale2();
    isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
    formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
  }
});

// node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date3 = new Date(string);
  return isNaN(date3) ? null : date3;
}
var parseIso;
var init_isoParse = __esm({
  "node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/isoParse.js"() {
    init_isoFormat();
    init_defaultLocale2();
    parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
  }
});

// node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/index.js
var init_src7 = __esm({
  "node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/index.js"() {
    init_defaultLocale2();
    init_locale2();
    init_isoFormat();
    init_isoParse();
  }
});

// node_modules/.pnpm/vega-format@1.1.1/node_modules/vega-format/build/vega-format.module.js
function memoize(method3) {
  const cache3 = {};
  return (spec) => cache3[spec] || (cache3[spec] = method3(spec));
}
function trimZeroes(numberFormat2, decimalChar) {
  return (x7) => {
    const str = numberFormat2(x7), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit(str, dec) {
  let i = str.lastIndexOf("e"), c2;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c2 = str.charCodeAt(i);
    if (c2 >= 48 && c2 <= 57)
      return i + 1;
  }
}
function numberLocale(locale7) {
  const format9 = memoize(locale7.format), formatPrefix4 = locale7.formatPrefix;
  return {
    format: format9,
    formatPrefix: formatPrefix4,
    formatFloat(spec) {
      const s3 = formatSpecifier(spec || ",");
      if (s3.precision == null) {
        s3.precision = 12;
        switch (s3.type) {
          case "%":
            s3.precision -= 2;
            break;
          case "e":
            s3.precision -= 1;
            break;
        }
        return trimZeroes(
          format9(s3),
          format9(".1f")(1)[1]
        );
      } else {
        return format9(s3);
      }
    },
    formatSpan(start, stop2, count5, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop2, count5), value4 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value4))) {
              specifier.precision = precision;
            }
            return formatPrefix4(specifier, value4);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value4))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format9(specifier);
    }
  };
}
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format,
    formatPrefix
  });
}
function numberFormatLocale(definition3) {
  return numberLocale(locale_default(definition3));
}
function numberFormatDefaultLocale(definition3) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition3) : defaultNumberLocale;
}
function timeMultiFormat(format9, interval3, spec) {
  spec = spec || {};
  if (!isObject2(spec)) {
    error2(`Invalid time multi-format specifier: ${spec}`);
  }
  const second3 = interval3(SECONDS), minute2 = interval3(MINUTES), hour2 = interval3(HOURS), day2 = interval3(DATE), week2 = interval3(WEEK), month2 = interval3(MONTH), quarter3 = interval3(QUARTER), year2 = interval3(YEAR), L = format9(spec[MILLISECONDS] || ".%L"), S = format9(spec[SECONDS] || ":%S"), M2 = format9(spec[MINUTES] || "%I:%M"), H = format9(spec[HOURS] || "%I %p"), d = format9(spec[DATE] || spec[DAY] || "%a %d"), w5 = format9(spec[WEEK] || "%b %d"), m2 = format9(spec[MONTH] || "%B"), q = format9(spec[QUARTER] || "%B"), y7 = format9(spec[YEAR] || "%Y");
  return (date3) => (second3(date3) < date3 ? L : minute2(date3) < date3 ? S : hour2(date3) < date3 ? M2 : day2(date3) < date3 ? H : month2(date3) < date3 ? week2(date3) < date3 ? d : w5 : year2(date3) < date3 ? quarter3(date3) < date3 ? m2 : q : y7)(date3);
}
function timeLocale(locale7) {
  const timeFormat5 = memoize(locale7.format), utcFormat4 = memoize(locale7.utcFormat);
  return {
    timeFormat: (spec) => isString2(spec) ? timeFormat5(spec) : timeMultiFormat(timeFormat5, timeInterval2, spec),
    utcFormat: (spec) => isString2(spec) ? utcFormat4(spec) : timeMultiFormat(utcFormat4, utcInterval, spec),
    timeParse: memoize(locale7.parse),
    utcParse: memoize(locale7.utcParse)
  };
}
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}
function timeFormatLocale(definition3) {
  return timeLocale(formatLocale(definition3));
}
function timeFormatDefaultLocale(definition3) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition3) : defaultTimeLocale;
}
function defaultLocale3(numberSpec, timeSpec) {
  const args = arguments.length;
  if (args && args !== 2) {
    error2("defaultLocale expects either zero or two arguments.");
  }
  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
var defaultNumberLocale, defaultTimeLocale, createLocale;
var init_vega_format_module = __esm({
  "node_modules/.pnpm/vega-format@1.1.1/node_modules/vega-format/build/vega-format.module.js"() {
    init_src4();
    init_src5();
    init_vega_time_module();
    init_vega_util_module2();
    init_src7();
    resetNumberFormatDefaultLocale();
    resetTimeFormatDefaultLocale();
    createLocale = (number12, time4) => extend2({}, number12, time4);
  }
});

// node_modules/.pnpm/vega-loader@4.5.1/node_modules/vega-loader/build/vega-loader.browser.module.js
function loaderFactory(fetch2, fs) {
  return (options2) => ({
    options: options2 || {},
    sanitize,
    load,
    fileAccess: !!fs,
    file: fileLoader(fs),
    http: httpLoader(fetch2)
  });
}
async function load(uri, options2) {
  const opt = await this.sanitize(uri, options2), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options2);
}
async function sanitize(uri, options2) {
  options2 = extend2({}, this.options, options2);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base3;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error2("Sanitize failure, invalid URI: " + $2(uri));
  }
  const hasProtocol = protocol_re.test(uri);
  if ((base3 = options2.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base3.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base3 + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol)) || options2.mode === "file" || options2.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith("//")) {
    if (options2.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options2.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options2.target) {
    result.target = options2.target + "";
  }
  if (options2.rel) {
    result.rel = options2.rel + "";
  }
  if (options2.context === "image" && options2.crossOrigin) {
    result.crossOrigin = options2.crossOrigin + "";
  }
  return result;
}
function fileLoader(fs) {
  return fs ? (filename) => new Promise((accept, reject) => {
    fs.readFile(filename, (error3, data3) => {
      if (error3)
        reject(error3);
      else
        accept(data3);
    });
  }) : fileReject;
}
async function fileReject() {
  error2("No file system access.");
}
function httpLoader(fetch2) {
  return fetch2 ? async function(url, options2) {
    const opt = extend2({}, this.options.http, options2), type4 = options2 && options2.response, response = await fetch2(url, opt);
    return !response.ok ? error2(response.status + "" + response.statusText) : isFunction2(response[type4]) ? response[type4]() : response.text();
  } : httpReject;
}
async function httpReject() {
  error2("No HTTP fetch method available.");
}
function inferType(values5, field4) {
  if (!values5 || !values5.length)
    return "unknown";
  const n = values5.length, m2 = typeTests.length, a4 = typeTests.map((_, i) => i + 1);
  for (let i = 0, t = 0, j, value4; i < n; ++i) {
    value4 = field4 ? values5[i][field4] : values5[i];
    for (j = 0; j < m2; ++j) {
      if (a4[j] && isValid(value4) && !typeTests[j](value4)) {
        a4[j] = 0;
        ++t;
        if (t === typeTests.length)
          return "string";
      }
    }
  }
  return typeList[a4.reduce((u, v) => u === 0 ? v : u, 0) - 1];
}
function inferTypes(data3, fields) {
  return fields.reduce((types4, field4) => {
    types4[field4] = inferType(data3, field4);
    return types4;
  }, {});
}
function delimitedFormat(delimiter) {
  const parse8 = function(data3, format9) {
    const delim = {
      delimiter
    };
    return dsv(data3, format9 ? extend2(format9, delim) : delim);
  };
  parse8.responseType = "text";
  return parse8;
}
function dsv(data3, format9) {
  if (format9.header) {
    data3 = format9.header.map($2).join(format9.delimiter) + "\n" + data3;
  }
  return dsv_default(format9.delimiter).parse(data3 + "");
}
function isBuffer(_) {
  return typeof Buffer === "function" && isFunction2(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json(data3, format9) {
  const prop = format9 && format9.property ? field2(format9.property) : identity2;
  return isObject2(data3) && !isBuffer(data3) ? parseJSON(prop(data3), format9) : prop(JSON.parse(data3));
}
function parseJSON(data3, format9) {
  if (!isArray2(data3) && isIterable2(data3)) {
    data3 = [...data3];
  }
  return format9 && format9.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}
function topojson(data3, format9) {
  let method3, object2, property2, filter6;
  data3 = json(data3, format9);
  if (format9 && format9.feature) {
    method3 = feature_default;
    property2 = format9.feature;
  } else if (format9 && format9.mesh) {
    method3 = mesh_default;
    property2 = format9.mesh;
    filter6 = filters[format9.filter];
  } else {
    error2("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method3(data3, object2, filter6) : error2("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
function formats(name4, reader) {
  if (arguments.length > 1) {
    format2[name4] = reader;
    return this;
  } else {
    return has2(format2, name4) ? format2[name4] : null;
  }
}
function responseType(type4) {
  const f = formats(type4);
  return f && f.responseType || "text";
}
function read(data3, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats(schema.type || "json");
  if (!reader)
    error2("Unknown data format type: " + schema.type);
  data3 = reader(data3, schema);
  if (schema.parse)
    parse(data3, schema.parse, timeParser, utcParser);
  if (has2(data3, "columns"))
    delete data3.columns;
  return data3;
}
function parse(data3, types4, timeParser, utcParser) {
  if (!data3.length)
    return;
  const locale7 = timeFormatDefaultLocale();
  timeParser = timeParser || locale7.timeParse;
  utcParser = utcParser || locale7.utcParse;
  let fields = data3.columns || Object.keys(data3[0]), datum2, field4, i, j, n, m2;
  if (types4 === "auto")
    types4 = inferTypes(data3, fields);
  fields = Object.keys(types4);
  const parsers = fields.map((field5) => {
    const type4 = types4[field5];
    let parts, pattern;
    if (type4 && (type4.startsWith("date:") || type4.startsWith("utc:"))) {
      parts = type4.split(/:(.+)?/, 2);
      pattern = parts[1];
      if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }
      const parse8 = parts[0] === "utc" ? utcParser : timeParser;
      return parse8(pattern);
    }
    if (!typeParsers[type4]) {
      throw Error("Illegal format pattern: " + field5 + ":" + type4);
    }
    return typeParsers[type4];
  });
  for (i = 0, n = data3.length, m2 = fields.length; i < n; ++i) {
    datum2 = data3[i];
    for (j = 0; j < m2; ++j) {
      field4 = fields[j];
      datum2[field4] = parsers[j](datum2[field4]);
    }
  }
}
var protocol_re, allowed_re, whitespace_re, fileProtocol, isValid, isBoolean2, isDate3, isNumber3, isInteger2, typeParsers, typeTests, typeList, filters, format2, loader;
var init_vega_loader_browser_module = __esm({
  "node_modules/.pnpm/vega-loader@4.5.1/node_modules/vega-loader/build/vega-loader.browser.module.js"() {
    init_vega_util_module2();
    init_src();
    init_src2();
    init_vega_format_module();
    protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/;
    allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
    whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
    fileProtocol = "file://";
    isValid = (_) => _ != null && _ === _;
    isBoolean2 = (_) => _ === "true" || _ === "false" || _ === true || _ === false;
    isDate3 = (_) => !Number.isNaN(Date.parse(_));
    isNumber3 = (_) => !Number.isNaN(+_) && !(_ instanceof Date);
    isInteger2 = (_) => isNumber3(_) && Number.isInteger(+_);
    typeParsers = {
      boolean: toBoolean2,
      integer: toNumber2,
      number: toNumber2,
      date: toDate2,
      string: toString2,
      unknown: identity2
    };
    typeTests = [isBoolean2, isInteger2, isNumber3, isDate3];
    typeList = ["boolean", "integer", "number", "date"];
    dsv.responseType = "text";
    json.responseType = "json";
    filters = {
      interior: (a4, b3) => a4 !== b3,
      exterior: (a4, b3) => a4 === b3
    };
    topojson.responseType = "json";
    format2 = {
      dsv,
      csv: delimitedFormat(","),
      tsv: delimitedFormat("	"),
      json,
      topojson
    };
    loader = loaderFactory(
      typeof fetch !== "undefined" && fetch,
      null
    );
  }
});

// node_modules/.pnpm/vega-dataflow@5.7.5/node_modules/vega-dataflow/build/vega-dataflow.module.js
function UniqueList(idFunc) {
  const $4 = idFunc || identity2, list = [], ids = {};
  list.add = (_) => {
    const id4 = $4(_);
    if (!ids[id4]) {
      ids[id4] = 1;
      list.push(_);
    }
    return list;
  };
  list.remove = (_) => {
    const id4 = $4(_);
    if (ids[id4]) {
      ids[id4] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0)
        list.splice(idx, 1);
    }
    return list;
  };
  return list;
}
async function asyncCallback(df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}
function isTuple(t) {
  return !!(t && tupleid(t));
}
function tupleid(t) {
  return t[TUPLE_ID_KEY];
}
function setid(t, id4) {
  t[TUPLE_ID_KEY] = id4;
  return t;
}
function ingest$1(datum2) {
  const t = datum2 === Object(datum2) ? datum2 : {
    data: datum2
  };
  return tupleid(t) ? t : setid(t, TUPLE_ID++);
}
function derive(t) {
  return rederive(t, ingest$1({}));
}
function rederive(t, d) {
  for (const k4 in t)
    d[k4] = t[k4];
  return d;
}
function replace(t, d) {
  return setid(d, tupleid(t));
}
function stableCompare(cmp, f) {
  return !cmp ? null : f ? (a4, b3) => cmp(a4, b3) || tupleid(f(a4)) - tupleid(f(b3)) : (a4, b3) => cmp(a4, b3) || tupleid(a4) - tupleid(b3);
}
function isChangeSet(v) {
  return v && v.constructor === changeset;
}
function changeset() {
  const add7 = [], rem2 = [], mod = [], remp = [], modp = [];
  let clean = null, reflow2 = false;
  return {
    constructor: changeset,
    insert(t) {
      const d = array2(t), n = d.length;
      for (let i = 0; i < n; ++i)
        add7.push(d[i]);
      return this;
    },
    remove(t) {
      const a4 = isFunction2(t) ? remp : rem2, d = array2(t), n = d.length;
      for (let i = 0; i < n; ++i)
        a4.push(d[i]);
      return this;
    },
    modify(t, field4, value4) {
      const m2 = {
        field: field4,
        value: constant2(value4)
      };
      if (isFunction2(t)) {
        m2.filter = t;
        modp.push(m2);
      } else {
        m2.tuple = t;
        mod.push(m2);
      }
      return this;
    },
    encode(t, set8) {
      if (isFunction2(t))
        modp.push({
          filter: t,
          field: set8
        });
      else
        mod.push({
          tuple: t,
          field: set8
        });
      return this;
    },
    clean(value4) {
      clean = value4;
      return this;
    },
    reflow() {
      reflow2 = true;
      return this;
    },
    pulse(pulse2, tuples) {
      const cur = {}, out = {};
      let i, n, m2, f, t, id4;
      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      }
      for (i = 0, n = rem2.length; i < n; ++i) {
        t = rem2[i];
        cur[tupleid(t)] = -1;
      }
      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach((t4) => {
          if (f(t4))
            cur[tupleid(t4)] = -1;
        });
      }
      for (i = 0, n = add7.length; i < n; ++i) {
        t = add7[i];
        id4 = tupleid(t);
        if (cur[id4]) {
          cur[id4] = 1;
        } else {
          pulse2.add.push(ingest$1(add7[i]));
        }
      }
      for (i = 0, n = tuples.length; i < n; ++i) {
        t = tuples[i];
        if (cur[tupleid(t)] < 0)
          pulse2.rem.push(t);
      }
      function modify2(t4, f2, v) {
        if (v) {
          t4[f2] = v(t4);
        } else {
          pulse2.encode = f2;
        }
        if (!reflow2)
          out[tupleid(t4)] = t4;
      }
      for (i = 0, n = mod.length; i < n; ++i) {
        m2 = mod[i];
        t = m2.tuple;
        f = m2.field;
        id4 = cur[tupleid(t)];
        if (id4 > 0) {
          modify2(t, f, m2.value);
          pulse2.modifies(f);
        }
      }
      for (i = 0, n = modp.length; i < n; ++i) {
        m2 = modp[i];
        f = m2.filter;
        tuples.forEach((t4) => {
          if (f(t4) && cur[tupleid(t4)] > 0) {
            modify2(t4, m2.field, m2.value);
          }
        });
        pulse2.modifies(m2.field);
      }
      if (reflow2) {
        pulse2.mod = rem2.length || remp.length ? tuples.filter((t4) => cur[tupleid(t4)] > 0) : tuples.slice();
      } else {
        for (id4 in out)
          pulse2.mod.push(out[id4]);
      }
      if (clean || clean == null && (rem2.length || remp.length)) {
        pulse2.clean(true);
      }
      return pulse2;
    }
  };
}
function Parameters() {
  Object.defineProperty(this, CACHE, {
    writable: true,
    value: {}
  });
}
function Operator(init2, update3, params2, react) {
  this.id = ++OP_ID;
  this.value = init2;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;
  if (update3) {
    this._update = update3;
  }
  if (params2)
    this.parameters(params2, react);
}
function flag(bit) {
  return function(state) {
    const f = this.flags;
    if (arguments.length === 0)
      return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}
function add(init2, update3, params2, react) {
  let shift = 1, op;
  if (init2 instanceof Operator) {
    op = init2;
  } else if (init2 && init2.prototype instanceof Operator) {
    op = new init2();
  } else if (isFunction2(init2)) {
    op = new Operator(null, init2);
  } else {
    shift = 0;
    op = new Operator(init2, update3);
  }
  this.rank(op);
  if (shift) {
    react = params2;
    params2 = update3;
  }
  if (params2)
    this.connect(op, op.parameters(params2, react));
  this.touch(op);
  return op;
}
function connect(target2, sources) {
  const targetRank = target2.rank, n = sources.length;
  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target2);
      return;
    }
  }
}
function EventStream(filter6, apply3, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive)
    this.receive = receive;
  if (filter6)
    this._filter = filter6;
  if (apply3)
    this._apply = apply3;
}
function stream(filter6, apply3, receive) {
  return new EventStream(filter6, apply3, receive);
}
function events(source5, type4, filter6, apply3) {
  const df = this, s3 = stream(filter6, apply3), send = function(e3) {
    e3.dataflow = df;
    try {
      s3.receive(e3);
    } catch (error3) {
      df.error(error3);
    } finally {
      df.run();
    }
  };
  let sources;
  if (typeof source5 === "string" && typeof document !== "undefined") {
    sources = document.querySelectorAll(source5);
  } else {
    sources = array2(source5);
  }
  const n = sources.length;
  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type4, send);
  }
  return s3;
}
function parse2(data3, format9) {
  const locale7 = this.locale();
  return read(data3, format9, locale7.timeParse, locale7.utcParse);
}
function ingest(target2, data3, format9) {
  data3 = this.parse(data3, format9);
  return this.pulse(target2, this.changeset().insert(data3));
}
async function request(url, format9) {
  const df = this;
  let status = 0, data3;
  try {
    data3 = await df.loader().load(url, {
      context: "dataflow",
      response: responseType(format9 && format9.type)
    });
    try {
      data3 = df.parse(data3, format9);
    } catch (err) {
      status = -2;
      df.warn("Data ingestion failed", url, err);
    }
  } catch (err) {
    status = -1;
    df.warn("Loading failed", url, err);
  }
  return {
    data: data3,
    status
  };
}
async function preload(target2, url, format9) {
  const df = this, pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format9);
  df.pulse(target2, df.changeset().remove(truthy2).insert(res.data || []));
  pending.done();
  return res;
}
function loadPending(df) {
  let accept;
  const pending = new Promise((a4) => accept = a4);
  pending.requests = 0;
  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };
  return df._pending = pending;
}
function on(source5, target2, update3, params2, options2) {
  const fn = source5 instanceof Operator ? onOperator : onStream;
  fn(this, source5, target2, update3, params2, options2);
  return this;
}
function onStream(df, stream2, target2, update3, params2, options2) {
  const opt = extend2({}, options2, SKIP);
  let func, op;
  if (!isFunction2(target2))
    target2 = constant2(target2);
  if (update3 === void 0) {
    func = (e3) => df.touch(target2(e3));
  } else if (isFunction2(update3)) {
    op = new Operator(null, update3, params2, false);
    func = (e3) => {
      op.evaluate(e3);
      const t = target2(e3), v = op.value;
      isChangeSet(v) ? df.pulse(t, v, options2) : df.update(t, v, opt);
    };
  } else {
    func = (e3) => df.update(target2(e3), update3, opt);
  }
  stream2.apply(func);
}
function onOperator(df, source5, target2, update3, params2, options2) {
  if (update3 === void 0) {
    source5.targets().add(target2);
  } else {
    const opt = options2 || {}, op = new Operator(null, updater(target2, update3), params2, false);
    op.modified(opt.force);
    op.rank = source5.rank;
    source5.targets().add(op);
    if (target2) {
      op.skip(true);
      op.value = target2.value;
      op.targets().add(target2);
      df.connect(target2, [op]);
    }
  }
}
function updater(target2, update3) {
  update3 = isFunction2(update3) ? update3 : constant2(update3);
  return target2 ? function(_, pulse2) {
    const value4 = update3(_, pulse2);
    if (!target2.skip()) {
      target2.skip(value4 !== this.value).value = value4;
    }
    return value4;
  } : update3;
}
function rank2(op) {
  op.rank = ++this._rank;
}
function rerank(op) {
  const queue = [op];
  let cur, list, i;
  while (queue.length) {
    this.rank(cur = queue.pop());
    if (list = cur._targets) {
      for (i = list.length; --i >= 0; ) {
        queue.push(cur = list[i]);
        if (cur === op)
          error2("Cycle detected in dataflow graph.");
      }
    }
  }
}
function Pulse(dataflow, stamp, encode2) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode2 || null;
}
function materialize(data3, filter6) {
  const out = [];
  visitArray2(data3, filter6, (_) => out.push(_));
  return out;
}
function filter2(pulse2, flags) {
  const map11 = {};
  pulse2.visit(flags, (t) => {
    map11[tupleid(t)] = 1;
  });
  return (t) => map11[tupleid(t)] ? null : t;
}
function addFilter(a4, b3) {
  return a4 ? (t, i) => a4(t, i) && b3(t, i) : b3;
}
function MultiPulse(dataflow, stamp, pulses, encode2) {
  const p = this;
  let c2 = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode2 || null;
  this.pulses = pulses;
  for (const pulse2 of pulses) {
    if (pulse2.stamp !== stamp)
      continue;
    if (pulse2.fields) {
      const hash2 = p.fields || (p.fields = {});
      for (const f in pulse2.fields) {
        hash2[f] = 1;
      }
    }
    if (pulse2.changed(p.ADD))
      c2 |= p.ADD;
    if (pulse2.changed(p.REM))
      c2 |= p.REM;
    if (pulse2.changed(p.MOD))
      c2 |= p.MOD;
  }
  this.changes = c2;
}
async function evaluate(encode2, prerun, postrun) {
  const df = this, async = [];
  if (df._pulse)
    return reentrant(df);
  if (df._pending)
    await df._pending;
  if (prerun)
    await asyncCallback(df, prerun);
  if (!df._touched.length) {
    df.debug("Dataflow invoked, but nothing to do.");
    return df;
  }
  const stamp = ++df._clock;
  df._pulse = new Pulse(df, stamp, encode2);
  df._touched.forEach((op2) => df._enqueue(op2, true));
  df._touched = UniqueList(id2);
  let count5 = 0, op, next, error3;
  try {
    while (df._heap.size() > 0) {
      op = df._heap.pop();
      if (op.rank !== op.qrank) {
        df._enqueue(op, true);
        continue;
      }
      next = op.run(df._getPulse(op, encode2));
      if (next.then) {
        next = await next;
      } else if (next.async) {
        async.push(next.async);
        next = StopPropagation;
      }
      if (next !== StopPropagation) {
        if (op._targets)
          op._targets.forEach((op2) => df._enqueue(op2));
      }
      ++count5;
    }
  } catch (err) {
    df._heap.clear();
    error3 = err;
  }
  df._input = {};
  df._pulse = null;
  df.debug(`Pulse ${stamp}: ${count5} operators`);
  if (error3) {
    df._postrun = [];
    df.error(error3);
  }
  if (df._postrun.length) {
    const pr = df._postrun.sort((a4, b3) => b3.priority - a4.priority);
    df._postrun = [];
    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  }
  if (postrun)
    await asyncCallback(df, postrun);
  if (async.length) {
    Promise.all(async).then((cb) => df.runAsync(null, () => {
      cb.forEach((f) => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }
  return df;
}
async function runAsync(encode2, prerun, postrun) {
  while (this._running)
    await this._running;
  const clear2 = () => this._running = null;
  (this._running = this.evaluate(encode2, prerun, postrun)).then(clear2, clear2);
  return this._running;
}
function run(encode2, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode2, prerun, postrun), this);
}
function runAfter(callback, enqueue2, priority) {
  if (this._pulse || enqueue2) {
    this._postrun.push({
      priority: priority || 0,
      callback
    });
  } else {
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}
function reentrant(df) {
  df.error("Dataflow already running. Use runAsync() to chain invocations.");
  return df;
}
function enqueue(op, force) {
  const q = op.stamp < this._clock;
  if (q)
    op.stamp = this._clock;
  if (q || force) {
    op.qrank = op.rank;
    this._heap.push(op);
  }
}
function getPulse(op, encode2) {
  const s3 = op.source, stamp = this._clock;
  return s3 && isArray2(s3) ? new MultiPulse(this, stamp, s3.map((_) => _.pulse), encode2) : this._input[op.id] || singlePulse(this._pulse, s3 && s3.pulse);
}
function singlePulse(p, s3) {
  if (s3 && s3.stamp === p.stamp) {
    return s3;
  }
  p = p.fork();
  if (s3 && s3 !== StopPropagation) {
    p.source = s3.source;
  }
  return p;
}
function touch(op, options2) {
  const opt = options2 || NO_OPT;
  if (this._pulse) {
    this._enqueue(op);
  } else {
    this._touched.add(op);
  }
  if (opt.skip)
    op.skip(true);
  return this;
}
function update(op, value4, options2) {
  const opt = options2 || NO_OPT;
  if (op.set(value4) || opt.force) {
    this.touch(op, opt);
  }
  return this;
}
function pulse(op, changeset2, options2) {
  this.touch(op, options2 || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)), t = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset2.pulse(p, t);
  return this;
}
function Heap(cmp) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: (x7) => {
      nodes.push(x7);
      return siftdown(nodes, 0, nodes.length - 1, cmp);
    },
    pop: () => {
      const last = nodes.pop();
      let item;
      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp);
      } else {
        item = last;
      }
      return item;
    }
  };
}
function siftdown(array9, start, idx, cmp) {
  let parent, pidx;
  const item = array9[idx];
  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array9[pidx];
    if (cmp(item, parent) < 0) {
      array9[idx] = parent;
      idx = pidx;
      continue;
    }
    break;
  }
  return array9[idx] = item;
}
function siftup(array9, idx, cmp) {
  const start = idx, end = array9.length, item = array9[idx];
  let cidx = (idx << 1) + 1, ridx;
  while (cidx < end) {
    ridx = cidx + 1;
    if (ridx < end && cmp(array9[cidx], array9[ridx]) >= 0) {
      cidx = ridx;
    }
    array9[idx] = array9[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }
  array9[idx] = item;
  return siftdown(array9, start, idx, cmp);
}
function Dataflow() {
  this.logger(logger2());
  this.logLevel(Error$12);
  this._clock = 0;
  this._rank = 0;
  this._locale = defaultLocale3();
  try {
    this._loader = loader();
  } catch (e3) {
  }
  this._touched = UniqueList(id2);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a4, b3) => a4.qrank - b3.qrank);
  this._postrun = [];
}
function logMethod(method3) {
  return function() {
    return this._log[method3].apply(this, arguments);
  };
}
function Transform(init2, params2) {
  Operator.call(this, init2, null, params2);
}
function definition(type4) {
  const t = transform(type4);
  return t && t.Definition || null;
}
function transform(type4) {
  type4 = type4 && type4.toLowerCase();
  return has2(transforms, type4) ? transforms[type4] : null;
}
var TUPLE_ID_KEY, TUPLE_ID, CACHE, OP_ID, PULSE, NO_PARAMS, SKIP$1, MODIFIED, STREAM_ID, SKIP, StopPropagation, ADD, REM, MOD, ADD_REM, ADD_MOD, ALL, REFLOW, SOURCE, NO_SOURCE, NO_FIELDS, NO_OPT, transforms;
var init_vega_dataflow_module = __esm({
  "node_modules/.pnpm/vega-dataflow@5.7.5/node_modules/vega-dataflow/build/vega-dataflow.module.js"() {
    init_vega_util_module2();
    init_vega_loader_browser_module();
    init_vega_format_module();
    TUPLE_ID_KEY = Symbol("vega_id");
    TUPLE_ID = 1;
    CACHE = "_:mod:_";
    Parameters.prototype = {
      set(name4, index8, value4, force) {
        const o = this, v = o[name4], mod = o[CACHE];
        if (index8 != null && index8 >= 0) {
          if (v[index8] !== value4 || force) {
            v[index8] = value4;
            mod[index8 + ":" + name4] = -1;
            mod[name4] = -1;
          }
        } else if (v !== value4 || force) {
          o[name4] = value4;
          mod[name4] = isArray2(value4) ? 1 + value4.length : -1;
        }
        return o;
      },
      modified(name4, index8) {
        const mod = this[CACHE];
        if (!arguments.length) {
          for (const k4 in mod) {
            if (mod[k4])
              return true;
          }
          return false;
        } else if (isArray2(name4)) {
          for (let k4 = 0; k4 < name4.length; ++k4) {
            if (mod[name4[k4]])
              return true;
          }
          return false;
        }
        return index8 != null && index8 >= 0 ? index8 + 1 < mod[name4] || !!mod[index8 + ":" + name4] : !!mod[name4];
      },
      clear() {
        this[CACHE] = {};
        return this;
      }
    };
    OP_ID = 0;
    PULSE = "pulse";
    NO_PARAMS = new Parameters();
    SKIP$1 = 1;
    MODIFIED = 2;
    Operator.prototype = {
      targets() {
        return this._targets || (this._targets = UniqueList(id2));
      },
      set(value4) {
        if (this.value !== value4) {
          this.value = value4;
          return 1;
        } else {
          return 0;
        }
      },
      skip: flag(SKIP$1),
      modified: flag(MODIFIED),
      parameters(params2, react, initonly) {
        react = react !== false;
        const argval = this._argval = this._argval || new Parameters(), argops = this._argops = this._argops || [], deps = [];
        let name4, value4, n, i;
        const add7 = (name5, index8, value5) => {
          if (value5 instanceof Operator) {
            if (value5 !== this) {
              if (react)
                value5.targets().add(this);
              deps.push(value5);
            }
            argops.push({
              op: value5,
              name: name5,
              index: index8
            });
          } else {
            argval.set(name5, index8, value5);
          }
        };
        for (name4 in params2) {
          value4 = params2[name4];
          if (name4 === PULSE) {
            array2(value4).forEach((op) => {
              if (!(op instanceof Operator)) {
                error2("Pulse parameters must be operator instances.");
              } else if (op !== this) {
                op.targets().add(this);
                deps.push(op);
              }
            });
            this.source = value4;
          } else if (isArray2(value4)) {
            argval.set(name4, -1, Array(n = value4.length));
            for (i = 0; i < n; ++i)
              add7(name4, i, value4[i]);
          } else {
            add7(name4, -1, value4);
          }
        }
        this.marshall().clear();
        if (initonly)
          argops.initonly = true;
        return deps;
      },
      marshall(stamp) {
        const argval = this._argval || NO_PARAMS, argops = this._argops;
        let item, i, op, mod;
        if (argops) {
          const n = argops.length;
          for (i = 0; i < n; ++i) {
            item = argops[i];
            op = item.op;
            mod = op.modified() && op.stamp === stamp;
            argval.set(item.name, item.index, op.value, mod);
          }
          if (argops.initonly) {
            for (i = 0; i < n; ++i) {
              item = argops[i];
              item.op.targets().remove(this);
            }
            this._argops = null;
            this._update = null;
          }
        }
        return argval;
      },
      detach() {
        const argops = this._argops;
        let i, n, item, op;
        if (argops) {
          for (i = 0, n = argops.length; i < n; ++i) {
            item = argops[i];
            op = item.op;
            if (op._targets) {
              op._targets.remove(this);
            }
          }
        }
        this.pulse = null;
        this.source = null;
      },
      evaluate(pulse2) {
        const update3 = this._update;
        if (update3) {
          const params2 = this.marshall(pulse2.stamp), v = update3.call(this, params2, pulse2);
          params2.clear();
          if (v !== this.value) {
            this.value = v;
          } else if (!this.modified()) {
            return pulse2.StopPropagation;
          }
        }
      },
      run(pulse2) {
        if (pulse2.stamp < this.stamp)
          return pulse2.StopPropagation;
        let rv;
        if (this.skip()) {
          this.skip(false);
          rv = 0;
        } else {
          rv = this.evaluate(pulse2);
        }
        return this.pulse = rv || pulse2;
      }
    };
    STREAM_ID = 0;
    EventStream.prototype = {
      _filter: truthy2,
      _apply: identity2,
      targets() {
        return this._targets || (this._targets = UniqueList(id2));
      },
      consume(_) {
        if (!arguments.length)
          return !!this._consume;
        this._consume = !!_;
        return this;
      },
      receive(evt) {
        if (this._filter(evt)) {
          const val = this.value = this._apply(evt), trg = this._targets, n = trg ? trg.length : 0;
          for (let i = 0; i < n; ++i)
            trg[i].receive(val);
          if (this._consume) {
            evt.preventDefault();
            evt.stopPropagation();
          }
        }
      },
      filter(filter6) {
        const s3 = stream(filter6);
        this.targets().add(s3);
        return s3;
      },
      apply(apply3) {
        const s3 = stream(null, apply3);
        this.targets().add(s3);
        return s3;
      },
      merge() {
        const s3 = stream();
        this.targets().add(s3);
        for (let i = 0, n = arguments.length; i < n; ++i) {
          arguments[i].targets().add(s3);
        }
        return s3;
      },
      throttle(pause) {
        let t = -1;
        return this.filter(() => {
          const now2 = Date.now();
          if (now2 - t > pause) {
            t = now2;
            return 1;
          } else {
            return 0;
          }
        });
      },
      debounce(delay) {
        const s3 = stream();
        this.targets().add(stream(null, null, debounce2(delay, (e3) => {
          const df = e3.dataflow;
          s3.receive(e3);
          if (df && df.run)
            df.run();
        })));
        return s3;
      },
      between(a4, b3) {
        let active = false;
        a4.targets().add(stream(null, null, () => active = true));
        b3.targets().add(stream(null, null, () => active = false));
        return this.filter(() => active);
      },
      detach() {
        this._filter = truthy2;
        this._targets = null;
      }
    };
    SKIP = {
      skip: true
    };
    StopPropagation = {};
    ADD = 1 << 0;
    REM = 1 << 1;
    MOD = 1 << 2;
    ADD_REM = ADD | REM;
    ADD_MOD = ADD | MOD;
    ALL = ADD | REM | MOD;
    REFLOW = 1 << 3;
    SOURCE = 1 << 4;
    NO_SOURCE = 1 << 5;
    NO_FIELDS = 1 << 6;
    Pulse.prototype = {
      StopPropagation,
      ADD,
      REM,
      MOD,
      ADD_REM,
      ADD_MOD,
      ALL,
      REFLOW,
      SOURCE,
      NO_SOURCE,
      NO_FIELDS,
      fork(flags) {
        return new Pulse(this.dataflow).init(this, flags);
      },
      clone() {
        const p = this.fork(ALL);
        p.add = p.add.slice();
        p.rem = p.rem.slice();
        p.mod = p.mod.slice();
        if (p.source)
          p.source = p.source.slice();
        return p.materialize(ALL | SOURCE);
      },
      addAll() {
        let p = this;
        const reuse = !p.source || p.add === p.rem || !p.rem.length && p.source.length === p.add.length;
        if (reuse) {
          return p;
        } else {
          p = new Pulse(this.dataflow).init(this);
          p.add = p.source;
          p.rem = [];
          return p;
        }
      },
      init(src, flags) {
        const p = this;
        p.stamp = src.stamp;
        p.encode = src.encode;
        if (src.fields && !(flags & NO_FIELDS)) {
          p.fields = src.fields;
        }
        if (flags & ADD) {
          p.addF = src.addF;
          p.add = src.add;
        } else {
          p.addF = null;
          p.add = [];
        }
        if (flags & REM) {
          p.remF = src.remF;
          p.rem = src.rem;
        } else {
          p.remF = null;
          p.rem = [];
        }
        if (flags & MOD) {
          p.modF = src.modF;
          p.mod = src.mod;
        } else {
          p.modF = null;
          p.mod = [];
        }
        if (flags & NO_SOURCE) {
          p.srcF = null;
          p.source = null;
        } else {
          p.srcF = src.srcF;
          p.source = src.source;
          if (src.cleans)
            p.cleans = src.cleans;
        }
        return p;
      },
      runAfter(func) {
        this.dataflow.runAfter(func);
      },
      changed(flags) {
        const f = flags || ALL;
        return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;
      },
      reflow(fork) {
        if (fork)
          return this.fork(ALL).reflow();
        const len = this.add.length, src = this.source && this.source.length;
        if (src && src !== len) {
          this.mod = this.source;
          if (len)
            this.filter(MOD, filter2(this, ADD));
        }
        return this;
      },
      clean(value4) {
        if (arguments.length) {
          this.cleans = !!value4;
          return this;
        } else {
          return this.cleans;
        }
      },
      modifies(_) {
        const hash2 = this.fields || (this.fields = {});
        if (isArray2(_)) {
          _.forEach((f) => hash2[f] = true);
        } else {
          hash2[_] = true;
        }
        return this;
      },
      modified(_, nomod) {
        const fields = this.fields;
        return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray2(_) ? _.some((f) => fields[f]) : fields[_];
      },
      filter(flags, filter6) {
        const p = this;
        if (flags & ADD)
          p.addF = addFilter(p.addF, filter6);
        if (flags & REM)
          p.remF = addFilter(p.remF, filter6);
        if (flags & MOD)
          p.modF = addFilter(p.modF, filter6);
        if (flags & SOURCE)
          p.srcF = addFilter(p.srcF, filter6);
        return p;
      },
      materialize(flags) {
        flags = flags || ALL;
        const p = this;
        if (flags & ADD && p.addF) {
          p.add = materialize(p.add, p.addF);
          p.addF = null;
        }
        if (flags & REM && p.remF) {
          p.rem = materialize(p.rem, p.remF);
          p.remF = null;
        }
        if (flags & MOD && p.modF) {
          p.mod = materialize(p.mod, p.modF);
          p.modF = null;
        }
        if (flags & SOURCE && p.srcF) {
          p.source = p.source.filter(p.srcF);
          p.srcF = null;
        }
        return p;
      },
      visit(flags, visitor) {
        const p = this, v = visitor;
        if (flags & SOURCE) {
          visitArray2(p.source, p.srcF, v);
          return p;
        }
        if (flags & ADD)
          visitArray2(p.add, p.addF, v);
        if (flags & REM)
          visitArray2(p.rem, p.remF, v);
        if (flags & MOD)
          visitArray2(p.mod, p.modF, v);
        const src = p.source;
        if (flags & REFLOW && src) {
          const sum6 = p.add.length + p.mod.length;
          if (sum6 === src.length)
            ;
          else if (sum6) {
            visitArray2(src, filter2(p, ADD_MOD), v);
          } else {
            visitArray2(src, p.srcF, v);
          }
        }
        return p;
      }
    };
    inherits2(MultiPulse, Pulse, {
      fork(flags) {
        const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);
        if (flags !== void 0) {
          if (flags & p.ADD)
            this.visit(p.ADD, (t) => p.add.push(t));
          if (flags & p.REM)
            this.visit(p.REM, (t) => p.rem.push(t));
          if (flags & p.MOD)
            this.visit(p.MOD, (t) => p.mod.push(t));
        }
        return p;
      },
      changed(flags) {
        return this.changes & flags;
      },
      modified(_) {
        const p = this, fields = p.fields;
        return !(fields && p.changes & p.MOD) ? 0 : isArray2(_) ? _.some((f) => fields[f]) : fields[_];
      },
      filter() {
        error2("MultiPulse does not support filtering.");
      },
      materialize() {
        error2("MultiPulse does not support materialization.");
      },
      visit(flags, visitor) {
        const p = this, pulses = p.pulses, n = pulses.length;
        let i = 0;
        if (flags & p.SOURCE) {
          for (; i < n; ++i) {
            pulses[i].visit(flags, visitor);
          }
        } else {
          for (; i < n; ++i) {
            if (pulses[i].stamp === p.stamp) {
              pulses[i].visit(flags, visitor);
            }
          }
        }
        return p;
      }
    });
    NO_OPT = {
      skip: false,
      force: false
    };
    Dataflow.prototype = {
      stamp() {
        return this._clock;
      },
      loader(_) {
        if (arguments.length) {
          this._loader = _;
          return this;
        } else {
          return this._loader;
        }
      },
      locale(_) {
        if (arguments.length) {
          this._locale = _;
          return this;
        } else {
          return this._locale;
        }
      },
      logger(logger3) {
        if (arguments.length) {
          this._log = logger3;
          return this;
        } else {
          return this._log;
        }
      },
      error: logMethod("error"),
      warn: logMethod("warn"),
      info: logMethod("info"),
      debug: logMethod("debug"),
      logLevel: logMethod("level"),
      cleanThreshold: 1e4,
      add,
      connect,
      rank: rank2,
      rerank,
      pulse,
      touch,
      update,
      changeset,
      ingest,
      parse: parse2,
      preload,
      request,
      events,
      on,
      evaluate,
      run,
      runAsync,
      runAfter,
      _enqueue: enqueue,
      _getPulse: getPulse
    };
    inherits2(Transform, Operator, {
      run(pulse2) {
        if (pulse2.stamp < this.stamp)
          return pulse2.StopPropagation;
        let rv;
        if (this.skip()) {
          this.skip(false);
        } else {
          rv = this.evaluate(pulse2);
        }
        rv = rv || pulse2;
        if (rv.then) {
          rv = rv.then((_) => this.pulse = _);
        } else if (rv !== pulse2.StopPropagation) {
          this.pulse = rv;
        }
        return rv;
      },
      evaluate(pulse2) {
        const params2 = this.marshall(pulse2.stamp), out = this.transform(params2, pulse2);
        params2.clear();
        return out;
      },
      transform() {
      }
    });
    transforms = {};
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/ascending.js
function ascending_default(a4, b3) {
  return a4 < b3 ? -1 : a4 > b3 ? 1 : a4 >= b3 ? 0 : NaN;
}
var init_ascending2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/ascending.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare6 = f;
  if (f.length === 1) {
    delta = (d, x7) => f(d) - x7;
    compare6 = ascendingComparator(f);
  }
  function left(a4, x7, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a4.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare6(a4[mid], x7) < 0)
        lo = mid + 1;
      else
        hi = mid;
    }
    return lo;
  }
  function right(a4, x7, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a4.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare6(a4[mid], x7) > 0)
        hi = mid;
      else
        lo = mid + 1;
    }
    return lo;
  }
  function center(a4, x7, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a4.length;
    const i = left(a4, x7, lo, hi - 1);
    return i > lo && delta(a4[i - 1], x7) > -delta(a4[i], x7) ? i - 1 : i;
  }
  return { left, center, right };
}
function ascendingComparator(f) {
  return (d, x7) => ascending_default(f(d), x7);
}
var init_bisector2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/bisector.js"() {
    init_ascending2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/number.js
function number_default(x7) {
  return x7 === null ? NaN : +x7;
}
function* numbers2(values5, valueof) {
  if (valueof === void 0) {
    for (let value4 of values5) {
      if (value4 != null && (value4 = +value4) >= value4) {
        yield value4;
      }
    }
  } else {
    let index8 = -1;
    for (let value4 of values5) {
      if ((value4 = valueof(value4, ++index8, values5)) != null && (value4 = +value4) >= value4) {
        yield value4;
      }
    }
  }
}
var init_number2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/number.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/bisect.js
var ascendingBisect2, bisectRight2, bisectLeft2, bisectCenter2, bisect_default3;
var init_bisect3 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/bisect.js"() {
    init_ascending2();
    init_bisector2();
    init_number2();
    ascendingBisect2 = bisector_default(ascending_default);
    bisectRight2 = ascendingBisect2.right;
    bisectLeft2 = ascendingBisect2.left;
    bisectCenter2 = bisector_default(number_default).center;
    bisect_default3 = bisectRight2;
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/count.js
var init_count2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/count.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/cross.js
var init_cross2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/cross.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/cumsum.js
var init_cumsum2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/cumsum.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/descending.js
var init_descending2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/descending.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/variance.js
function variance2(values5, valueof) {
  let count5 = 0;
  let delta;
  let mean4 = 0;
  let sum6 = 0;
  if (valueof === void 0) {
    for (let value4 of values5) {
      if (value4 != null && (value4 = +value4) >= value4) {
        delta = value4 - mean4;
        mean4 += delta / ++count5;
        sum6 += delta * (value4 - mean4);
      }
    }
  } else {
    let index8 = -1;
    for (let value4 of values5) {
      if ((value4 = valueof(value4, ++index8, values5)) != null && (value4 = +value4) >= value4) {
        delta = value4 - mean4;
        mean4 += delta / ++count5;
        sum6 += delta * (value4 - mean4);
      }
    }
  }
  if (count5 > 1)
    return sum6 / (count5 - 1);
}
var init_variance2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/variance.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/deviation.js
function deviation2(values5, valueof) {
  const v = variance2(values5, valueof);
  return v ? Math.sqrt(v) : v;
}
var init_deviation2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/deviation.js"() {
    init_variance2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/extent.js
var init_extent2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/extent.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/fsum.js
var Adder2;
var init_fsum2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/fsum.js"() {
    Adder2 = class {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x7) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y7 = p[j], hi = x7 + y7, lo = Math.abs(x7) < Math.abs(y7) ? x7 - (hi - y7) : y7 - (hi - x7);
          if (lo)
            p[i++] = lo;
          x7 = hi;
        }
        p[i] = x7;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x7, y7, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x7 = hi;
            y7 = p[--n];
            hi = x7 + y7;
            lo = y7 - (hi - x7);
            if (lo)
              break;
          }
          if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
            y7 = lo * 2;
            x7 = hi + y7;
            if (y7 == x7 - hi)
              hi = x7;
          }
        }
        return hi;
      }
    };
  }
});

// node_modules/.pnpm/internmap@1.0.1/node_modules/internmap/src/index.js
var init_src8 = __esm({
  "node_modules/.pnpm/internmap@1.0.1/node_modules/internmap/src/index.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/identity.js
var init_identity4 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/identity.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/group.js
var init_group2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/group.js"() {
    init_src8();
    init_identity4();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/permute.js
function permute_default(source5, keys5) {
  return Array.from(keys5, (key3) => source5[key3]);
}
var init_permute2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/permute.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/sort.js
var init_sort2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/sort.js"() {
    init_ascending2();
    init_permute2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/groupSort.js
var init_groupSort2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/groupSort.js"() {
    init_ascending2();
    init_group2();
    init_sort2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/array.js
var array4, slice2, map4;
var init_array2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/array.js"() {
    array4 = Array.prototype;
    slice2 = array4.slice;
    map4 = array4.map;
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/constant.js
var init_constant2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/ticks.js
function ticks_default(start, stop2, count5) {
  var reverse6, i = -1, n, ticks3, step;
  stop2 = +stop2, start = +start, count5 = +count5;
  if (start === stop2 && count5 > 0)
    return [start];
  if (reverse6 = stop2 < start)
    n = start, start = stop2, stop2 = n;
  if ((step = tickIncrement2(start, stop2, count5)) === 0 || !isFinite(step))
    return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop2 / step);
    if (r0 * step < start)
      ++r0;
    if (r1 * step > stop2)
      --r1;
    ticks3 = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks3[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop2 * step);
    if (r0 / step < start)
      ++r0;
    if (r1 / step > stop2)
      --r1;
    ticks3 = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks3[i] = (r0 + i) / step;
  }
  if (reverse6)
    ticks3.reverse();
  return ticks3;
}
function tickIncrement2(start, stop2, count5) {
  var step = (stop2 - start) / Math.max(0, count5), power = Math.floor(Math.log(step) / Math.LN10), error3 = step / Math.pow(10, power);
  return power >= 0 ? (error3 >= e102 ? 10 : error3 >= e52 ? 5 : error3 >= e22 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error3 >= e102 ? 10 : error3 >= e52 ? 5 : error3 >= e22 ? 2 : 1);
}
function tickStep2(start, stop2, count5) {
  var step0 = Math.abs(stop2 - start) / Math.max(0, count5), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error3 = step0 / step1;
  if (error3 >= e102)
    step1 *= 10;
  else if (error3 >= e52)
    step1 *= 5;
  else if (error3 >= e22)
    step1 *= 2;
  return stop2 < start ? -step1 : step1;
}
var e102, e52, e22;
var init_ticks3 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/ticks.js"() {
    e102 = Math.sqrt(50);
    e52 = Math.sqrt(10);
    e22 = Math.sqrt(2);
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/nice.js
var init_nice2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/nice.js"() {
    init_ticks3();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/threshold/sturges.js
var init_sturges2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/threshold/sturges.js"() {
    init_count2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/bin.js
var init_bin2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/bin.js"() {
    init_array2();
    init_bisect3();
    init_constant2();
    init_extent2();
    init_identity4();
    init_nice2();
    init_ticks3();
    init_sturges2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/max.js
function max2(values5, valueof) {
  let max8;
  if (valueof === void 0) {
    for (const value4 of values5) {
      if (value4 != null && (max8 < value4 || max8 === void 0 && value4 >= value4)) {
        max8 = value4;
      }
    }
  } else {
    let index8 = -1;
    for (let value4 of values5) {
      if ((value4 = valueof(value4, ++index8, values5)) != null && (max8 < value4 || max8 === void 0 && value4 >= value4)) {
        max8 = value4;
      }
    }
  }
  return max8;
}
var init_max2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/max.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/min.js
function min2(values5, valueof) {
  let min8;
  if (valueof === void 0) {
    for (const value4 of values5) {
      if (value4 != null && (min8 > value4 || min8 === void 0 && value4 >= value4)) {
        min8 = value4;
      }
    }
  } else {
    let index8 = -1;
    for (let value4 of values5) {
      if ((value4 = valueof(value4, ++index8, values5)) != null && (min8 > value4 || min8 === void 0 && value4 >= value4)) {
        min8 = value4;
      }
    }
  }
  return min8;
}
var init_min2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/min.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/quickselect.js
function quickselect2(array9, k4, left = 0, right = array9.length - 1, compare6 = ascending_default) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m2 = k4 - left + 1;
      const z = Math.log(n);
      const s3 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s3 * (n - s3) / n) * (m2 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k4 - m2 * s3 / n + sd));
      const newRight = Math.min(right, Math.floor(k4 + (n - m2) * s3 / n + sd));
      quickselect2(array9, k4, newLeft, newRight, compare6);
    }
    const t = array9[k4];
    let i = left;
    let j = right;
    swap(array9, left, k4);
    if (compare6(array9[right], t) > 0)
      swap(array9, left, right);
    while (i < j) {
      swap(array9, i, j), ++i, --j;
      while (compare6(array9[i], t) < 0)
        ++i;
      while (compare6(array9[j], t) > 0)
        --j;
    }
    if (compare6(array9[left], t) === 0)
      swap(array9, left, j);
    else
      ++j, swap(array9, j, right);
    if (j <= k4)
      left = j + 1;
    if (k4 <= j)
      right = j - 1;
  }
  return array9;
}
function swap(array9, i, j) {
  const t = array9[i];
  array9[i] = array9[j];
  array9[j] = t;
}
var init_quickselect2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/quickselect.js"() {
    init_ascending2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/quantile.js
function quantile2(values5, p, valueof) {
  values5 = Float64Array.from(numbers2(values5, valueof));
  if (!(n = values5.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return min2(values5);
  if (p >= 1)
    return max2(values5);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max2(quickselect2(values5, i0).subarray(0, i0 + 1)), value1 = min2(values5.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted2(values5, p, valueof = number_default) {
  if (!(n = values5.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return +valueof(values5[0], 0, values5);
  if (p >= 1)
    return +valueof(values5[n - 1], n - 1, values5);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values5[i0], i0, values5), value1 = +valueof(values5[i0 + 1], i0 + 1, values5);
  return value0 + (value1 - value0) * (i - i0);
}
var init_quantile2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/quantile.js"() {
    init_max2();
    init_min2();
    init_quickselect2();
    init_number2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/threshold/freedmanDiaconis.js
var init_freedmanDiaconis2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/threshold/freedmanDiaconis.js"() {
    init_count2();
    init_quantile2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/threshold/scott.js
var init_scott2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/threshold/scott.js"() {
    init_count2();
    init_deviation2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/maxIndex.js
var init_maxIndex2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/maxIndex.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/mean.js
function mean2(values5, valueof) {
  let count5 = 0;
  let sum6 = 0;
  if (valueof === void 0) {
    for (let value4 of values5) {
      if (value4 != null && (value4 = +value4) >= value4) {
        ++count5, sum6 += value4;
      }
    }
  } else {
    let index8 = -1;
    for (let value4 of values5) {
      if ((value4 = valueof(value4, ++index8, values5)) != null && (value4 = +value4) >= value4) {
        ++count5, sum6 += value4;
      }
    }
  }
  if (count5)
    return sum6 / count5;
}
var init_mean2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/mean.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/median.js
function median_default(values5, valueof) {
  return quantile2(values5, 0.5, valueof);
}
var init_median2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/median.js"() {
    init_quantile2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array9 of arrays) {
    yield* array9;
  }
}
function merge3(arrays) {
  return Array.from(flatten(arrays));
}
var init_merge3 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/merge.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/minIndex.js
var init_minIndex2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/minIndex.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/pairs.js
var init_pairs2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/pairs.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/range.js
function range_default(start, stop2, step) {
  start = +start, stop2 = +stop2, step = (n = arguments.length) < 2 ? (stop2 = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop2 - start) / step)) | 0, range7 = new Array(n);
  while (++i < n) {
    range7[i] = start + i * step;
  }
  return range7;
}
var init_range2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/range.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/least.js
var init_least2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/least.js"() {
    init_ascending2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/leastIndex.js
var init_leastIndex2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/leastIndex.js"() {
    init_ascending2();
    init_minIndex2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/greatest.js
var init_greatest2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/greatest.js"() {
    init_ascending2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/greatestIndex.js
var init_greatestIndex2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/greatestIndex.js"() {
    init_ascending2();
    init_maxIndex2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/scan.js
var init_scan2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/scan.js"() {
    init_leastIndex2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/shuffle.js
function shuffler2(random3) {
  return function shuffle2(array9, i0 = 0, i1 = array9.length) {
    let m2 = i1 - (i0 = +i0);
    while (m2) {
      const i = random3() * m2-- | 0, t = array9[m2 + i0];
      array9[m2 + i0] = array9[i + i0];
      array9[i + i0] = t;
    }
    return array9;
  };
}
var shuffle_default2;
var init_shuffle2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/shuffle.js"() {
    shuffle_default2 = shuffler2(Math.random);
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/sum.js
function sum2(values5, valueof) {
  let sum6 = 0;
  if (valueof === void 0) {
    for (let value4 of values5) {
      if (value4 = +value4) {
        sum6 += value4;
      }
    }
  } else {
    let index8 = -1;
    for (let value4 of values5) {
      if (value4 = +valueof(value4, ++index8, values5)) {
        sum6 += value4;
      }
    }
  }
  return sum6;
}
var init_sum2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/sum.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/transpose.js
var init_transpose2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/transpose.js"() {
    init_min2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/zip.js
var init_zip2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/zip.js"() {
    init_transpose2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/every.js
var init_every2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/every.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/some.js
var init_some2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/some.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/filter.js
var init_filter2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/filter.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/map.js
var init_map2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/map.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/reduce.js
var init_reduce2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/reduce.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/reverse.js
var init_reverse3 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/reverse.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/difference.js
var init_difference2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/difference.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/disjoint.js
var init_disjoint2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/disjoint.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/set.js
var init_set = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/set.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/intersection.js
var init_intersection2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/intersection.js"() {
    init_set();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/superset.js
var init_superset2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/superset.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/subset.js
var init_subset2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/subset.js"() {
    init_superset2();
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/union.js
var init_union2 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/union.js"() {
  }
});

// node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/index.js
var init_src9 = __esm({
  "node_modules/.pnpm/d3-array@2.12.1/node_modules/d3-array/src/index.js"() {
    init_bisect3();
    init_ascending2();
    init_bisector2();
    init_count2();
    init_cross2();
    init_cumsum2();
    init_descending2();
    init_deviation2();
    init_extent2();
    init_fsum2();
    init_group2();
    init_groupSort2();
    init_bin2();
    init_freedmanDiaconis2();
    init_scott2();
    init_sturges2();
    init_max2();
    init_maxIndex2();
    init_mean2();
    init_median2();
    init_merge3();
    init_min2();
    init_minIndex2();
    init_nice2();
    init_pairs2();
    init_permute2();
    init_quantile2();
    init_quickselect2();
    init_range2();
    init_least2();
    init_leastIndex2();
    init_greatest2();
    init_greatestIndex2();
    init_scan2();
    init_shuffle2();
    init_sum2();
    init_ticks3();
    init_transpose2();
    init_variance2();
    init_zip2();
    init_every2();
    init_some2();
    init_filter2();
    init_map2();
    init_reduce2();
    init_reverse3();
    init_sort2();
    init_difference2();
    init_disjoint2();
    init_intersection2();
    init_subset2();
    init_superset2();
    init_union2();
    init_src8();
  }
});

// node_modules/.pnpm/vega-statistics@1.7.10/node_modules/vega-statistics/build/vega-statistics.module.js
function* numbers3(values5, valueof) {
  if (valueof == null) {
    for (let value4 of values5) {
      if (value4 != null && value4 !== "" && (value4 = +value4) >= value4) {
        yield value4;
      }
    }
  } else {
    let index8 = -1;
    for (let value4 of values5) {
      value4 = valueof(value4, ++index8, values5);
      if (value4 != null && value4 !== "" && (value4 = +value4) >= value4) {
        yield value4;
      }
    }
  }
}
function quantiles(array9, p, f) {
  const values5 = Float64Array.from(numbers3(array9, f));
  values5.sort(ascending_default);
  return p.map((_) => quantileSorted2(values5, _));
}
function quartiles(array9, f) {
  return quantiles(array9, [0.25, 0.5, 0.75], f);
}
function estimateBandwidth(array9, f) {
  const n = array9.length, d = deviation2(array9, f), q = quartiles(array9, f), h4 = (q[2] - q[0]) / 1.34, v = Math.min(d, h4) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n, -0.2);
}
function bin2(_) {
  const maxb = _.maxbins || 20, base3 = _.base || 10, logb = Math.log(base3), div = _.divide || [5, 2];
  let min8 = _.extent[0], max8 = _.extent[1], step, level, minstep, v, i, n;
  const span3 = _.span || max8 - min8 || Math.abs(min8) || 1;
  if (_.step) {
    step = _.step;
  } else if (_.steps) {
    v = span3 / maxb;
    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i)
      ;
    step = _.steps[Math.max(0, i - 1)];
  } else {
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base3, Math.round(Math.log(span3) / logb) - level));
    while (Math.ceil(span3 / step) > maxb) {
      step *= base3;
    }
    for (i = 0, n = div.length; i < n; ++i) {
      v = step / div[i];
      if (v >= minstep && span3 / v <= maxb)
        step = v;
    }
  }
  v = Math.log(step);
  const precision = v >= 0 ? 0 : ~~(-v / logb) + 1, eps = Math.pow(base3, -precision - 1);
  if (_.nice || _.nice === void 0) {
    v = Math.floor(min8 / step + eps) * step;
    min8 = min8 < v ? v - step : v;
    max8 = Math.ceil(max8 / step) * step;
  }
  return {
    start: min8,
    stop: max8 === min8 ? min8 + step : max8,
    step
  };
}
function setRandom(r2) {
  random = r2;
}
function bootstrapCI(array9, samples, alpha, f) {
  if (!array9.length)
    return [void 0, void 0];
  const values5 = Float64Array.from(numbers3(array9, f)), n = values5.length, m2 = samples;
  let a4, i, j, mu;
  for (j = 0, mu = Array(m2); j < m2; ++j) {
    for (a4 = 0, i = 0; i < n; ++i) {
      a4 += values5[~~(random() * n)];
    }
    mu[j] = a4 / n;
  }
  mu.sort(ascending_default);
  return [quantile2(mu, alpha / 2), quantile2(mu, 1 - alpha / 2)];
}
function dotbin(array9, step, smooth, f) {
  f = f || ((_) => _);
  const n = array9.length, v = new Float64Array(n);
  let i = 0, j = 1, a4 = f(array9[0]), b3 = a4, w5 = a4 + step, x7;
  for (; j < n; ++j) {
    x7 = f(array9[j]);
    if (x7 >= w5) {
      b3 = (a4 + b3) / 2;
      for (; i < j; ++i)
        v[i] = b3;
      w5 = x7 + step;
      a4 = x7;
    }
    b3 = x7;
  }
  b3 = (a4 + b3) / 2;
  for (; i < j; ++i)
    v[i] = b3;
  return smooth ? smoothing(v, step + step / 4) : v;
}
function smoothing(v, thresh) {
  const n = v.length;
  let a4 = 0, b3 = 1, c2, d;
  while (v[a4] === v[b3])
    ++b3;
  while (b3 < n) {
    c2 = b3 + 1;
    while (v[b3] === v[c2])
      ++c2;
    if (v[b3] - v[b3 - 1] < thresh) {
      d = b3 + (a4 + c2 - b3 - b3 >> 1);
      while (d < b3)
        v[d++] = v[b3];
      while (d > b3)
        v[d--] = v[a4];
    }
    a4 = b3;
    b3 = c2;
  }
  return v;
}
function lcg(seed) {
  return function() {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}
function integer(min8, max8) {
  if (max8 == null) {
    max8 = min8;
    min8 = 0;
  }
  let a4, b3, d;
  const dist2 = {
    min(_) {
      if (arguments.length) {
        a4 = _ || 0;
        d = b3 - a4;
        return dist2;
      } else {
        return a4;
      }
    },
    max(_) {
      if (arguments.length) {
        b3 = _ || 0;
        d = b3 - a4;
        return dist2;
      } else {
        return b3;
      }
    },
    sample() {
      return a4 + Math.floor(d * random());
    },
    pdf(x7) {
      return x7 === Math.floor(x7) && x7 >= a4 && x7 < b3 ? 1 / d : 0;
    },
    cdf(x7) {
      const v = Math.floor(x7);
      return v < a4 ? 0 : v >= b3 ? 1 : (v - a4 + 1) / d;
    },
    icdf(p) {
      return p >= 0 && p <= 1 ? a4 - 1 + Math.floor(p * d) : NaN;
    }
  };
  return dist2.min(min8).max(max8);
}
function sampleNormal(mean4, stdev) {
  mean4 = mean4 || 0;
  stdev = stdev == null ? 1 : stdev;
  let x7 = 0, y7 = 0, rds, c2;
  if (nextSample === nextSample) {
    x7 = nextSample;
    nextSample = NaN;
  } else {
    do {
      x7 = random() * 2 - 1;
      y7 = random() * 2 - 1;
      rds = x7 * x7 + y7 * y7;
    } while (rds === 0 || rds > 1);
    c2 = Math.sqrt(-2 * Math.log(rds) / rds);
    x7 *= c2;
    nextSample = y7 * c2;
  }
  return mean4 + x7 * stdev;
}
function densityNormal(value4, mean4, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value4 - (mean4 || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
}
function cumulativeNormal(value4, mean4, stdev) {
  mean4 = mean4 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value4 - mean4) / stdev, Z = Math.abs(z);
  let cd;
  if (Z > 37) {
    cd = 0;
  } else {
    const exp5 = Math.exp(-Z * Z / 2);
    let sum6;
    if (Z < 7.07106781186547) {
      sum6 = 0.0352624965998911 * Z + 0.700383064443688;
      sum6 = sum6 * Z + 6.37396220353165;
      sum6 = sum6 * Z + 33.912866078383;
      sum6 = sum6 * Z + 112.079291497871;
      sum6 = sum6 * Z + 221.213596169931;
      sum6 = sum6 * Z + 220.206867912376;
      cd = exp5 * sum6;
      sum6 = 0.0883883476483184 * Z + 1.75566716318264;
      sum6 = sum6 * Z + 16.064177579207;
      sum6 = sum6 * Z + 86.7807322029461;
      sum6 = sum6 * Z + 296.564248779674;
      sum6 = sum6 * Z + 637.333633378831;
      sum6 = sum6 * Z + 793.826512519948;
      sum6 = sum6 * Z + 440.413735824752;
      cd = cd / sum6;
    } else {
      sum6 = Z + 0.65;
      sum6 = Z + 4 / sum6;
      sum6 = Z + 3 / sum6;
      sum6 = Z + 2 / sum6;
      sum6 = Z + 1 / sum6;
      cd = exp5 / sum6 / 2.506628274631;
    }
  }
  return z > 0 ? 1 - cd : cd;
}
function quantileNormal(p, mean4, stdev) {
  if (p < 0 || p > 1)
    return NaN;
  return (mean4 || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
}
function erfinv(x7) {
  let w5 = -Math.log((1 - x7) * (1 + x7)), p;
  if (w5 < 6.25) {
    w5 -= 3.125;
    p = -364441206401782e-35;
    p = -16850591381820166e-35 + p * w5;
    p = 128584807152564e-32 + p * w5;
    p = 11157877678025181e-33 + p * w5;
    p = -1333171662854621e-31 + p * w5;
    p = 20972767875968562e-33 + p * w5;
    p = 6637638134358324e-30 + p * w5;
    p = -4054566272975207e-29 + p * w5;
    p = -8151934197605472e-29 + p * w5;
    p = 26335093153082323e-28 + p * w5;
    p = -12975133253453532e-27 + p * w5;
    p = -5415412054294628e-26 + p * w5;
    p = 10512122733215323e-25 + p * w5;
    p = -4112633980346984e-24 + p * w5;
    p = -29070369957882005e-24 + p * w5;
    p = 42347877827932404e-23 + p * w5;
    p = -13654692000834679e-22 + p * w5;
    p = -13882523362786469e-21 + p * w5;
    p = 18673420803405714e-20 + p * w5;
    p = -740702534166267e-18 + p * w5;
    p = -0.006033670871430149 + p * w5;
    p = 0.24015818242558962 + p * w5;
    p = 1.6536545626831027 + p * w5;
  } else if (w5 < 16) {
    w5 = Math.sqrt(w5) - 3.25;
    p = 22137376921775787e-25;
    p = 9075656193888539e-23 + p * w5;
    p = -27517406297064545e-23 + p * w5;
    p = 18239629214389228e-24 + p * w5;
    p = 15027403968909828e-22 + p * w5;
    p = -4013867526981546e-21 + p * w5;
    p = 29234449089955446e-22 + p * w5;
    p = 12475304481671779e-21 + p * w5;
    p = -47318229009055734e-21 + p * w5;
    p = 6828485145957318e-20 + p * w5;
    p = 24031110387097894e-21 + p * w5;
    p = -3550375203628475e-19 + p * w5;
    p = 9532893797373805e-19 + p * w5;
    p = -0.0016882755560235047 + p * w5;
    p = 0.002491442096107851 + p * w5;
    p = -0.003751208507569241 + p * w5;
    p = 0.005370914553590064 + p * w5;
    p = 1.0052589676941592 + p * w5;
    p = 3.0838856104922208 + p * w5;
  } else if (Number.isFinite(w5)) {
    w5 = Math.sqrt(w5) - 5;
    p = -27109920616438573e-27;
    p = -2555641816996525e-25 + p * w5;
    p = 15076572693500548e-25 + p * w5;
    p = -3789465440126737e-24 + p * w5;
    p = 761570120807834e-23 + p * w5;
    p = -1496002662714924e-23 + p * w5;
    p = 2914795345090108e-23 + p * w5;
    p = -6771199775845234e-23 + p * w5;
    p = 22900482228026655e-23 + p * w5;
    p = -99298272942317e-20 + p * w5;
    p = 4526062597223154e-21 + p * w5;
    p = -1968177810553167e-20 + p * w5;
    p = 7599527703001776e-20 + p * w5;
    p = -21503011930044477e-20 + p * w5;
    p = -13871931833623122e-20 + p * w5;
    p = 1.0103004648645344 + p * w5;
    p = 4.849906401408584 + p * w5;
  } else {
    p = Infinity;
  }
  return p * x7;
}
function gaussian(mean4, stdev) {
  let mu, sigma;
  const dist2 = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist2;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist2;
      } else {
        return sigma;
      }
    },
    sample: () => sampleNormal(mu, sigma),
    pdf: (value4) => densityNormal(value4, mu, sigma),
    cdf: (value4) => cumulativeNormal(value4, mu, sigma),
    icdf: (p) => quantileNormal(p, mu, sigma)
  };
  return dist2.mean(mean4).stdev(stdev);
}
function kde(support, bandwidth2) {
  const kernel = gaussian();
  let n = 0;
  const dist2 = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist2.bandwidth(bandwidth2);
      } else {
        return support;
      }
    },
    bandwidth(_) {
      if (!arguments.length)
        return bandwidth2;
      bandwidth2 = _;
      if (!bandwidth2 && support)
        bandwidth2 = estimateBandwidth(support);
      return dist2;
    },
    sample() {
      return support[~~(random() * n)] + bandwidth2 * kernel.sample();
    },
    pdf(x7) {
      let y7 = 0, i = 0;
      for (; i < n; ++i) {
        y7 += kernel.pdf((x7 - support[i]) / bandwidth2);
      }
      return y7 / bandwidth2 / n;
    },
    cdf(x7) {
      let y7 = 0, i = 0;
      for (; i < n; ++i) {
        y7 += kernel.cdf((x7 - support[i]) / bandwidth2);
      }
      return y7 / n;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return dist2.data(support);
}
function sampleLogNormal(mean4, stdev) {
  mean4 = mean4 || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean4 + sampleNormal() * stdev);
}
function densityLogNormal(value4, mean4, stdev) {
  if (value4 <= 0)
    return 0;
  mean4 = mean4 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (Math.log(value4) - mean4) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value4);
}
function cumulativeLogNormal(value4, mean4, stdev) {
  return cumulativeNormal(Math.log(value4), mean4, stdev);
}
function quantileLogNormal(p, mean4, stdev) {
  return Math.exp(quantileNormal(p, mean4, stdev));
}
function lognormal(mean4, stdev) {
  let mu, sigma;
  const dist2 = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist2;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist2;
      } else {
        return sigma;
      }
    },
    sample: () => sampleLogNormal(mu, sigma),
    pdf: (value4) => densityLogNormal(value4, mu, sigma),
    cdf: (value4) => cumulativeLogNormal(value4, mu, sigma),
    icdf: (p) => quantileLogNormal(p, mu, sigma)
  };
  return dist2.mean(mean4).stdev(stdev);
}
function mixture(dists, weights) {
  let m2 = 0, w5;
  function normalize4(x7) {
    const w6 = [];
    let sum6 = 0, i;
    for (i = 0; i < m2; ++i) {
      sum6 += w6[i] = x7[i] == null ? 1 : +x7[i];
    }
    for (i = 0; i < m2; ++i) {
      w6[i] /= sum6;
    }
    return w6;
  }
  const dist2 = {
    weights(_) {
      if (arguments.length) {
        w5 = normalize4(weights = _ || []);
        return dist2;
      }
      return weights;
    },
    distributions(_) {
      if (arguments.length) {
        if (_) {
          m2 = _.length;
          dists = _;
        } else {
          m2 = 0;
          dists = [];
        }
        return dist2.weights(weights);
      }
      return dists;
    },
    sample() {
      const r2 = random();
      let d = dists[m2 - 1], v = w5[0], i = 0;
      for (; i < m2 - 1; v += w5[++i]) {
        if (r2 < v) {
          d = dists[i];
          break;
        }
      }
      return d.sample();
    },
    pdf(x7) {
      let p = 0, i = 0;
      for (; i < m2; ++i) {
        p += w5[i] * dists[i].pdf(x7);
      }
      return p;
    },
    cdf(x7) {
      let p = 0, i = 0;
      for (; i < m2; ++i) {
        p += w5[i] * dists[i].cdf(x7);
      }
      return p;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return dist2.distributions(dists).weights(weights);
}
function sampleUniform(min8, max8) {
  if (max8 == null) {
    max8 = min8 == null ? 1 : min8;
    min8 = 0;
  }
  return min8 + (max8 - min8) * random();
}
function densityUniform(value4, min8, max8) {
  if (max8 == null) {
    max8 = min8 == null ? 1 : min8;
    min8 = 0;
  }
  return value4 >= min8 && value4 <= max8 ? 1 / (max8 - min8) : 0;
}
function cumulativeUniform(value4, min8, max8) {
  if (max8 == null) {
    max8 = min8 == null ? 1 : min8;
    min8 = 0;
  }
  return value4 < min8 ? 0 : value4 > max8 ? 1 : (value4 - min8) / (max8 - min8);
}
function quantileUniform(p, min8, max8) {
  if (max8 == null) {
    max8 = min8 == null ? 1 : min8;
    min8 = 0;
  }
  return p >= 0 && p <= 1 ? min8 + p * (max8 - min8) : NaN;
}
function uniform(min8, max8) {
  let a4, b3;
  const dist2 = {
    min(_) {
      if (arguments.length) {
        a4 = _ || 0;
        return dist2;
      } else {
        return a4;
      }
    },
    max(_) {
      if (arguments.length) {
        b3 = _ == null ? 1 : _;
        return dist2;
      } else {
        return b3;
      }
    },
    sample: () => sampleUniform(a4, b3),
    pdf: (value4) => densityUniform(value4, a4, b3),
    cdf: (value4) => cumulativeUniform(value4, a4, b3),
    icdf: (p) => quantileUniform(p, a4, b3)
  };
  if (max8 == null) {
    max8 = min8 == null ? 1 : min8;
    min8 = 0;
  }
  return dist2.min(min8).max(max8);
}
function ols(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}
function points(data3, x7, y7, sort5) {
  data3 = data3.filter((d2) => {
    let u = x7(d2), v = y7(d2);
    return u != null && (u = +u) >= u && v != null && (v = +v) >= v;
  });
  if (sort5) {
    data3.sort((a4, b3) => x7(a4) - x7(b3));
  }
  const n = data3.length, X4 = new Float64Array(n), Y4 = new Float64Array(n);
  let i = 0, ux = 0, uy = 0, xv, yv, d;
  for (d of data3) {
    X4[i] = xv = +x7(d);
    Y4[i] = yv = +y7(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }
  for (i = 0; i < n; ++i) {
    X4[i] -= ux;
    Y4[i] -= uy;
  }
  return [X4, Y4, ux, uy];
}
function visitPoints(data3, x7, y7, callback) {
  let i = -1, u, v;
  for (const d of data3) {
    u = x7(d);
    v = y7(d);
    if (u != null && (u = +u) >= u && v != null && (v = +v) >= v) {
      callback(u, v, ++i);
    }
  }
}
function rSquared(data3, x7, y7, uY, predict) {
  let SSE = 0, SST = 0;
  visitPoints(data3, x7, y7, (dx, dy) => {
    const sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}
function linear(data3, x7, y7) {
  let X4 = 0, Y4 = 0, XY = 0, X24 = 0, n = 0;
  visitPoints(data3, x7, y7, (dx, dy) => {
    ++n;
    X4 += (dx - X4) / n;
    Y4 += (dy - Y4) / n;
    XY += (dx * dy - XY) / n;
    X24 += (dx * dx - X24) / n;
  });
  const coef = ols(X4, Y4, XY, X24), predict = (x8) => coef[0] + coef[1] * x8;
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x7, y7, Y4, predict)
  };
}
function log2(data3, x7, y7) {
  let X4 = 0, Y4 = 0, XY = 0, X24 = 0, n = 0;
  visitPoints(data3, x7, y7, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X4 += (dx - X4) / n;
    Y4 += (dy - Y4) / n;
    XY += (dx * dy - XY) / n;
    X24 += (dx * dx - X24) / n;
  });
  const coef = ols(X4, Y4, XY, X24), predict = (x8) => coef[0] + coef[1] * Math.log(x8);
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x7, y7, Y4, predict)
  };
}
function exp2(data3, x7, y7) {
  const [xv, yv, ux, uy] = points(data3, x7, y7);
  let YL = 0, XY = 0, XYL = 0, X2Y = 0, n = 0, dx, ly3, xy;
  visitPoints(data3, x7, y7, (_, dy) => {
    dx = xv[n++];
    ly3 = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly3 - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly3 - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });
  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy), predict = (x8) => Math.exp(c0 + c1 * (x8 - ux));
  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict,
    rSquared: rSquared(data3, x7, y7, uy, predict)
  };
}
function pow2(data3, x7, y7) {
  let X4 = 0, Y4 = 0, XY = 0, X24 = 0, YS = 0, n = 0;
  visitPoints(data3, x7, y7, (dx, dy) => {
    const lx3 = Math.log(dx), ly3 = Math.log(dy);
    ++n;
    X4 += (lx3 - X4) / n;
    Y4 += (ly3 - Y4) / n;
    XY += (lx3 * ly3 - XY) / n;
    X24 += (lx3 * lx3 - X24) / n;
    YS += (dy - YS) / n;
  });
  const coef = ols(X4, Y4, XY, X24), predict = (x8) => coef[0] * Math.pow(x8, coef[1]);
  coef[0] = Math.exp(coef[0]);
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x7, y7, YS, predict)
  };
}
function quad(data3, x7, y7) {
  const [xv, yv, ux, uy] = points(data3, x7, y7), n = xv.length;
  let X24 = 0, X32 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x22;
  for (i = 0; i < n; ) {
    dx = xv[i];
    dy = yv[i++];
    x22 = dx * dx;
    X24 += (x22 - X24) / i;
    X32 += (x22 * dx - X32) / i;
    X4 += (x22 * x22 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x22 * dy - X2Y) / i;
  }
  const X2X2 = X4 - X24 * X24, d = X24 * X2X2 - X32 * X32, a4 = (X2Y * X24 - XY * X32) / d, b3 = (XY * X2X2 - X2Y * X32) / d, c2 = -a4 * X24, predict = (x8) => {
    x8 = x8 - ux;
    return a4 * x8 * x8 + b3 * x8 + c2 + uy;
  };
  return {
    coef: [c2 - b3 * ux + a4 * ux * ux + uy, b3 - 2 * a4 * ux, a4],
    predict,
    rSquared: rSquared(data3, x7, y7, uy, predict)
  };
}
function poly(data3, x7, y7, order) {
  if (order === 1)
    return linear(data3, x7, y7);
  if (order === 2)
    return quad(data3, x7, y7);
  const [xv, yv, ux, uy] = points(data3, x7, y7), n = xv.length, lhs = [], rhs = [], k4 = order + 1;
  let i, j, l, v, c2;
  for (i = 0; i < k4; ++i) {
    for (l = 0, v = 0; l < n; ++l) {
      v += Math.pow(xv[l], i) * yv[l];
    }
    lhs.push(v);
    c2 = new Float64Array(k4);
    for (j = 0; j < k4; ++j) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i + j);
      }
      c2[j] = v;
    }
    rhs.push(c2);
  }
  rhs.push(lhs);
  const coef = gaussianElimination(rhs), predict = (x8) => {
    x8 -= ux;
    let y8 = uy + coef[0] + coef[1] * x8 + coef[2] * x8 * x8;
    for (i = 3; i < k4; ++i)
      y8 += coef[i] * Math.pow(x8, i);
    return y8;
  };
  return {
    coef: uncenter(k4, coef, -ux, uy),
    predict,
    rSquared: rSquared(data3, x7, y7, uy, predict)
  };
}
function uncenter(k4, a4, x7, y7) {
  const z = Array(k4);
  let i, j, v, c2;
  for (i = 0; i < k4; ++i)
    z[i] = 0;
  for (i = k4 - 1; i >= 0; --i) {
    v = a4[i];
    c2 = 1;
    z[i] += v;
    for (j = 1; j <= i; ++j) {
      c2 *= (i + 1 - j) / j;
      z[i - j] += v * Math.pow(x7, j) * c2;
    }
  }
  z[0] += y7;
  return z;
}
function gaussianElimination(matrix) {
  const n = matrix.length - 1, coef = [];
  let i, j, k4, r2, t;
  for (i = 0; i < n; ++i) {
    r2 = i;
    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r2])) {
        r2 = j;
      }
    }
    for (k4 = i; k4 < n + 1; ++k4) {
      t = matrix[k4][i];
      matrix[k4][i] = matrix[k4][r2];
      matrix[k4][r2] = t;
    }
    for (j = i + 1; j < n; ++j) {
      for (k4 = n; k4 >= i; k4--) {
        matrix[k4][j] -= matrix[k4][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (j = n - 1; j >= 0; --j) {
    t = 0;
    for (k4 = j + 1; k4 < n; ++k4) {
      t += matrix[k4][j] * coef[k4];
    }
    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }
  return coef;
}
function loess(data3, x7, y7, bandwidth2) {
  const [xv, yv, ux, uy] = points(data3, x7, y7, true), n = xv.length, bw = Math.max(2, ~~(bandwidth2 * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
  for (let iter = -1; ++iter <= maxiters; ) {
    const interval3 = [0, bw - 1];
    for (let i = 0; i < n; ++i) {
      const dx = xv[i], i0 = interval3[0], i1 = interval3[1], edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0, X4 = 0, Y4 = 0, XY = 0, X24 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1);
      for (let k4 = i0; k4 <= i1; ++k4) {
        const xk = xv[k4], yk = yv[k4], w5 = tricube(Math.abs(dx - xk) * denom) * robustWeights[k4], xkw = xk * w5;
        W += w5;
        X4 += xkw;
        Y4 += yk * w5;
        XY += yk * xkw;
        X24 += xk * xkw;
      }
      const [a4, b3] = ols(X4 / W, Y4 / W, XY / W, X24 / W);
      yhat[i] = a4 + b3 * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval3);
    }
    if (iter === maxiters) {
      break;
    }
    const medianResidual = median_default(residuals);
    if (Math.abs(medianResidual) < epsilon)
      break;
    for (let i = 0, arg, w5; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual);
      robustWeights[i] = arg >= 1 ? epsilon : (w5 = 1 - arg * arg) * w5;
    }
  }
  return output(xv, yhat, ux, uy);
}
function tricube(x7) {
  return (x7 = 1 - x7 * x7 * x7) * x7 * x7;
}
function updateInterval(xv, i, interval3) {
  const val = xv[i];
  let left = interval3[0], right = interval3[1] + 1;
  if (right >= xv.length)
    return;
  while (i > left && xv[right] - val <= val - xv[left]) {
    interval3[0] = ++left;
    interval3[1] = right;
    ++right;
  }
}
function output(xv, yhat, ux, uy) {
  const n = xv.length, out = [];
  let i = 0, cnt = 0, prev = [], v;
  for (; i < n; ++i) {
    v = xv[i] + ux;
    if (prev[0] === v) {
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}
function sampleCurve(f, extent5, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);
  const point16 = (x7) => [x7, f(x7)], minX = extent5[0], maxX = extent5[1], span3 = maxX - minX, stop2 = span3 / maxSteps, prev = [point16(minX)], next = [];
  if (minSteps === maxSteps) {
    for (let i = 1; i < maxSteps; ++i) {
      prev.push(point16(minX + i / minSteps * span3));
    }
    prev.push(point16(maxX));
    return prev;
  } else {
    next.push(point16(maxX));
    for (let i = minSteps; --i > 0; ) {
      next.push(point16(minX + i / minSteps * span3));
    }
  }
  let p02 = prev[0];
  let p1 = next[next.length - 1];
  const sx = 1 / span3;
  const sy = scaleY(p02[1], next);
  while (p1) {
    const pm = point16((p02[0] + p1[0]) / 2);
    const dx = pm[0] - p02[0] >= stop2;
    if (dx && angleDelta(p02, pm, p1, sx, sy) > MIN_RADIANS) {
      next.push(pm);
    } else {
      p02 = p1;
      prev.push(p1);
      next.pop();
    }
    p1 = next[next.length - 1];
  }
  return prev;
}
function scaleY(init2, points2) {
  let ymin = init2;
  let ymax = init2;
  const n = points2.length;
  for (let i = 0; i < n; ++i) {
    const y7 = points2[i][1];
    if (y7 < ymin)
      ymin = y7;
    if (y7 > ymax)
      ymax = y7;
  }
  return 1 / (ymax - ymin);
}
function angleDelta(p, q, r2, sx, sy) {
  const a0 = Math.atan2(sy * (r2[1] - p[1]), sx * (r2[0] - p[0])), a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
  return Math.abs(a0 - a1);
}
var random, SQRT2PI, SQRT2, nextSample, maxiters, epsilon, MIN_RADIANS;
var init_vega_statistics_module = __esm({
  "node_modules/.pnpm/vega-statistics@1.7.10/node_modules/vega-statistics/build/vega-statistics.module.js"() {
    init_src9();
    random = Math.random;
    SQRT2PI = Math.sqrt(2 * Math.PI);
    SQRT2 = Math.SQRT2;
    nextSample = NaN;
    maxiters = 2;
    epsilon = 1e-12;
    MIN_RADIANS = 0.5 * Math.PI / 180;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/interval.js
function newInterval(floori, offseti, count5, field4) {
  function interval3(date3) {
    return floori(date3 = arguments.length === 0 ? new Date() : new Date(+date3)), date3;
  }
  interval3.floor = function(date3) {
    return floori(date3 = new Date(+date3)), date3;
  };
  interval3.ceil = function(date3) {
    return floori(date3 = new Date(date3 - 1)), offseti(date3, 1), floori(date3), date3;
  };
  interval3.round = function(date3) {
    var d0 = interval3(date3), d1 = interval3.ceil(date3);
    return date3 - d0 < d1 - date3 ? d0 : d1;
  };
  interval3.offset = function(date3, step) {
    return offseti(date3 = new Date(+date3), step == null ? 1 : Math.floor(step)), date3;
  };
  interval3.range = function(start, stop2, step) {
    var range7 = [], previous;
    start = interval3.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop2) || !(step > 0))
      return range7;
    do
      range7.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop2);
    return range7;
  };
  interval3.filter = function(test2) {
    return newInterval(function(date3) {
      if (date3 >= date3)
        while (floori(date3), !test2(date3))
          date3.setTime(date3 - 1);
    }, function(date3, step) {
      if (date3 >= date3) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date3, -1), !test2(date3)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date3, 1), !test2(date3)) {
            }
          }
      }
    });
  };
  if (count5) {
    interval3.count = function(start, end) {
      t03.setTime(+start), t12.setTime(+end);
      floori(t03), floori(t12);
      return Math.floor(count5(t03, t12));
    };
    interval3.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval3 : interval3.filter(field4 ? function(d) {
        return field4(d) % step === 0;
      } : function(d) {
        return interval3.count(0, d) % step === 0;
      });
    };
  }
  return interval3;
}
var t03, t12;
var init_interval2 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/interval.js"() {
    t03 = new Date();
    t12 = new Date();
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/millisecond.js
var millisecond2, millisecond_default, milliseconds2;
var init_millisecond2 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/millisecond.js"() {
    init_interval2();
    millisecond2 = newInterval(function() {
    }, function(date3, step) {
      date3.setTime(+date3 + step);
    }, function(start, end) {
      return end - start;
    });
    millisecond2.every = function(k4) {
      k4 = Math.floor(k4);
      if (!isFinite(k4) || !(k4 > 0))
        return null;
      if (!(k4 > 1))
        return millisecond2;
      return newInterval(function(date3) {
        date3.setTime(Math.floor(date3 / k4) * k4);
      }, function(date3, step) {
        date3.setTime(+date3 + step * k4);
      }, function(start, end) {
        return (end - start) / k4;
      });
    };
    millisecond_default = millisecond2;
    milliseconds2 = millisecond2.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/duration.js
var durationSecond3, durationMinute3, durationHour3, durationDay3, durationWeek3, durationMonth3, durationYear3;
var init_duration2 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/duration.js"() {
    durationSecond3 = 1e3;
    durationMinute3 = durationSecond3 * 60;
    durationHour3 = durationMinute3 * 60;
    durationDay3 = durationHour3 * 24;
    durationWeek3 = durationDay3 * 7;
    durationMonth3 = durationDay3 * 30;
    durationYear3 = durationDay3 * 365;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/second.js
var second2, second_default, seconds2;
var init_second2 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/second.js"() {
    init_interval2();
    init_duration2();
    second2 = newInterval(function(date3) {
      date3.setTime(date3 - date3.getMilliseconds());
    }, function(date3, step) {
      date3.setTime(+date3 + step * durationSecond3);
    }, function(start, end) {
      return (end - start) / durationSecond3;
    }, function(date3) {
      return date3.getUTCSeconds();
    });
    second_default = second2;
    seconds2 = second2.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/minute.js
var minute, minute_default, minutes;
var init_minute2 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/minute.js"() {
    init_interval2();
    init_duration2();
    minute = newInterval(function(date3) {
      date3.setTime(date3 - date3.getMilliseconds() - date3.getSeconds() * durationSecond3);
    }, function(date3, step) {
      date3.setTime(+date3 + step * durationMinute3);
    }, function(start, end) {
      return (end - start) / durationMinute3;
    }, function(date3) {
      return date3.getMinutes();
    });
    minute_default = minute;
    minutes = minute.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/hour.js
var hour, hour_default, hours;
var init_hour2 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/hour.js"() {
    init_interval2();
    init_duration2();
    hour = newInterval(function(date3) {
      date3.setTime(date3 - date3.getMilliseconds() - date3.getSeconds() * durationSecond3 - date3.getMinutes() * durationMinute3);
    }, function(date3, step) {
      date3.setTime(+date3 + step * durationHour3);
    }, function(start, end) {
      return (end - start) / durationHour3;
    }, function(date3) {
      return date3.getHours();
    });
    hour_default = hour;
    hours = hour.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/day.js
var day, day_default, days;
var init_day2 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/day.js"() {
    init_interval2();
    init_duration2();
    day = newInterval(
      (date3) => date3.setHours(0, 0, 0, 0),
      (date3, step) => date3.setDate(date3.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute3) / durationDay3,
      (date3) => date3.getDate() - 1
    );
    day_default = day;
    days = day.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/week.js
function weekday2(i) {
  return newInterval(function(date3) {
    date3.setDate(date3.getDate() - (date3.getDay() + 7 - i) % 7);
    date3.setHours(0, 0, 0, 0);
  }, function(date3, step) {
    date3.setDate(date3.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute3) / durationWeek3;
  });
}
var sunday, monday, tuesday, wednesday, thursday, friday, saturday, sundays, mondays, tuesdays, wednesdays, thursdays, fridays, saturdays;
var init_week2 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/week.js"() {
    init_interval2();
    init_duration2();
    sunday = weekday2(0);
    monday = weekday2(1);
    tuesday = weekday2(2);
    wednesday = weekday2(3);
    thursday = weekday2(4);
    friday = weekday2(5);
    saturday = weekday2(6);
    sundays = sunday.range;
    mondays = monday.range;
    tuesdays = tuesday.range;
    wednesdays = wednesday.range;
    thursdays = thursday.range;
    fridays = friday.range;
    saturdays = saturday.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/month.js
var month, month_default, months;
var init_month2 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/month.js"() {
    init_interval2();
    month = newInterval(function(date3) {
      date3.setDate(1);
      date3.setHours(0, 0, 0, 0);
    }, function(date3, step) {
      date3.setMonth(date3.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date3) {
      return date3.getMonth();
    });
    month_default = month;
    months = month.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/year.js
var year, year_default, years;
var init_year2 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/year.js"() {
    init_interval2();
    year = newInterval(function(date3) {
      date3.setMonth(0, 1);
      date3.setHours(0, 0, 0, 0);
    }, function(date3, step) {
      date3.setFullYear(date3.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date3) {
      return date3.getFullYear();
    });
    year.every = function(k4) {
      return !isFinite(k4 = Math.floor(k4)) || !(k4 > 0) ? null : newInterval(function(date3) {
        date3.setFullYear(Math.floor(date3.getFullYear() / k4) * k4);
        date3.setMonth(0, 1);
        date3.setHours(0, 0, 0, 0);
      }, function(date3, step) {
        date3.setFullYear(date3.getFullYear() + step * k4);
      });
    };
    year_default = year;
    years = year.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcMinute.js
var utcMinute2, utcMinute_default, utcMinutes2;
var init_utcMinute = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcMinute.js"() {
    init_interval2();
    init_duration2();
    utcMinute2 = newInterval(function(date3) {
      date3.setUTCSeconds(0, 0);
    }, function(date3, step) {
      date3.setTime(+date3 + step * durationMinute3);
    }, function(start, end) {
      return (end - start) / durationMinute3;
    }, function(date3) {
      return date3.getUTCMinutes();
    });
    utcMinute_default = utcMinute2;
    utcMinutes2 = utcMinute2.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcHour.js
var utcHour2, utcHour_default, utcHours2;
var init_utcHour = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcHour.js"() {
    init_interval2();
    init_duration2();
    utcHour2 = newInterval(function(date3) {
      date3.setUTCMinutes(0, 0, 0);
    }, function(date3, step) {
      date3.setTime(+date3 + step * durationHour3);
    }, function(start, end) {
      return (end - start) / durationHour3;
    }, function(date3) {
      return date3.getUTCHours();
    });
    utcHour_default = utcHour2;
    utcHours2 = utcHour2.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcDay.js
var utcDay2, utcDay_default, utcDays2;
var init_utcDay = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcDay.js"() {
    init_interval2();
    init_duration2();
    utcDay2 = newInterval(function(date3) {
      date3.setUTCHours(0, 0, 0, 0);
    }, function(date3, step) {
      date3.setUTCDate(date3.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay3;
    }, function(date3) {
      return date3.getUTCDate() - 1;
    });
    utcDay_default = utcDay2;
    utcDays2 = utcDay2.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcWeek.js
function utcWeekday2(i) {
  return newInterval(function(date3) {
    date3.setUTCDate(date3.getUTCDate() - (date3.getUTCDay() + 7 - i) % 7);
    date3.setUTCHours(0, 0, 0, 0);
  }, function(date3, step) {
    date3.setUTCDate(date3.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek3;
  });
}
var utcSunday2, utcMonday2, utcTuesday2, utcWednesday2, utcThursday2, utcFriday2, utcSaturday2, utcSundays2, utcMondays2, utcTuesdays2, utcWednesdays2, utcThursdays2, utcFridays2, utcSaturdays2;
var init_utcWeek = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcWeek.js"() {
    init_interval2();
    init_duration2();
    utcSunday2 = utcWeekday2(0);
    utcMonday2 = utcWeekday2(1);
    utcTuesday2 = utcWeekday2(2);
    utcWednesday2 = utcWeekday2(3);
    utcThursday2 = utcWeekday2(4);
    utcFriday2 = utcWeekday2(5);
    utcSaturday2 = utcWeekday2(6);
    utcSundays2 = utcSunday2.range;
    utcMondays2 = utcMonday2.range;
    utcTuesdays2 = utcTuesday2.range;
    utcWednesdays2 = utcWednesday2.range;
    utcThursdays2 = utcThursday2.range;
    utcFridays2 = utcFriday2.range;
    utcSaturdays2 = utcSaturday2.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcMonth.js
var utcMonth2, utcMonth_default, utcMonths2;
var init_utcMonth = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcMonth.js"() {
    init_interval2();
    utcMonth2 = newInterval(function(date3) {
      date3.setUTCDate(1);
      date3.setUTCHours(0, 0, 0, 0);
    }, function(date3, step) {
      date3.setUTCMonth(date3.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date3) {
      return date3.getUTCMonth();
    });
    utcMonth_default = utcMonth2;
    utcMonths2 = utcMonth2.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcYear.js
var utcYear2, utcYear_default, utcYears2;
var init_utcYear = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/utcYear.js"() {
    init_interval2();
    utcYear2 = newInterval(function(date3) {
      date3.setUTCMonth(0, 1);
      date3.setUTCHours(0, 0, 0, 0);
    }, function(date3, step) {
      date3.setUTCFullYear(date3.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date3) {
      return date3.getUTCFullYear();
    });
    utcYear2.every = function(k4) {
      return !isFinite(k4 = Math.floor(k4)) || !(k4 > 0) ? null : newInterval(function(date3) {
        date3.setUTCFullYear(Math.floor(date3.getUTCFullYear() / k4) * k4);
        date3.setUTCMonth(0, 1);
        date3.setUTCHours(0, 0, 0, 0);
      }, function(date3, step) {
        date3.setUTCFullYear(date3.getUTCFullYear() + step * k4);
      });
    };
    utcYear_default = utcYear2;
    utcYears2 = utcYear2.range;
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/ticks.js
function ticker2(year2, month2, week2, day2, hour2, minute2) {
  const tickIntervals = [
    [second_default, 1, durationSecond3],
    [second_default, 5, 5 * durationSecond3],
    [second_default, 15, 15 * durationSecond3],
    [second_default, 30, 30 * durationSecond3],
    [minute2, 1, durationMinute3],
    [minute2, 5, 5 * durationMinute3],
    [minute2, 15, 15 * durationMinute3],
    [minute2, 30, 30 * durationMinute3],
    [hour2, 1, durationHour3],
    [hour2, 3, 3 * durationHour3],
    [hour2, 6, 6 * durationHour3],
    [hour2, 12, 12 * durationHour3],
    [day2, 1, durationDay3],
    [day2, 2, 2 * durationDay3],
    [week2, 1, durationWeek3],
    [month2, 1, durationMonth3],
    [month2, 3, 3 * durationMonth3],
    [year2, 1, durationYear3]
  ];
  function ticks3(start, stop2, count5) {
    const reverse6 = stop2 < start;
    if (reverse6)
      [start, stop2] = [stop2, start];
    const interval3 = count5 && typeof count5.range === "function" ? count5 : tickInterval(start, stop2, count5);
    const ticks4 = interval3 ? interval3.range(start, +stop2 + 1) : [];
    return reverse6 ? ticks4.reverse() : ticks4;
  }
  function tickInterval(start, stop2, count5) {
    const target2 = Math.abs(stop2 - start) / count5;
    const i = bisector_default(([, , step2]) => step2).right(tickIntervals, target2);
    if (i === tickIntervals.length)
      return year2.every(tickStep2(start / durationYear3, stop2 / durationYear3, count5));
    if (i === 0)
      return millisecond_default.every(Math.max(tickStep2(start, stop2, count5), 1));
    const [t, step] = tickIntervals[target2 / tickIntervals[i - 1][2] < tickIntervals[i][2] / target2 ? i - 1 : i];
    return t.every(step);
  }
  return [ticks3, tickInterval];
}
var utcTicks2, utcTickInterval2, timeTicks2, timeTickInterval2;
var init_ticks4 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/ticks.js"() {
    init_src9();
    init_duration2();
    init_millisecond2();
    init_second2();
    init_minute2();
    init_hour2();
    init_day2();
    init_week2();
    init_month2();
    init_year2();
    init_utcMinute();
    init_utcHour();
    init_utcDay();
    init_utcWeek();
    init_utcMonth();
    init_utcYear();
    [utcTicks2, utcTickInterval2] = ticker2(utcYear_default, utcMonth_default, utcSunday2, utcDay_default, utcHour_default, utcMinute_default);
    [timeTicks2, timeTickInterval2] = ticker2(year_default, month_default, sunday, day_default, hour_default, minute_default);
  }
});

// node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/index.js
var init_src10 = __esm({
  "node_modules/.pnpm/d3-time@2.1.1/node_modules/d3-time/src/index.js"() {
    init_interval2();
    init_millisecond2();
    init_second2();
    init_minute2();
    init_hour2();
    init_day2();
    init_week2();
    init_month2();
    init_year2();
    init_utcMinute();
    init_utcHour();
    init_utcDay();
    init_utcWeek();
    init_utcMonth();
    init_utcYear();
    init_ticks4();
  }
});

// node_modules/.pnpm/vega-time@2.0.4/node_modules/vega-time/build/vega-time.module.js
function timeUnits(units) {
  const u = array(units).slice(), m2 = {};
  if (!u.length)
    error("Missing time unit.");
  u.forEach((unit3) => {
    if (has(UNITS2, unit3)) {
      m2[unit3] = 1;
    } else {
      error("Invalid time unit: ".concat(unit3, "."));
    }
  });
  const numTypes = (m2[WEEK2] || m2[DAY2] ? 1 : 0) + (m2[QUARTER2] || m2[MONTH2] || m2[DATE2] ? 1 : 0) + (m2[DAYOFYEAR2] ? 1 : 0);
  if (numTypes > 1) {
    error("Incompatible time units: ".concat(units));
  }
  u.sort((a4, b3) => UNITS2[a4] - UNITS2[b3]);
  return u;
}
function timeUnitSpecifier(units, specifiers) {
  const s3 = extend({}, defaultSpecifiers2, specifiers), u = timeUnits(units), n = u.length;
  let fmt = "", start = 0, end, key3;
  for (start = 0; start < n; ) {
    for (end = u.length; end > start; --end) {
      key3 = u.slice(start, end).join("-");
      if (s3[key3] != null) {
        fmt += s3[key3];
        start = end;
        break;
      }
    }
  }
  return fmt.trim();
}
function localYear2(y7) {
  t04.setFullYear(y7);
  t04.setMonth(0);
  t04.setDate(1);
  t04.setHours(0, 0, 0, 0);
  return t04;
}
function dayofyear(d) {
  return localDayOfYear2(new Date(d));
}
function week(d) {
  return localWeekNum2(new Date(d));
}
function localDayOfYear2(d) {
  return day_default.count(localYear2(d.getFullYear()) - 1, d);
}
function localWeekNum2(d) {
  return sunday.count(localYear2(d.getFullYear()) - 1, d);
}
function localFirst2(y7) {
  return localYear2(y7).getDay();
}
function localDate2(y7, m2, d, H, M2, S, L) {
  if (0 <= y7 && y7 < 100) {
    const date3 = new Date(-1, m2, d, H, M2, S, L);
    date3.setFullYear(y7);
    return date3;
  }
  return new Date(y7, m2, d, H, M2, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear2(new Date(d));
}
function utcweek(d) {
  return utcWeekNum2(new Date(d));
}
function utcDayOfYear2(d) {
  const y7 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay_default.count(y7 - 1, d);
}
function utcWeekNum2(d) {
  const y7 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday2.count(y7 - 1, d);
}
function utcFirst2(y7) {
  t04.setTime(Date.UTC(y7, 0, 1));
  return t04.getUTCDay();
}
function utcDate2(y7, m2, d, H, M2, S, L) {
  if (0 <= y7 && y7 < 100) {
    const date3 = new Date(Date.UTC(-1, m2, d, H, M2, S, L));
    date3.setUTCFullYear(d.y);
    return date3;
  }
  return new Date(Date.UTC(y7, m2, d, H, M2, S, L));
}
function floor(units, step, get8, inv, newDate3) {
  const s3 = step || 1, b3 = peek(units), _ = (unit3, p, key3) => {
    key3 = key3 || unit3;
    return getUnit(get8[key3], inv[key3], unit3 === b3 && s3, p);
  };
  const t = new Date(), u = toSet(units), y7 = u[YEAR2] ? _(YEAR2) : constant(2012), m2 = u[MONTH2] ? _(MONTH2) : u[QUARTER2] ? _(QUARTER2) : zero, d = u[WEEK2] && u[DAY2] ? _(DAY2, 1, WEEK2 + DAY2) : u[WEEK2] ? _(WEEK2, 1) : u[DAY2] ? _(DAY2, 1) : u[DATE2] ? _(DATE2, 1) : u[DAYOFYEAR2] ? _(DAYOFYEAR2, 1) : one, H = u[HOURS2] ? _(HOURS2) : zero, M2 = u[MINUTES2] ? _(MINUTES2) : zero, S = u[SECONDS2] ? _(SECONDS2) : zero, L = u[MILLISECONDS2] ? _(MILLISECONDS2) : zero;
  return function(v) {
    t.setTime(+v);
    const year2 = y7(t);
    return newDate3(year2, m2(t), d(t, year2), H(t), M2(t), S(t), L(t));
  };
}
function getUnit(f, inv, step, phase) {
  const u = step <= 1 ? f : phase ? (d, y7) => phase + step * Math.floor((f(d, y7) - phase) / step) : (d, y7) => step * Math.floor(f(d, y7) / step);
  return inv ? (d, y7) => inv(u(d, y7), y7) : u;
}
function weekday3(week2, day2, firstDay) {
  return day2 + week2 * 7 - (firstDay + 6) % 7;
}
function timeFloor(units, step) {
  return floor(units, step || 1, localGet2, localInv2, localDate2);
}
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet2, utcInv2, utcDate2);
}
function timeInterval3(unit3) {
  return timeIntervals2[unit3];
}
function utcInterval2(unit3) {
  return utcIntervals2[unit3];
}
function offset(ival, date3, step) {
  return ival ? ival.offset(date3, step) : void 0;
}
function timeOffset(unit3, date3, step) {
  return offset(timeInterval3(unit3), date3, step);
}
function utcOffset(unit3, date3, step) {
  return offset(utcInterval2(unit3), date3, step);
}
function sequence(ival, start, stop2, step) {
  return ival ? ival.range(start, stop2, step) : void 0;
}
function timeSequence(unit3, start, stop2, step) {
  return sequence(timeInterval3(unit3), start, stop2, step);
}
function utcSequence(unit3, start, stop2, step) {
  return sequence(utcInterval2(unit3), start, stop2, step);
}
function bin3(opt) {
  const ext = opt.extent, max8 = opt.maxbins || 40, target2 = Math.abs(span(ext)) / max8;
  let i = bisector_default((i2) => i2[2]).right(intervals2, target2), units, step;
  if (i === intervals2.length) {
    units = Year2, step = tickStep2(ext[0] / durationYear4, ext[1] / durationYear4, max8);
  } else if (i) {
    i = intervals2[target2 / intervals2[i - 1][2] < intervals2[i][2] / target2 ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli2;
    step = Math.max(tickStep2(ext[0], ext[1], max8), 1);
  }
  return {
    units,
    step
  };
}
var YEAR2, QUARTER2, MONTH2, WEEK2, DATE2, DAY2, DAYOFYEAR2, HOURS2, MINUTES2, SECONDS2, MILLISECONDS2, TIME_UNITS2, UNITS2, defaultSpecifiers2, t04, localGet2, localInv2, utcGet2, utcInv2, timeIntervals2, utcIntervals2, durationSecond4, durationMinute4, durationHour4, durationDay4, durationWeek4, durationMonth4, durationYear4, Milli2, Seconds2, Minutes2, Hours2, Day2, Week2, Month2, Year2, intervals2;
var init_vega_time_module2 = __esm({
  "node_modules/.pnpm/vega-time@2.0.4/node_modules/vega-time/build/vega-time.module.js"() {
    init_vega_util_module();
    init_src10();
    init_src9();
    YEAR2 = "year";
    QUARTER2 = "quarter";
    MONTH2 = "month";
    WEEK2 = "week";
    DATE2 = "date";
    DAY2 = "day";
    DAYOFYEAR2 = "dayofyear";
    HOURS2 = "hours";
    MINUTES2 = "minutes";
    SECONDS2 = "seconds";
    MILLISECONDS2 = "milliseconds";
    TIME_UNITS2 = [YEAR2, QUARTER2, MONTH2, WEEK2, DATE2, DAY2, DAYOFYEAR2, HOURS2, MINUTES2, SECONDS2, MILLISECONDS2];
    UNITS2 = TIME_UNITS2.reduce((o, u, i) => (o[u] = 1 + i, o), {});
    defaultSpecifiers2 = {
      [YEAR2]: "%Y ",
      [QUARTER2]: "Q%q ",
      [MONTH2]: "%b ",
      [DATE2]: "%d ",
      [WEEK2]: "W%U ",
      [DAY2]: "%a ",
      [DAYOFYEAR2]: "%j ",
      [HOURS2]: "%H:00",
      [MINUTES2]: "00:%M",
      [SECONDS2]: ":%S",
      [MILLISECONDS2]: ".%L",
      ["".concat(YEAR2, "-").concat(MONTH2)]: "%Y-%m ",
      ["".concat(YEAR2, "-").concat(MONTH2, "-").concat(DATE2)]: "%Y-%m-%d ",
      ["".concat(HOURS2, "-").concat(MINUTES2)]: "%H:%M"
    };
    t04 = new Date();
    localGet2 = {
      [YEAR2]: (d) => d.getFullYear(),
      [QUARTER2]: (d) => Math.floor(d.getMonth() / 3),
      [MONTH2]: (d) => d.getMonth(),
      [DATE2]: (d) => d.getDate(),
      [HOURS2]: (d) => d.getHours(),
      [MINUTES2]: (d) => d.getMinutes(),
      [SECONDS2]: (d) => d.getSeconds(),
      [MILLISECONDS2]: (d) => d.getMilliseconds(),
      [DAYOFYEAR2]: (d) => localDayOfYear2(d),
      [WEEK2]: (d) => localWeekNum2(d),
      [WEEK2 + DAY2]: (d, y7) => weekday3(localWeekNum2(d), d.getDay(), localFirst2(y7)),
      [DAY2]: (d, y7) => weekday3(1, d.getDay(), localFirst2(y7))
    };
    localInv2 = {
      [QUARTER2]: (q) => 3 * q,
      [WEEK2]: (w5, y7) => weekday3(w5, 0, localFirst2(y7))
    };
    utcGet2 = {
      [YEAR2]: (d) => d.getUTCFullYear(),
      [QUARTER2]: (d) => Math.floor(d.getUTCMonth() / 3),
      [MONTH2]: (d) => d.getUTCMonth(),
      [DATE2]: (d) => d.getUTCDate(),
      [HOURS2]: (d) => d.getUTCHours(),
      [MINUTES2]: (d) => d.getUTCMinutes(),
      [SECONDS2]: (d) => d.getUTCSeconds(),
      [MILLISECONDS2]: (d) => d.getUTCMilliseconds(),
      [DAYOFYEAR2]: (d) => utcDayOfYear2(d),
      [WEEK2]: (d) => utcWeekNum2(d),
      [DAY2]: (d, y7) => weekday3(1, d.getUTCDay(), utcFirst2(y7)),
      [WEEK2 + DAY2]: (d, y7) => weekday3(utcWeekNum2(d), d.getUTCDay(), utcFirst2(y7))
    };
    utcInv2 = {
      [QUARTER2]: (q) => 3 * q,
      [WEEK2]: (w5, y7) => weekday3(w5, 0, utcFirst2(y7))
    };
    timeIntervals2 = {
      [YEAR2]: year_default,
      [QUARTER2]: month_default.every(3),
      [MONTH2]: month_default,
      [WEEK2]: sunday,
      [DATE2]: day_default,
      [DAY2]: day_default,
      [DAYOFYEAR2]: day_default,
      [HOURS2]: hour_default,
      [MINUTES2]: minute_default,
      [SECONDS2]: second_default,
      [MILLISECONDS2]: millisecond_default
    };
    utcIntervals2 = {
      [YEAR2]: utcYear_default,
      [QUARTER2]: utcMonth_default.every(3),
      [MONTH2]: utcMonth_default,
      [WEEK2]: utcSunday2,
      [DATE2]: utcDay_default,
      [DAY2]: utcDay_default,
      [DAYOFYEAR2]: utcDay_default,
      [HOURS2]: utcHour_default,
      [MINUTES2]: utcMinute_default,
      [SECONDS2]: second_default,
      [MILLISECONDS2]: millisecond_default
    };
    durationSecond4 = 1e3;
    durationMinute4 = durationSecond4 * 60;
    durationHour4 = durationMinute4 * 60;
    durationDay4 = durationHour4 * 24;
    durationWeek4 = durationDay4 * 7;
    durationMonth4 = durationDay4 * 30;
    durationYear4 = durationDay4 * 365;
    Milli2 = [YEAR2, MONTH2, DATE2, HOURS2, MINUTES2, SECONDS2, MILLISECONDS2];
    Seconds2 = Milli2.slice(0, -1);
    Minutes2 = Seconds2.slice(0, -1);
    Hours2 = Minutes2.slice(0, -1);
    Day2 = Hours2.slice(0, -1);
    Week2 = [YEAR2, WEEK2];
    Month2 = [YEAR2, MONTH2];
    Year2 = [YEAR2];
    intervals2 = [[Seconds2, 1, durationSecond4], [Seconds2, 5, 5 * durationSecond4], [Seconds2, 15, 15 * durationSecond4], [Seconds2, 30, 30 * durationSecond4], [Minutes2, 1, durationMinute4], [Minutes2, 5, 5 * durationMinute4], [Minutes2, 15, 15 * durationMinute4], [Minutes2, 30, 30 * durationMinute4], [Hours2, 1, durationHour4], [Hours2, 3, 3 * durationHour4], [Hours2, 6, 6 * durationHour4], [Hours2, 12, 12 * durationHour4], [Day2, 1, durationDay4], [Week2, 1, durationWeek4], [Month2, 1, durationMonth4], [Month2, 3, 3 * durationMonth4], [Year2, 1, durationYear4]];
  }
});

// node_modules/.pnpm/vega-transforms@4.9.4/node_modules/vega-transforms/build/vega-transforms.module.js
var vega_transforms_module_exports = {};
__export(vega_transforms_module_exports, {
  aggregate: () => Aggregate,
  bin: () => Bin,
  collect: () => Collect,
  compare: () => Compare,
  countpattern: () => CountPattern,
  cross: () => Cross,
  density: () => Density,
  dotbin: () => DotBin,
  expression: () => Expression,
  extent: () => Extent,
  facet: () => Facet,
  field: () => Field,
  filter: () => Filter,
  flatten: () => Flatten,
  fold: () => Fold,
  formula: () => Formula,
  generate: () => Generate,
  impute: () => Impute,
  joinaggregate: () => JoinAggregate,
  kde: () => KDE,
  key: () => Key,
  load: () => Load,
  lookup: () => Lookup,
  multiextent: () => MultiExtent,
  multivalues: () => MultiValues,
  params: () => Params,
  pivot: () => Pivot,
  prefacet: () => PreFacet,
  project: () => Project,
  proxy: () => Proxy,
  quantile: () => Quantile,
  relay: () => Relay,
  sample: () => Sample,
  sequence: () => Sequence,
  sieve: () => Sieve,
  subflow: () => Subflow,
  timeunit: () => TimeUnit,
  tupleindex: () => TupleIndex,
  values: () => Values,
  window: () => Window
});
function multikey(f) {
  return (x7) => {
    const n = f.length;
    let i = 1, k4 = String(f[0](x7));
    for (; i < n; ++i) {
      k4 += "|" + f[i](x7);
    }
    return k4;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function() {
    return "";
  } : fields.length === 1 ? fields[0] : multikey(fields);
}
function measureName(op, field4, as) {
  return as || op + (!field4 ? "" : "_" + field4);
}
function measure(key3, value4) {
  return (out) => extend({
    name: key3,
    out: out || key3
  }, base_op, value4);
}
function createMeasure(op, name4) {
  return AggregateOps[op](name4);
}
function compareIndex(a4, b3) {
  return a4.idx - b3.idx;
}
function resolve(agg) {
  const map11 = {};
  agg.forEach((a4) => map11[a4.name] = a4);
  const getreqs = (a4) => {
    if (!a4.req)
      return;
    a4.req.forEach((key3) => {
      if (!map11[key3])
        getreqs(map11[key3] = AggregateOps[key3]());
    });
  };
  agg.forEach(getreqs);
  return Object.values(map11).sort(compareIndex);
}
function init() {
  this.valid = 0;
  this.missing = 0;
  this._ops.forEach((op) => op.init(this));
}
function add2(v, t) {
  if (v == null || v === "") {
    ++this.missing;
    return;
  }
  if (v !== v)
    return;
  ++this.valid;
  this._ops.forEach((op) => op.add(this, v, t));
}
function rem(v, t) {
  if (v == null || v === "") {
    --this.missing;
    return;
  }
  if (v !== v)
    return;
  --this.valid;
  this._ops.forEach((op) => op.rem(this, v, t));
}
function set2(t) {
  this._out.forEach((op) => t[op.out] = op.value(this));
  return t;
}
function compileMeasures(agg, field4) {
  const get8 = field4 || identity, ops2 = resolve(agg), out = agg.slice().sort(compareIndex);
  function ctr(cell2) {
    this._ops = ops2;
    this._out = out;
    this.cell = cell2;
    this.init();
  }
  ctr.prototype.init = init;
  ctr.prototype.add = add2;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set2;
  ctr.prototype.get = get8;
  ctr.fields = agg.map((op) => op.out);
  return ctr;
}
function TupleStore(key3) {
  this._key = key3 ? field(key3) : tupleid;
  this.reset();
}
function Aggregate(params2) {
  Transform.call(this, null, params2);
  this._adds = [];
  this._mods = [];
  this._alen = 0;
  this._mlen = 0;
  this._drop = true;
  this._cross = false;
  this._dims = [];
  this._dnames = [];
  this._measures = [];
  this._countOnly = false;
  this._counts = null;
  this._prev = null;
  this._inputs = null;
  this._outputs = null;
}
function Bin(params2) {
  Transform.call(this, null, params2);
}
function SortedList(idFunc, source5, input) {
  const $4 = idFunc;
  let data3 = source5 || [], add7 = input || [], rem2 = {}, cnt = 0;
  return {
    add: (t) => add7.push(t),
    remove: (t) => rem2[$4(t)] = ++cnt,
    size: () => data3.length,
    data: (compare6, resort) => {
      if (cnt) {
        data3 = data3.filter((t) => !rem2[$4(t)]);
        rem2 = {};
        cnt = 0;
      }
      if (resort && compare6) {
        data3.sort(compare6);
      }
      if (add7.length) {
        data3 = compare6 ? merge(compare6, data3, add7.sort(compare6)) : data3.concat(add7);
        add7 = [];
      }
      return data3;
    }
  };
}
function Collect(params2) {
  Transform.call(this, [], params2);
}
function Compare(params2) {
  Operator.call(this, null, update$5, params2);
}
function update$5(_) {
  return this.value && !_.modified() ? this.value : compare2(_.fields, _.orders);
}
function CountPattern(params2) {
  Transform.call(this, null, params2);
}
function tokenize(text5, tcase, match4) {
  switch (tcase) {
    case "upper":
      text5 = text5.toUpperCase();
      break;
    case "lower":
      text5 = text5.toLowerCase();
      break;
  }
  return text5.match(match4);
}
function Cross(params2) {
  Transform.call(this, null, params2);
}
function cross3(input, a4, b3, filter6) {
  var data3 = [], t = {}, n = input.length, i = 0, j, left;
  for (; i < n; ++i) {
    t[a4] = left = input[i];
    for (j = 0; j < n; ++j) {
      t[b3] = input[j];
      if (filter6(t)) {
        data3.push(ingest$1(t));
        t = {};
        t[a4] = left;
      }
    }
  }
  return data3;
}
function parse3(def3, data3) {
  const func = def3[FUNCTION];
  if (!has(Distributions, func)) {
    error("Unknown distribution function: " + func);
  }
  const d = Distributions[func]();
  for (const name4 in def3) {
    if (name4 === FIELD) {
      d.data((def3.from || data3()).map(def3[name4]));
    } else if (name4 === DISTRIBUTIONS) {
      d[name4](def3[name4].map((_) => parse3(_, data3)));
    } else if (typeof d[name4] === FUNCTION) {
      d[name4](def3[name4]);
    }
  }
  return d;
}
function Density(params2) {
  Transform.call(this, null, params2);
}
function source(pulse2) {
  return () => pulse2.materialize(pulse2.SOURCE).source;
}
function fieldNames(fields, as) {
  if (!fields)
    return null;
  return fields.map((f, i) => as[i] || accessorName(f));
}
function partition$1(data3, groupby, field4) {
  const groups4 = [], get8 = (f) => f(t);
  let map11, i, n, t, k4, g;
  if (groupby == null) {
    groups4.push(data3.map(field4));
  } else {
    for (map11 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k4 = groupby.map(get8);
      g = map11[k4];
      if (!g) {
        map11[k4] = g = [];
        g.dims = k4;
        groups4.push(g);
      }
      g.push(field4(t));
    }
  }
  return groups4;
}
function DotBin(params2) {
  Transform.call(this, null, params2);
}
function Expression(params2) {
  Operator.call(this, null, update$4, params2);
  this.modified(true);
}
function update$4(_) {
  const expr2 = _.expr;
  return this.value && !_.modified("expr") ? this.value : accessor((datum2) => expr2(datum2, _), accessorFields(expr2), accessorName(expr2));
}
function Extent(params2) {
  Transform.call(this, [void 0, void 0], params2);
}
function Subflow(pulse2, parent) {
  Operator.call(this, pulse2);
  this.parent = parent;
  this.count = 0;
}
function Facet(params2) {
  Transform.call(this, {}, params2);
  this._keys = fastmap();
  const a4 = this._targets = [];
  a4.active = 0;
  a4.forEach = (f) => {
    for (let i = 0, n = a4.active; i < n; ++i) {
      f(a4[i], i, a4);
    }
  };
}
function Field(params2) {
  Operator.call(this, null, update$3, params2);
}
function update$3(_) {
  return this.value && !_.modified() ? this.value : isArray(_.name) ? array(_.name).map((f) => field(f)) : field(_.name, _.as);
}
function Filter(params2) {
  Transform.call(this, fastmap(), params2);
}
function Flatten(params2) {
  Transform.call(this, [], params2);
}
function Fold(params2) {
  Transform.call(this, [], params2);
}
function Formula(params2) {
  Transform.call(this, null, params2);
}
function Generate(params2) {
  Transform.call(this, [], params2);
}
function Impute(params2) {
  Transform.call(this, [], params2);
}
function getValue(_) {
  var m2 = _.method || Methods.value, v;
  if (Methods[m2] == null) {
    error("Unrecognized imputation method: " + m2);
  } else if (m2 === Methods.value) {
    v = _.value !== void 0 ? _.value : 0;
    return () => v;
  } else {
    return Methods[m2];
  }
}
function getField(_) {
  const f = _.field;
  return (t) => t ? f(t) : NaN;
}
function partition(data3, groupby, key3, keyvals) {
  var get8 = (f) => f(t), groups4 = [], domain4 = keyvals ? keyvals.slice() : [], kMap = {}, gMap = {}, gVals, gKey, group6, i, j, k4, n, t;
  domain4.forEach((k5, i2) => kMap[k5] = i2 + 1);
  for (i = 0, n = data3.length; i < n; ++i) {
    t = data3[i];
    k4 = key3(t);
    j = kMap[k4] || (kMap[k4] = domain4.push(k4));
    gKey = (gVals = groupby ? groupby.map(get8) : Empty) + "";
    if (!(group6 = gMap[gKey])) {
      group6 = gMap[gKey] = [];
      groups4.push(group6);
      group6.values = gVals;
    }
    group6[j - 1] = t;
  }
  groups4.domain = domain4;
  return groups4;
}
function JoinAggregate(params2) {
  Aggregate.call(this, params2);
}
function KDE(params2) {
  Transform.call(this, null, params2);
}
function Key(params2) {
  Operator.call(this, null, update$2, params2);
}
function update$2(_) {
  return this.value && !_.modified() ? this.value : key(_.fields, _.flat);
}
function Load(params2) {
  Transform.call(this, [], params2);
  this._pending = null;
}
function stop(_) {
  return _.modified("async") && !(_.modified("values") || _.modified("url") || _.modified("format"));
}
function output2(op, pulse2, data3) {
  data3.forEach(ingest$1);
  const out = pulse2.fork(pulse2.NO_FIELDS & pulse2.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data3;
  op._pending = null;
  if (out.rem.length)
    out.clean(true);
  return out;
}
function Lookup(params2) {
  Transform.call(this, {}, params2);
}
function MultiExtent(params2) {
  Operator.call(this, null, update$1, params2);
}
function update$1(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }
  const ext = _.extents, n = ext.length;
  let min8 = Infinity, max8 = -Infinity, i, e3;
  for (i = 0; i < n; ++i) {
    e3 = ext[i];
    if (e3[0] < min8)
      min8 = e3[0];
    if (e3[1] > max8)
      max8 = e3[1];
  }
  return [min8, max8];
}
function MultiValues(params2) {
  Operator.call(this, null, update2, params2);
}
function update2(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data3, _2) => data3.concat(_2), []);
}
function Params(params2) {
  Transform.call(this, null, params2);
}
function Pivot(params2) {
  Aggregate.call(this, params2);
}
function aggregateParams(_, pulse2) {
  const key3 = _.field, value4 = _.value, op = (_.op === "count" ? "__count__" : _.op) || "sum", fields = accessorFields(key3).concat(accessorFields(value4)), keys5 = pivotKeys(key3, _.limit || 0, pulse2);
  if (pulse2.changed())
    _.set("__pivot__", null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys5.map(() => op),
    fields: keys5.map((k4) => get(k4, key3, value4, fields)),
    as: keys5.map((k4) => k4 + ""),
    modified: _.modified.bind(_)
  };
}
function get(k4, key3, value4, fields) {
  return accessor((d) => key3(d) === k4 ? value4(d) : NaN, fields, k4 + "");
}
function pivotKeys(key3, limit, pulse2) {
  const map11 = {}, list = [];
  pulse2.visit(pulse2.SOURCE, (t) => {
    const k4 = key3(t);
    if (!map11[k4]) {
      map11[k4] = 1;
      list.push(k4);
    }
  });
  list.sort(ascending);
  return limit ? list.slice(0, limit) : list;
}
function PreFacet(params2) {
  Facet.call(this, params2);
}
function Project(params2) {
  Transform.call(this, null, params2);
}
function project(s3, t, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t[as[i]] = fields[i](s3);
  }
  return t;
}
function Proxy(params2) {
  Transform.call(this, null, params2);
}
function Quantile(params2) {
  Transform.call(this, null, params2);
}
function Relay(params2) {
  Transform.call(this, null, params2);
}
function Sample(params2) {
  Transform.call(this, [], params2);
  this.count = 0;
}
function Sequence(params2) {
  Transform.call(this, null, params2);
}
function Sieve(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
function TimeUnit(params2) {
  Transform.call(this, null, params2);
}
function TupleIndex(params2) {
  Transform.call(this, fastmap(), params2);
}
function Values(params2) {
  Transform.call(this, null, params2);
}
function WindowOp(op, field4, param2, as) {
  const fn = WindowOps[op](field4, param2);
  return {
    init: fn.init || zero,
    update: function(w5, t) {
      t[as] = fn.next(w5);
    }
  };
}
function find(field4, data3, index8) {
  for (let n = data3.length; index8 < n; ++index8) {
    const v = field4(data3[index8]);
    if (v != null)
      return index8;
  }
  return -1;
}
function WindowState(_) {
  const ops2 = array(_.ops), fields = array(_.fields), params2 = array(_.params), as = array(_.as), outputs = this.outputs = [], windows = this.windows = [], inputs = {}, map11 = {}, counts = [], measures = [];
  let countOnly = true;
  function visitInputs(f) {
    array(accessorFields(f)).forEach((_2) => inputs[_2] = 1);
  }
  visitInputs(_.sort);
  ops2.forEach((op, i) => {
    const field4 = fields[i], mname = accessorName(field4), name4 = measureName(op, mname, as[i]);
    visitInputs(field4);
    outputs.push(name4);
    if (has(WindowOps, op)) {
      windows.push(WindowOp(op, fields[i], params2[i], name4));
    } else {
      if (field4 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      if (op === "count") {
        counts.push(name4);
        return;
      }
      countOnly = false;
      let m2 = map11[mname];
      if (!m2) {
        m2 = map11[mname] = [];
        m2.field = field4;
        measures.push(m2);
      }
      m2.push(createMeasure(op, name4));
    }
  });
  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }
  this.inputs = Object.keys(inputs);
}
function cell(measures, counts, countOnly) {
  measures = measures.map((m2) => compileMeasures(m2, m2.field));
  const cell2 = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };
  if (!countOnly) {
    var n = measures.length, a4 = cell2.agg = Array(n), i = 0;
    for (; i < n; ++i)
      a4[i] = new measures[i](cell2);
  }
  if (cell2.store) {
    var store = cell2.data = new TupleStore();
  }
  cell2.add = function(t) {
    cell2.num += 1;
    if (countOnly)
      return;
    if (store)
      store.add(t);
    for (let i2 = 0; i2 < n; ++i2) {
      a4[i2].add(a4[i2].get(t), t);
    }
  };
  cell2.rem = function(t) {
    cell2.num -= 1;
    if (countOnly)
      return;
    if (store)
      store.rem(t);
    for (let i2 = 0; i2 < n; ++i2) {
      a4[i2].rem(a4[i2].get(t), t);
    }
  };
  cell2.set = function(t) {
    let i2, n2;
    if (store)
      store.values();
    for (i2 = 0, n2 = counts.length; i2 < n2; ++i2)
      t[counts[i2]] = cell2.num;
    if (!countOnly)
      for (i2 = 0, n2 = a4.length; i2 < n2; ++i2)
        a4[i2].set(t);
  };
  cell2.init = function() {
    cell2.num = 0;
    if (store)
      store.reset();
    for (let i2 = 0; i2 < n; ++i2)
      a4[i2].init();
  };
  return cell2;
}
function Window(params2) {
  Transform.call(this, {}, params2);
  this._mlen = 0;
  this._mods = [];
}
function processPartition(list, state, cmp, _) {
  const sort5 = _.sort, range7 = sort5 && !_.ignorePeers, frame2 = _.frame || [null, 0], data3 = list.data(cmp), n = data3.length, b3 = range7 ? bisector_default(sort5) : null, w5 = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: data3,
    compare: sort5 || constant(-1)
  };
  state.init();
  for (let i = 0; i < n; ++i) {
    setWindow(w5, frame2, i, n);
    if (range7)
      adjustRange(w5, b3);
    state.update(w5, data3[i]);
  }
}
function setWindow(w5, f, i, n) {
  w5.p0 = w5.i0;
  w5.p1 = w5.i1;
  w5.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w5.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w5.index = i;
}
function adjustRange(w5, bisect2) {
  const r0 = w5.i0, r1 = w5.i1 - 1, c2 = w5.compare, d = w5.data, n = d.length - 1;
  if (r0 > 0 && !c2(d[r0], d[r0 - 1]))
    w5.i0 = bisect2.left(d, d[r0]);
  if (r1 < n && !c2(d[r1], d[r1 + 1]))
    w5.i1 = bisect2.right(d, d[r1]);
}
var noop, base_op, AggregateOps, ValidAggregateOps, prototype$1, EPSILON$1, Distributions, DISTRIBUTIONS, FUNCTION, FIELD, distributions, mixture2, Output, autostep, Methods, Empty, EPSILON, OUTPUT, WindowOps, ValidWindowOps, prototype;
var init_vega_transforms_module = __esm({
  "node_modules/.pnpm/vega-transforms@4.9.4/node_modules/vega-transforms/build/vega-transforms.module.js"() {
    init_vega_util_module();
    init_vega_dataflow_module();
    init_vega_statistics_module();
    init_src9();
    init_vega_time_module2();
    noop = () => {
    };
    base_op = {
      init: noop,
      add: noop,
      rem: noop,
      idx: 0
    };
    AggregateOps = {
      values: {
        init: (m2) => m2.cell.store = true,
        value: (m2) => m2.cell.data.values(),
        idx: -1
      },
      count: {
        value: (m2) => m2.cell.num
      },
      __count__: {
        value: (m2) => m2.missing + m2.valid
      },
      missing: {
        value: (m2) => m2.missing
      },
      valid: {
        value: (m2) => m2.valid
      },
      sum: {
        init: (m2) => m2.sum = 0,
        value: (m2) => m2.sum,
        add: (m2, v) => m2.sum += +v,
        rem: (m2, v) => m2.sum -= v
      },
      product: {
        init: (m2) => m2.product = 1,
        value: (m2) => m2.valid ? m2.product : void 0,
        add: (m2, v) => m2.product *= v,
        rem: (m2, v) => m2.product /= v
      },
      mean: {
        init: (m2) => m2.mean = 0,
        value: (m2) => m2.valid ? m2.mean : void 0,
        add: (m2, v) => (m2.mean_d = v - m2.mean, m2.mean += m2.mean_d / m2.valid),
        rem: (m2, v) => (m2.mean_d = v - m2.mean, m2.mean -= m2.valid ? m2.mean_d / m2.valid : m2.mean)
      },
      average: {
        value: (m2) => m2.valid ? m2.mean : void 0,
        req: ["mean"],
        idx: 1
      },
      variance: {
        init: (m2) => m2.dev = 0,
        value: (m2) => m2.valid > 1 ? m2.dev / (m2.valid - 1) : void 0,
        add: (m2, v) => m2.dev += m2.mean_d * (v - m2.mean),
        rem: (m2, v) => m2.dev -= m2.mean_d * (v - m2.mean),
        req: ["mean"],
        idx: 1
      },
      variancep: {
        value: (m2) => m2.valid > 1 ? m2.dev / m2.valid : void 0,
        req: ["variance"],
        idx: 2
      },
      stdev: {
        value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / (m2.valid - 1)) : void 0,
        req: ["variance"],
        idx: 2
      },
      stdevp: {
        value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / m2.valid) : void 0,
        req: ["variance"],
        idx: 2
      },
      stderr: {
        value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / (m2.valid * (m2.valid - 1))) : void 0,
        req: ["variance"],
        idx: 2
      },
      distinct: {
        value: (m2) => m2.cell.data.distinct(m2.get),
        req: ["values"],
        idx: 3
      },
      ci0: {
        value: (m2) => m2.cell.data.ci0(m2.get),
        req: ["values"],
        idx: 3
      },
      ci1: {
        value: (m2) => m2.cell.data.ci1(m2.get),
        req: ["values"],
        idx: 3
      },
      median: {
        value: (m2) => m2.cell.data.q2(m2.get),
        req: ["values"],
        idx: 3
      },
      q1: {
        value: (m2) => m2.cell.data.q1(m2.get),
        req: ["values"],
        idx: 3
      },
      q3: {
        value: (m2) => m2.cell.data.q3(m2.get),
        req: ["values"],
        idx: 3
      },
      min: {
        init: (m2) => m2.min = void 0,
        value: (m2) => m2.min = Number.isNaN(m2.min) ? m2.cell.data.min(m2.get) : m2.min,
        add: (m2, v) => {
          if (v < m2.min || m2.min === void 0)
            m2.min = v;
        },
        rem: (m2, v) => {
          if (v <= m2.min)
            m2.min = NaN;
        },
        req: ["values"],
        idx: 4
      },
      max: {
        init: (m2) => m2.max = void 0,
        value: (m2) => m2.max = Number.isNaN(m2.max) ? m2.cell.data.max(m2.get) : m2.max,
        add: (m2, v) => {
          if (v > m2.max || m2.max === void 0)
            m2.max = v;
        },
        rem: (m2, v) => {
          if (v >= m2.max)
            m2.max = NaN;
        },
        req: ["values"],
        idx: 4
      },
      argmin: {
        init: (m2) => m2.argmin = void 0,
        value: (m2) => m2.argmin || m2.cell.data.argmin(m2.get),
        add: (m2, v, t) => {
          if (v < m2.min)
            m2.argmin = t;
        },
        rem: (m2, v) => {
          if (v <= m2.min)
            m2.argmin = void 0;
        },
        req: ["min", "values"],
        idx: 3
      },
      argmax: {
        init: (m2) => m2.argmax = void 0,
        value: (m2) => m2.argmax || m2.cell.data.argmax(m2.get),
        add: (m2, v, t) => {
          if (v > m2.max)
            m2.argmax = t;
        },
        rem: (m2, v) => {
          if (v >= m2.max)
            m2.argmax = void 0;
        },
        req: ["max", "values"],
        idx: 3
      }
    };
    ValidAggregateOps = Object.keys(AggregateOps);
    ValidAggregateOps.forEach((key3) => {
      AggregateOps[key3] = measure(key3, AggregateOps[key3]);
    });
    prototype$1 = TupleStore.prototype;
    prototype$1.reset = function() {
      this._add = [];
      this._rem = [];
      this._ext = null;
      this._get = null;
      this._q = null;
    };
    prototype$1.add = function(v) {
      this._add.push(v);
    };
    prototype$1.rem = function(v) {
      this._rem.push(v);
    };
    prototype$1.values = function() {
      this._get = null;
      if (this._rem.length === 0)
        return this._add;
      const a4 = this._add, r2 = this._rem, k4 = this._key, n = a4.length, m2 = r2.length, x7 = Array(n - m2), map11 = {};
      let i, j, v;
      for (i = 0; i < m2; ++i) {
        map11[k4(r2[i])] = 1;
      }
      for (i = 0, j = 0; i < n; ++i) {
        if (map11[k4(v = a4[i])]) {
          map11[k4(v)] = 0;
        } else {
          x7[j++] = v;
        }
      }
      this._rem = [];
      return this._add = x7;
    };
    prototype$1.distinct = function(get8) {
      const v = this.values(), map11 = {};
      let n = v.length, count5 = 0, s3;
      while (--n >= 0) {
        s3 = get8(v[n]) + "";
        if (!has(map11, s3)) {
          map11[s3] = 1;
          ++count5;
        }
      }
      return count5;
    };
    prototype$1.extent = function(get8) {
      if (this._get !== get8 || !this._ext) {
        const v = this.values(), i = extentIndex(v, get8);
        this._ext = [v[i[0]], v[i[1]]];
        this._get = get8;
      }
      return this._ext;
    };
    prototype$1.argmin = function(get8) {
      return this.extent(get8)[0] || {};
    };
    prototype$1.argmax = function(get8) {
      return this.extent(get8)[1] || {};
    };
    prototype$1.min = function(get8) {
      const m2 = this.extent(get8)[0];
      return m2 != null ? get8(m2) : void 0;
    };
    prototype$1.max = function(get8) {
      const m2 = this.extent(get8)[1];
      return m2 != null ? get8(m2) : void 0;
    };
    prototype$1.quartile = function(get8) {
      if (this._get !== get8 || !this._q) {
        this._q = quartiles(this.values(), get8);
        this._get = get8;
      }
      return this._q;
    };
    prototype$1.q1 = function(get8) {
      return this.quartile(get8)[0];
    };
    prototype$1.q2 = function(get8) {
      return this.quartile(get8)[1];
    };
    prototype$1.q3 = function(get8) {
      return this.quartile(get8)[2];
    };
    prototype$1.ci = function(get8) {
      if (this._get !== get8 || !this._ci) {
        this._ci = bootstrapCI(this.values(), 1e3, 0.05, get8);
        this._get = get8;
      }
      return this._ci;
    };
    prototype$1.ci0 = function(get8) {
      return this.ci(get8)[0];
    };
    prototype$1.ci1 = function(get8) {
      return this.ci(get8)[1];
    };
    Aggregate.Definition = {
      "type": "Aggregate",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "ops",
        "type": "enum",
        "array": true,
        "values": ValidAggregateOps
      }, {
        "name": "fields",
        "type": "field",
        "null": true,
        "array": true
      }, {
        "name": "as",
        "type": "string",
        "null": true,
        "array": true
      }, {
        "name": "drop",
        "type": "boolean",
        "default": true
      }, {
        "name": "cross",
        "type": "boolean",
        "default": false
      }, {
        "name": "key",
        "type": "field"
      }]
    };
    inherits(Aggregate, Transform, {
      transform(_, pulse2) {
        const aggr = this, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), mod = _.modified();
        aggr.stamp = out.stamp;
        if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
          aggr._prev = aggr.value;
          aggr.value = mod ? aggr.init(_) : {};
          pulse2.visit(pulse2.SOURCE, (t) => aggr.add(t));
        } else {
          aggr.value = aggr.value || aggr.init(_);
          pulse2.visit(pulse2.REM, (t) => aggr.rem(t));
          pulse2.visit(pulse2.ADD, (t) => aggr.add(t));
        }
        out.modifies(aggr._outputs);
        aggr._drop = _.drop !== false;
        if (_.cross && aggr._dims.length > 1) {
          aggr._drop = false;
          aggr.cross();
        }
        if (pulse2.clean() && aggr._drop) {
          out.clean(true).runAfter(() => this.clean());
        }
        return aggr.changes(out);
      },
      cross() {
        const aggr = this, curr = aggr.value, dims = aggr._dnames, vals2 = dims.map(() => ({})), n = dims.length;
        function collect2(cells) {
          let key3, i, t, v;
          for (key3 in cells) {
            t = cells[key3].tuple;
            for (i = 0; i < n; ++i) {
              vals2[i][v = t[dims[i]]] = v;
            }
          }
        }
        collect2(aggr._prev);
        collect2(curr);
        function generate3(base3, tuple, index8) {
          const name4 = dims[index8], v = vals2[index8++];
          for (const k4 in v) {
            const key3 = base3 ? base3 + "|" + k4 : k4;
            tuple[name4] = v[k4];
            if (index8 < n)
              generate3(key3, tuple, index8);
            else if (!curr[key3])
              aggr.cell(key3, tuple);
          }
        }
        generate3("", {}, 0);
      },
      init(_) {
        const inputs = this._inputs = [], outputs = this._outputs = [], inputMap = {};
        function inputVisit(get8) {
          const fields2 = array(accessorFields(get8)), n2 = fields2.length;
          let i2 = 0, f;
          for (; i2 < n2; ++i2) {
            if (!inputMap[f = fields2[i2]]) {
              inputMap[f] = 1;
              inputs.push(f);
            }
          }
        }
        this._dims = array(_.groupby);
        this._dnames = this._dims.map((d) => {
          const dname = accessorName(d);
          inputVisit(d);
          outputs.push(dname);
          return dname;
        });
        this.cellkey = _.key ? _.key : groupkey(this._dims);
        this._countOnly = true;
        this._counts = [];
        this._measures = [];
        const fields = _.fields || [null], ops2 = _.ops || ["count"], as = _.as || [], n = fields.length, map11 = {};
        let field4, op, m2, mname, outname, i;
        if (n !== ops2.length) {
          error("Unmatched number of fields and aggregate ops.");
        }
        for (i = 0; i < n; ++i) {
          field4 = fields[i];
          op = ops2[i];
          if (field4 == null && op !== "count") {
            error("Null aggregate field specified.");
          }
          mname = accessorName(field4);
          outname = measureName(op, mname, as[i]);
          outputs.push(outname);
          if (op === "count") {
            this._counts.push(outname);
            continue;
          }
          m2 = map11[mname];
          if (!m2) {
            inputVisit(field4);
            m2 = map11[mname] = [];
            m2.field = field4;
            this._measures.push(m2);
          }
          if (op !== "count")
            this._countOnly = false;
          m2.push(createMeasure(op, outname));
        }
        this._measures = this._measures.map((m3) => compileMeasures(m3, m3.field));
        return {};
      },
      cellkey: groupkey(),
      cell(key3, t) {
        let cell2 = this.value[key3];
        if (!cell2) {
          cell2 = this.value[key3] = this.newcell(key3, t);
          this._adds[this._alen++] = cell2;
        } else if (cell2.num === 0 && this._drop && cell2.stamp < this.stamp) {
          cell2.stamp = this.stamp;
          this._adds[this._alen++] = cell2;
        } else if (cell2.stamp < this.stamp) {
          cell2.stamp = this.stamp;
          this._mods[this._mlen++] = cell2;
        }
        return cell2;
      },
      newcell(key3, t) {
        const cell2 = {
          key: key3,
          num: 0,
          agg: null,
          tuple: this.newtuple(t, this._prev && this._prev[key3]),
          stamp: this.stamp,
          store: false
        };
        if (!this._countOnly) {
          const measures = this._measures, n = measures.length;
          cell2.agg = Array(n);
          for (let i = 0; i < n; ++i) {
            cell2.agg[i] = new measures[i](cell2);
          }
        }
        if (cell2.store) {
          cell2.data = new TupleStore();
        }
        return cell2;
      },
      newtuple(t, p) {
        const names = this._dnames, dims = this._dims, n = dims.length, x7 = {};
        for (let i = 0; i < n; ++i) {
          x7[names[i]] = dims[i](t);
        }
        return p ? replace(p.tuple, x7) : ingest$1(x7);
      },
      clean() {
        const cells = this.value;
        for (const key3 in cells) {
          if (cells[key3].num === 0) {
            delete cells[key3];
          }
        }
      },
      add(t) {
        const key3 = this.cellkey(t), cell2 = this.cell(key3, t);
        cell2.num += 1;
        if (this._countOnly)
          return;
        if (cell2.store)
          cell2.data.add(t);
        const agg = cell2.agg;
        for (let i = 0, n = agg.length; i < n; ++i) {
          agg[i].add(agg[i].get(t), t);
        }
      },
      rem(t) {
        const key3 = this.cellkey(t), cell2 = this.cell(key3, t);
        cell2.num -= 1;
        if (this._countOnly)
          return;
        if (cell2.store)
          cell2.data.rem(t);
        const agg = cell2.agg;
        for (let i = 0, n = agg.length; i < n; ++i) {
          agg[i].rem(agg[i].get(t), t);
        }
      },
      celltuple(cell2) {
        const tuple = cell2.tuple, counts = this._counts;
        if (cell2.store) {
          cell2.data.values();
        }
        for (let i = 0, n = counts.length; i < n; ++i) {
          tuple[counts[i]] = cell2.num;
        }
        if (!this._countOnly) {
          const agg = cell2.agg;
          for (let i = 0, n = agg.length; i < n; ++i) {
            agg[i].set(tuple);
          }
        }
        return tuple;
      },
      changes(out) {
        const adds = this._adds, mods = this._mods, prev = this._prev, drop = this._drop, add7 = out.add, rem2 = out.rem, mod = out.mod;
        let cell2, key3, i, n;
        if (prev)
          for (key3 in prev) {
            cell2 = prev[key3];
            if (!drop || cell2.num)
              rem2.push(cell2.tuple);
          }
        for (i = 0, n = this._alen; i < n; ++i) {
          add7.push(this.celltuple(adds[i]));
          adds[i] = null;
        }
        for (i = 0, n = this._mlen; i < n; ++i) {
          cell2 = mods[i];
          (cell2.num === 0 && drop ? rem2 : mod).push(this.celltuple(cell2));
          mods[i] = null;
        }
        this._alen = this._mlen = 0;
        this._prev = null;
        return out;
      }
    });
    EPSILON$1 = 1e-14;
    Bin.Definition = {
      "type": "Bin",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "interval",
        "type": "boolean",
        "default": true
      }, {
        "name": "anchor",
        "type": "number"
      }, {
        "name": "maxbins",
        "type": "number",
        "default": 20
      }, {
        "name": "base",
        "type": "number",
        "default": 10
      }, {
        "name": "divide",
        "type": "number",
        "array": true,
        "default": [5, 2]
      }, {
        "name": "extent",
        "type": "number",
        "array": true,
        "length": 2,
        "required": true
      }, {
        "name": "span",
        "type": "number"
      }, {
        "name": "step",
        "type": "number"
      }, {
        "name": "steps",
        "type": "number",
        "array": true
      }, {
        "name": "minstep",
        "type": "number",
        "default": 0
      }, {
        "name": "nice",
        "type": "boolean",
        "default": true
      }, {
        "name": "name",
        "type": "string"
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["bin0", "bin1"]
      }]
    };
    inherits(Bin, Transform, {
      transform(_, pulse2) {
        const band5 = _.interval !== false, bins2 = this._bins(_), start = bins2.start, step = bins2.step, as = _.as || ["bin0", "bin1"], b0 = as[0], b1 = as[1];
        let flag2;
        if (_.modified()) {
          pulse2 = pulse2.reflow(true);
          flag2 = pulse2.SOURCE;
        } else {
          flag2 = pulse2.modified(accessorFields(_.field)) ? pulse2.ADD_MOD : pulse2.ADD;
        }
        pulse2.visit(flag2, band5 ? (t) => {
          const v = bins2(t);
          t[b0] = v;
          t[b1] = v == null ? null : start + step * (1 + (v - start) / step);
        } : (t) => t[b0] = bins2(t));
        return pulse2.modifies(band5 ? as : b0);
      },
      _bins(_) {
        if (this.value && !_.modified()) {
          return this.value;
        }
        const field4 = _.field, bins2 = bin2(_), step = bins2.step;
        let start = bins2.start, stop2 = start + Math.ceil((bins2.stop - start) / step) * step, a4, d;
        if ((a4 = _.anchor) != null) {
          d = a4 - (start + step * Math.floor((a4 - start) / step));
          start += d;
          stop2 += d;
        }
        const f = function(t) {
          let v = toNumber(field4(t));
          return v == null ? null : v < start ? -Infinity : v > stop2 ? Infinity : (v = Math.max(start, Math.min(v, stop2 - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));
        };
        f.start = start;
        f.stop = bins2.stop;
        f.step = step;
        return this.value = accessor(f, accessorFields(field4), _.name || "bin_" + accessorName(field4));
      }
    });
    Collect.Definition = {
      "type": "Collect",
      "metadata": {
        "source": true
      },
      "params": [{
        "name": "sort",
        "type": "compare"
      }]
    };
    inherits(Collect, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.ALL), list = SortedList(tupleid, this.value, out.materialize(out.ADD).add), sort5 = _.sort, mod = pulse2.changed() || sort5 && (_.modified("sort") || pulse2.modified(sort5.fields));
        out.visit(out.REM, list.remove);
        this.modified(mod);
        this.value = out.source = list.data(stableCompare(sort5), mod);
        if (pulse2.source && pulse2.source.root) {
          this.value.root = pulse2.source.root;
        }
        return out;
      }
    });
    inherits(Compare, Operator);
    CountPattern.Definition = {
      "type": "CountPattern",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "case",
        "type": "enum",
        "values": ["upper", "lower", "mixed"],
        "default": "mixed"
      }, {
        "name": "pattern",
        "type": "string",
        "default": '[\\w"]+'
      }, {
        "name": "stopwords",
        "type": "string",
        "default": ""
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["text", "count"]
      }]
    };
    inherits(CountPattern, Transform, {
      transform(_, pulse2) {
        const process2 = (update3) => (tuple) => {
          var tokens = tokenize(get8(tuple), _.case, match4) || [], t;
          for (var i = 0, n = tokens.length; i < n; ++i) {
            if (!stop2.test(t = tokens[i]))
              update3(t);
          }
        };
        const init2 = this._parameterCheck(_, pulse2), counts = this._counts, match4 = this._match, stop2 = this._stop, get8 = _.field, as = _.as || ["text", "count"], add7 = process2((t) => counts[t] = 1 + (counts[t] || 0)), rem2 = process2((t) => counts[t] -= 1);
        if (init2) {
          pulse2.visit(pulse2.SOURCE, add7);
        } else {
          pulse2.visit(pulse2.ADD, add7);
          pulse2.visit(pulse2.REM, rem2);
        }
        return this._finish(pulse2, as);
      },
      _parameterCheck(_, pulse2) {
        let init2 = false;
        if (_.modified("stopwords") || !this._stop) {
          this._stop = new RegExp("^" + (_.stopwords || "") + "$", "i");
          init2 = true;
        }
        if (_.modified("pattern") || !this._match) {
          this._match = new RegExp(_.pattern || "[\\w']+", "g");
          init2 = true;
        }
        if (_.modified("field") || pulse2.modified(_.field.fields)) {
          init2 = true;
        }
        if (init2)
          this._counts = {};
        return init2;
      },
      _finish(pulse2, as) {
        const counts = this._counts, tuples = this._tuples || (this._tuples = {}), text5 = as[0], count5 = as[1], out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
        let w5, t, c2;
        for (w5 in counts) {
          t = tuples[w5];
          c2 = counts[w5] || 0;
          if (!t && c2) {
            tuples[w5] = t = ingest$1({});
            t[text5] = w5;
            t[count5] = c2;
            out.add.push(t);
          } else if (c2 === 0) {
            if (t)
              out.rem.push(t);
            counts[w5] = null;
            tuples[w5] = null;
          } else if (t[count5] !== c2) {
            t[count5] = c2;
            out.mod.push(t);
          }
        }
        return out.modifies(as);
      }
    });
    Cross.Definition = {
      "type": "Cross",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "filter",
        "type": "expr"
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["a", "b"]
      }]
    };
    inherits(Cross, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE), as = _.as || ["a", "b"], a4 = as[0], b3 = as[1], reset3 = !this.value || pulse2.changed(pulse2.ADD_REM) || _.modified("as") || _.modified("filter");
        let data3 = this.value;
        if (reset3) {
          if (data3)
            out.rem = data3;
          data3 = pulse2.materialize(pulse2.SOURCE).source;
          out.add = this.value = cross3(data3, a4, b3, _.filter || truthy);
        } else {
          out.mod = data3;
        }
        out.source = this.value;
        return out.modifies(as);
      }
    });
    Distributions = {
      kde,
      mixture,
      normal: gaussian,
      lognormal,
      uniform
    };
    DISTRIBUTIONS = "distributions";
    FUNCTION = "function";
    FIELD = "field";
    distributions = [{
      "key": {
        "function": "normal"
      },
      "params": [{
        "name": "mean",
        "type": "number",
        "default": 0
      }, {
        "name": "stdev",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "function": "lognormal"
      },
      "params": [{
        "name": "mean",
        "type": "number",
        "default": 0
      }, {
        "name": "stdev",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "function": "uniform"
      },
      "params": [{
        "name": "min",
        "type": "number",
        "default": 0
      }, {
        "name": "max",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "function": "kde"
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "from",
        "type": "data"
      }, {
        "name": "bandwidth",
        "type": "number",
        "default": 0
      }]
    }];
    mixture2 = {
      "key": {
        "function": "mixture"
      },
      "params": [{
        "name": "distributions",
        "type": "param",
        "array": true,
        "params": distributions
      }, {
        "name": "weights",
        "type": "number",
        "array": true
      }]
    };
    Density.Definition = {
      "type": "Density",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "extent",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "steps",
        "type": "number"
      }, {
        "name": "minsteps",
        "type": "number",
        "default": 25
      }, {
        "name": "maxsteps",
        "type": "number",
        "default": 200
      }, {
        "name": "method",
        "type": "string",
        "default": "pdf",
        "values": ["pdf", "cdf"]
      }, {
        "name": "distribution",
        "type": "param",
        "params": distributions.concat(mixture2)
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "default": ["value", "density"]
      }]
    };
    inherits(Density, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
        if (!this.value || pulse2.changed() || _.modified()) {
          const dist2 = parse3(_.distribution, source(pulse2)), minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
          let method3 = _.method || "pdf";
          if (method3 !== "pdf" && method3 !== "cdf") {
            error("Invalid density method: " + method3);
          }
          if (!_.extent && !dist2.data) {
            error("Missing density extent parameter.");
          }
          method3 = dist2[method3];
          const as = _.as || ["value", "density"], domain4 = _.extent || extent(dist2.data()), values5 = sampleCurve(method3, domain4, minsteps, maxsteps).map((v) => {
            const tuple = {};
            tuple[as[0]] = v[0];
            tuple[as[1]] = v[1];
            return ingest$1(tuple);
          });
          if (this.value)
            out.rem = this.value;
          this.value = out.add = out.source = values5;
        }
        return out;
      }
    });
    Output = "bin";
    DotBin.Definition = {
      "type": "DotBin",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "step",
        "type": "number"
      }, {
        "name": "smooth",
        "type": "boolean",
        "default": false
      }, {
        "name": "as",
        "type": "string",
        "default": Output
      }]
    };
    autostep = (data3, field4) => span(extent(data3, field4)) / 30;
    inherits(DotBin, Transform, {
      transform(_, pulse2) {
        if (this.value && !(_.modified() || pulse2.changed())) {
          return pulse2;
        }
        const source5 = pulse2.materialize(pulse2.SOURCE).source, groups4 = partition$1(pulse2.source, _.groupby, identity), smooth = _.smooth || false, field4 = _.field, step = _.step || autostep(source5, field4), sort5 = stableCompare((a4, b3) => field4(a4) - field4(b3)), as = _.as || Output, n = groups4.length;
        let min8 = Infinity, max8 = -Infinity, i = 0, j;
        for (; i < n; ++i) {
          const g = groups4[i].sort(sort5);
          j = -1;
          for (const v of dotbin(g, step, smooth, field4)) {
            if (v < min8)
              min8 = v;
            if (v > max8)
              max8 = v;
            g[++j][as] = v;
          }
        }
        this.value = {
          start: min8,
          stop: max8,
          step
        };
        return pulse2.reflow(true).modifies(as);
      }
    });
    inherits(Expression, Operator);
    Extent.Definition = {
      "type": "Extent",
      "metadata": {},
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }]
    };
    inherits(Extent, Transform, {
      transform(_, pulse2) {
        const extent5 = this.value, field4 = _.field, mod = pulse2.changed() || pulse2.modified(field4.fields) || _.modified("field");
        let min8 = extent5[0], max8 = extent5[1];
        if (mod || min8 == null) {
          min8 = Infinity;
          max8 = -Infinity;
        }
        pulse2.visit(mod ? pulse2.SOURCE : pulse2.ADD, (t) => {
          const v = toNumber(field4(t));
          if (v != null) {
            if (v < min8)
              min8 = v;
            if (v > max8)
              max8 = v;
          }
        });
        if (!Number.isFinite(min8) || !Number.isFinite(max8)) {
          let name4 = accessorName(field4);
          if (name4)
            name4 = ` for field "${name4}"`;
          pulse2.dataflow.warn(`Infinite extent${name4}: [${min8}, ${max8}]`);
          min8 = max8 = void 0;
        }
        this.value = [min8, max8];
      }
    });
    inherits(Subflow, Operator, {
      connect(target2) {
        this.detachSubflow = target2.detachSubflow;
        this.targets().add(target2);
        return target2.source = this;
      },
      add(t) {
        this.count += 1;
        this.value.add.push(t);
      },
      rem(t) {
        this.count -= 1;
        this.value.rem.push(t);
      },
      mod(t) {
        this.value.mod.push(t);
      },
      init(pulse2) {
        this.value.init(pulse2, pulse2.NO_SOURCE);
      },
      evaluate() {
        return this.value;
      }
    });
    inherits(Facet, Transform, {
      activate(flow) {
        this._targets[this._targets.active++] = flow;
      },
      subflow(key3, flow, pulse2, parent) {
        const flows = this.value;
        let sf = has(flows, key3) && flows[key3], df, p;
        if (!sf) {
          p = parent || (p = this._group[key3]) && p.tuple;
          df = pulse2.dataflow;
          sf = new Subflow(pulse2.fork(pulse2.NO_SOURCE), this);
          df.add(sf).connect(flow(df, key3, p));
          flows[key3] = sf;
          this.activate(sf);
        } else if (sf.value.stamp < pulse2.stamp) {
          sf.init(pulse2);
          this.activate(sf);
        }
        return sf;
      },
      clean() {
        const flows = this.value;
        let detached = 0;
        for (const key3 in flows) {
          if (flows[key3].count === 0) {
            const detach = flows[key3].detachSubflow;
            if (detach)
              detach();
            delete flows[key3];
            ++detached;
          }
        }
        if (detached) {
          const active = this._targets.filter((sf) => sf && sf.count > 0);
          this.initTargets(active);
        }
      },
      initTargets(act) {
        const a4 = this._targets, n = a4.length, m2 = act ? act.length : 0;
        let i = 0;
        for (; i < m2; ++i) {
          a4[i] = act[i];
        }
        for (; i < n && a4[i] != null; ++i) {
          a4[i] = null;
        }
        a4.active = m2;
      },
      transform(_, pulse2) {
        const df = pulse2.dataflow, key3 = _.key, flow = _.subflow, cache3 = this._keys, rekey = _.modified("key"), subflow = (key4) => this.subflow(key4, flow, pulse2);
        this._group = _.group || {};
        this.initTargets();
        pulse2.visit(pulse2.REM, (t) => {
          const id4 = tupleid(t), k4 = cache3.get(id4);
          if (k4 !== void 0) {
            cache3.delete(id4);
            subflow(k4).rem(t);
          }
        });
        pulse2.visit(pulse2.ADD, (t) => {
          const k4 = key3(t);
          cache3.set(tupleid(t), k4);
          subflow(k4).add(t);
        });
        if (rekey || pulse2.modified(key3.fields)) {
          pulse2.visit(pulse2.MOD, (t) => {
            const id4 = tupleid(t), k0 = cache3.get(id4), k1 = key3(t);
            if (k0 === k1) {
              subflow(k1).mod(t);
            } else {
              cache3.set(id4, k1);
              subflow(k0).rem(t);
              subflow(k1).add(t);
            }
          });
        } else if (pulse2.changed(pulse2.MOD)) {
          pulse2.visit(pulse2.MOD, (t) => {
            subflow(cache3.get(tupleid(t))).mod(t);
          });
        }
        if (rekey) {
          pulse2.visit(pulse2.REFLOW, (t) => {
            const id4 = tupleid(t), k0 = cache3.get(id4), k1 = key3(t);
            if (k0 !== k1) {
              cache3.set(id4, k1);
              subflow(k0).rem(t);
              subflow(k1).add(t);
            }
          });
        }
        if (pulse2.clean()) {
          df.runAfter(() => {
            this.clean();
            cache3.clean();
          });
        } else if (cache3.empty > df.cleanThreshold) {
          df.runAfter(cache3.clean);
        }
        return pulse2;
      }
    });
    inherits(Field, Operator);
    Filter.Definition = {
      "type": "Filter",
      "metadata": {
        "changes": true
      },
      "params": [{
        "name": "expr",
        "type": "expr",
        "required": true
      }]
    };
    inherits(Filter, Transform, {
      transform(_, pulse2) {
        const df = pulse2.dataflow, cache3 = this.value, output3 = pulse2.fork(), add7 = output3.add, rem2 = output3.rem, mod = output3.mod, test2 = _.expr;
        let isMod = true;
        pulse2.visit(pulse2.REM, (t) => {
          const id4 = tupleid(t);
          if (!cache3.has(id4))
            rem2.push(t);
          else
            cache3.delete(id4);
        });
        pulse2.visit(pulse2.ADD, (t) => {
          if (test2(t, _))
            add7.push(t);
          else
            cache3.set(tupleid(t), 1);
        });
        function revisit(t) {
          const id4 = tupleid(t), b3 = test2(t, _), s3 = cache3.get(id4);
          if (b3 && s3) {
            cache3.delete(id4);
            add7.push(t);
          } else if (!b3 && !s3) {
            cache3.set(id4, 1);
            rem2.push(t);
          } else if (isMod && b3 && !s3) {
            mod.push(t);
          }
        }
        pulse2.visit(pulse2.MOD, revisit);
        if (_.modified()) {
          isMod = false;
          pulse2.visit(pulse2.REFLOW, revisit);
        }
        if (cache3.empty > df.cleanThreshold)
          df.runAfter(cache3.clean);
        return output3;
      }
    });
    Flatten.Definition = {
      "type": "Flatten",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "fields",
        "type": "field",
        "array": true,
        "required": true
      }, {
        "name": "index",
        "type": "string"
      }, {
        "name": "as",
        "type": "string",
        "array": true
      }]
    };
    inherits(Flatten, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(fields, _.as || []), index8 = _.index || null, m2 = as.length;
        out.rem = this.value;
        pulse2.visit(pulse2.SOURCE, (t) => {
          const arrays = fields.map((f) => f(t)), maxlen = arrays.reduce((l, a4) => Math.max(l, a4.length), 0);
          let i = 0, j, d, v;
          for (; i < maxlen; ++i) {
            d = derive(t);
            for (j = 0; j < m2; ++j) {
              d[as[j]] = (v = arrays[j][i]) == null ? null : v;
            }
            if (index8) {
              d[index8] = i;
            }
            out.add.push(d);
          }
        });
        this.value = out.source = out.add;
        if (index8)
          out.modifies(index8);
        return out.modifies(as);
      }
    });
    Fold.Definition = {
      "type": "Fold",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "fields",
        "type": "field",
        "array": true,
        "required": true
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["key", "value"]
      }]
    };
    inherits(Fold, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, fnames = fields.map(accessorName), as = _.as || ["key", "value"], k4 = as[0], v = as[1], n = fields.length;
        out.rem = this.value;
        pulse2.visit(pulse2.SOURCE, (t) => {
          for (let i = 0, d; i < n; ++i) {
            d = derive(t);
            d[k4] = fnames[i];
            d[v] = fields[i](t);
            out.add.push(d);
          }
        });
        this.value = out.source = out.add;
        return out.modifies(as);
      }
    });
    Formula.Definition = {
      "type": "Formula",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "expr",
        "type": "expr",
        "required": true
      }, {
        "name": "as",
        "type": "string",
        "required": true
      }, {
        "name": "initonly",
        "type": "boolean"
      }]
    };
    inherits(Formula, Transform, {
      transform(_, pulse2) {
        const func = _.expr, as = _.as, mod = _.modified(), flag2 = _.initonly ? pulse2.ADD : mod ? pulse2.SOURCE : pulse2.modified(func.fields) || pulse2.modified(as) ? pulse2.ADD_MOD : pulse2.ADD;
        if (mod) {
          pulse2 = pulse2.materialize().reflow(true);
        }
        if (!_.initonly) {
          pulse2.modifies(as);
        }
        return pulse2.visit(flag2, (t) => t[as] = func(t, _));
      }
    });
    inherits(Generate, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.ALL), gen = _.generator;
        let data3 = this.value, num = _.size - data3.length, add7, rem2, t;
        if (num > 0) {
          for (add7 = []; --num >= 0; ) {
            add7.push(t = ingest$1(gen(_)));
            data3.push(t);
          }
          out.add = out.add.length ? out.materialize(out.ADD).add.concat(add7) : add7;
        } else {
          rem2 = data3.slice(0, -num);
          out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem2) : rem2;
          data3 = data3.slice(-num);
        }
        out.source = this.value = data3;
        return out;
      }
    });
    Methods = {
      value: "value",
      median: median_default,
      mean: mean2,
      min: min2,
      max: max2
    };
    Empty = [];
    Impute.Definition = {
      "type": "Impute",
      "metadata": {
        "changes": true
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "key",
        "type": "field",
        "required": true
      }, {
        "name": "keyvals",
        "array": true
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "method",
        "type": "enum",
        "default": "value",
        "values": ["value", "mean", "median", "max", "min"]
      }, {
        "name": "value",
        "default": 0
      }]
    };
    inherits(Impute, Transform, {
      transform(_, pulse2) {
        var out = pulse2.fork(pulse2.ALL), impute = getValue(_), field4 = getField(_), fName = accessorName(_.field), kName = accessorName(_.key), gNames = (_.groupby || []).map(accessorName), groups4 = partition(pulse2.source, _.groupby, _.key, _.keyvals), curr = [], prev = this.value, m2 = groups4.domain.length, group6, value4, gVals, kVal, g, i, j, l, n, t;
        for (g = 0, l = groups4.length; g < l; ++g) {
          group6 = groups4[g];
          gVals = group6.values;
          value4 = NaN;
          for (j = 0; j < m2; ++j) {
            if (group6[j] != null)
              continue;
            kVal = groups4.domain[j];
            t = {
              _impute: true
            };
            for (i = 0, n = gVals.length; i < n; ++i)
              t[gNames[i]] = gVals[i];
            t[kName] = kVal;
            t[fName] = Number.isNaN(value4) ? value4 = impute(group6, field4) : value4;
            curr.push(ingest$1(t));
          }
        }
        if (curr.length)
          out.add = out.materialize(out.ADD).add.concat(curr);
        if (prev.length)
          out.rem = out.materialize(out.REM).rem.concat(prev);
        this.value = curr;
        return out;
      }
    });
    JoinAggregate.Definition = {
      "type": "JoinAggregate",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "fields",
        "type": "field",
        "null": true,
        "array": true
      }, {
        "name": "ops",
        "type": "enum",
        "array": true,
        "values": ValidAggregateOps
      }, {
        "name": "as",
        "type": "string",
        "null": true,
        "array": true
      }, {
        "name": "key",
        "type": "field"
      }]
    };
    inherits(JoinAggregate, Aggregate, {
      transform(_, pulse2) {
        const aggr = this, mod = _.modified();
        let cells;
        if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
          cells = aggr.value = mod ? aggr.init(_) : {};
          pulse2.visit(pulse2.SOURCE, (t) => aggr.add(t));
        } else {
          cells = aggr.value = aggr.value || this.init(_);
          pulse2.visit(pulse2.REM, (t) => aggr.rem(t));
          pulse2.visit(pulse2.ADD, (t) => aggr.add(t));
        }
        aggr.changes();
        pulse2.visit(pulse2.SOURCE, (t) => {
          extend(t, cells[aggr.cellkey(t)].tuple);
        });
        return pulse2.reflow(mod).modifies(this._outputs);
      },
      changes() {
        const adds = this._adds, mods = this._mods;
        let i, n;
        for (i = 0, n = this._alen; i < n; ++i) {
          this.celltuple(adds[i]);
          adds[i] = null;
        }
        for (i = 0, n = this._mlen; i < n; ++i) {
          this.celltuple(mods[i]);
          mods[i] = null;
        }
        this._alen = this._mlen = 0;
      }
    });
    KDE.Definition = {
      "type": "KDE",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "cumulative",
        "type": "boolean",
        "default": false
      }, {
        "name": "counts",
        "type": "boolean",
        "default": false
      }, {
        "name": "bandwidth",
        "type": "number",
        "default": 0
      }, {
        "name": "extent",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "resolve",
        "type": "enum",
        "values": ["shared", "independent"],
        "default": "independent"
      }, {
        "name": "steps",
        "type": "number"
      }, {
        "name": "minsteps",
        "type": "number",
        "default": 25
      }, {
        "name": "maxsteps",
        "type": "number",
        "default": 200
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "default": ["value", "density"]
      }]
    };
    inherits(KDE, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
        if (!this.value || pulse2.changed() || _.modified()) {
          const source5 = pulse2.materialize(pulse2.SOURCE).source, groups4 = partition$1(source5, _.groupby, _.field), names = (_.groupby || []).map(accessorName), bandwidth2 = _.bandwidth, method3 = _.cumulative ? "cdf" : "pdf", as = _.as || ["value", "density"], values5 = [];
          let domain4 = _.extent, minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
          if (method3 !== "pdf" && method3 !== "cdf") {
            error("Invalid density method: " + method3);
          }
          if (_.resolve === "shared") {
            if (!domain4)
              domain4 = extent(source5, _.field);
            minsteps = maxsteps = _.steps || maxsteps;
          }
          groups4.forEach((g) => {
            const density = kde(g, bandwidth2)[method3], scale8 = _.counts ? g.length : 1, local2 = domain4 || extent(g);
            sampleCurve(density, local2, minsteps, maxsteps).forEach((v) => {
              const t = {};
              for (let i = 0; i < names.length; ++i) {
                t[names[i]] = g.dims[i];
              }
              t[as[0]] = v[0];
              t[as[1]] = v[1] * scale8;
              values5.push(ingest$1(t));
            });
          });
          if (this.value)
            out.rem = this.value;
          this.value = out.add = out.source = values5;
        }
        return out;
      }
    });
    inherits(Key, Operator);
    inherits(Load, Transform, {
      transform(_, pulse2) {
        const df = pulse2.dataflow;
        if (this._pending) {
          return output2(this, pulse2, this._pending);
        }
        if (stop(_))
          return pulse2.StopPropagation;
        if (_.values) {
          return output2(this, pulse2, df.parse(_.values, _.format));
        } else if (_.async) {
          const p = df.request(_.url, _.format).then((res) => {
            this._pending = array(res.data);
            return (df2) => df2.touch(this);
          });
          return {
            async: p
          };
        } else {
          return df.request(_.url, _.format).then((res) => output2(this, pulse2, array(res.data)));
        }
      }
    });
    Lookup.Definition = {
      "type": "Lookup",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "index",
        "type": "index",
        "params": [{
          "name": "from",
          "type": "data",
          "required": true
        }, {
          "name": "key",
          "type": "field",
          "required": true
        }]
      }, {
        "name": "values",
        "type": "field",
        "array": true
      }, {
        "name": "fields",
        "type": "field",
        "array": true,
        "required": true
      }, {
        "name": "as",
        "type": "string",
        "array": true
      }, {
        "name": "default",
        "default": null
      }]
    };
    inherits(Lookup, Transform, {
      transform(_, pulse2) {
        const keys5 = _.fields, index8 = _.index, values5 = _.values, defaultValue = _.default == null ? null : _.default, reset3 = _.modified(), n = keys5.length;
        let flag2 = reset3 ? pulse2.SOURCE : pulse2.ADD, out = pulse2, as = _.as, set8, m2, mods;
        if (values5) {
          m2 = values5.length;
          if (n > 1 && !as) {
            error('Multi-field lookup requires explicit "as" parameter.');
          }
          if (as && as.length !== n * m2) {
            error('The "as" parameter has too few output field names.');
          }
          as = as || values5.map(accessorName);
          set8 = function(t) {
            for (var i = 0, k4 = 0, j, v; i < n; ++i) {
              v = index8.get(keys5[i](t));
              if (v == null)
                for (j = 0; j < m2; ++j, ++k4)
                  t[as[k4]] = defaultValue;
              else
                for (j = 0; j < m2; ++j, ++k4)
                  t[as[k4]] = values5[j](v);
            }
          };
        } else {
          if (!as) {
            error("Missing output field names.");
          }
          set8 = function(t) {
            for (var i = 0, v; i < n; ++i) {
              v = index8.get(keys5[i](t));
              t[as[i]] = v == null ? defaultValue : v;
            }
          };
        }
        if (reset3) {
          out = pulse2.reflow(true);
        } else {
          mods = keys5.some((k4) => pulse2.modified(k4.fields));
          flag2 |= mods ? pulse2.MOD : 0;
        }
        pulse2.visit(flag2, set8);
        return out.modifies(as);
      }
    });
    inherits(MultiExtent, Operator);
    inherits(MultiValues, Operator);
    inherits(Params, Transform, {
      transform(_, pulse2) {
        this.modified(_.modified());
        this.value = _;
        return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
      }
    });
    Pivot.Definition = {
      "type": "Pivot",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "value",
        "type": "field",
        "required": true
      }, {
        "name": "op",
        "type": "enum",
        "values": ValidAggregateOps,
        "default": "sum"
      }, {
        "name": "limit",
        "type": "number",
        "default": 0
      }, {
        "name": "key",
        "type": "field"
      }]
    };
    inherits(Pivot, Aggregate, {
      _transform: Aggregate.prototype.transform,
      transform(_, pulse2) {
        return this._transform(aggregateParams(_, pulse2), pulse2);
      }
    });
    inherits(PreFacet, Facet, {
      transform(_, pulse2) {
        const flow = _.subflow, field4 = _.field, subflow = (t) => this.subflow(tupleid(t), flow, pulse2, t);
        if (_.modified("field") || field4 && pulse2.modified(accessorFields(field4))) {
          error("PreFacet does not support field modification.");
        }
        this.initTargets();
        if (field4) {
          pulse2.visit(pulse2.MOD, (t) => {
            const sf = subflow(t);
            field4(t).forEach((_2) => sf.mod(_2));
          });
          pulse2.visit(pulse2.ADD, (t) => {
            const sf = subflow(t);
            field4(t).forEach((_2) => sf.add(ingest$1(_2)));
          });
          pulse2.visit(pulse2.REM, (t) => {
            const sf = subflow(t);
            field4(t).forEach((_2) => sf.rem(_2));
          });
        } else {
          pulse2.visit(pulse2.MOD, (t) => subflow(t).mod(t));
          pulse2.visit(pulse2.ADD, (t) => subflow(t).add(t));
          pulse2.visit(pulse2.REM, (t) => subflow(t).rem(t));
        }
        if (pulse2.clean()) {
          pulse2.runAfter(() => this.clean());
        }
        return pulse2;
      }
    });
    Project.Definition = {
      "type": "Project",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "fields",
        "type": "field",
        "array": true
      }, {
        "name": "as",
        "type": "string",
        "null": true,
        "array": true
      }]
    };
    inherits(Project, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(_.fields, _.as || []), derive2 = fields ? (s3, t) => project(s3, t, fields, as) : rederive;
        let lut;
        if (this.value) {
          lut = this.value;
        } else {
          pulse2 = pulse2.addAll();
          lut = this.value = {};
        }
        pulse2.visit(pulse2.REM, (t) => {
          const id4 = tupleid(t);
          out.rem.push(lut[id4]);
          lut[id4] = null;
        });
        pulse2.visit(pulse2.ADD, (t) => {
          const dt = derive2(t, ingest$1({}));
          lut[tupleid(t)] = dt;
          out.add.push(dt);
        });
        pulse2.visit(pulse2.MOD, (t) => {
          out.mod.push(derive2(t, lut[tupleid(t)]));
        });
        return out;
      }
    });
    inherits(Proxy, Transform, {
      transform(_, pulse2) {
        this.value = _.value;
        return _.modified("value") ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
      }
    });
    Quantile.Definition = {
      "type": "Quantile",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "probs",
        "type": "number",
        "array": true
      }, {
        "name": "step",
        "type": "number",
        "default": 0.01
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "default": ["prob", "value"]
      }]
    };
    EPSILON = 1e-14;
    inherits(Quantile, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), as = _.as || ["prob", "value"];
        if (this.value && !_.modified() && !pulse2.changed()) {
          out.source = this.value;
          return out;
        }
        const source5 = pulse2.materialize(pulse2.SOURCE).source, groups4 = partition$1(source5, _.groupby, _.field), names = (_.groupby || []).map(accessorName), values5 = [], step = _.step || 0.01, p = _.probs || range_default(step / 2, 1 - EPSILON, step), n = p.length;
        groups4.forEach((g) => {
          const q = quantiles(g, p);
          for (let i = 0; i < n; ++i) {
            const t = {};
            for (let i2 = 0; i2 < names.length; ++i2) {
              t[names[i2]] = g.dims[i2];
            }
            t[as[0]] = p[i];
            t[as[1]] = q[i];
            values5.push(ingest$1(t));
          }
        });
        if (this.value)
          out.rem = this.value;
        this.value = out.add = out.source = values5;
        return out;
      }
    });
    inherits(Relay, Transform, {
      transform(_, pulse2) {
        let out, lut;
        if (this.value) {
          lut = this.value;
        } else {
          out = pulse2 = pulse2.addAll();
          lut = this.value = {};
        }
        if (_.derive) {
          out = pulse2.fork(pulse2.NO_SOURCE);
          pulse2.visit(pulse2.REM, (t) => {
            const id4 = tupleid(t);
            out.rem.push(lut[id4]);
            lut[id4] = null;
          });
          pulse2.visit(pulse2.ADD, (t) => {
            const dt = derive(t);
            lut[tupleid(t)] = dt;
            out.add.push(dt);
          });
          pulse2.visit(pulse2.MOD, (t) => {
            const dt = lut[tupleid(t)];
            for (const k4 in t) {
              dt[k4] = t[k4];
              out.modifies(k4);
            }
            out.mod.push(dt);
          });
        }
        return out;
      }
    });
    Sample.Definition = {
      "type": "Sample",
      "metadata": {},
      "params": [{
        "name": "size",
        "type": "number",
        "default": 1e3
      }]
    };
    inherits(Sample, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE), mod = _.modified("size"), num = _.size, map11 = this.value.reduce((m2, t) => (m2[tupleid(t)] = 1, m2), {});
        let res = this.value, cnt = this.count, cap = 0;
        function update3(t) {
          let p, idx;
          if (res.length < num) {
            res.push(t);
          } else {
            idx = ~~((cnt + 1) * random());
            if (idx < res.length && idx >= cap) {
              p = res[idx];
              if (map11[tupleid(p)])
                out.rem.push(p);
              res[idx] = t;
            }
          }
          ++cnt;
        }
        if (pulse2.rem.length) {
          pulse2.visit(pulse2.REM, (t) => {
            const id4 = tupleid(t);
            if (map11[id4]) {
              map11[id4] = -1;
              out.rem.push(t);
            }
            --cnt;
          });
          res = res.filter((t) => map11[tupleid(t)] !== -1);
        }
        if ((pulse2.rem.length || mod) && res.length < num && pulse2.source) {
          cap = cnt = res.length;
          pulse2.visit(pulse2.SOURCE, (t) => {
            if (!map11[tupleid(t)])
              update3(t);
          });
          cap = -1;
        }
        if (mod && res.length > num) {
          const n = res.length - num;
          for (let i = 0; i < n; ++i) {
            map11[tupleid(res[i])] = -1;
            out.rem.push(res[i]);
          }
          res = res.slice(n);
        }
        if (pulse2.mod.length) {
          pulse2.visit(pulse2.MOD, (t) => {
            if (map11[tupleid(t)])
              out.mod.push(t);
          });
        }
        if (pulse2.add.length) {
          pulse2.visit(pulse2.ADD, update3);
        }
        if (pulse2.add.length || cap < 0) {
          out.add = res.filter((t) => !map11[tupleid(t)]);
        }
        this.count = cnt;
        this.value = out.source = res;
        return out;
      }
    });
    Sequence.Definition = {
      "type": "Sequence",
      "metadata": {
        "generates": true,
        "changes": true
      },
      "params": [{
        "name": "start",
        "type": "number",
        "required": true
      }, {
        "name": "stop",
        "type": "number",
        "required": true
      }, {
        "name": "step",
        "type": "number",
        "default": 1
      }, {
        "name": "as",
        "type": "string",
        "default": "data"
      }]
    };
    inherits(Sequence, Transform, {
      transform(_, pulse2) {
        if (this.value && !_.modified())
          return;
        const out = pulse2.materialize().fork(pulse2.MOD), as = _.as || "data";
        out.rem = this.value ? pulse2.rem.concat(this.value) : pulse2.rem;
        this.value = range_default(_.start, _.stop, _.step || 1).map((v) => {
          const t = {};
          t[as] = v;
          return ingest$1(t);
        });
        out.add = pulse2.add.concat(this.value);
        return out;
      }
    });
    inherits(Sieve, Transform, {
      transform(_, pulse2) {
        this.value = pulse2.source;
        return pulse2.changed() ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
      }
    });
    OUTPUT = ["unit0", "unit1"];
    TimeUnit.Definition = {
      "type": "TimeUnit",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field",
        "required": true
      }, {
        "name": "interval",
        "type": "boolean",
        "default": true
      }, {
        "name": "units",
        "type": "enum",
        "values": TIME_UNITS2,
        "array": true
      }, {
        "name": "step",
        "type": "number",
        "default": 1
      }, {
        "name": "maxbins",
        "type": "number",
        "default": 40
      }, {
        "name": "extent",
        "type": "date",
        "array": true
      }, {
        "name": "timezone",
        "type": "enum",
        "default": "local",
        "values": ["local", "utc"]
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": OUTPUT
      }]
    };
    inherits(TimeUnit, Transform, {
      transform(_, pulse2) {
        const field4 = _.field, band5 = _.interval !== false, utc = _.timezone === "utc", floor3 = this._floor(_, pulse2), offset5 = (utc ? utcInterval2 : timeInterval3)(floor3.unit).offset, as = _.as || OUTPUT, u0 = as[0], u1 = as[1], step = floor3.step;
        let min8 = floor3.start || Infinity, max8 = floor3.stop || -Infinity, flag2 = pulse2.ADD;
        if (_.modified() || pulse2.modified(accessorFields(field4))) {
          pulse2 = pulse2.reflow(true);
          flag2 = pulse2.SOURCE;
          min8 = Infinity;
          max8 = -Infinity;
        }
        pulse2.visit(flag2, (t) => {
          const v = field4(t);
          let a4, b3;
          if (v == null) {
            t[u0] = null;
            if (band5)
              t[u1] = null;
          } else {
            t[u0] = a4 = b3 = floor3(v);
            if (band5)
              t[u1] = b3 = offset5(a4, step);
            if (a4 < min8)
              min8 = a4;
            if (b3 > max8)
              max8 = b3;
          }
        });
        floor3.start = min8;
        floor3.stop = max8;
        return pulse2.modifies(band5 ? as : u0);
      },
      _floor(_, pulse2) {
        const utc = _.timezone === "utc";
        const {
          units,
          step
        } = _.units ? {
          units: _.units,
          step: _.step || 1
        } : bin3({
          extent: _.extent || extent(pulse2.materialize(pulse2.SOURCE).source, _.field),
          maxbins: _.maxbins
        });
        const tunits = timeUnits(units), prev = this.value || {}, floor3 = (utc ? utcFloor : timeFloor)(tunits, step);
        floor3.unit = peek(tunits);
        floor3.units = tunits;
        floor3.step = step;
        floor3.start = prev.start;
        floor3.stop = prev.stop;
        return this.value = floor3;
      }
    });
    inherits(TupleIndex, Transform, {
      transform(_, pulse2) {
        const df = pulse2.dataflow, field4 = _.field, index8 = this.value, set8 = (t) => index8.set(field4(t), t);
        let mod = true;
        if (_.modified("field") || pulse2.modified(field4.fields)) {
          index8.clear();
          pulse2.visit(pulse2.SOURCE, set8);
        } else if (pulse2.changed()) {
          pulse2.visit(pulse2.REM, (t) => index8.delete(field4(t)));
          pulse2.visit(pulse2.ADD, set8);
        } else {
          mod = false;
        }
        this.modified(mod);
        if (index8.empty > df.cleanThreshold)
          df.runAfter(index8.clean);
        return pulse2.fork();
      }
    });
    inherits(Values, Transform, {
      transform(_, pulse2) {
        const run2 = !this.value || _.modified("field") || _.modified("sort") || pulse2.changed() || _.sort && pulse2.modified(_.sort.fields);
        if (run2) {
          this.value = (_.sort ? pulse2.source.slice().sort(stableCompare(_.sort)) : pulse2.source).map(_.field);
        }
      }
    });
    WindowOps = {
      row_number: function() {
        return {
          next: (w5) => w5.index + 1
        };
      },
      rank: function() {
        let rank4;
        return {
          init: () => rank4 = 1,
          next: (w5) => {
            const i = w5.index, data3 = w5.data;
            return i && w5.compare(data3[i - 1], data3[i]) ? rank4 = i + 1 : rank4;
          }
        };
      },
      dense_rank: function() {
        let drank;
        return {
          init: () => drank = 1,
          next: (w5) => {
            const i = w5.index, d = w5.data;
            return i && w5.compare(d[i - 1], d[i]) ? ++drank : drank;
          }
        };
      },
      percent_rank: function() {
        const rank4 = WindowOps.rank(), next = rank4.next;
        return {
          init: rank4.init,
          next: (w5) => (next(w5) - 1) / (w5.data.length - 1)
        };
      },
      cume_dist: function() {
        let cume;
        return {
          init: () => cume = 0,
          next: (w5) => {
            const d = w5.data, c2 = w5.compare;
            let i = w5.index;
            if (cume < i) {
              while (i + 1 < d.length && !c2(d[i], d[i + 1]))
                ++i;
              cume = i;
            }
            return (1 + cume) / d.length;
          }
        };
      },
      ntile: function(field4, num) {
        num = +num;
        if (!(num > 0))
          error("ntile num must be greater than zero.");
        const cume = WindowOps.cume_dist(), next = cume.next;
        return {
          init: cume.init,
          next: (w5) => Math.ceil(num * next(w5))
        };
      },
      lag: function(field4, offset5) {
        offset5 = +offset5 || 1;
        return {
          next: (w5) => {
            const i = w5.index - offset5;
            return i >= 0 ? field4(w5.data[i]) : null;
          }
        };
      },
      lead: function(field4, offset5) {
        offset5 = +offset5 || 1;
        return {
          next: (w5) => {
            const i = w5.index + offset5, d = w5.data;
            return i < d.length ? field4(d[i]) : null;
          }
        };
      },
      first_value: function(field4) {
        return {
          next: (w5) => field4(w5.data[w5.i0])
        };
      },
      last_value: function(field4) {
        return {
          next: (w5) => field4(w5.data[w5.i1 - 1])
        };
      },
      nth_value: function(field4, nth) {
        nth = +nth;
        if (!(nth > 0))
          error("nth_value nth must be greater than zero.");
        return {
          next: (w5) => {
            const i = w5.i0 + (nth - 1);
            return i < w5.i1 ? field4(w5.data[i]) : null;
          }
        };
      },
      prev_value: function(field4) {
        let prev;
        return {
          init: () => prev = null,
          next: (w5) => {
            const v = field4(w5.data[w5.index]);
            return v != null ? prev = v : prev;
          }
        };
      },
      next_value: function(field4) {
        let v, i;
        return {
          init: () => (v = null, i = -1),
          next: (w5) => {
            const d = w5.data;
            return w5.index <= i ? v : (i = find(field4, d, w5.index)) < 0 ? (i = d.length, v = null) : v = field4(d[i]);
          }
        };
      }
    };
    ValidWindowOps = Object.keys(WindowOps);
    prototype = WindowState.prototype;
    prototype.init = function() {
      this.windows.forEach((_) => _.init());
      if (this.cell)
        this.cell.init();
    };
    prototype.update = function(w5, t) {
      const cell2 = this.cell, wind = this.windows, data3 = w5.data, m2 = wind && wind.length;
      let j;
      if (cell2) {
        for (j = w5.p0; j < w5.i0; ++j)
          cell2.rem(data3[j]);
        for (j = w5.p1; j < w5.i1; ++j)
          cell2.add(data3[j]);
        cell2.set(t);
      }
      for (j = 0; j < m2; ++j)
        wind[j].update(w5, t);
    };
    Window.Definition = {
      "type": "Window",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "sort",
        "type": "compare"
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "ops",
        "type": "enum",
        "array": true,
        "values": ValidWindowOps.concat(ValidAggregateOps)
      }, {
        "name": "params",
        "type": "number",
        "null": true,
        "array": true
      }, {
        "name": "fields",
        "type": "field",
        "null": true,
        "array": true
      }, {
        "name": "as",
        "type": "string",
        "null": true,
        "array": true
      }, {
        "name": "frame",
        "type": "number",
        "null": true,
        "array": true,
        "length": 2,
        "default": [null, 0]
      }, {
        "name": "ignorePeers",
        "type": "boolean",
        "default": false
      }]
    };
    inherits(Window, Transform, {
      transform(_, pulse2) {
        this.stamp = pulse2.stamp;
        const mod = _.modified(), cmp = stableCompare(_.sort), key3 = groupkey(_.groupby), group6 = (t) => this.group(key3(t));
        let state = this.state;
        if (!state || mod) {
          state = this.state = new WindowState(_);
        }
        if (mod || pulse2.modified(state.inputs)) {
          this.value = {};
          pulse2.visit(pulse2.SOURCE, (t) => group6(t).add(t));
        } else {
          pulse2.visit(pulse2.REM, (t) => group6(t).remove(t));
          pulse2.visit(pulse2.ADD, (t) => group6(t).add(t));
        }
        for (let i = 0, n = this._mlen; i < n; ++i) {
          processPartition(this._mods[i], state, cmp, _);
        }
        this._mlen = 0;
        this._mods = [];
        return pulse2.reflow(mod).modifies(state.outputs);
      },
      group(key3) {
        let group6 = this.value[key3];
        if (!group6) {
          group6 = this.value[key3] = SortedList(tupleid);
          group6.stamp = -1;
        }
        if (group6.stamp < this.stamp) {
          group6.stamp = this.stamp;
          this._mods[this._mlen++] = group6;
        }
        return group6;
      }
    });
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/constant.js
function constant_default2(x7) {
  return function constant5() {
    return x7;
  };
}
var init_constant3 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/math.js
function acos(x7) {
  return x7 > 1 ? 0 : x7 < -1 ? pi : Math.acos(x7);
}
function asin(x7) {
  return x7 >= 1 ? halfPi : x7 <= -1 ? -halfPi : Math.asin(x7);
}
var abs, atan2, cos, max3, min3, sin, sqrt, epsilon2, pi, halfPi, tau;
var init_math = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/math.js"() {
    abs = Math.abs;
    atan2 = Math.atan2;
    cos = Math.cos;
    max3 = Math.max;
    min3 = Math.min;
    sin = Math.sin;
    sqrt = Math.sqrt;
    epsilon2 = 1e-12;
    pi = Math.PI;
    halfPi = pi / 2;
    tau = 2 * pi;
  }
});

// node_modules/.pnpm/d3-path@3.1.0/node_modules/d3-path/src/path.js
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d > 15)
    return append;
  const k4 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k4) / k4 + strings[i];
    }
  };
}
function path() {
  return new Path();
}
var pi2, tau2, epsilon3, tauEpsilon, Path;
var init_path = __esm({
  "node_modules/.pnpm/d3-path@3.1.0/node_modules/d3-path/src/path.js"() {
    pi2 = Math.PI;
    tau2 = 2 * pi2;
    epsilon3 = 1e-6;
    tauEpsilon = tau2 - epsilon3;
    Path = class {
      constructor(digits) {
        this._x0 = this._y0 = this._x1 = this._y1 = null;
        this._ = "";
        this._append = digits == null ? append : appendRound(digits);
      }
      moveTo(x7, y7) {
        this._append`M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._append`Z`;
        }
      }
      lineTo(x7, y7) {
        this._append`L${this._x1 = +x7},${this._y1 = +y7}`;
      }
      quadraticCurveTo(x13, y13, x7, y7) {
        this._append`Q${+x13},${+y13},${this._x1 = +x7},${this._y1 = +y7}`;
      }
      bezierCurveTo(x13, y13, x22, y22, x7, y7) {
        this._append`C${+x13},${+y13},${+x22},${+y22},${this._x1 = +x7},${this._y1 = +y7}`;
      }
      arcTo(x13, y13, x22, y22, r2) {
        x13 = +x13, y13 = +y13, x22 = +x22, y22 = +y22, r2 = +r2;
        if (r2 < 0)
          throw new Error(`negative radius: ${r2}`);
        let x07 = this._x1, y07 = this._y1, x21 = x22 - x13, y21 = y22 - y13, x01 = x07 - x13, y01 = y07 - y13, l01_2 = x01 * x01 + y01 * y01;
        if (this._x1 === null) {
          this._append`M${this._x1 = x13},${this._y1 = y13}`;
        } else if (!(l01_2 > epsilon3))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon3) || !r2) {
          this._append`L${this._x1 = x13},${this._y1 = y13}`;
        } else {
          let x20 = x22 - x07, y20 = y22 - y07, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
          if (Math.abs(t01 - 1) > epsilon3) {
            this._append`L${x13 + t01 * x01},${y13 + t01 * y01}`;
          }
          this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x13 + t21 * x21},${this._y1 = y13 + t21 * y21}`;
        }
      }
      arc(x7, y7, r2, a0, a1, ccw) {
        x7 = +x7, y7 = +y7, r2 = +r2, ccw = !!ccw;
        if (r2 < 0)
          throw new Error(`negative radius: ${r2}`);
        let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x07 = x7 + dx, y07 = y7 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (this._x1 === null) {
          this._append`M${x07},${y07}`;
        } else if (Math.abs(this._x1 - x07) > epsilon3 || Math.abs(this._y1 - y07) > epsilon3) {
          this._append`L${x07},${y07}`;
        }
        if (!r2)
          return;
        if (da < 0)
          da = da % tau2 + tau2;
        if (da > tauEpsilon) {
          this._append`A${r2},${r2},0,1,${cw2},${x7 - dx},${y7 - dy}A${r2},${r2},0,1,${cw2},${this._x1 = x07},${this._y1 = y07}`;
        } else if (da > epsilon3) {
          this._append`A${r2},${r2},0,${+(da >= pi2)},${cw2},${this._x1 = x7 + r2 * Math.cos(a1)},${this._y1 = y7 + r2 * Math.sin(a1)}`;
        }
      }
      rect(x7, y7, w5, h4) {
        this._append`M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}h${w5 = +w5}v${+h4}h${-w5}Z`;
      }
      toString() {
        return this._;
      }
    };
    path.prototype = Path.prototype;
  }
});

// node_modules/.pnpm/d3-path@3.1.0/node_modules/d3-path/src/index.js
var init_src11 = __esm({
  "node_modules/.pnpm/d3-path@3.1.0/node_modules/d3-path/src/index.js"() {
    init_path();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/path.js
function withPath(shape3) {
  let digits = 3;
  shape3.digits = function(_) {
    if (!arguments.length)
      return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape3;
  };
  return () => new Path(digits);
}
var init_path2 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/path.js"() {
    init_src11();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x07, y07, x13, y13, x22, y22, x32, y32) {
  var x10 = x13 - x07, y10 = y13 - y07, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;
  if (t * t < epsilon2)
    return;
  t = (x322 * (y07 - y22) - y322 * (x07 - x22)) / t;
  return [x07 + t * x10, y07 + t * y10];
}
function cornerTangents(x07, y07, x13, y13, r1, rc, cw2) {
  var x01 = x07 - x13, y01 = y07 - y13, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x07 + ox, y11 = y07 + oy, x10 = x13 + ox, y10 = y13 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r2 = r1 - rc, D3 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max3(0, r2 * r2 * d2 - D3 * D3)), cx0 = (D3 * dy - dx * d) / d2, cy0 = (-D3 * dx - dy * d) / d2, cx1 = (D3 * dy + dx * d) / d2, cy1 = (-D3 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default2(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context4 = null, path5 = withPath(arc5);
  function arc5() {
    var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw2 = a1 > a0;
    if (!context4)
      context4 = buffer = path5();
    if (r1 < r0)
      r2 = r1, r1 = r0, r0 = r2;
    if (!(r1 > epsilon2))
      context4.moveTo(0, 0);
    else if (da > tau - epsilon2) {
      context4.moveTo(r1 * cos(a0), r1 * sin(a0));
      context4.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon2) {
        context4.moveTo(r0 * cos(a1), r0 * sin(a1));
        context4.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon2 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min3(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t07, t15;
      if (rp > epsilon2) {
        var p02 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p02 * 2) > epsilon2)
          p02 *= cw2 ? 1 : -1, a00 += p02, a10 -= p02;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon2)
          p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon2) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da < pi) {
          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min3(rc, (r0 - lc) / (kc - 1));
            rc1 = min3(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon2))
        context4.moveTo(x01, y01);
      else if (rc1 > epsilon2) {
        t07 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
        t15 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context4.moveTo(t07.cx + t07.x01, t07.cy + t07.y01);
        if (rc1 < rc)
          context4.arc(t07.cx, t07.cy, rc1, atan2(t07.y01, t07.x01), atan2(t15.y01, t15.x01), !cw2);
        else {
          context4.arc(t07.cx, t07.cy, rc1, atan2(t07.y01, t07.x01), atan2(t07.y11, t07.x11), !cw2);
          context4.arc(0, 0, r1, atan2(t07.cy + t07.y11, t07.cx + t07.x11), atan2(t15.cy + t15.y11, t15.cx + t15.x11), !cw2);
          context4.arc(t15.cx, t15.cy, rc1, atan2(t15.y11, t15.x11), atan2(t15.y01, t15.x01), !cw2);
        }
      } else
        context4.moveTo(x01, y01), context4.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon2) || !(da0 > epsilon2))
        context4.lineTo(x10, y10);
      else if (rc0 > epsilon2) {
        t07 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t15 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
        context4.lineTo(t07.cx + t07.x01, t07.cy + t07.y01);
        if (rc0 < rc)
          context4.arc(t07.cx, t07.cy, rc0, atan2(t07.y01, t07.x01), atan2(t15.y01, t15.x01), !cw2);
        else {
          context4.arc(t07.cx, t07.cy, rc0, atan2(t07.y01, t07.x01), atan2(t07.y11, t07.x11), !cw2);
          context4.arc(0, 0, r0, atan2(t07.cy + t07.y11, t07.cx + t07.x11), atan2(t15.cy + t15.y11, t15.cx + t15.x11), cw2);
          context4.arc(t15.cx, t15.cy, rc0, atan2(t15.y11, t15.x11), atan2(t15.y01, t15.x01), !cw2);
        }
      } else
        context4.arc(0, 0, r0, a10, a00, cw2);
    }
    context4.closePath();
    if (buffer)
      return context4 = null, buffer + "" || null;
  }
  arc5.centroid = function() {
    var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a4) * r2, sin(a4) * r2];
  };
  arc5.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default2(+_), arc5) : innerRadius;
  };
  arc5.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default2(+_), arc5) : outerRadius;
  };
  arc5.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default2(+_), arc5) : cornerRadius;
  };
  arc5.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), arc5) : padRadius;
  };
  arc5.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default2(+_), arc5) : startAngle;
  };
  arc5.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default2(+_), arc5) : endAngle;
  };
  arc5.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default2(+_), arc5) : padAngle;
  };
  arc5.context = function(_) {
    return arguments.length ? (context4 = _ == null ? null : _, arc5) : context4;
  };
  return arc5;
}
var init_arc = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/arc.js"() {
    init_constant3();
    init_math();
    init_path2();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/array.js
function array_default(x7) {
  return typeof x7 === "object" && "length" in x7 ? x7 : Array.from(x7);
}
var slice3;
var init_array3 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/array.js"() {
    slice3 = Array.prototype.slice;
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/linear.js
function Linear(context4) {
  this._context = context4;
}
function linear_default(context4) {
  return new Linear(context4);
}
var init_linear = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/linear.js"() {
    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
          default:
            this._context.lineTo(x7, y7);
            break;
        }
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}
var init_point = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/point.js"() {
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/line.js
function line_default(x7, y7) {
  var defined2 = constant_default2(true), context4 = null, curve2 = linear_default, output3 = null, path5 = withPath(line5);
  x7 = typeof x7 === "function" ? x7 : x7 === void 0 ? x : constant_default2(x7);
  y7 = typeof y7 === "function" ? y7 : y7 === void 0 ? y : constant_default2(y7);
  function line5(data3) {
    var i, n = (data3 = array_default(data3)).length, d, defined0 = false, buffer;
    if (context4 == null)
      output3 = curve2(buffer = path5());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          output3.lineStart();
        else
          output3.lineEnd();
      }
      if (defined0)
        output3.point(+x7(d, i, data3), +y7(d, i, data3));
    }
    if (buffer)
      return output3 = null, buffer + "" || null;
  }
  line5.x = function(_) {
    return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default2(+_), line5) : x7;
  };
  line5.y = function(_) {
    return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default2(+_), line5) : y7;
  };
  line5.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default2(!!_), line5) : defined2;
  };
  line5.curve = function(_) {
    return arguments.length ? (curve2 = _, context4 != null && (output3 = curve2(context4)), line5) : curve2;
  };
  line5.context = function(_) {
    return arguments.length ? (_ == null ? context4 = output3 = null : output3 = curve2(context4 = _), line5) : context4;
  };
  return line5;
}
var init_line = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/line.js"() {
    init_array3();
    init_constant3();
    init_linear();
    init_path2();
    init_point();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/area.js
function area_default(x07, y07, y13) {
  var x13 = null, defined2 = constant_default2(true), context4 = null, curve2 = linear_default, output3 = null, path5 = withPath(area5);
  x07 = typeof x07 === "function" ? x07 : x07 === void 0 ? x : constant_default2(+x07);
  y07 = typeof y07 === "function" ? y07 : y07 === void 0 ? constant_default2(0) : constant_default2(+y07);
  y13 = typeof y13 === "function" ? y13 : y13 === void 0 ? y : constant_default2(+y13);
  function area5(data3) {
    var i, j, k4, n = (data3 = array_default(data3)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context4 == null)
      output3 = curve2(buffer = path5());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output3.areaStart();
          output3.lineStart();
        } else {
          output3.lineEnd();
          output3.lineStart();
          for (k4 = i - 1; k4 >= j; --k4) {
            output3.point(x0z[k4], y0z[k4]);
          }
          output3.lineEnd();
          output3.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x07(d, i, data3), y0z[i] = +y07(d, i, data3);
        output3.point(x13 ? +x13(d, i, data3) : x0z[i], y13 ? +y13(d, i, data3) : y0z[i]);
      }
    }
    if (buffer)
      return output3 = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined2).curve(curve2).context(context4);
  }
  area5.x = function(_) {
    return arguments.length ? (x07 = typeof _ === "function" ? _ : constant_default2(+_), x13 = null, area5) : x07;
  };
  area5.x0 = function(_) {
    return arguments.length ? (x07 = typeof _ === "function" ? _ : constant_default2(+_), area5) : x07;
  };
  area5.x1 = function(_) {
    return arguments.length ? (x13 = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), area5) : x13;
  };
  area5.y = function(_) {
    return arguments.length ? (y07 = typeof _ === "function" ? _ : constant_default2(+_), y13 = null, area5) : y07;
  };
  area5.y0 = function(_) {
    return arguments.length ? (y07 = typeof _ === "function" ? _ : constant_default2(+_), area5) : y07;
  };
  area5.y1 = function(_) {
    return arguments.length ? (y13 = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), area5) : y13;
  };
  area5.lineX0 = area5.lineY0 = function() {
    return arealine().x(x07).y(y07);
  };
  area5.lineY1 = function() {
    return arealine().x(x07).y(y13);
  };
  area5.lineX1 = function() {
    return arealine().x(x13).y(y07);
  };
  area5.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default2(!!_), area5) : defined2;
  };
  area5.curve = function(_) {
    return arguments.length ? (curve2 = _, context4 != null && (output3 = curve2(context4)), area5) : curve2;
  };
  area5.context = function(_) {
    return arguments.length ? (_ == null ? context4 = output3 = null : output3 = curve2(context4 = _), area5) : context4;
  };
  return area5;
}
var init_area = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/area.js"() {
    init_array3();
    init_constant3();
    init_linear();
    init_line();
    init_path2();
    init_point();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/descending.js
var init_descending3 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/descending.js"() {
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/identity.js
var init_identity5 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/identity.js"() {
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/pie.js
var init_pie = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/pie.js"() {
    init_array3();
    init_constant3();
    init_descending3();
    init_identity5();
    init_math();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/radial.js
function Radial(curve2) {
  this._curve = curve2;
}
function curveRadial(curve2) {
  function radial3(context4) {
    return new Radial(curve2(context4));
  }
  radial3._curve = curve2;
  return radial3;
}
var curveRadialLinear;
var init_radial = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/radial.js"() {
    init_linear();
    curveRadialLinear = curveRadial(linear_default);
    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a4, r2) {
        this._curve.point(r2 * Math.sin(a4), r2 * -Math.cos(a4));
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/lineRadial.js
var init_lineRadial = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/lineRadial.js"() {
    init_radial();
    init_line();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/areaRadial.js
var init_areaRadial = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/areaRadial.js"() {
    init_radial();
    init_area();
    init_lineRadial();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/pointRadial.js
var init_pointRadial = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/pointRadial.js"() {
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/bump.js
var init_bump = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/bump.js"() {
    init_pointRadial();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/link.js
var init_link = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/link.js"() {
    init_array3();
    init_constant3();
    init_bump();
    init_path2();
    init_point();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3;
var init_asterisk = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/asterisk.js"() {
    init_math();
    sqrt3 = sqrt(3);
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/circle.js
var circle_default;
var init_circle = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/circle.js"() {
    init_math();
    circle_default = {
      draw(context4, size) {
        const r2 = sqrt(size / pi);
        context4.moveTo(r2, 0);
        context4.arc(0, 0, r2, 0, tau);
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/cross.js
var init_cross3 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/cross.js"() {
    init_math();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/diamond.js
var tan30, tan30_2;
var init_diamond = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/diamond.js"() {
    init_math();
    tan30 = sqrt(1 / 3);
    tan30_2 = tan30 * 2;
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/diamond2.js
var init_diamond2 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/diamond2.js"() {
    init_math();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/plus.js
var init_plus = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/plus.js"() {
    init_math();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/square.js
var init_square = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/square.js"() {
    init_math();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/square2.js
var init_square2 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/square2.js"() {
    init_math();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/star.js
var kr, kx, ky;
var init_star = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/star.js"() {
    init_math();
    kr = sin(pi / 10) / sin(7 * pi / 10);
    kx = sin(tau / 10) * kr;
    ky = -cos(tau / 10) * kr;
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/triangle.js
var sqrt32;
var init_triangle = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/triangle.js"() {
    init_math();
    sqrt32 = sqrt(3);
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33;
var init_triangle2 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/triangle2.js"() {
    init_math();
    sqrt33 = sqrt(3);
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/wye.js
var s, k, a;
var init_wye = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/wye.js"() {
    init_math();
    s = sqrt(3) / 2;
    k = 1 / sqrt(12);
    a = (k / 2 + 1) * 3;
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/times.js
var init_times = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol/times.js"() {
    init_math();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol.js
function Symbol2(type4, size) {
  let context4 = null, path5 = withPath(symbol3);
  type4 = typeof type4 === "function" ? type4 : constant_default2(type4 || circle_default);
  size = typeof size === "function" ? size : constant_default2(size === void 0 ? 64 : +size);
  function symbol3() {
    let buffer;
    if (!context4)
      context4 = buffer = path5();
    type4.apply(this, arguments).draw(context4, +size.apply(this, arguments));
    if (buffer)
      return context4 = null, buffer + "" || null;
  }
  symbol3.type = function(_) {
    return arguments.length ? (type4 = typeof _ === "function" ? _ : constant_default2(_), symbol3) : type4;
  };
  symbol3.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default2(+_), symbol3) : size;
  };
  symbol3.context = function(_) {
    return arguments.length ? (context4 = _ == null ? null : _, symbol3) : context4;
  };
  return symbol3;
}
var init_symbol = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/symbol.js"() {
    init_constant3();
    init_path2();
    init_asterisk();
    init_circle();
    init_cross3();
    init_diamond();
    init_diamond2();
    init_plus();
    init_square();
    init_square2();
    init_star();
    init_triangle();
    init_triangle2();
    init_wye();
    init_times();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/noop.js
function noop_default() {
}
var init_noop = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/noop.js"() {
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/basis.js
function point(that, x7, y7) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x7) / 6,
    (that._y0 + 4 * that._y1 + y7) / 6
  );
}
function Basis(context4) {
  this._context = context4;
}
function basis_default(context4) {
  return new Basis(context4);
}
var init_basis = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/basis.js"() {
    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3:
            point(this, this._x1, this._y1);
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
          default:
            point(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = x7;
        this._y0 = this._y1, this._y1 = y7;
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context4) {
  this._context = context4;
}
function basisClosed_default(context4) {
  return new BasisClosed(context4);
}
var init_basisClosed = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/basisClosed.js"() {
    init_noop();
    init_basis();
    BasisClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x2 = x7, this._y2 = y7;
            break;
          case 1:
            this._point = 2;
            this._x3 = x7, this._y3 = y7;
            break;
          case 2:
            this._point = 3;
            this._x4 = x7, this._y4 = y7;
            this._context.moveTo((this._x0 + 4 * this._x1 + x7) / 6, (this._y0 + 4 * this._y1 + y7) / 6);
            break;
          default:
            point(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = x7;
        this._y0 = this._y1, this._y1 = y7;
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context4) {
  this._context = context4;
}
function basisOpen_default(context4) {
  return new BasisOpen(context4);
}
var init_basisOpen = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/basisOpen.js"() {
    init_basis();
    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            var x07 = (this._x0 + 4 * this._x1 + x7) / 6, y07 = (this._y0 + 4 * this._y1 + y7) / 6;
            this._line ? this._context.lineTo(x07, y07) : this._context.moveTo(x07, y07);
            break;
          case 3:
            this._point = 4;
          default:
            point(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = x7;
        this._y0 = this._y1, this._y1 = y7;
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/bundle.js
function Bundle(context4, beta) {
  this._basis = new Basis(context4);
  this._beta = beta;
}
var bundle_default;
var init_bundle = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/bundle.js"() {
    init_basis();
    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x7 = this._x, y7 = this._y, j = x7.length - 1;
        if (j > 0) {
          var x07 = x7[0], y07 = y7[0], dx = x7[j] - x07, dy = y7[j] - y07, i = -1, t;
          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x7[i] + (1 - this._beta) * (x07 + t * dx),
              this._beta * y7[i] + (1 - this._beta) * (y07 + t * dy)
            );
          }
        }
        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x7, y7) {
        this._x.push(+x7);
        this._y.push(+y7);
      }
    };
    bundle_default = function custom(beta) {
      function bundle3(context4) {
        return beta === 1 ? new Basis(context4) : new Bundle(context4, beta);
      }
      bundle3.beta = function(beta2) {
        return custom(+beta2);
      };
      return bundle3;
    }(0.85);
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x7, y7) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x7),
    that._y2 + that._k * (that._y1 - y7),
    that._x2,
    that._y2
  );
}
function Cardinal(context4, tension) {
  this._context = context4;
  this._k = (1 - tension) / 6;
}
var cardinal_default;
var init_cardinal = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/cardinal.js"() {
    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            point2(this, this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
            this._x1 = x7, this._y1 = y7;
            break;
          case 2:
            this._point = 3;
          default:
            point2(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    cardinal_default = function custom2(tension) {
      function cardinal(context4) {
        return new Cardinal(context4, tension);
      }
      cardinal.tension = function(tension2) {
        return custom2(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context4, tension) {
  this._context = context4;
  this._k = (1 - tension) / 6;
}
var cardinalClosed_default;
var init_cardinalClosed = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/cardinalClosed.js"() {
    init_noop();
    init_cardinal();
    CardinalClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x7, this._y3 = y7;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x7, this._y4 = y7);
            break;
          case 2:
            this._point = 3;
            this._x5 = x7, this._y5 = y7;
            break;
          default:
            point2(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    cardinalClosed_default = function custom3(tension) {
      function cardinal(context4) {
        return new CardinalClosed(context4, tension);
      }
      cardinal.tension = function(tension2) {
        return custom3(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context4, tension) {
  this._context = context4;
  this._k = (1 - tension) / 6;
}
var cardinalOpen_default;
var init_cardinalOpen = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/cardinalOpen.js"() {
    init_cardinal();
    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point2(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    cardinalOpen_default = function custom4(tension) {
      function cardinal(context4) {
        return new CardinalOpen(context4, tension);
      }
      cardinal.tension = function(tension2) {
        return custom4(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x7, y7) {
  var x13 = that._x1, y13 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon2) {
    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x13 = (x13 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y13 = (y13 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon2) {
    var b3 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b3 + that._x1 * that._l23_2a - x7 * that._l12_2a) / m2;
    y22 = (y22 * b3 + that._y1 * that._l23_2a - y7 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x13, y13, x22, y22, that._x2, that._y2);
}
function CatmullRom(context4, alpha) {
  this._context = context4;
  this._alpha = alpha;
}
var catmullRom_default;
var init_catmullRom = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/catmullRom.js"() {
    init_math();
    init_cardinal();
    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            this.point(this._x2, this._y2);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        if (this._point) {
          var x23 = this._x2 - x7, y23 = this._y2 - y7;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
          default:
            point3(this, x7, y7);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    catmullRom_default = function custom5(alpha) {
      function catmullRom(context4) {
        return alpha ? new CatmullRom(context4, alpha) : new Cardinal(context4, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom5(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context4, alpha) {
  this._context = context4;
  this._alpha = alpha;
}
var catmullRomClosed_default;
var init_catmullRomClosed = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/catmullRomClosed.js"() {
    init_cardinalClosed();
    init_noop();
    init_catmullRom();
    CatmullRomClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        if (this._point) {
          var x23 = this._x2 - x7, y23 = this._y2 - y7;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x7, this._y3 = y7;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x7, this._y4 = y7);
            break;
          case 2:
            this._point = 3;
            this._x5 = x7, this._y5 = y7;
            break;
          default:
            point3(this, x7, y7);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    catmullRomClosed_default = function custom6(alpha) {
      function catmullRom(context4) {
        return alpha ? new CatmullRomClosed(context4, alpha) : new CardinalClosed(context4, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom6(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context4, alpha) {
  this._context = context4;
  this._alpha = alpha;
}
var catmullRomOpen_default;
var init_catmullRomOpen = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/catmullRomOpen.js"() {
    init_cardinalOpen();
    init_catmullRom();
    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        if (this._point) {
          var x23 = this._x2 - x7, y23 = this._y2 - y7;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point3(this, x7, y7);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    catmullRomOpen_default = function custom7(alpha) {
      function catmullRom(context4) {
        return alpha ? new CatmullRomOpen(context4, alpha) : new CardinalOpen(context4, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom7(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context4) {
  this._context = context4;
}
function linearClosed_default(context4) {
  return new LinearClosed(context4);
}
var init_linearClosed = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/linearClosed.js"() {
    init_noop();
    LinearClosed.prototype = {
      areaStart: noop_default,
      areaEnd: noop_default,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point)
          this._context.closePath();
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        if (this._point)
          this._context.lineTo(x7, y7);
        else
          this._point = 1, this._context.moveTo(x7, y7);
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/monotone.js
function sign(x7) {
  return x7 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h4 = that._x1 - that._x0;
  return h4 ? (3 * (that._y1 - that._y0) / h4 - t) / 2 : t;
}
function point4(that, t07, t15) {
  var x07 = that._x0, y07 = that._y0, x13 = that._x1, y13 = that._y1, dx = (x13 - x07) / 3;
  that._context.bezierCurveTo(x07 + dx, y07 + dx * t07, x13 - dx, y13 - dx * t15, x13, y13);
}
function MonotoneX(context4) {
  this._context = context4;
}
function MonotoneY(context4) {
  this._context = new ReflectContext(context4);
}
function ReflectContext(context4) {
  this._context = context4;
}
function monotoneX(context4) {
  return new MonotoneX(context4);
}
function monotoneY(context4) {
  return new MonotoneY(context4);
}
var init_monotone = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/monotone.js"() {
    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
          case 3:
            point4(this, this._t0, slope2(this, this._t0));
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        var t15 = NaN;
        x7 = +x7, y7 = +y7;
        if (x7 === this._x1 && y7 === this._y1)
          return;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            point4(this, slope2(this, t15 = slope3(this, x7, y7)), t15);
            break;
          default:
            point4(this, this._t0, t15 = slope3(this, x7, y7));
            break;
        }
        this._x0 = this._x1, this._x1 = x7;
        this._y0 = this._y1, this._y1 = y7;
        this._t0 = t15;
      }
    };
    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x7, y7) {
      MonotoneX.prototype.point.call(this, y7, x7);
    };
    ReflectContext.prototype = {
      moveTo: function(x7, y7) {
        this._context.moveTo(y7, x7);
      },
      closePath: function() {
        this._context.closePath();
      },
      lineTo: function(x7, y7) {
        this._context.lineTo(y7, x7);
      },
      bezierCurveTo: function(x13, y13, x22, y22, x7, y7) {
        this._context.bezierCurveTo(y13, x13, y22, x22, y7, x7);
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/natural.js
function Natural(context4) {
  this._context = context4;
}
function controlPoints(x7) {
  var i, n = x7.length - 1, m2, a4 = new Array(n), b3 = new Array(n), r2 = new Array(n);
  a4[0] = 0, b3[0] = 2, r2[0] = x7[0] + 2 * x7[1];
  for (i = 1; i < n - 1; ++i)
    a4[i] = 1, b3[i] = 4, r2[i] = 4 * x7[i] + 2 * x7[i + 1];
  a4[n - 1] = 2, b3[n - 1] = 7, r2[n - 1] = 8 * x7[n - 1] + x7[n];
  for (i = 1; i < n; ++i)
    m2 = a4[i] / b3[i - 1], b3[i] -= m2, r2[i] -= m2 * r2[i - 1];
  a4[n - 1] = r2[n - 1] / b3[n - 1];
  for (i = n - 2; i >= 0; --i)
    a4[i] = (r2[i] - a4[i + 1]) / b3[i];
  b3[n - 1] = (x7[n] + a4[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b3[i] = 2 * x7[i + 1] - a4[i + 1];
  return [a4, b3];
}
function natural_default(context4) {
  return new Natural(context4);
}
var init_natural = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/natural.js"() {
    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x7 = this._x, y7 = this._y, n = x7.length;
        if (n) {
          this._line ? this._context.lineTo(x7[0], y7[0]) : this._context.moveTo(x7[0], y7[0]);
          if (n === 2) {
            this._context.lineTo(x7[1], y7[1]);
          } else {
            var px3 = controlPoints(x7), py3 = controlPoints(y7);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px3[0][i0], py3[0][i0], px3[1][i0], py3[1][i0], x7[i1], y7[i1]);
            }
          }
        }
        if (this._line || this._line !== 0 && n === 1)
          this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x7, y7) {
        this._x.push(+x7);
        this._y.push(+y7);
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/step.js
function Step(context4, t) {
  this._context = context4;
  this._t = t;
}
function step_default(context4) {
  return new Step(context4, 0.5);
}
function stepBefore(context4) {
  return new Step(context4, 0);
}
function stepAfter(context4) {
  return new Step(context4, 1);
}
var init_step = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/curve/step.js"() {
    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2)
          this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        if (this._line >= 0)
          this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y7);
              this._context.lineTo(x7, y7);
            } else {
              var x13 = this._x * (1 - this._t) + x7 * this._t;
              this._context.lineTo(x13, this._y);
              this._context.lineTo(x13, y7);
            }
            break;
          }
        }
        this._x = x7, this._y = y7;
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/offset/none.js
var init_none = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/offset/none.js"() {
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/none.js
var init_none2 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/none.js"() {
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/stack.js
var init_stack = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/stack.js"() {
    init_array3();
    init_constant3();
    init_none();
    init_none2();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/offset/expand.js
var init_expand = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/offset/expand.js"() {
    init_none();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/offset/diverging.js
var init_diverging = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/offset/diverging.js"() {
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/offset/silhouette.js
var init_silhouette = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/offset/silhouette.js"() {
    init_none();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/offset/wiggle.js
var init_wiggle = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/offset/wiggle.js"() {
    init_none();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/appearance.js
var init_appearance = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/appearance.js"() {
    init_none2();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/ascending.js
var init_ascending3 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/ascending.js"() {
    init_none2();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/descending.js
var init_descending4 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/descending.js"() {
    init_ascending3();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/insideOut.js
var init_insideOut = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/insideOut.js"() {
    init_appearance();
    init_ascending3();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/reverse.js
var init_reverse4 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/order/reverse.js"() {
    init_none2();
  }
});

// node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/index.js
var init_src12 = __esm({
  "node_modules/.pnpm/d3-shape@3.2.0/node_modules/d3-shape/src/index.js"() {
    init_arc();
    init_area();
    init_line();
    init_pie();
    init_areaRadial();
    init_lineRadial();
    init_pointRadial();
    init_link();
    init_symbol();
    init_asterisk();
    init_circle();
    init_cross3();
    init_diamond();
    init_diamond2();
    init_plus();
    init_square();
    init_square2();
    init_star();
    init_triangle();
    init_triangle2();
    init_wye();
    init_times();
    init_basisClosed();
    init_basisOpen();
    init_basis();
    init_bump();
    init_bundle();
    init_cardinalClosed();
    init_cardinalOpen();
    init_cardinal();
    init_catmullRomClosed();
    init_catmullRomOpen();
    init_catmullRom();
    init_linearClosed();
    init_linear();
    init_monotone();
    init_natural();
    init_step();
    init_stack();
    init_expand();
    init_diverging();
    init_none();
    init_silhouette();
    init_wiggle();
    init_appearance();
    init_ascending3();
    init_descending4();
    init_insideOut();
    init_none2();
    init_reverse4();
  }
});

// node_modules/.pnpm/vega-canvas@1.2.7/node_modules/vega-canvas/build/vega-canvas.browser.module.js
function domCanvas(w5, h4) {
  if (typeof document !== "undefined" && document.createElement) {
    const c2 = document.createElement("canvas");
    if (c2 && c2.getContext) {
      c2.width = w5;
      c2.height = h4;
      return c2;
    }
  }
  return null;
}
var domImage;
var init_vega_canvas_browser_module = __esm({
  "node_modules/.pnpm/vega-canvas@1.2.7/node_modules/vega-canvas/build/vega-canvas.browser.module.js"() {
    domImage = () => typeof Image !== "undefined" ? Image : null;
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/init.js
function initRange(domain4, range7) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain4);
      break;
    default:
      this.range(range7).domain(domain4);
      break;
  }
  return this;
}
function initInterpolator(domain4, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain4 === "function")
        this.interpolator(domain4);
      else
        this.range(domain4);
      break;
    }
    default: {
      this.domain(domain4);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}
var init_init = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/init.js"() {
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/ordinal.js
function ordinal() {
  var index8 = new InternMap(), domain4 = [], range7 = [], unknown = implicit;
  function scale8(d) {
    let i = index8.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index8.set(d, i = domain4.push(d) - 1);
    }
    return range7[i % range7.length];
  }
  scale8.domain = function(_) {
    if (!arguments.length)
      return domain4.slice();
    domain4 = [], index8 = new InternMap();
    for (const value4 of _) {
      if (index8.has(value4))
        continue;
      index8.set(value4, domain4.push(value4) - 1);
    }
    return scale8;
  };
  scale8.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), scale8) : range7.slice();
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  scale8.copy = function() {
    return ordinal(domain4, range7).unknown(unknown);
  };
  initRange.apply(scale8, arguments);
  return scale8;
}
var implicit;
var init_ordinal = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/ordinal.js"() {
    init_src4();
    init_init();
    implicit = Symbol("implicit");
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/band.js
var init_band = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/band.js"() {
    init_src4();
    init_init();
    init_ordinal();
  }
});

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend3(parent, definition3) {
  var prototype2 = Object.create(parent.prototype);
  for (var key3 in definition3)
    prototype2[key3] = definition3[key3];
  return prototype2;
}
var init_define = __esm({
  "node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/define.js"() {
  }
});

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/color.js
function Color() {
}
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format9) {
  var m2, l;
  format9 = (format9 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format9)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format9)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format9)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format9)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format9)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format9)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format9)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format9) ? rgbn(named[format9]) : format9 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r2, g, b3, a4) {
  if (a4 <= 0)
    r2 = g = b3 = NaN;
  return new Rgb(r2, g, b3, a4);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r2, g, b3, opacity2) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b3, opacity2 == null ? 1 : opacity2);
}
function Rgb(r2, g, b3, opacity2) {
  this.r = +r2;
  this.g = +g;
  this.b = +b3;
  this.opacity = +opacity2;
}
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a4 = clampa(this.opacity);
  return `${a4 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? ")" : `, ${a4})`}`;
}
function clampa(opacity2) {
  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
}
function clampi(value4) {
  return Math.max(0, Math.min(255, Math.round(value4) || 0));
}
function hex(value4) {
  value4 = clampi(value4);
  return (value4 < 16 ? "0" : "") + value4.toString(16);
}
function hsla(h4, s3, l, a4) {
  if (a4 <= 0)
    h4 = s3 = l = NaN;
  else if (l <= 0 || l >= 1)
    h4 = s3 = NaN;
  else if (s3 <= 0)
    h4 = NaN;
  return new Hsl(h4, s3, l, a4);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b3 = o.b / 255, min8 = Math.min(r2, g, b3), max8 = Math.max(r2, g, b3), h4 = NaN, s3 = max8 - min8, l = (max8 + min8) / 2;
  if (s3) {
    if (r2 === max8)
      h4 = (g - b3) / s3 + (g < b3) * 6;
    else if (g === max8)
      h4 = (b3 - r2) / s3 + 2;
    else
      h4 = (r2 - g) / s3 + 4;
    s3 /= l < 0.5 ? max8 + min8 : 2 - max8 - min8;
    h4 *= 60;
  } else {
    s3 = l > 0 && l < 1 ? 0 : h4;
  }
  return new Hsl(h4, s3, l, o.opacity);
}
function hsl(h4, s3, l, opacity2) {
  return arguments.length === 1 ? hslConvert(h4) : new Hsl(h4, s3, l, opacity2 == null ? 1 : opacity2);
}
function Hsl(h4, s3, l, opacity2) {
  this.h = +h4;
  this.s = +s3;
  this.l = +l;
  this.opacity = +opacity2;
}
function clamph(value4) {
  value4 = (value4 || 0) % 360;
  return value4 < 0 ? value4 + 360 : value4;
}
function clampt(value4) {
  return Math.max(0, Math.min(1, value4 || 0));
}
function hsl2rgb(h4, m1, m2) {
  return (h4 < 60 ? m1 + (m2 - m1) * h4 / 60 : h4 < 180 ? m2 : h4 < 240 ? m1 + (m2 - m1) * (240 - h4) / 60 : m1) * 255;
}
var darker, brighter, reI, reN, reP, reHex, reRgbInteger, reRgbPercent, reRgbaInteger, reRgbaPercent, reHslPercent, reHslaPercent, named;
var init_color = __esm({
  "node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/color.js"() {
    init_define();
    darker = 0.7;
    brighter = 1 / darker;
    reI = "\\s*([+-]?\\d+)\\s*";
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
    reHex = /^#([0-9a-f]{3,8})$/;
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
    named = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define_default(Color, color, {
      copy(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    define_default(Rgb, rgb, extend3(Color, {
      brighter(k4) {
        k4 = k4 == null ? brighter : Math.pow(brighter, k4);
        return new Rgb(this.r * k4, this.g * k4, this.b * k4, this.opacity);
      },
      darker(k4) {
        k4 = k4 == null ? darker : Math.pow(darker, k4);
        return new Rgb(this.r * k4, this.g * k4, this.b * k4, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex,
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    define_default(Hsl, hsl, extend3(Color, {
      brighter(k4) {
        k4 = k4 == null ? brighter : Math.pow(brighter, k4);
        return new Hsl(this.h, this.s, this.l * k4, this.opacity);
      },
      darker(k4) {
        k4 = k4 == null ? darker : Math.pow(darker, k4);
        return new Hsl(this.h, this.s, this.l * k4, this.opacity);
      },
      rgb() {
        var h4 = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h4) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s3, m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h4 >= 240 ? h4 - 240 : h4 + 120, m1, m2),
          hsl2rgb(h4, m1, m2),
          hsl2rgb(h4 < 120 ? h4 + 240 : h4 - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a4 = clampa(this.opacity);
        return `${a4 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? ")" : `, ${a4})`}`;
      }
    }));
  }
});

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/math.js
var radians, degrees;
var init_math2 = __esm({
  "node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/math.js"() {
    radians = Math.PI / 180;
    degrees = 180 / Math.PI;
  }
});

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/lab.js
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r2 = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b3 = rgb2lrgb(o.b), y7 = xyz2lab((0.2225045 * r2 + 0.7168786 * g + 0.0606169 * b3) / Yn), x7, z;
  if (r2 === g && g === b3)
    x7 = z = y7;
  else {
    x7 = xyz2lab((0.4360747 * r2 + 0.3850649 * g + 0.1430804 * b3) / Xn);
    z = xyz2lab((0.0139322 * r2 + 0.0971045 * g + 0.7141733 * b3) / Zn);
  }
  return new Lab(116 * y7 - 16, 500 * (x7 - y7), 200 * (y7 - z), o.opacity);
}
function lab(l, a4, b3, opacity2) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a4, b3, opacity2 == null ? 1 : opacity2);
}
function Lab(l, a4, b3, opacity2) {
  this.l = +l;
  this.a = +a4;
  this.b = +b3;
  this.opacity = +opacity2;
}
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t05;
}
function lab2xyz(t) {
  return t > t13 ? t * t * t : t2 * (t - t05);
}
function lrgb2rgb(x7) {
  return 255 * (x7 <= 31308e-7 ? 12.92 * x7 : 1.055 * Math.pow(x7, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x7) {
  return (x7 /= 255) <= 0.04045 ? x7 / 12.92 : Math.pow((x7 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h4 = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h4 < 0 ? h4 + 360 : h4, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h4, c2, l, opacity2) {
  return arguments.length === 1 ? hclConvert(h4) : new Hcl(h4, c2, l, opacity2 == null ? 1 : opacity2);
}
function Hcl(h4, c2, l, opacity2) {
  this.h = +h4;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity2;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h4 = o.h * radians;
  return new Lab(o.l, Math.cos(h4) * o.c, Math.sin(h4) * o.c, o.opacity);
}
var K, Xn, Yn, Zn, t05, t13, t2, t3;
var init_lab = __esm({
  "node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/lab.js"() {
    init_define();
    init_color();
    init_math2();
    K = 18;
    Xn = 0.96422;
    Yn = 1;
    Zn = 0.82521;
    t05 = 4 / 29;
    t13 = 6 / 29;
    t2 = 3 * t13 * t13;
    t3 = t13 * t13 * t13;
    define_default(Lab, lab, extend3(Color, {
      brighter(k4) {
        return new Lab(this.l + K * (k4 == null ? 1 : k4), this.a, this.b, this.opacity);
      },
      darker(k4) {
        return new Lab(this.l - K * (k4 == null ? 1 : k4), this.a, this.b, this.opacity);
      },
      rgb() {
        var y7 = (this.l + 16) / 116, x7 = isNaN(this.a) ? y7 : y7 + this.a / 500, z = isNaN(this.b) ? y7 : y7 - this.b / 200;
        x7 = Xn * lab2xyz(x7);
        y7 = Yn * lab2xyz(y7);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb(3.1338561 * x7 - 1.6168667 * y7 - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x7 + 1.9161415 * y7 + 0.033454 * z),
          lrgb2rgb(0.0719453 * x7 - 0.2289914 * y7 + 1.4052427 * z),
          this.opacity
        );
      }
    }));
    define_default(Hcl, hcl, extend3(Color, {
      brighter(k4) {
        return new Hcl(this.h, this.c, this.l + K * (k4 == null ? 1 : k4), this.opacity);
      },
      darker(k4) {
        return new Hcl(this.h, this.c, this.l - K * (k4 == null ? 1 : k4), this.opacity);
      },
      rgb() {
        return hcl2lab(this).rgb();
      }
    }));
  }
});

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/cubehelix.js
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r2 = o.r / 255, g = o.g / 255, b3 = o.b / 255, l = (BC_DA * b3 + ED * r2 - EB * g) / (BC_DA + ED - EB), bl3 = b3 - l, k4 = (E * (g - l) - C * bl3) / D, s3 = Math.sqrt(k4 * k4 + bl3 * bl3) / (E * l * (1 - l)), h4 = s3 ? Math.atan2(k4, bl3) * degrees - 120 : NaN;
  return new Cubehelix(h4 < 0 ? h4 + 360 : h4, s3, l, o.opacity);
}
function cubehelix(h4, s3, l, opacity2) {
  return arguments.length === 1 ? cubehelixConvert(h4) : new Cubehelix(h4, s3, l, opacity2 == null ? 1 : opacity2);
}
function Cubehelix(h4, s3, l, opacity2) {
  this.h = +h4;
  this.s = +s3;
  this.l = +l;
  this.opacity = +opacity2;
}
var A, B, C, D, E, ED, EB, BC_DA;
var init_cubehelix = __esm({
  "node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/cubehelix.js"() {
    init_define();
    init_color();
    init_math2();
    A = -0.14861;
    B = 1.78277;
    C = -0.29227;
    D = -0.90649;
    E = 1.97294;
    ED = E * D;
    EB = E * B;
    BC_DA = B * C - D * A;
    define_default(Cubehelix, cubehelix, extend3(Color, {
      brighter(k4) {
        k4 = k4 == null ? brighter : Math.pow(brighter, k4);
        return new Cubehelix(this.h, this.s, this.l * k4, this.opacity);
      },
      darker(k4) {
        k4 = k4 == null ? darker : Math.pow(darker, k4);
        return new Cubehelix(this.h, this.s, this.l * k4, this.opacity);
      },
      rgb() {
        var h4 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh4 = Math.cos(h4), sinh4 = Math.sin(h4);
        return new Rgb(
          255 * (l + a4 * (A * cosh4 + B * sinh4)),
          255 * (l + a4 * (C * cosh4 + D * sinh4)),
          255 * (l + a4 * (E * cosh4)),
          this.opacity
        );
      }
    }));
  }
});

// node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/index.js
var init_src13 = __esm({
  "node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/index.js"() {
    init_color();
    init_lab();
    init_cubehelix();
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basis.js
function basis(t15, v0, v1, v2, v3) {
  var t23 = t15 * t15, t33 = t23 * t15;
  return ((1 - 3 * t15 + 3 * t23 - t33) * v0 + (4 - 6 * t23 + 3 * t33) * v1 + (1 + 3 * t15 + 3 * t23 - 3 * t33) * v2 + t33 * v3) / 6;
}
function basis_default2(values5) {
  var n = values5.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values5[i], v2 = values5[i + 1], v0 = i > 0 ? values5[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values5[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}
var init_basis2 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basis.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values5) {
  var n = values5.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values5[(i + n - 1) % n], v1 = values5[i % n], v2 = values5[(i + 1) % n], v3 = values5[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}
var init_basisClosed2 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basisClosed.js"() {
    init_basis2();
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/constant.js
var constant_default3;
var init_constant4 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/constant.js"() {
    constant_default3 = (x7) => () => x7;
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/color.js
function linear2(a4, d) {
  return function(t) {
    return a4 + t * d;
  };
}
function exponential(a4, b3, y7) {
  return a4 = Math.pow(a4, y7), b3 = Math.pow(b3, y7) - a4, y7 = 1 / y7, function(t) {
    return Math.pow(a4 + t * b3, y7);
  };
}
function hue(a4, b3) {
  var d = b3 - a4;
  return d ? linear2(a4, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a4) ? b3 : a4);
}
function gamma(y7) {
  return (y7 = +y7) === 1 ? nogamma : function(a4, b3) {
    return b3 - a4 ? exponential(a4, b3, y7) : constant_default3(isNaN(a4) ? b3 : a4);
  };
}
function nogamma(a4, b3) {
  var d = b3 - a4;
  return d ? linear2(a4, d) : constant_default3(isNaN(a4) ? b3 : a4);
}
var init_color2 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/color.js"() {
    init_constant4();
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/rgb.js
function rgbSpline(spline) {
  return function(colors3) {
    var n = colors3.length, r2 = new Array(n), g = new Array(n), b3 = new Array(n), i, color7;
    for (i = 0; i < n; ++i) {
      color7 = rgb(colors3[i]);
      r2[i] = color7.r || 0;
      g[i] = color7.g || 0;
      b3[i] = color7.b || 0;
    }
    r2 = spline(r2);
    g = spline(g);
    b3 = spline(b3);
    color7.opacity = 1;
    return function(t) {
      color7.r = r2(t);
      color7.g = g(t);
      color7.b = b3(t);
      return color7 + "";
    };
  };
}
var rgb_default, rgbBasis, rgbBasisClosed;
var init_rgb = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/rgb.js"() {
    init_src13();
    init_basis2();
    init_basisClosed2();
    init_color2();
    rgb_default = function rgbGamma(y7) {
      var color7 = gamma(y7);
      function rgb3(start, end) {
        var r2 = color7((start = rgb(start)).r, (end = rgb(end)).r), g = color7(start.g, end.g), b3 = color7(start.b, end.b), opacity2 = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r2(t);
          start.g = g(t);
          start.b = b3(t);
          start.opacity = opacity2(t);
          return start + "";
        };
      }
      rgb3.gamma = rgbGamma;
      return rgb3;
    }(1);
    rgbBasis = rgbSpline(basis_default2);
    rgbBasisClosed = rgbSpline(basisClosed_default2);
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a4, b3) {
  if (!b3)
    b3 = [];
  var n = a4 ? Math.min(b3.length, a4.length) : 0, c2 = b3.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c2[i] = a4[i] * (1 - t) + b3[i] * t;
    return c2;
  };
}
function isNumberArray(x7) {
  return ArrayBuffer.isView(x7) && !(x7 instanceof DataView);
}
var init_numberArray = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/numberArray.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/array.js
function array_default2(a4, b3) {
  return (isNumberArray(b3) ? numberArray_default : genericArray)(a4, b3);
}
function genericArray(a4, b3) {
  var nb = b3 ? b3.length : 0, na = a4 ? Math.min(nb, a4.length) : 0, x7 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x7[i] = value_default(a4[i], b3[i]);
  for (; i < nb; ++i)
    c2[i] = b3[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c2[i] = x7[i](t);
    return c2;
  };
}
var init_array4 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/array.js"() {
    init_value();
    init_numberArray();
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/date.js
function date_default(a4, b3) {
  var d = new Date();
  return a4 = +a4, b3 = +b3, function(t) {
    return d.setTime(a4 * (1 - t) + b3 * t), d;
  };
}
var init_date = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/date.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/number.js
function number_default2(a4, b3) {
  return a4 = +a4, b3 = +b3, function(t) {
    return a4 * (1 - t) + b3 * t;
  };
}
var init_number3 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/number.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/object.js
function object_default(a4, b3) {
  var i = {}, c2 = {}, k4;
  if (a4 === null || typeof a4 !== "object")
    a4 = {};
  if (b3 === null || typeof b3 !== "object")
    b3 = {};
  for (k4 in b3) {
    if (k4 in a4) {
      i[k4] = value_default(a4[k4], b3[k4]);
    } else {
      c2[k4] = b3[k4];
    }
  }
  return function(t) {
    for (k4 in i)
      c2[k4] = i[k4](t);
    return c2;
  };
}
var init_object = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/object.js"() {
    init_value();
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/string.js
function zero4(b3) {
  return function() {
    return b3;
  };
}
function one3(b3) {
  return function(t) {
    return b3(t) + "";
  };
}
function string_default(a4, b3) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s3 = [], q = [];
  a4 = a4 + "", b3 = b3 + "";
  while ((am = reA.exec(a4)) && (bm = reB.exec(b3))) {
    if ((bs = bm.index) > bi) {
      bs = b3.slice(bi, bs);
      if (s3[i])
        s3[i] += bs;
      else
        s3[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s3[i])
        s3[i] += bm;
      else
        s3[++i] = bm;
    } else {
      s3[++i] = null;
      q.push({ i, x: number_default2(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b3.length) {
    bs = b3.slice(bi);
    if (s3[i])
      s3[i] += bs;
    else
      s3[++i] = bs;
  }
  return s3.length < 2 ? q[0] ? one3(q[0].x) : zero4(b3) : (b3 = q.length, function(t) {
    for (var i2 = 0, o; i2 < b3; ++i2)
      s3[(o = q[i2]).i] = o.x(t);
    return s3.join("");
  });
}
var reA, reB;
var init_string = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/string.js"() {
    init_number3();
    reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
    reB = new RegExp(reA.source, "g");
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/value.js
function value_default(a4, b3) {
  var t = typeof b3, c2;
  return b3 == null || t === "boolean" ? constant_default3(b3) : (t === "number" ? number_default2 : t === "string" ? (c2 = color(b3)) ? (b3 = c2, rgb_default) : string_default : b3 instanceof color ? rgb_default : b3 instanceof Date ? date_default : isNumberArray(b3) ? numberArray_default : Array.isArray(b3) ? genericArray : typeof b3.valueOf !== "function" && typeof b3.toString !== "function" || isNaN(b3) ? object_default : number_default2)(a4, b3);
}
var init_value = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/value.js"() {
    init_src13();
    init_rgb();
    init_array4();
    init_date();
    init_number3();
    init_object();
    init_string();
    init_constant4();
    init_numberArray();
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/discrete.js
function discrete_default(range7) {
  var n = range7.length;
  return function(t) {
    return range7[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var init_discrete = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/discrete.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/hue.js
function hue_default(a4, b3) {
  var i = hue(+a4, +b3);
  return function(t) {
    var x7 = i(t);
    return x7 - 360 * Math.floor(x7 / 360);
  };
}
var init_hue = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/hue.js"() {
    init_color2();
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/round.js
function round_default(a4, b3) {
  return a4 = +a4, b3 = +b3, function(t) {
    return Math.round(a4 * (1 - t) + b3 * t);
  };
}
var init_round = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/round.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/decompose.js
function decompose_default(a4, b3, c2, d, e3, f) {
  var scaleX, scaleY2, skewX;
  if (scaleX = Math.sqrt(a4 * a4 + b3 * b3))
    a4 /= scaleX, b3 /= scaleX;
  if (skewX = a4 * c2 + b3 * d)
    c2 -= a4 * skewX, d -= b3 * skewX;
  if (scaleY2 = Math.sqrt(c2 * c2 + d * d))
    c2 /= scaleY2, d /= scaleY2, skewX /= scaleY2;
  if (a4 * d < b3 * c2)
    a4 = -a4, b3 = -b3, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f,
    rotate: Math.atan2(b3, a4) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY: scaleY2
  };
}
var degrees2, identity4;
var init_decompose = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/decompose.js"() {
    degrees2 = 180 / Math.PI;
    identity4 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/parse.js
function parseCss(value4) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value4 + "");
  return m2.isIdentity ? identity4 : decompose_default(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value4) {
  if (value4 == null)
    return identity4;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value4);
  if (!(value4 = svgNode.transform.baseVal.consolidate()))
    return identity4;
  value4 = value4.matrix;
  return decompose_default(value4.a, value4.b, value4.c, value4.d, value4.e, value4.f);
}
var svgNode;
var init_parse = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/parse.js"() {
    init_decompose();
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse8, pxComma, pxParen, degParen) {
  function pop(s3) {
    return s3.length ? s3.pop() + " " : "";
  }
  function translate5(xa, ya, xb, yb, s3, q) {
    if (xa !== xb || ya !== yb) {
      var i = s3.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
    } else if (xb || yb) {
      s3.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate3(a4, b3, s3, q) {
    if (a4 !== b3) {
      if (a4 - b3 > 180)
        b3 += 360;
      else if (b3 - a4 > 180)
        a4 += 360;
      q.push({ i: s3.push(pop(s3) + "rotate(", null, degParen) - 2, x: number_default2(a4, b3) });
    } else if (b3) {
      s3.push(pop(s3) + "rotate(" + b3 + degParen);
    }
  }
  function skewX(a4, b3, s3, q) {
    if (a4 !== b3) {
      q.push({ i: s3.push(pop(s3) + "skewX(", null, degParen) - 2, x: number_default2(a4, b3) });
    } else if (b3) {
      s3.push(pop(s3) + "skewX(" + b3 + degParen);
    }
  }
  function scale8(xa, ya, xb, yb, s3, q) {
    if (xa !== xb || ya !== yb) {
      var i = s3.push(pop(s3) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s3.push(pop(s3) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a4, b3) {
    var s3 = [], q = [];
    a4 = parse8(a4), b3 = parse8(b3);
    translate5(a4.translateX, a4.translateY, b3.translateX, b3.translateY, s3, q);
    rotate3(a4.rotate, b3.rotate, s3, q);
    skewX(a4.skewX, b3.skewX, s3, q);
    scale8(a4.scaleX, a4.scaleY, b3.scaleX, b3.scaleY, s3, q);
    a4 = b3 = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s3[(o = q[i]).i] = o.x(t);
      return s3.join("");
    };
  };
}
var interpolateTransformCss, interpolateTransformSvg;
var init_transform2 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/index.js"() {
    init_number3();
    init_parse();
    interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/zoom.js
function cosh(x7) {
  return ((x7 = Math.exp(x7)) + 1 / x7) / 2;
}
function sinh(x7) {
  return ((x7 = Math.exp(x7)) - 1 / x7) / 2;
}
function tanh(x7) {
  return ((x7 = Math.exp(2 * x7)) - 1) / (x7 + 1);
}
var epsilon22, zoom_default;
var init_zoom = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/zoom.js"() {
    epsilon22 = 1e-12;
    zoom_default = function zoomRho(rho, rho2, rho4) {
      function zoom3(p02, p1) {
        var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        if (d2 < epsilon22) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        } else {
          var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s3 = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s3 + r0) - sinh(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh(rho * s3 + r0)
            ];
          };
        }
        i.duration = S * 1e3 * rho / Math.SQRT2;
        return i;
      }
      zoom3.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };
      return zoom3;
    }(Math.SQRT2, 2, 4);
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/hsl.js
function hsl2(hue3) {
  return function(start, end) {
    var h4 = hue3((start = hsl(start)).h, (end = hsl(end)).h), s3 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity2 = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h4(t);
      start.s = s3(t);
      start.l = l(t);
      start.opacity = opacity2(t);
      return start + "";
    };
  };
}
var hsl_default, hslLong;
var init_hsl = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/hsl.js"() {
    init_src13();
    init_color2();
    hsl_default = hsl2(hue);
    hslLong = hsl2(nogamma);
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/lab.js
function lab2(start, end) {
  var l = nogamma((start = lab(start)).l, (end = lab(end)).l), a4 = nogamma(start.a, end.a), b3 = nogamma(start.b, end.b), opacity2 = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a4(t);
    start.b = b3(t);
    start.opacity = opacity2(t);
    return start + "";
  };
}
var init_lab2 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/lab.js"() {
    init_src13();
    init_color2();
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/hcl.js
function hcl2(hue3) {
  return function(start, end) {
    var h4 = hue3((start = hcl(start)).h, (end = hcl(end)).h), c2 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity2 = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h4(t);
      start.c = c2(t);
      start.l = l(t);
      start.opacity = opacity2(t);
      return start + "";
    };
  };
}
var hcl_default, hclLong;
var init_hcl = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/hcl.js"() {
    init_src13();
    init_color2();
    hcl_default = hcl2(hue);
    hclLong = hcl2(nogamma);
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue3) {
  return function cubehelixGamma(y7) {
    y7 = +y7;
    function cubehelix5(start, end) {
      var h4 = hue3((start = cubehelix(start)).h, (end = cubehelix(end)).h), s3 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity2 = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h4(t);
        start.s = s3(t);
        start.l = l(Math.pow(t, y7));
        start.opacity = opacity2(t);
        return start + "";
      };
    }
    cubehelix5.gamma = cubehelixGamma;
    return cubehelix5;
  }(1);
}
var cubehelix_default, cubehelixLong;
var init_cubehelix2 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/cubehelix.js"() {
    init_src13();
    init_color2();
    cubehelix_default = cubehelix2(hue);
    cubehelixLong = cubehelix2(nogamma);
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate4, values5) {
  if (values5 === void 0)
    values5 = interpolate4, interpolate4 = value_default;
  var i = 0, n = values5.length - 1, v = values5[0], I = new Array(n < 0 ? 0 : n);
  while (i < n)
    I[i] = interpolate4(v, v = values5[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}
var init_piecewise = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/piecewise.js"() {
    init_value();
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/quantize.js
function quantize_default2(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i)
    samples[i] = interpolator(i / (n - 1));
  return samples;
}
var init_quantize2 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/quantize.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/index.js
var src_exports = {};
__export(src_exports, {
  interpolate: () => value_default,
  interpolateArray: () => array_default2,
  interpolateBasis: () => basis_default2,
  interpolateBasisClosed: () => basisClosed_default2,
  interpolateCubehelix: () => cubehelix_default,
  interpolateCubehelixLong: () => cubehelixLong,
  interpolateDate: () => date_default,
  interpolateDiscrete: () => discrete_default,
  interpolateHcl: () => hcl_default,
  interpolateHclLong: () => hclLong,
  interpolateHsl: () => hsl_default,
  interpolateHslLong: () => hslLong,
  interpolateHue: () => hue_default,
  interpolateLab: () => lab2,
  interpolateNumber: () => number_default2,
  interpolateNumberArray: () => numberArray_default,
  interpolateObject: () => object_default,
  interpolateRgb: () => rgb_default,
  interpolateRgbBasis: () => rgbBasis,
  interpolateRgbBasisClosed: () => rgbBasisClosed,
  interpolateRound: () => round_default,
  interpolateString: () => string_default,
  interpolateTransformCss: () => interpolateTransformCss,
  interpolateTransformSvg: () => interpolateTransformSvg,
  interpolateZoom: () => zoom_default,
  piecewise: () => piecewise,
  quantize: () => quantize_default2
});
var init_src14 = __esm({
  "node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/index.js"() {
    init_value();
    init_array4();
    init_basis2();
    init_basisClosed2();
    init_date();
    init_discrete();
    init_hue();
    init_number3();
    init_numberArray();
    init_object();
    init_round();
    init_string();
    init_transform2();
    init_zoom();
    init_rgb();
    init_hsl();
    init_lab2();
    init_hcl();
    init_cubehelix2();
    init_piecewise();
    init_quantize2();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/constant.js
function constants(x7) {
  return function() {
    return x7;
  };
}
var init_constant5 = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/number.js
function number2(x7) {
  return +x7;
}
var init_number4 = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/number.js"() {
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/continuous.js
function identity5(x7) {
  return x7;
}
function normalize(a4, b3) {
  return (b3 -= a4 = +a4) ? function(x7) {
    return (x7 - a4) / b3;
  } : constants(isNaN(b3) ? NaN : 0.5);
}
function clamper(a4, b3) {
  var t;
  if (a4 > b3)
    t = a4, a4 = b3, b3 = t;
  return function(x7) {
    return Math.max(a4, Math.min(b3, x7));
  };
}
function bimap(domain4, range7, interpolate4) {
  var d0 = domain4[0], d1 = domain4[1], r0 = range7[0], r1 = range7[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate4(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate4(r0, r1);
  return function(x7) {
    return r0(d0(x7));
  };
}
function polymap(domain4, range7, interpolate4) {
  var j = Math.min(domain4.length, range7.length) - 1, d = new Array(j), r2 = new Array(j), i = -1;
  if (domain4[j] < domain4[0]) {
    domain4 = domain4.slice().reverse();
    range7 = range7.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain4[i], domain4[i + 1]);
    r2[i] = interpolate4(range7[i], range7[i + 1]);
  }
  return function(x7) {
    var i2 = bisect_default2(domain4, x7, 1, j) - 1;
    return r2[i2](d[i2](x7));
  };
}
function copy(source5, target2) {
  return target2.domain(source5.domain()).range(source5.range()).interpolate(source5.interpolate()).clamp(source5.clamp()).unknown(source5.unknown());
}
function transformer() {
  var domain4 = unit, range7 = unit, interpolate4 = value_default, transform4, untransform, unknown, clamp3 = identity5, piecewise3, output3, input;
  function rescale() {
    var n = Math.min(domain4.length, range7.length);
    if (clamp3 !== identity5)
      clamp3 = clamper(domain4[0], domain4[n - 1]);
    piecewise3 = n > 2 ? polymap : bimap;
    output3 = input = null;
    return scale8;
  }
  function scale8(x7) {
    return x7 == null || isNaN(x7 = +x7) ? unknown : (output3 || (output3 = piecewise3(domain4.map(transform4), range7, interpolate4)))(transform4(clamp3(x7)));
  }
  scale8.invert = function(y7) {
    return clamp3(untransform((input || (input = piecewise3(range7, domain4.map(transform4), number_default2)))(y7)));
  };
  scale8.domain = function(_) {
    return arguments.length ? (domain4 = Array.from(_, number2), rescale()) : domain4.slice();
  };
  scale8.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), rescale()) : range7.slice();
  };
  scale8.rangeRound = function(_) {
    return range7 = Array.from(_), interpolate4 = round_default, rescale();
  };
  scale8.clamp = function(_) {
    return arguments.length ? (clamp3 = _ ? true : identity5, rescale()) : clamp3 !== identity5;
  };
  scale8.interpolate = function(_) {
    return arguments.length ? (interpolate4 = _, rescale()) : interpolate4;
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  return function(t, u) {
    transform4 = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity5, identity5);
}
var unit;
var init_continuous = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/continuous.js"() {
    init_src4();
    init_src14();
    init_constant5();
    init_number4();
    unit = [0, 1];
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default2(x7, p) {
  if ((i = (x7 = p ? x7.toExponential(p - 1) : x7.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x7.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x7.slice(i + 1)
  ];
}
var init_formatDecimal2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatDecimal.js"() {
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/exponent.js
function exponent_default2(x7) {
  return x7 = formatDecimal_default2(Math.abs(x7)), x7 ? x7[1] : NaN;
}
var init_exponent2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/exponent.js"() {
    init_formatDecimal2();
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatGroup.js
function formatGroup_default2(grouping, thousands) {
  return function(value4, width2) {
    var i = value4.length, t = [], j = 0, g = grouping[0], length4 = 0;
    while (i > 0 && g > 0) {
      if (length4 + g + 1 > width2)
        g = Math.max(1, width2 - length4);
      t.push(value4.substring(i -= g, i + g));
      if ((length4 += g + 1) > width2)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
var init_formatGroup2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatGroup.js"() {
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default2(numerals) {
  return function(value4) {
    return value4.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var init_formatNumerals2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatNumerals.js"() {
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatSpecifier.js
function formatSpecifier2(specifier) {
  return new FormatSpecifier2(specifier);
}
function FormatSpecifier2(specifier) {
  if (!(match4 = re2.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match4;
  this.fill = match4[1] || " ";
  this.align = match4[2] || ">";
  this.sign = match4[3] || "-";
  this.symbol = match4[4] || "";
  this.zero = !!match4[5];
  this.width = match4[6] && +match4[6];
  this.comma = !!match4[7];
  this.precision = match4[8] && +match4[8].slice(1);
  this.trim = !!match4[9];
  this.type = match4[10] || "";
}
var re2;
var init_formatSpecifier2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatSpecifier.js"() {
    re2 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    formatSpecifier2.prototype = FormatSpecifier2.prototype;
    FormatSpecifier2.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatTrim.js
function formatTrim_default2(s3) {
  out:
    for (var n = s3.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s3[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (i0 > 0) {
            if (!+s3[i])
              break out;
            i0 = 0;
          }
          break;
      }
    }
  return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
}
var init_formatTrim2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatTrim.js"() {
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatPrefixAuto.js
function formatPrefixAuto_default2(x7, p) {
  var d = formatDecimal_default2(x7, p);
  if (!d)
    return x7 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent2 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimal_default2(x7, Math.max(0, p + i - 1))[0];
}
var prefixExponent2;
var init_formatPrefixAuto2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatPrefixAuto.js"() {
    init_formatDecimal2();
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatRounded.js
function formatRounded_default2(x7, p) {
  var d = formatDecimal_default2(x7, p);
  if (!d)
    return x7 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
var init_formatRounded2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatRounded.js"() {
    init_formatDecimal2();
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatTypes.js
var formatTypes_default2;
var init_formatTypes2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/formatTypes.js"() {
    init_formatPrefixAuto2();
    init_formatRounded2();
    formatTypes_default2 = {
      "%": function(x7, p) {
        return (x7 * 100).toFixed(p);
      },
      "b": function(x7) {
        return Math.round(x7).toString(2);
      },
      "c": function(x7) {
        return x7 + "";
      },
      "d": function(x7) {
        return Math.round(x7).toString(10);
      },
      "e": function(x7, p) {
        return x7.toExponential(p);
      },
      "f": function(x7, p) {
        return x7.toFixed(p);
      },
      "g": function(x7, p) {
        return x7.toPrecision(p);
      },
      "o": function(x7) {
        return Math.round(x7).toString(8);
      },
      "p": function(x7, p) {
        return formatRounded_default2(x7 * 100, p);
      },
      "r": formatRounded_default2,
      "s": formatPrefixAuto_default2,
      "X": function(x7) {
        return Math.round(x7).toString(16).toUpperCase();
      },
      "x": function(x7) {
        return Math.round(x7).toString(16);
      }
    };
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/identity.js
function identity_default5(x7) {
  return x7;
}
var init_identity6 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/identity.js"() {
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/locale.js
function locale_default2(locale7) {
  var group6 = locale7.grouping && locale7.thousands ? formatGroup_default2(locale7.grouping, locale7.thousands) : identity_default5, currency = locale7.currency, decimal = locale7.decimal, numerals = locale7.numerals ? formatNumerals_default2(locale7.numerals) : identity_default5, percent = locale7.percent || "%";
  function newFormat(specifier) {
    specifier = formatSpecifier2(specifier);
    var fill3 = specifier.fill, align2 = specifier.align, sign5 = specifier.sign, symbol3 = specifier.symbol, zero10 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type4 = specifier.type;
    if (type4 === "n")
      comma = true, type4 = "g";
    else if (!formatTypes_default2[type4])
      precision == null && (precision = 12), trim = true, type4 = "g";
    if (zero10 || fill3 === "0" && align2 === "=")
      zero10 = true, fill3 = "0", align2 = "=";
    var prefix = symbol3 === "$" ? currency[0] : symbol3 === "#" && /[boxX]/.test(type4) ? "0" + type4.toLowerCase() : "", suffix = symbol3 === "$" ? currency[1] : /[%p]/.test(type4) ? percent : "";
    var formatType = formatTypes_default2[type4], maybeSuffix = /[defgprs%]/.test(type4);
    precision = precision == null ? 6 : /[gprs]/.test(type4) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format9(value4) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
      if (type4 === "c") {
        valueSuffix = formatType(value4) + valueSuffix;
        value4 = "";
      } else {
        value4 = +value4;
        var valueNegative = value4 < 0;
        value4 = formatType(Math.abs(value4), precision);
        if (trim)
          value4 = formatTrim_default2(value4);
        if (valueNegative && +value4 === 0)
          valueNegative = false;
        valuePrefix = (valueNegative ? sign5 === "(" ? sign5 : "-" : sign5 === "-" || sign5 === "(" ? "" : sign5) + valuePrefix;
        valueSuffix = (type4 === "s" ? prefixes2[8 + prefixExponent2 / 3] : "") + valueSuffix + (valueNegative && sign5 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value4.length;
          while (++i < n) {
            if (c2 = value4.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value4.slice(i + 1) : value4.slice(i)) + valueSuffix;
              value4 = value4.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero10)
        value4 = group6(value4, Infinity);
      var length4 = valuePrefix.length + value4.length + valueSuffix.length, padding3 = length4 < width2 ? new Array(width2 - length4 + 1).join(fill3) : "";
      if (comma && zero10)
        value4 = group6(padding3 + value4, padding3.length ? width2 - valueSuffix.length : Infinity), padding3 = "";
      switch (align2) {
        case "<":
          value4 = valuePrefix + value4 + valueSuffix + padding3;
          break;
        case "=":
          value4 = valuePrefix + padding3 + value4 + valueSuffix;
          break;
        case "^":
          value4 = padding3.slice(0, length4 = padding3.length >> 1) + valuePrefix + value4 + valueSuffix + padding3.slice(length4);
          break;
        default:
          value4 = padding3 + valuePrefix + value4 + valueSuffix;
          break;
      }
      return numerals(value4);
    }
    format9.toString = function() {
      return specifier + "";
    };
    return format9;
  }
  function formatPrefix4(specifier, value4) {
    var f = newFormat((specifier = formatSpecifier2(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default2(value4) / 3))) * 3, k4 = Math.pow(10, -e3), prefix = prefixes2[8 + e3 / 3];
    return function(value5) {
      return f(k4 * value5) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix4
  };
}
var prefixes2;
var init_locale3 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/locale.js"() {
    init_exponent2();
    init_formatGroup2();
    init_formatNumerals2();
    init_formatSpecifier2();
    init_formatTrim2();
    init_formatTypes2();
    init_formatPrefixAuto2();
    init_identity6();
    prefixes2 = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/defaultLocale.js
function defaultLocale4(definition3) {
  locale3 = locale_default2(definition3);
  format3 = locale3.format;
  formatPrefix2 = locale3.formatPrefix;
  return locale3;
}
var locale3, format3, formatPrefix2;
var init_defaultLocale3 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/defaultLocale.js"() {
    init_locale3();
    defaultLocale4({
      decimal: ".",
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default2(step) {
  return Math.max(0, -exponent_default2(Math.abs(step)));
}
var init_precisionFixed2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/precisionFixed.js"() {
    init_exponent2();
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default2(step, value4) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default2(value4) / 3))) * 3 - exponent_default2(Math.abs(step)));
}
var init_precisionPrefix2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/precisionPrefix.js"() {
    init_exponent2();
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/precisionRound.js
function precisionRound_default2(step, max8) {
  step = Math.abs(step), max8 = Math.abs(max8) - step;
  return Math.max(0, exponent_default2(max8) - exponent_default2(step)) + 1;
}
var init_precisionRound2 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/precisionRound.js"() {
    init_exponent2();
  }
});

// node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  format: () => format3,
  formatDefaultLocale: () => defaultLocale4,
  formatLocale: () => locale_default2,
  formatPrefix: () => formatPrefix2,
  formatSpecifier: () => formatSpecifier2,
  precisionFixed: () => precisionFixed_default2,
  precisionPrefix: () => precisionPrefix_default2,
  precisionRound: () => precisionRound_default2
});
var init_src15 = __esm({
  "node_modules/.pnpm/d3-format@1.3.2/node_modules/d3-format/src/index.js"() {
    init_defaultLocale3();
    init_locale3();
    init_formatSpecifier2();
    init_precisionFixed2();
    init_precisionPrefix2();
    init_precisionRound2();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop2, count5, specifier) {
  var step = tickStep(start, stop2, count5), precision;
  specifier = formatSpecifier2(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value4 = Math.max(Math.abs(start), Math.abs(stop2));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default2(step, value4)))
        specifier.precision = precision;
      return formatPrefix2(specifier, value4);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default2(step, Math.max(Math.abs(start), Math.abs(stop2)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default2(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format3(specifier);
}
var init_tickFormat = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/tickFormat.js"() {
    init_src4();
    init_src15();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/linear.js
function linearish(scale8) {
  var domain4 = scale8.domain;
  scale8.ticks = function(count5) {
    var d = domain4();
    return ticks(d[0], d[d.length - 1], count5 == null ? 10 : count5);
  };
  scale8.tickFormat = function(count5, specifier) {
    var d = domain4();
    return tickFormat(d[0], d[d.length - 1], count5 == null ? 10 : count5, specifier);
  };
  scale8.nice = function(count5) {
    if (count5 == null)
      count5 = 10;
    var d = domain4();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop2 = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop2 < start) {
      step = start, start = stop2, stop2 = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop2, count5);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop2;
        return domain4(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop2 = Math.ceil(stop2 / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop2 = Math.floor(stop2 * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale8;
  };
  return scale8;
}
function linear3() {
  var scale8 = continuous();
  scale8.copy = function() {
    return copy(scale8, linear3());
  };
  initRange.apply(scale8, arguments);
  return linearish(scale8);
}
var init_linear2 = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/linear.js"() {
    init_src4();
    init_continuous();
    init_init();
    init_tickFormat();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/identity.js
function identity6(domain4) {
  var unknown;
  function scale8(x7) {
    return x7 == null || isNaN(x7 = +x7) ? unknown : x7;
  }
  scale8.invert = scale8;
  scale8.domain = scale8.range = function(_) {
    return arguments.length ? (domain4 = Array.from(_, number2), scale8) : domain4.slice();
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  scale8.copy = function() {
    return identity6(domain4).unknown(unknown);
  };
  domain4 = arguments.length ? Array.from(domain4, number2) : [0, 1];
  return linearish(scale8);
}
var init_identity7 = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/identity.js"() {
    init_linear2();
    init_number4();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/nice.js
function nice3(domain4, interval3) {
  domain4 = domain4.slice();
  var i0 = 0, i1 = domain4.length - 1, x07 = domain4[i0], x13 = domain4[i1], t;
  if (x13 < x07) {
    t = i0, i0 = i1, i1 = t;
    t = x07, x07 = x13, x13 = t;
  }
  domain4[i0] = interval3.floor(x07);
  domain4[i1] = interval3.ceil(x13);
  return domain4;
}
var init_nice3 = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/nice.js"() {
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/log.js
function transformLog(x7) {
  return Math.log(x7);
}
function transformExp(x7) {
  return Math.exp(x7);
}
function transformLogn(x7) {
  return -Math.log(-x7);
}
function transformExpn(x7) {
  return -Math.exp(-x7);
}
function pow10(x7) {
  return isFinite(x7) ? +("1e" + x7) : x7 < 0 ? 0 : x7;
}
function powp(base3) {
  return base3 === 10 ? pow10 : base3 === Math.E ? Math.exp : (x7) => Math.pow(base3, x7);
}
function logp(base3) {
  return base3 === Math.E ? Math.log : base3 === 10 && Math.log10 || base3 === 2 && Math.log2 || (base3 = Math.log(base3), (x7) => Math.log(x7) / base3);
}
function reflect(f) {
  return (x7, k4) => -f(-x7, k4);
}
function loggish(transform4) {
  const scale8 = transform4(transformLog, transformExp);
  const domain4 = scale8.domain;
  let base3 = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base3), pows = powp(base3);
    if (domain4()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform4(transformLogn, transformExpn);
    } else {
      transform4(transformLog, transformExp);
    }
    return scale8;
  }
  scale8.base = function(_) {
    return arguments.length ? (base3 = +_, rescale()) : base3;
  };
  scale8.domain = function(_) {
    return arguments.length ? (domain4(_), rescale()) : domain4();
  };
  scale8.ticks = (count5) => {
    const d = domain4();
    let u = d[0];
    let v = d[d.length - 1];
    const r2 = v < u;
    if (r2)
      [u, v] = [v, u];
    let i = logs(u);
    let j = logs(v);
    let k4;
    let t;
    const n = count5 == null ? 10 : +count5;
    let z = [];
    if (!(base3 % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0)
        for (; i <= j; ++i) {
          for (k4 = 1; k4 < base3; ++k4) {
            t = i < 0 ? k4 / pows(-i) : k4 * pows(i);
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      else
        for (; i <= j; ++i) {
          for (k4 = base3 - 1; k4 >= 1; --k4) {
            t = i > 0 ? k4 / pows(-i) : k4 * pows(i);
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      if (z.length * 2 < n)
        z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r2 ? z.reverse() : z;
  };
  scale8.tickFormat = (count5, specifier) => {
    if (count5 == null)
      count5 = 10;
    if (specifier == null)
      specifier = base3 === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base3 % 1) && (specifier = formatSpecifier2(specifier)).precision == null)
        specifier.trim = true;
      specifier = format3(specifier);
    }
    if (count5 === Infinity)
      return specifier;
    const k4 = Math.max(1, base3 * count5 / scale8.ticks().length);
    return (d) => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base3 < base3 - 0.5)
        i *= base3;
      return i <= k4 ? specifier(d) : "";
    };
  };
  scale8.nice = () => {
    return domain4(nice3(domain4(), {
      floor: (x7) => pows(Math.floor(logs(x7))),
      ceil: (x7) => pows(Math.ceil(logs(x7)))
    }));
  };
  return scale8;
}
function log3() {
  const scale8 = loggish(transformer()).domain([1, 10]);
  scale8.copy = () => copy(scale8, log3()).base(scale8.base());
  initRange.apply(scale8, arguments);
  return scale8;
}
var init_log = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/log.js"() {
    init_src4();
    init_src15();
    init_nice3();
    init_continuous();
    init_init();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/symlog.js
function transformSymlog(c2) {
  return function(x7) {
    return Math.sign(x7) * Math.log1p(Math.abs(x7 / c2));
  };
}
function transformSymexp(c2) {
  return function(x7) {
    return Math.sign(x7) * Math.expm1(Math.abs(x7)) * c2;
  };
}
function symlogish(transform4) {
  var c2 = 1, scale8 = transform4(transformSymlog(c2), transformSymexp(c2));
  scale8.constant = function(_) {
    return arguments.length ? transform4(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
  };
  return linearish(scale8);
}
function symlog2() {
  var scale8 = symlogish(transformer());
  scale8.copy = function() {
    return copy(scale8, symlog2()).constant(scale8.constant());
  };
  return initRange.apply(scale8, arguments);
}
var init_symlog = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/symlog.js"() {
    init_linear2();
    init_continuous();
    init_init();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x7) {
    return x7 < 0 ? -Math.pow(-x7, exponent) : Math.pow(x7, exponent);
  };
}
function transformSqrt(x7) {
  return x7 < 0 ? -Math.sqrt(-x7) : Math.sqrt(x7);
}
function transformSquare(x7) {
  return x7 < 0 ? -x7 * x7 : x7 * x7;
}
function powish(transform4) {
  var scale8 = transform4(identity5, identity5), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform4(identity5, identity5) : exponent === 0.5 ? transform4(transformSqrt, transformSquare) : transform4(transformPow(exponent), transformPow(1 / exponent));
  }
  scale8.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale8);
}
function pow3() {
  var scale8 = powish(transformer());
  scale8.copy = function() {
    return copy(scale8, pow3()).exponent(scale8.exponent());
  };
  initRange.apply(scale8, arguments);
  return scale8;
}
function sqrt2() {
  return pow3.apply(null, arguments).exponent(0.5);
}
var init_pow = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/pow.js"() {
    init_linear2();
    init_continuous();
    init_init();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/radial.js
var init_radial2 = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/radial.js"() {
    init_continuous();
    init_init();
    init_linear2();
    init_number4();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/quantile.js
function quantile3() {
  var domain4 = [], range7 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range7.length);
    thresholds = new Array(n - 1);
    while (++i < n)
      thresholds[i - 1] = quantileSorted(domain4, i / n);
    return scale8;
  }
  function scale8(x7) {
    return x7 == null || isNaN(x7 = +x7) ? unknown : range7[bisect_default2(thresholds, x7)];
  }
  scale8.invertExtent = function(y7) {
    var i = range7.indexOf(y7);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain4[0],
      i < thresholds.length ? thresholds[i] : domain4[domain4.length - 1]
    ];
  };
  scale8.domain = function(_) {
    if (!arguments.length)
      return domain4.slice();
    domain4 = [];
    for (let d of _)
      if (d != null && !isNaN(d = +d))
        domain4.push(d);
    domain4.sort(ascending3);
    return rescale();
  };
  scale8.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), rescale()) : range7.slice();
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  scale8.quantiles = function() {
    return thresholds.slice();
  };
  scale8.copy = function() {
    return quantile3().domain(domain4).range(range7).unknown(unknown);
  };
  return initRange.apply(scale8, arguments);
}
var init_quantile3 = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/quantile.js"() {
    init_src4();
    init_init();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/quantize.js
function quantize() {
  var x07 = 0, x13 = 1, n = 1, domain4 = [0.5], range7 = [0, 1], unknown;
  function scale8(x7) {
    return x7 != null && x7 <= x7 ? range7[bisect_default2(domain4, x7, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain4 = new Array(n);
    while (++i < n)
      domain4[i] = ((i + 1) * x13 - (i - n) * x07) / (n + 1);
    return scale8;
  }
  scale8.domain = function(_) {
    return arguments.length ? ([x07, x13] = _, x07 = +x07, x13 = +x13, rescale()) : [x07, x13];
  };
  scale8.range = function(_) {
    return arguments.length ? (n = (range7 = Array.from(_)).length - 1, rescale()) : range7.slice();
  };
  scale8.invertExtent = function(y7) {
    var i = range7.indexOf(y7);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x07, domain4[0]] : i >= n ? [domain4[n - 1], x13] : [domain4[i - 1], domain4[i]];
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : scale8;
  };
  scale8.thresholds = function() {
    return domain4.slice();
  };
  scale8.copy = function() {
    return quantize().domain([x07, x13]).range(range7).unknown(unknown);
  };
  return initRange.apply(linearish(scale8), arguments);
}
var init_quantize3 = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/quantize.js"() {
    init_src4();
    init_linear2();
    init_init();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain4 = [0.5], range7 = [0, 1], unknown, n = 1;
  function scale8(x7) {
    return x7 != null && x7 <= x7 ? range7[bisect_default2(domain4, x7, 0, n)] : unknown;
  }
  scale8.domain = function(_) {
    return arguments.length ? (domain4 = Array.from(_), n = Math.min(domain4.length, range7.length - 1), scale8) : domain4.slice();
  };
  scale8.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), n = Math.min(domain4.length, range7.length - 1), scale8) : range7.slice();
  };
  scale8.invertExtent = function(y7) {
    var i = range7.indexOf(y7);
    return [domain4[i - 1], domain4[i]];
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  scale8.copy = function() {
    return threshold().domain(domain4).range(range7).unknown(unknown);
  };
  return initRange.apply(scale8, arguments);
}
var init_threshold = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/threshold.js"() {
    init_src4();
    init_init();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number3(t) {
  return t instanceof Date ? +t : +new Date(+t);
}
function calendar(ticks3, tickInterval, year2, month2, week2, day2, hour2, minute2, second3, format9) {
  var scale8 = continuous(), invert2 = scale8.invert, domain4 = scale8.domain;
  var formatMillisecond = format9(".%L"), formatSecond = format9(":%S"), formatMinute = format9("%I:%M"), formatHour = format9("%I %p"), formatDay = format9("%a %d"), formatWeek = format9("%b %d"), formatMonth = format9("%B"), formatYear5 = format9("%Y");
  function tickFormat5(date3) {
    return (second3(date3) < date3 ? formatMillisecond : minute2(date3) < date3 ? formatSecond : hour2(date3) < date3 ? formatMinute : day2(date3) < date3 ? formatHour : month2(date3) < date3 ? week2(date3) < date3 ? formatDay : formatWeek : year2(date3) < date3 ? formatMonth : formatYear5)(date3);
  }
  scale8.invert = function(y7) {
    return new Date(invert2(y7));
  };
  scale8.domain = function(_) {
    return arguments.length ? domain4(Array.from(_, number3)) : domain4().map(date);
  };
  scale8.ticks = function(interval3) {
    var d = domain4();
    return ticks3(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
  };
  scale8.tickFormat = function(count5, specifier) {
    return specifier == null ? tickFormat5 : format9(specifier);
  };
  scale8.nice = function(interval3) {
    var d = domain4();
    if (!interval3 || typeof interval3.range !== "function")
      interval3 = tickInterval(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
    return interval3 ? domain4(nice3(d, interval3)) : scale8;
  };
  scale8.copy = function() {
    return copy(scale8, calendar(ticks3, tickInterval, year2, month2, week2, day2, hour2, minute2, second3, format9));
  };
  return scale8;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var init_time = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/time.js"() {
    init_src6();
    init_src7();
    init_continuous();
    init_init();
    init_nice3();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
var init_utcTime = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/utcTime.js"() {
    init_src6();
    init_src7();
    init_time();
    init_init();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/sequential.js
function transformer2() {
  var x07 = 0, x13 = 1, t07, t15, k10, transform4, interpolator = identity5, clamp3 = false, unknown;
  function scale8(x7) {
    return x7 == null || isNaN(x7 = +x7) ? unknown : interpolator(k10 === 0 ? 0.5 : (x7 = (transform4(x7) - t07) * k10, clamp3 ? Math.max(0, Math.min(1, x7)) : x7));
  }
  scale8.domain = function(_) {
    return arguments.length ? ([x07, x13] = _, t07 = transform4(x07 = +x07), t15 = transform4(x13 = +x13), k10 = t07 === t15 ? 0 : 1 / (t15 - t07), scale8) : [x07, x13];
  };
  scale8.clamp = function(_) {
    return arguments.length ? (clamp3 = !!_, scale8) : clamp3;
  };
  scale8.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale8) : interpolator;
  };
  function range7(interpolate4) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate4(r0, r1), scale8) : [interpolator(0), interpolator(1)];
    };
  }
  scale8.range = range7(value_default);
  scale8.rangeRound = range7(round_default);
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  return function(t) {
    transform4 = t, t07 = t(x07), t15 = t(x13), k10 = t07 === t15 ? 0 : 1 / (t15 - t07);
    return scale8;
  };
}
function copy2(source5, target2) {
  return target2.domain(source5.domain()).interpolator(source5.interpolator()).clamp(source5.clamp()).unknown(source5.unknown());
}
function sequential() {
  var scale8 = linearish(transformer2()(identity5));
  scale8.copy = function() {
    return copy2(scale8, sequential());
  };
  return initInterpolator.apply(scale8, arguments);
}
function sequentialLog() {
  var scale8 = loggish(transformer2()).domain([1, 10]);
  scale8.copy = function() {
    return copy2(scale8, sequentialLog()).base(scale8.base());
  };
  return initInterpolator.apply(scale8, arguments);
}
function sequentialSymlog() {
  var scale8 = symlogish(transformer2());
  scale8.copy = function() {
    return copy2(scale8, sequentialSymlog()).constant(scale8.constant());
  };
  return initInterpolator.apply(scale8, arguments);
}
function sequentialPow() {
  var scale8 = powish(transformer2());
  scale8.copy = function() {
    return copy2(scale8, sequentialPow()).exponent(scale8.exponent());
  };
  return initInterpolator.apply(scale8, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
var init_sequential = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/sequential.js"() {
    init_src14();
    init_continuous();
    init_init();
    init_linear2();
    init_log();
    init_symlog();
    init_pow();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/sequentialQuantile.js
var init_sequentialQuantile = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/sequentialQuantile.js"() {
    init_src4();
    init_continuous();
    init_init();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x07 = 0, x13 = 0.5, x22 = 1, s3 = 1, t07, t15, t23, k10, k21, interpolator = identity5, transform4, clamp3 = false, unknown;
  function scale8(x7) {
    return isNaN(x7 = +x7) ? unknown : (x7 = 0.5 + ((x7 = +transform4(x7)) - t15) * (s3 * x7 < s3 * t15 ? k10 : k21), interpolator(clamp3 ? Math.max(0, Math.min(1, x7)) : x7));
  }
  scale8.domain = function(_) {
    return arguments.length ? ([x07, x13, x22] = _, t07 = transform4(x07 = +x07), t15 = transform4(x13 = +x13), t23 = transform4(x22 = +x22), k10 = t07 === t15 ? 0 : 0.5 / (t15 - t07), k21 = t15 === t23 ? 0 : 0.5 / (t23 - t15), s3 = t15 < t07 ? -1 : 1, scale8) : [x07, x13, x22];
  };
  scale8.clamp = function(_) {
    return arguments.length ? (clamp3 = !!_, scale8) : clamp3;
  };
  scale8.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale8) : interpolator;
  };
  function range7(interpolate4) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate4, [r0, r1, r2]), scale8) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale8.range = range7(value_default);
  scale8.rangeRound = range7(round_default);
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  return function(t) {
    transform4 = t, t07 = t(x07), t15 = t(x13), t23 = t(x22), k10 = t07 === t15 ? 0 : 0.5 / (t15 - t07), k21 = t15 === t23 ? 0 : 0.5 / (t23 - t15), s3 = t15 < t07 ? -1 : 1;
    return scale8;
  };
}
function diverging() {
  var scale8 = linearish(transformer3()(identity5));
  scale8.copy = function() {
    return copy2(scale8, diverging());
  };
  return initInterpolator.apply(scale8, arguments);
}
function divergingLog() {
  var scale8 = loggish(transformer3()).domain([0.1, 1, 10]);
  scale8.copy = function() {
    return copy2(scale8, divergingLog()).base(scale8.base());
  };
  return initInterpolator.apply(scale8, arguments);
}
function divergingSymlog() {
  var scale8 = symlogish(transformer3());
  scale8.copy = function() {
    return copy2(scale8, divergingSymlog()).constant(scale8.constant());
  };
  return initInterpolator.apply(scale8, arguments);
}
function divergingPow() {
  var scale8 = powish(transformer3());
  scale8.copy = function() {
    return copy2(scale8, divergingPow()).exponent(scale8.exponent());
  };
  return initInterpolator.apply(scale8, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
var init_diverging2 = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/diverging.js"() {
    init_src14();
    init_continuous();
    init_init();
    init_linear2();
    init_log();
    init_sequential();
    init_symlog();
    init_pow();
  }
});

// node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/index.js
var init_src16 = __esm({
  "node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/index.js"() {
    init_band();
    init_identity7();
    init_linear2();
    init_log();
    init_symlog();
    init_ordinal();
    init_pow();
    init_radial2();
    init_quantile3();
    init_quantize3();
    init_threshold();
    init_time();
    init_utcTime();
    init_sequential();
    init_sequentialQuantile();
    init_diverging2();
    init_tickFormat();
  }
});

// node_modules/.pnpm/vega-scale@7.3.0/node_modules/vega-scale/build/vega-scale.module.js
function bandSpace(count5, paddingInner2, paddingOuter2) {
  const space = count5 - paddingInner2 + paddingOuter2 * 2;
  return count5 ? space > 0 ? space : 1 : 0;
}
function invertRange(scale8) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale8.invert(lo), scale8.invert(hi)];
  };
}
function invertRangeExtent(scale8) {
  return function(_) {
    const range7 = scale8.range();
    let lo = _[0], hi = _[1], min8 = -1, max8, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min8 < 0)
          min8 = i;
        max8 = i;
      }
    }
    if (min8 < 0)
      return void 0;
    lo = scale8.invertExtent(range7[min8]);
    hi = scale8.invertExtent(range7[max8]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band2() {
  const scale8 = ordinal().unknown(void 0), domain4 = scale8.domain, ordinalRange = scale8.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale8.unknown;
  function rescale() {
    const n = domain4().length, reverse6 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse6], space = bandSpace(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse6 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values5 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse6 ? values5.reverse() : values5);
  }
  scale8.domain = function(_) {
    if (arguments.length) {
      domain4(_);
      return rescale();
    } else {
      return domain4();
    }
  };
  scale8.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale8.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale8.bandwidth = function() {
    return bandwidth2;
  };
  scale8.step = function() {
    return step;
  };
  scale8.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale8.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale8.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale8.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale8.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale8.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse6 = range$1[1] < range$1[0], values5 = reverse6 ? ordinalRange().reverse() : ordinalRange(), n = values5.length - 1;
    let lo = +_[0], hi = +_[1], a4, b3, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values5[0] || lo > range$1[1 - reverse6])
      return;
    a4 = Math.max(0, bisectRight(values5, lo) - 1);
    b3 = lo === hi ? a4 : bisectRight(values5, hi) - 1;
    if (lo - values5[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse6) {
      t = a4;
      a4 = n - b3;
      b3 = n - t;
    }
    return a4 > b3 ? void 0 : domain4().slice(a4, b3 + 1);
  };
  scale8.invert = function(_) {
    const value4 = scale8.invertRange([_, _]);
    return value4 ? value4[0] : value4;
  };
  scale8.copy = function() {
    return band2().domain(domain4()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish(scale8) {
  const copy6 = scale8.copy;
  scale8.padding = scale8.paddingOuter;
  delete scale8.paddingInner;
  scale8.copy = function() {
    return pointish(copy6());
  };
  return scale8;
}
function point6() {
  return pointish(band2().paddingInner(1));
}
function numbers4(_) {
  return map6.call(_, toNumber2);
}
function scaleBinOrdinal() {
  let domain4 = [], range7 = [];
  function scale8(x7) {
    return x7 == null || x7 !== x7 ? void 0 : range7[(bisect_default2(domain4, x7) - 1) % range7.length];
  }
  scale8.domain = function(_) {
    if (arguments.length) {
      domain4 = numbers4(_);
      return scale8;
    } else {
      return domain4.slice();
    }
  };
  scale8.range = function(_) {
    if (arguments.length) {
      range7 = slice4.call(_);
      return scale8;
    } else {
      return range7.slice();
    }
  };
  scale8.tickFormat = function(count5, specifier) {
    return tickFormat(domain4[0], peek2(domain4), count5 == null ? 10 : count5, specifier);
  };
  scale8.copy = function() {
    return scaleBinOrdinal().domain(scale8.domain()).range(scale8.range());
  };
  return scale8;
}
function registerScale(scale8) {
  scale8[VEGA_SCALE] = true;
  return scale8;
}
function create(type4, constructor, metadata3) {
  const ctr = function scale8() {
    const s3 = constructor();
    if (!s3.invertRange) {
      s3.invertRange = s3.invert ? invertRange(s3) : s3.invertExtent ? invertRangeExtent(s3) : void 0;
    }
    s3.type = type4;
    return registerScale(s3);
  };
  ctr.metadata = toSet2(array2(metadata3));
  return ctr;
}
function scale(type4, scale8, metadata3) {
  if (arguments.length > 1) {
    scales.set(type4, create(type4, scale8, metadata3));
    return this;
  } else {
    return isValidScaleType(type4) ? scales.get(type4) : void 0;
  }
}
function isValidScaleType(type4) {
  return scales.has(type4);
}
function hasType(key3, type4) {
  const s3 = scales.get(key3);
  return s3 && s3.metadata[type4];
}
function isDiscrete(key3) {
  return hasType(key3, Discrete);
}
function isDiscretizing(key3) {
  return hasType(key3, Discretizing);
}
function isLogarithmic(key3) {
  return hasType(key3, Log);
}
function isTemporal(key3) {
  return hasType(key3, Temporal);
}
function interpolateColors(colors3, type4, gamma3) {
  return piecewise(interpolate(type4 || "rgb", gamma3), colors3);
}
function interpolate(type4, gamma3) {
  const interp = src_exports[method(type4)];
  return gamma3 != null && interp && interp.gamma ? interp.gamma(gamma3) : interp;
}
function method(type4) {
  return "interpolate" + type4.toLowerCase().split("-").map((s3) => s3[0].toUpperCase() + s3.slice(1)).join("");
}
function colors(palette) {
  const n = palette.length / 6 | 0, c2 = new Array(n);
  for (let i = 0; i < n; ) {
    c2[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c2;
}
function apply(_, f) {
  for (const k4 in _)
    scheme(k4, f(_[k4]));
}
function scheme(name4, scheme4) {
  name4 = name4 && name4.toLowerCase();
  if (arguments.length > 1) {
    schemes[name4] = scheme4;
    return this;
  } else {
    return schemes[name4];
  }
}
function validTicks(scale8, ticks3, count5) {
  let range7 = scale8.range(), lo = range7[0], hi = peek2(range7), cmp = ascending4;
  if (lo > hi) {
    range7 = hi;
    hi = lo;
    lo = range7;
    cmp = descending2;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks3 = ticks3.map((v) => [v, scale8(v)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count5 > 0 && ticks3.length > 1) {
    const endpoints = [ticks3[0], peek2(ticks3)];
    while (ticks3.length > count5 && ticks3.length >= 3) {
      ticks3 = ticks3.filter((_, i) => !(i % 2));
    }
    if (ticks3.length < 3) {
      ticks3 = endpoints;
    }
  }
  return ticks3;
}
function tickValues(scale8, count5) {
  return scale8.bins ? validTicks(scale8, scale8.bins) : scale8.ticks ? scale8.ticks(count5) : scale8.domain();
}
function tickFormat2(locale7, scale8, count5, specifier, formatType, noSkip) {
  const type4 = scale8.type;
  let format9 = defaultFormatter;
  if (type4 === Time || formatType === Time) {
    format9 = locale7.timeFormat(specifier);
  } else if (type4 === UTC || formatType === UTC) {
    format9 = locale7.utcFormat(specifier);
  } else if (isLogarithmic(type4)) {
    const varfmt = locale7.formatFloat(specifier);
    if (noSkip || scale8.bins) {
      format9 = varfmt;
    } else {
      const test2 = tickLog(scale8, count5, false);
      format9 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale8.tickFormat) {
    const d = scale8.domain();
    format9 = locale7.formatSpan(d[0], d[d.length - 1], count5, specifier);
  } else if (specifier) {
    format9 = locale7.format(specifier);
  }
  return format9;
}
function tickLog(scale8, count5, values5) {
  const ticks3 = tickValues(scale8, count5), base3 = scale8.base(), logb = Math.log(base3), k4 = Math.max(1, base3 * count5 / ticks3.length);
  const test2 = (d) => {
    let i = d / Math.pow(base3, Math.round(Math.log(d) / logb));
    if (i * base3 < base3 - 0.5)
      i *= base3;
    return i <= k4;
  };
  return values5 ? ticks3.filter(test2) : test2;
}
function labelValues(scale8, count5) {
  return scale8.bins ? binValues(scale8.bins) : scale8.type === Log ? tickLog(scale8, count5, true) : symbols[scale8.type] ? thresholdValues(scale8[symbols[scale8.type]]()) : tickValues(scale8, count5);
}
function thresholdFormat(locale7, scale8, specifier) {
  const _ = scale8[formats2[scale8.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale7.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues(thresholds) {
  const values5 = [-Infinity].concat(thresholds);
  values5.max = Infinity;
  return values5;
}
function binValues(bins2) {
  const values5 = bins2.slice(0, -1);
  values5.max = peek2(bins2);
  return values5;
}
function labelFormat(locale7, scale8, count5, type4, specifier, formatType, noSkip) {
  const format9 = formats2[scale8.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale7, scale8, specifier) : tickFormat2(locale7, scale8, count5, specifier, formatType, noSkip);
  return type4 === SymbolLegend && isDiscreteRange(scale8) ? formatRange(format9) : type4 === DiscreteLegend ? formatDiscrete(format9) : formatPoint(format9);
}
function format4(locale7, scale8, specifier, formatType) {
  const type4 = formatType || scale8.type;
  if (isString2(specifier) && isTemporal(type4)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type4 === Time ? locale7.timeFormat("%A, %d %B %Y, %X") : !specifier && type4 === UTC ? locale7.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat(locale7, scale8, 5, null, specifier, formatType, true);
}
function domainCaption(locale7, scale8, opt) {
  opt = opt || {};
  const max8 = Math.max(3, opt.maxlen || 7), fmt = format4(locale7, scale8, opt.format, opt.formatType);
  if (isDiscretizing(scale8.type)) {
    const v = labelValues(scale8).slice(1).map(fmt), n = v.length;
    return `${n} boundar${n === 1 ? "y" : "ies"}: ${v.join(", ")}`;
  } else if (isDiscrete(scale8.type)) {
    const d = scale8.domain(), n = d.length, v = n > max8 ? d.slice(0, max8 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return `${n} value${n === 1 ? "" : "s"}: ${v}`;
  } else {
    const d = scale8.domain();
    return `values from ${fmt(d[0])} to ${fmt(peek2(d))}`;
  }
}
var Identity, Linear2, Log, Pow, Sqrt, Symlog, Time, UTC, Sequential, Diverging, Quantile2, Quantize, Threshold, Ordinal, Point, Band, BinOrdinal, Continuous, Discrete, Discretizing, Interpolating, Temporal, map6, slice4, scales, VEGA_SCALE, continuous2, discrete, schemes, SymbolLegend, DiscreteLegend, defaultFormatter, ascending4, descending2, symbols, formats2, isDiscreteRange, formatRange, get2, formatDiscrete, formatPoint, formatValue;
var init_vega_scale_module = __esm({
  "node_modules/.pnpm/vega-scale@7.3.0/node_modules/vega-scale/build/vega-scale.module.js"() {
    init_vega_util_module2();
    init_src4();
    init_src16();
    init_src16();
    init_src16();
    init_src14();
    init_vega_time_module();
    Identity = "identity";
    Linear2 = "linear";
    Log = "log";
    Pow = "pow";
    Sqrt = "sqrt";
    Symlog = "symlog";
    Time = "time";
    UTC = "utc";
    Sequential = "sequential";
    Diverging = "diverging";
    Quantile2 = "quantile";
    Quantize = "quantize";
    Threshold = "threshold";
    Ordinal = "ordinal";
    Point = "point";
    Band = "band";
    BinOrdinal = "bin-ordinal";
    Continuous = "continuous";
    Discrete = "discrete";
    Discretizing = "discretizing";
    Interpolating = "interpolating";
    Temporal = "temporal";
    map6 = Array.prototype.map;
    slice4 = Array.prototype.slice;
    scales = /* @__PURE__ */ new Map();
    VEGA_SCALE = Symbol("vega_scale");
    scale(Identity, identity6);
    scale(Linear2, linear3, Continuous);
    scale(Log, log3, [Continuous, Log]);
    scale(Pow, pow3, Continuous);
    scale(Sqrt, sqrt2, Continuous);
    scale(Symlog, symlog2, Continuous);
    scale(Time, time, [Continuous, Temporal]);
    scale(UTC, utcTime, [Continuous, Temporal]);
    scale(Sequential, sequential, [Continuous, Interpolating]);
    scale(`${Sequential}-${Linear2}`, sequential, [Continuous, Interpolating]);
    scale(`${Sequential}-${Log}`, sequentialLog, [Continuous, Interpolating, Log]);
    scale(`${Sequential}-${Pow}`, sequentialPow, [Continuous, Interpolating]);
    scale(`${Sequential}-${Sqrt}`, sequentialSqrt, [Continuous, Interpolating]);
    scale(`${Sequential}-${Symlog}`, sequentialSymlog, [Continuous, Interpolating]);
    scale(`${Diverging}-${Linear2}`, diverging, [Continuous, Interpolating]);
    scale(`${Diverging}-${Log}`, divergingLog, [Continuous, Interpolating, Log]);
    scale(`${Diverging}-${Pow}`, divergingPow, [Continuous, Interpolating]);
    scale(`${Diverging}-${Sqrt}`, divergingSqrt, [Continuous, Interpolating]);
    scale(`${Diverging}-${Symlog}`, divergingSymlog, [Continuous, Interpolating]);
    scale(Quantile2, quantile3, [Discretizing, Quantile2]);
    scale(Quantize, quantize, Discretizing);
    scale(Threshold, threshold, Discretizing);
    scale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);
    scale(Ordinal, ordinal, Discrete);
    scale(Band, band2, Discrete);
    scale(Point, point6, Discrete);
    continuous2 = {
      blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
      greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
      greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
      oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
      purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
      reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
      blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
      bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
      greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
      orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
      purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
      purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
      purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
      redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
      yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
      yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
      yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
      blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
      brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
      purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
      purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
      redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
      redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
      yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
      redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
      redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
      pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
      spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
      viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
      magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
      inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
      plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
      cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
      rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
      sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
      turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
      browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
      tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
      teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
      warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
      goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
      goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
      goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
      lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
      lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
      lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
      lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
      lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
      darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
      darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
      darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
      darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
      darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
    };
    discrete = {
      category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
      category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
      category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
      category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
      tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
      tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
      accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
      dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
      paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
      pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
      pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
      set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
      set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
      set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
    };
    schemes = {};
    apply(discrete, colors);
    apply(continuous2, (_) => interpolateColors(colors(_)));
    SymbolLegend = "symbol";
    DiscreteLegend = "discrete";
    defaultFormatter = (value4) => isArray2(value4) ? value4.map((v) => String(v)) : String(value4);
    ascending4 = (a4, b3) => a4[1] - b3[1];
    descending2 = (a4, b3) => b3[1] - a4[1];
    symbols = {
      [Quantile2]: "quantiles",
      [Quantize]: "thresholds",
      [Threshold]: "domain"
    };
    formats2 = {
      [Quantile2]: "quantiles",
      [Quantize]: "domain"
    };
    isDiscreteRange = (scale8) => symbols[scale8.type] || scale8.bins;
    formatRange = (format9) => (value4, index8, array9) => {
      const limit = get2(array9[index8 + 1], get2(array9.max, Infinity)), lo = formatValue(value4, format9), hi = formatValue(limit, format9);
      return lo && hi ? lo + "  " + hi : hi ? "< " + hi : " " + lo;
    };
    get2 = (value4, dflt) => value4 != null ? value4 : dflt;
    formatDiscrete = (format9) => (value4, index8) => index8 ? format9(value4) : null;
    formatPoint = (format9) => (value4) => format9(value4);
    formatValue = (value4, format9) => Number.isFinite(value4) ? format9(value4) : null;
  }
});

// node_modules/.pnpm/vega-scenegraph@4.10.2/node_modules/vega-scenegraph/build/vega-scenegraph.module.js
function isGradient(value4) {
  return value4 && value4.gradient;
}
function gradientRef(g, defs, base3) {
  const type4 = g.gradient;
  let id4 = g.id, prefix = type4 === "radial" ? patternPrefix : "";
  if (!id4) {
    id4 = g.id = "gradient_" + gradient_id++;
    if (type4 === "radial") {
      g.x1 = get3(g.x1, 0.5);
      g.y1 = get3(g.y1, 0.5);
      g.r1 = get3(g.r1, 0);
      g.x2 = get3(g.x2, 0.5);
      g.y2 = get3(g.y2, 0.5);
      g.r2 = get3(g.r2, 0.5);
      prefix = patternPrefix;
    } else {
      g.x1 = get3(g.x1, 0);
      g.y1 = get3(g.y1, 0);
      g.x2 = get3(g.x2, 1);
      g.y2 = get3(g.y2, 0);
    }
  }
  defs[id4] = g;
  return "url(" + (base3 || "") + "#" + prefix + id4 + ")";
}
function get3(val, def3) {
  return val != null ? val : def3;
}
function curves(type4, orientation, tension) {
  var entry2 = has2(lookup, type4) && lookup[type4], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
function parse4(path5) {
  const commands = [];
  const matches = path5.match(commandPattern) || [];
  matches.forEach((str) => {
    let cmd = str[0];
    const type4 = cmd.toLowerCase();
    const paramCount = paramCounts[type4];
    const params2 = parseParams(type4, paramCount, str.slice(1).trim());
    const count5 = params2.length;
    if (count5 < paramCount || count5 && count5 % paramCount !== 0) {
      throw Error("Invalid SVG path, incorrect parameter count");
    }
    commands.push([cmd, ...params2.slice(0, paramCount)]);
    if (count5 === paramCount) {
      return;
    }
    if (type4 === "m") {
      cmd = cmd === "M" ? "L" : "l";
    }
    for (let i = paramCount; i < count5; i += paramCount) {
      commands.push([cmd, ...params2.slice(i, i + paramCount)]);
    }
  });
  return commands;
}
function parseParams(type4, paramCount, segment) {
  const params2 = [];
  for (let index8 = 0; paramCount && index8 < segment.length; ) {
    for (let i = 0; i < paramCount; ++i) {
      const pattern = type4 === "a" && (i === 3 || i === 4) ? flagPattern : numberPattern;
      const match4 = segment.slice(index8).match(pattern);
      if (match4 === null) {
        throw Error("Invalid SVG path, incorrect parameter type");
      }
      index8 += match4[0].length;
      params2.push(+match4[0]);
      const ws = segment.slice(index8).match(spacePattern);
      if (ws !== null) {
        index8 += ws[0].length;
      }
    }
  }
  return params2;
}
function segments(x7, y7, rx, ry, large, sweep, rotateX, ox, oy) {
  const key3 = join.call(arguments);
  if (segmentCache[key3]) {
    return segmentCache[key3];
  }
  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px3 = cos_th * (ox - x7) * 0.5 + sin_th * (oy - y7) * 0.5;
  const py3 = cos_th * (oy - y7) * 0.5 - sin_th * (ox - x7) * 0.5;
  let pl = px3 * px3 / (rx * rx) + py3 * py3 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x07 = a00 * ox + a01 * oy;
  const y07 = a10 * ox + a11 * oy;
  const x13 = a00 * x7 + a01 * y7;
  const y13 = a10 * x7 + a11 * y7;
  const d = (x13 - x07) * (x13 - x07) + (y13 - y07) * (y13 - y07);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0)
    sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large)
    sfactor = -sfactor;
  const xc = 0.5 * (x07 + x13) - sfactor * (y13 - y07);
  const yc = 0.5 * (y07 + y13) + sfactor * (x13 - x07);
  const th0 = Math.atan2(y07 - yc, x07 - xc);
  const th1 = Math.atan2(y13 - yc, x13 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache[key3] = result;
}
function bezier(params2) {
  const key3 = join.call(params2);
  if (bezierCache[key3]) {
    return bezierCache[key3];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x13 = cx + cos_th0 - t * sin_th0;
  const y13 = cy + sin_th0 + t * cos_th0;
  const x32 = cx + cos_th1;
  const y32 = cy + sin_th1;
  const x22 = x32 + t * sin_th1;
  const y22 = y32 - t * cos_th1;
  return bezierCache[key3] = [a00 * x13 + a01 * y13, a10 * x13 + a11 * y13, a00 * x22 + a01 * y22, a10 * x22 + a11 * y22, a00 * x32 + a01 * y32, a10 * x32 + a11 * y32];
}
function scale$1(current2, sX, sY) {
  const c2 = temp[0] = current2[0];
  if (c2 === "a" || c2 === "A") {
    temp[1] = sX * current2[1];
    temp[2] = sY * current2[2];
    temp[3] = current2[3];
    temp[4] = current2[4];
    temp[5] = current2[5];
    temp[6] = sX * current2[6];
    temp[7] = sY * current2[7];
  } else if (c2 === "h" || c2 === "H") {
    temp[1] = sX * current2[1];
  } else if (c2 === "v" || c2 === "V") {
    temp[1] = sY * current2[1];
  } else {
    for (var i = 1, n = current2.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current2[i];
    }
  }
  return temp;
}
function pathRender(context4, path5, l, t, sX, sY) {
  var current2, previous = null, x7 = 0, y7 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY, anchorX = 0, anchorY = 0;
  if (l == null)
    l = 0;
  if (t == null)
    t = 0;
  if (sX == null)
    sX = 1;
  if (sY == null)
    sY = sX;
  if (context4.beginPath)
    context4.beginPath();
  for (var i = 0, len = path5.length; i < len; ++i) {
    current2 = path5[i];
    if (sX !== 1 || sY !== 1) {
      current2 = scale$1(current2, sX, sY);
    }
    switch (current2[0]) {
      case "l":
        x7 += current2[1];
        y7 += current2[2];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "L":
        x7 = current2[1];
        y7 = current2[2];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "h":
        x7 += current2[1];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "H":
        x7 = current2[1];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "v":
        y7 += current2[1];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "V":
        y7 = current2[1];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "m":
        x7 += current2[1];
        y7 += current2[2];
        anchorX = x7;
        anchorY = y7;
        context4.moveTo(x7 + l, y7 + t);
        break;
      case "M":
        x7 = current2[1];
        y7 = current2[2];
        anchorX = x7;
        anchorY = y7;
        context4.moveTo(x7 + l, y7 + t);
        break;
      case "c":
        tempX = x7 + current2[5];
        tempY = y7 + current2[6];
        controlX = x7 + current2[3];
        controlY = y7 + current2[4];
        context4.bezierCurveTo(
          x7 + current2[1] + l,
          y7 + current2[2] + t,
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x7 = tempX;
        y7 = tempY;
        break;
      case "C":
        x7 = current2[5];
        y7 = current2[6];
        controlX = current2[3];
        controlY = current2[4];
        context4.bezierCurveTo(current2[1] + l, current2[2] + t, controlX + l, controlY + t, x7 + l, y7 + t);
        break;
      case "s":
        tempX = x7 + current2[3];
        tempY = y7 + current2[4];
        controlX = 2 * x7 - controlX;
        controlY = 2 * y7 - controlY;
        context4.bezierCurveTo(controlX + l, controlY + t, x7 + current2[1] + l, y7 + current2[2] + t, tempX + l, tempY + t);
        controlX = x7 + current2[1];
        controlY = y7 + current2[2];
        x7 = tempX;
        y7 = tempY;
        break;
      case "S":
        tempX = current2[3];
        tempY = current2[4];
        controlX = 2 * x7 - controlX;
        controlY = 2 * y7 - controlY;
        context4.bezierCurveTo(controlX + l, controlY + t, current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x7 = tempX;
        y7 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "q":
        tempX = x7 + current2[3];
        tempY = y7 + current2[4];
        controlX = x7 + current2[1];
        controlY = y7 + current2[2];
        context4.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x7 = tempX;
        y7 = tempY;
        break;
      case "Q":
        tempX = current2[3];
        tempY = current2[4];
        context4.quadraticCurveTo(current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x7 = tempX;
        y7 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "t":
        tempX = x7 + current2[1];
        tempY = y7 + current2[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x7;
          controlY = y7;
        } else if (previous[0] === "t") {
          controlX = 2 * x7 - tempControlX;
          controlY = 2 * y7 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x7 - controlX;
          controlY = 2 * y7 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context4.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x7 = tempX;
        y7 = tempY;
        controlX = x7 + current2[1];
        controlY = y7 + current2[2];
        break;
      case "T":
        tempX = current2[1];
        tempY = current2[2];
        controlX = 2 * x7 - controlX;
        controlY = 2 * y7 - controlY;
        context4.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x7 = tempX;
        y7 = tempY;
        break;
      case "a":
        drawArc(context4, x7 + l, y7 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x7 + l, current2[7] + y7 + t]);
        x7 += current2[6];
        y7 += current2[7];
        break;
      case "A":
        drawArc(context4, x7 + l, y7 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t]);
        x7 = current2[6];
        y7 = current2[7];
        break;
      case "z":
      case "Z":
        x7 = anchorX;
        y7 = anchorY;
        context4.closePath();
        break;
    }
    previous = current2;
  }
}
function drawArc(context4, x7, y7, coords) {
  const seg = segments(
    coords[5],
    coords[6],
    coords[0],
    coords[1],
    coords[3],
    coords[4],
    coords[2],
    x7,
    y7
  );
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context4.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
function symbols2(_) {
  return has2(builtins, _) ? builtins[_] : customSymbol(_);
}
function customSymbol(path5) {
  if (!has2(custom8, path5)) {
    const parsed = parse4(path5);
    custom8[path5] = {
      draw: function(context4, size) {
        pathRender(context4, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom8[path5];
}
function rectangleX(d) {
  return d.x;
}
function rectangleY(d) {
  return d.y;
}
function rectangleWidth(d) {
  return d.width;
}
function rectangleHeight(d) {
  return d.height;
}
function number4(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp(value4, min8, max8) {
  return Math.max(min8, Math.min(value4, max8));
}
function vg_rect() {
  var x7 = rectangleX, y7 = rectangleY, width2 = rectangleWidth, height2 = rectangleHeight, crTL = number4(0), crTR = crTL, crBL = crTL, crBR = crTL, context4 = null;
  function rectangle3(_, x07, y07) {
    var buffer, x13 = x07 != null ? x07 : +x7.call(this, _), y13 = y07 != null ? y07 : +y7.call(this, _), w5 = +width2.call(this, _), h4 = +height2.call(this, _), s3 = Math.min(w5, h4) / 2, tl3 = clamp(+crTL.call(this, _), 0, s3), tr3 = clamp(+crTR.call(this, _), 0, s3), bl3 = clamp(+crBL.call(this, _), 0, s3), br3 = clamp(+crBR.call(this, _), 0, s3);
    if (!context4)
      context4 = buffer = path();
    if (tl3 <= 0 && tr3 <= 0 && bl3 <= 0 && br3 <= 0) {
      context4.rect(x13, y13, w5, h4);
    } else {
      var x22 = x13 + w5, y22 = y13 + h4;
      context4.moveTo(x13 + tl3, y13);
      context4.lineTo(x22 - tr3, y13);
      context4.bezierCurveTo(x22 - C2 * tr3, y13, x22, y13 + C2 * tr3, x22, y13 + tr3);
      context4.lineTo(x22, y22 - br3);
      context4.bezierCurveTo(x22, y22 - C2 * br3, x22 - C2 * br3, y22, x22 - br3, y22);
      context4.lineTo(x13 + bl3, y22);
      context4.bezierCurveTo(x13 + C2 * bl3, y22, x13, y22 - C2 * bl3, x13, y22 - bl3);
      context4.lineTo(x13, y13 + tl3);
      context4.bezierCurveTo(x13, y13 + C2 * tl3, x13 + C2 * tl3, y13, x13 + tl3, y13);
      context4.closePath();
    }
    if (buffer) {
      context4 = null;
      return buffer + "" || null;
    }
  }
  rectangle3.x = function(_) {
    if (arguments.length) {
      x7 = number4(_);
      return rectangle3;
    } else {
      return x7;
    }
  };
  rectangle3.y = function(_) {
    if (arguments.length) {
      y7 = number4(_);
      return rectangle3;
    } else {
      return y7;
    }
  };
  rectangle3.width = function(_) {
    if (arguments.length) {
      width2 = number4(_);
      return rectangle3;
    } else {
      return width2;
    }
  };
  rectangle3.height = function(_) {
    if (arguments.length) {
      height2 = number4(_);
      return rectangle3;
    } else {
      return height2;
    }
  };
  rectangle3.cornerRadius = function(tl3, tr3, br3, bl3) {
    if (arguments.length) {
      crTL = number4(tl3);
      crTR = tr3 != null ? number4(tr3) : crTL;
      crBR = br3 != null ? number4(br3) : crTL;
      crBL = bl3 != null ? number4(bl3) : crTR;
      return rectangle3;
    } else {
      return crTL;
    }
  };
  rectangle3.context = function(_) {
    if (arguments.length) {
      context4 = _ == null ? null : _;
      return rectangle3;
    } else {
      return context4;
    }
  };
  return rectangle3;
}
function vg_trail() {
  var x7, y7, size, defined2, context4 = null, ready, x13, y13, r1;
  function point16(x22, y22, w22) {
    const r2 = w22 / 2;
    if (ready) {
      var ux = y13 - y22, uy = x22 - x13;
      if (ux || uy) {
        var ud = Math.sqrt(ux * ux + uy * uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t = Math.atan2(uy, ux);
        context4.moveTo(x13 - rx, y13 - ry);
        context4.lineTo(x22 - ux * r2, y22 - uy * r2);
        context4.arc(x22, y22, r2, t - Math.PI, t);
        context4.lineTo(x13 + rx, y13 + ry);
        context4.arc(x13, y13, r1, t, t + Math.PI);
      } else {
        context4.arc(x22, y22, r2, 0, Tau);
      }
      context4.closePath();
    } else {
      ready = 1;
    }
    x13 = x22;
    y13 = y22;
    r1 = r2;
  }
  function trail4(data3) {
    var i, n = data3.length, d, defined0 = false, buffer;
    if (context4 == null)
      context4 = buffer = path();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          ready = 0;
      }
      if (defined0)
        point16(+x7(d, i, data3), +y7(d, i, data3), +size(d, i, data3));
    }
    if (buffer) {
      context4 = null;
      return buffer + "" || null;
    }
  }
  trail4.x = function(_) {
    if (arguments.length) {
      x7 = _;
      return trail4;
    } else {
      return x7;
    }
  };
  trail4.y = function(_) {
    if (arguments.length) {
      y7 = _;
      return trail4;
    } else {
      return y7;
    }
  };
  trail4.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail4;
    } else {
      return size;
    }
  };
  trail4.defined = function(_) {
    if (arguments.length) {
      defined2 = _;
      return trail4;
    } else {
      return defined2;
    }
  };
  trail4.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context4 = null;
      } else {
        context4 = _;
      }
      return trail4;
    } else {
      return context4;
    }
  };
  return trail4;
}
function value$1(a4, b3) {
  return a4 != null ? a4 : b3;
}
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$1(context4, item) {
  return arcShape.context(context4)(item);
}
function area$1(context4, items2) {
  const item = items2[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context4)(items2);
}
function line$1(context4, items2) {
  const item = items2[0], interp = item.interpolate || "linear";
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context4)(items2);
}
function rectangle(context4, item, x7, y7) {
  return rectShape.context(context4)(item, x7, y7);
}
function shape$1(context4, item) {
  return (item.mark.shape || item.shape).context(context4)(item);
}
function symbol$1(context4, item) {
  return symbolShape.context(context4)(item);
}
function trail$1(context4, items2) {
  return trailShape.context(context4)(items2);
}
function clip$1(renderer, item, size) {
  var clip4 = item.clip, defs = renderer._defs, id4 = item.clip_id || (item.clip_id = "clip" + clip_id++), c2 = defs.clipping[id4] || (defs.clipping[id4] = {
    id: id4
  });
  if (isFunction2(clip4)) {
    c2.path = clip4(null);
  } else if (hasCornerRadius(size)) {
    c2.path = rectangle(null, size, 0, 0);
  } else {
    c2.width = size.width || 0;
    c2.height = size.height || 0;
  }
  return "url(#" + id4 + ")";
}
function Bounds(b3) {
  this.clear();
  if (b3)
    this.union(b3);
}
function Item(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds();
}
function GroupItem(mark) {
  Item.call(this, mark);
  this.items = this.items || [];
}
function ResourceLoader(customLoader) {
  this._pending = 0;
  this._loader = customLoader || loader();
}
function increment(loader3) {
  loader3._pending += 1;
}
function decrement(loader3) {
  loader3._pending -= 1;
}
function boundStroke(bounds3, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds3.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }
  return bounds3;
}
function miterAdjustment(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
function boundContext(_, deg) {
  bounds = _;
  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }
  return context$1;
}
function quadExtrema(x07, x13, x22, cb) {
  const t = (x07 - x13) / (x07 + x22 - 2 * x13);
  if (0 < t && t < 1)
    cb(x07 + (x13 - x07) * t);
}
function cubicExtrema(x07, x13, x22, x32, cb) {
  const a4 = x32 - x07 + 3 * x13 - 3 * x22, b3 = x07 + x22 - 2 * x13, c2 = x07 - x13;
  let t07 = 0, t15 = 0, r2;
  if (Math.abs(a4) > Epsilon) {
    r2 = b3 * b3 + c2 * a4;
    if (r2 >= 0) {
      r2 = Math.sqrt(r2);
      t07 = (-b3 + r2) / a4;
      t15 = (-b3 - r2) / a4;
    }
  } else {
    t07 = 0.5 * c2 / b3;
  }
  if (0 < t07 && t07 < 1)
    cb(cubic(t07, x07, x13, x22, x32));
  if (0 < t15 && t15 < 1)
    cb(cubic(t15, x07, x13, x22, x32));
}
function cubic(t, x07, x13, x22, x32) {
  const s3 = 1 - t, s22 = s3 * s3, t23 = t * t;
  return s22 * s3 * x07 + 3 * s22 * t * x13 + 3 * s3 * t23 * x22 + t23 * t * x32;
}
function intersectPath(draw4) {
  return function(item, brush) {
    if (!context)
      return true;
    draw4(context, item);
    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = b;
    for (let y7 = y13; y7 <= y22; ++y7) {
      for (let x7 = x13; x7 <= x22; ++x7) {
        if (context.isPointInPath(x7, y7)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x7 = item.x || 0, y7 = item.y || 0, w5 = item.width || 0, h4 = item.height || 0;
  return box.intersects(b.set(x7, y7, x7 + w5, y7 + h4));
}
function intersectRule(item, box) {
  const x7 = item.x || 0, y7 = item.y || 0, x22 = item.x2 != null ? item.x2 : x7, y22 = item.y2 != null ? item.y2 : y7;
  return intersectBoxLine(box, x7, y7, x22, y22);
}
function intersectBoxLine(box, x7, y7, u, v) {
  const {
    x1: x13,
    y1: y13,
    x2: x22,
    y2: y22
  } = box, dx = u - x7, dy = v - y7;
  let t07 = 0, t15 = 1, p, q, r2, e3;
  for (e3 = 0; e3 < 4; ++e3) {
    if (e3 === 0) {
      p = -dx;
      q = -(x13 - x7);
    }
    if (e3 === 1) {
      p = dx;
      q = x22 - x7;
    }
    if (e3 === 2) {
      p = -dy;
      q = -(y13 - y7);
    }
    if (e3 === 3) {
      p = dy;
      q = y22 - y7;
    }
    if (Math.abs(p) < 1e-10 && q < 0)
      return false;
    r2 = q / p;
    if (p < 0) {
      if (r2 > t15)
        return false;
      else if (r2 > t07)
        t07 = r2;
    } else if (p > 0) {
      if (r2 < t07)
        return false;
      else if (r2 < t15)
        t15 = r2;
    }
  }
  return true;
}
function blend(context4, item) {
  context4.globalCompositeOperation = item.blend || "source-over";
}
function value(value4, dflt) {
  return value4 == null ? dflt : value4;
}
function addStops(gradient5, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient5.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient5;
}
function gradient(context4, spec, bounds3) {
  const w5 = bounds3.width(), h4 = bounds3.height();
  let gradient5;
  if (spec.gradient === "radial") {
    gradient5 = context4.createRadialGradient(bounds3.x1 + value(spec.x1, 0.5) * w5, bounds3.y1 + value(spec.y1, 0.5) * h4, Math.max(w5, h4) * value(spec.r1, 0), bounds3.x1 + value(spec.x2, 0.5) * w5, bounds3.y1 + value(spec.y2, 0.5) * h4, Math.max(w5, h4) * value(spec.r2, 0.5));
  } else {
    const x13 = value(spec.x1, 0), y13 = value(spec.y1, 0), x22 = value(spec.x2, 1), y22 = value(spec.y2, 0);
    if (x13 === x22 || y13 === y22 || w5 === h4) {
      gradient5 = context4.createLinearGradient(bounds3.x1 + x13 * w5, bounds3.y1 + y13 * h4, bounds3.x1 + x22 * w5, bounds3.y1 + y22 * h4);
    } else {
      const image4 = domCanvas(Math.ceil(w5), Math.ceil(h4)), ictx = image4.getContext("2d");
      ictx.scale(w5, h4);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x13, y13, x22, y22), spec.stops);
      ictx.fillRect(0, 0, w5, h4);
      return context4.createPattern(image4, "no-repeat");
    }
  }
  return addStops(gradient5, spec.stops);
}
function color2(context4, item, value4) {
  return isGradient(value4) ? gradient(context4, value4, item.bounds) : value4;
}
function fill(context4, item, opacity2) {
  opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity2 > 0) {
    context4.globalAlpha = opacity2;
    context4.fillStyle = color2(context4, item, item.fill);
    return true;
  } else {
    return false;
  }
}
function stroke(context4, item, opacity2) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0)
    return false;
  opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity2 > 0) {
    context4.globalAlpha = opacity2;
    context4.strokeStyle = color2(context4, item, item.stroke);
    context4.lineWidth = lw;
    context4.lineCap = item.strokeCap || "butt";
    context4.lineJoin = item.strokeJoin || "miter";
    context4.miterLimit = item.strokeMiterLimit || 10;
    if (context4.setLineDash) {
      context4.setLineDash(item.strokeDash || Empty2);
      context4.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare4(a4, b3) {
  return a4.zindex - b3.zindex || a4.index - b3.index;
}
function zorder(scene) {
  if (!scene.zdirty)
    return scene.zitems;
  var items2 = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items2.length; i < n; ++i) {
    item = items2[i];
    item.index = i;
    if (item.zindex)
      output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare4);
}
function visit(scene, visitor) {
  var items2 = scene.items, i, n;
  if (!items2 || !items2.length)
    return;
  const zitems = zorder(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items2.length; i < n; ++i) {
      if (!items2[i].zindex)
        visitor(items2[i]);
    }
    items2 = zitems;
  }
  for (i = 0, n = items2.length; i < n; ++i) {
    visitor(items2[i]);
  }
}
function pickVisit(scene, visitor) {
  var items2 = scene.items, hit3, i;
  if (!items2 || !items2.length)
    return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length)
    items2 = zitems;
  for (i = items2.length; --i >= 0; ) {
    if (hit3 = visitor(items2[i]))
      return hit3;
  }
  if (items2 === zitems) {
    for (items2 = scene.items, i = items2.length; --i >= 0; ) {
      if (!items2[i].zindex) {
        if (hit3 = visitor(items2[i]))
          return hit3;
      }
    }
  }
  return null;
}
function drawAll(path5) {
  return function(context4, scene, bounds3) {
    visit(scene, (item) => {
      if (!bounds3 || bounds3.intersects(item.bounds)) {
        drawPath(path5, context4, item, item);
      }
    });
  };
}
function drawOne(path5) {
  return function(context4, scene, bounds3) {
    if (scene.items.length && (!bounds3 || bounds3.intersects(scene.bounds))) {
      drawPath(path5, context4, scene.items[0], scene.items);
    }
  };
}
function drawPath(path5, context4, item, items2) {
  var opacity2 = item.opacity == null ? 1 : item.opacity;
  if (opacity2 === 0)
    return;
  if (path5(context4, items2))
    return;
  blend(context4, item);
  if (item.fill && fill(context4, item, opacity2)) {
    context4.fill();
  }
  if (item.stroke && stroke(context4, item, opacity2)) {
    context4.stroke();
  }
}
function pick$1(test2) {
  test2 = test2 || truthy2;
  return function(context4, scene, x7, y7, gx, gy) {
    x7 *= context4.pixelRatio;
    y7 *= context4.pixelRatio;
    return pickVisit(scene, (item) => {
      const b3 = item.bounds;
      if (b3 && !b3.contains(gx, gy) || !b3)
        return;
      if (test2(context4, item, x7, y7, gx, gy))
        return item;
    });
  };
}
function hitPath(path5, filled2) {
  return function(context4, o, x7, y7) {
    var item = Array.isArray(o) ? o[0] : o, fill3 = filled2 == null ? item.fill : filled2, stroke3 = item.stroke && context4.isPointInStroke, lw, lc;
    if (stroke3) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context4.lineWidth = lw != null ? lw : 1;
      context4.lineCap = lc != null ? lc : "butt";
    }
    return path5(context4, o) ? false : fill3 && context4.isPointInPath(x7, y7) || stroke3 && context4.isPointInStroke(x7, y7);
  };
}
function pickPath(path5) {
  return pick$1(hitPath(path5));
}
function translate(x7, y7) {
  return "translate(" + x7 + "," + y7 + ")";
}
function rotate(a4) {
  return "rotate(" + a4 + ")";
}
function scale2(scaleX, scaleY2) {
  return "scale(" + scaleX + "," + scaleY2 + ")";
}
function translateItem(item) {
  return translate(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "");
}
function transformItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale2(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath(type4, shape3, isect) {
  function attr3(emit3, item) {
    emit3("transform", rotateItem(item));
    emit3("d", shape3(null, item));
  }
  function bound3(bounds3, item) {
    shape3(boundContext(bounds3, item.angle), item);
    return boundStroke(bounds3, item).translate(item.x || 0, item.y || 0);
  }
  function draw4(context4, item) {
    var x7 = item.x || 0, y7 = item.y || 0, a4 = item.angle || 0;
    context4.translate(x7, y7);
    if (a4)
      context4.rotate(a4 *= DegToRad);
    context4.beginPath();
    shape3(context4, item);
    if (a4)
      context4.rotate(-a4);
    context4.translate(-x7, -y7);
  }
  return {
    type: type4,
    tag: "path",
    nested: false,
    attr: attr3,
    bound: bound3,
    draw: drawAll(draw4),
    pick: pickPath(draw4),
    isect: isect || intersectPath(draw4)
  };
}
function pickArea(a4, p) {
  var v = a4[0].orient === "horizontal" ? p[1] : p[0], z = a4[0].orient === "horizontal" ? "y" : "x", i = a4.length, min8 = Infinity, hit3, d;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    d = Math.abs(a4[i][z] - v);
    if (d < min8) {
      min8 = d;
      hit3 = a4[i];
    }
  }
  return hit3;
}
function pickLine(a4, p) {
  var t = Math.pow(a4[0].strokeWidth || 1, 2), i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t)
      return a4[i];
  }
  return null;
}
function pickTrail(a4, p) {
  var i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a4[i].size || 1;
    if (dd < dx * dx)
      return a4[i];
  }
  return null;
}
function markMultiItemPath(type4, shape3, tip) {
  function attr3(emit3, item) {
    var items2 = item.mark.items;
    if (items2.length)
      emit3("d", shape3(null, items2));
  }
  function bound3(bounds3, mark) {
    var items2 = mark.items;
    if (items2.length === 0) {
      return bounds3;
    } else {
      shape3(boundContext(bounds3), items2);
      return boundStroke(bounds3, items2[0]);
    }
  }
  function draw4(context4, items2) {
    context4.beginPath();
    shape3(context4, items2);
  }
  const hit3 = hitPath(draw4);
  function pick4(context4, scene, x7, y7, gx, gy) {
    var items2 = scene.items, b3 = scene.bounds;
    if (!items2 || !items2.length || b3 && !b3.contains(gx, gy)) {
      return null;
    }
    x7 *= context4.pixelRatio;
    y7 *= context4.pixelRatio;
    return hit3(context4, items2, x7, y7) ? items2[0] : null;
  }
  return {
    type: type4,
    tag: "path",
    nested: true,
    attr: attr3,
    bound: bound3,
    draw: drawOne(draw4),
    pick: pick4,
    isect: intersectPoint,
    tip
  };
}
function clip(context4, scene) {
  var clip4 = scene.clip;
  context4.save();
  if (isFunction2(clip4)) {
    context4.beginPath();
    clip4(context4);
    context4.clip();
  } else {
    clipGroup(context4, scene.group);
  }
}
function clipGroup(context4, group6) {
  context4.beginPath();
  hasCornerRadius(group6) ? rectangle(context4, group6, 0, 0) : context4.rect(0, 0, group6.width || 0, group6.height || 0);
  context4.clip();
}
function offset$1(item) {
  const sw = value(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$5(emit3, item) {
  emit3("transform", translateItem(item));
}
function emitRectangle(emit3, item) {
  const off = offset$1(item);
  emit3("d", rectangle(null, item, off, off));
}
function background(emit3, item) {
  emit3("class", "background");
  emit3("aria-hidden", true);
  emitRectangle(emit3, item);
}
function foreground(emit3, item) {
  emit3("class", "foreground");
  emit3("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle(emit3, item);
  } else {
    emit3("d", "");
  }
}
function content(emit3, item, renderer) {
  const url = item.clip ? clip$1(renderer, item, item) : null;
  emit3("clip-path", url);
}
function bound$5(bounds3, group6) {
  if (!group6.clip && group6.items) {
    const items2 = group6.items, m2 = items2.length;
    for (let j = 0; j < m2; ++j) {
      bounds3.union(items2[j].bounds);
    }
  }
  if ((group6.clip || group6.width || group6.height) && !group6.noBound) {
    bounds3.add(0, 0).add(group6.width || 0, group6.height || 0);
  }
  boundStroke(bounds3, group6);
  return bounds3.translate(group6.x || 0, group6.y || 0);
}
function rectanglePath(context4, group6, x7, y7) {
  const off = offset$1(group6);
  context4.beginPath();
  rectangle(context4, group6, (x7 || 0) + off, (y7 || 0) + off);
}
function draw$4(context4, scene, bounds3) {
  visit(scene, (group6) => {
    const gx = group6.x || 0, gy = group6.y || 0, fore = group6.strokeForeground, opacity2 = group6.opacity == null ? 1 : group6.opacity;
    if ((group6.stroke || group6.fill) && opacity2) {
      rectanglePath(context4, group6, gx, gy);
      blend(context4, group6);
      if (group6.fill && fill(context4, group6, opacity2)) {
        context4.fill();
      }
      if (group6.stroke && !fore && stroke(context4, group6, opacity2)) {
        context4.stroke();
      }
    }
    context4.save();
    context4.translate(gx, gy);
    if (group6.clip)
      clipGroup(context4, group6);
    if (bounds3)
      bounds3.translate(-gx, -gy);
    visit(group6, (item) => {
      this.draw(context4, item, bounds3);
    });
    if (bounds3)
      bounds3.translate(gx, gy);
    context4.restore();
    if (fore && group6.stroke && opacity2) {
      rectanglePath(context4, group6, gx, gy);
      blend(context4, group6);
      if (stroke(context4, group6, opacity2)) {
        context4.stroke();
      }
    }
  });
}
function pick(context4, scene, x7, y7, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x7 * context4.pixelRatio, cy = y7 * context4.pixelRatio;
  return pickVisit(scene, (group6) => {
    let hit3, dx, dy;
    const b3 = group6.bounds;
    if (b3 && !b3.contains(gx, gy))
      return;
    dx = group6.x || 0;
    dy = group6.y || 0;
    const dw = dx + (group6.width || 0), dh = dy + (group6.height || 0), c2 = group6.clip;
    if (c2 && (gx < dx || gx > dw || gy < dy || gy > dh))
      return;
    context4.save();
    context4.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c2 && hasCornerRadius(group6) && !hitCorner(context4, group6, cx, cy)) {
      context4.restore();
      return null;
    }
    const fore = group6.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group6.stroke && hitForeground(context4, group6, cx, cy)) {
      context4.restore();
      return group6;
    }
    hit3 = pickVisit(group6, (mark) => pickMark(mark, dx, dy) ? this.pick(mark, x7, y7, dx, dy) : null);
    if (!hit3 && ix && (group6.fill || !fore && group6.stroke) && hitBackground(context4, group6, cx, cy)) {
      hit3 = group6;
    }
    context4.restore();
    return hit3 || null;
  });
}
function pickMark(mark, x7, y7) {
  return (mark.interactive !== false || mark.marktype === "group") && mark.bounds && mark.bounds.contains(x7, y7);
}
function getImage(item, renderer) {
  var image4 = item.image;
  if (!image4 || item.url && item.url !== image4.url) {
    image4 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image5) => {
      item.image = image5;
      item.image.url = item.url;
    });
  }
  return image4;
}
function imageWidth(item, image4) {
  return item.width != null ? item.width : !image4 || !image4.width ? 0 : item.aspect !== false && item.height ? item.height * image4.width / image4.height : image4.width;
}
function imageHeight(item, image4) {
  return item.height != null ? item.height : !image4 || !image4.height ? 0 : item.aspect !== false && item.width ? item.width * image4.height / image4.width : image4.height;
}
function imageXOffset(align2, w5) {
  return align2 === "center" ? w5 / 2 : align2 === "right" ? w5 : 0;
}
function imageYOffset(baseline3, h4) {
  return baseline3 === "middle" ? h4 / 2 : baseline3 === "bottom" ? h4 : 0;
}
function attr$4(emit3, item, renderer) {
  const img = getImage(item, renderer), w5 = imageWidth(item, img), h4 = imageHeight(item, img), x7 = (item.x || 0) - imageXOffset(item.align, w5), y7 = (item.y || 0) - imageYOffset(item.baseline, h4), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit3("href", i, metadata["xmlns:xlink"], "xlink:href");
  emit3("transform", translate(x7, y7));
  emit3("width", w5);
  emit3("height", h4);
  emit3("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$4(bounds3, item) {
  const img = item.image, w5 = imageWidth(item, img), h4 = imageHeight(item, img), x7 = (item.x || 0) - imageXOffset(item.align, w5), y7 = (item.y || 0) - imageYOffset(item.baseline, h4);
  return bounds3.set(x7, y7, x7 + w5, y7 + h4);
}
function draw$3(context4, scene, bounds3) {
  visit(scene, (item) => {
    if (bounds3 && !bounds3.intersects(item.bounds))
      return;
    const img = getImage(item, this);
    let w5 = imageWidth(item, img);
    let h4 = imageHeight(item, img);
    if (w5 === 0 || h4 === 0)
      return;
    let x7 = (item.x || 0) - imageXOffset(item.align, w5), y7 = (item.y || 0) - imageYOffset(item.baseline, h4), opacity2, ar0, ar1, t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w5 / ar0;
          y7 += (h4 - t) / 2;
          h4 = t;
        } else {
          t = h4 * ar0;
          x7 += (w5 - t) / 2;
          w5 = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend(context4, item);
      context4.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
      context4.imageSmoothingEnabled = item.smooth !== false;
      context4.drawImage(img, x7, y7, w5, h4);
    }
  });
}
function attr$3(emit3, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit3("vector-effect", "non-scaling-stroke");
  }
  emit3("transform", transformItem(item));
  emit3("d", item.path);
}
function path$1(context4, item) {
  var path5 = item.path;
  if (path5 == null)
    return true;
  var x7 = item.x || 0, y7 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a4 = (item.angle || 0) * DegToRad, cache3 = item.pathCache;
  if (!cache3 || cache3.path !== path5) {
    (item.pathCache = cache3 = parse4(path5)).path = path5;
  }
  if (a4 && context4.rotate && context4.translate) {
    context4.translate(x7, y7);
    context4.rotate(a4);
    pathRender(context4, cache3, 0, 0, sx, sy);
    context4.rotate(-a4);
    context4.translate(-x7, -y7);
  } else {
    pathRender(context4, cache3, x7, y7, sx, sy);
  }
}
function bound$3(bounds3, item) {
  return path$1(boundContext(bounds3, item.angle), item) ? bounds3.set(0, 0, 0, 0) : boundStroke(bounds3, item, true);
}
function attr$2(emit3, item) {
  emit3("d", rectangle(null, item));
}
function bound$2(bounds3, item) {
  var x7, y7;
  return boundStroke(bounds3.set(x7 = item.x || 0, y7 = item.y || 0, x7 + item.width || 0, y7 + item.height || 0), item);
}
function draw$2(context4, item) {
  context4.beginPath();
  rectangle(context4, item);
}
function attr$1(emit3, item) {
  emit3("transform", translateItem(item));
  emit3("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit3("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$1(bounds3, item) {
  var x13, y13;
  return boundStroke(bounds3.set(x13 = item.x || 0, y13 = item.y || 0, item.x2 != null ? item.x2 : x13, item.y2 != null ? item.y2 : y13), item);
}
function path2(context4, item, opacity2) {
  var x13, y13, x22, y22;
  if (item.stroke && stroke(context4, item, opacity2)) {
    x13 = item.x || 0;
    y13 = item.y || 0;
    x22 = item.x2 != null ? item.x2 : x13;
    y22 = item.y2 != null ? item.y2 : y13;
    context4.beginPath();
    context4.moveTo(x13, y13);
    context4.lineTo(x22, y22);
    return true;
  }
  return false;
}
function draw$1(context4, scene, bounds3) {
  visit(scene, (item) => {
    if (bounds3 && !bounds3.intersects(item.bounds))
      return;
    var opacity2 = item.opacity == null ? 1 : item.opacity;
    if (opacity2 && path2(context4, item, opacity2)) {
      blend(context4, item);
      context4.stroke();
    }
  });
}
function hit$1(context4, item, x7, y7) {
  if (!context4.isPointInStroke)
    return false;
  return path2(context4, item, 1) && context4.isPointInStroke(x7, y7);
}
function useCanvas(use) {
  textMetrics.width = use && context ? measureWidth : estimateWidth;
}
function estimateWidth(item, text5) {
  return _estimateWidth(textValue(item, text5), fontSize(item));
}
function _estimateWidth(text5, currentFontHeight) {
  return ~~(0.8 * text5.length * currentFontHeight);
}
function measureWidth(item, text5) {
  return fontSize(item) <= 0 || !(text5 = textValue(item, text5)) ? 0 : _measureWidth(text5, font(item));
}
function _measureWidth(text5, currentFont) {
  const key3 = `(${currentFont}) ${text5}`;
  let width2 = widthCache.get(key3);
  if (width2 === void 0) {
    context.font = currentFont;
    width2 = context.measureText(text5).width;
    widthCache.set(key3, width2);
  }
  return width2;
}
function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}
function lineArray(_) {
  return isArray2(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines(item) {
  return lineArray(item.lineBreak && item.text && !isArray2(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl3 = textLines(item);
  return (isArray2(tl3) ? tl3.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line5) {
  const text5 = line5 == null ? "" : (line5 + "").trim();
  return item.limit > 0 && text5.length ? truncate2(item, text5) : text5;
}
function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    const currentFont = font(item);
    return (text5) => _measureWidth(text5, currentFont);
  } else {
    const currentFontHeight = fontSize(item);
    return (text5) => _estimateWidth(text5, currentFontHeight);
  }
}
function truncate2(item, text5) {
  var limit = +item.limit, width2 = widthGetter(item);
  if (width2(text5) < limit)
    return text5;
  var ellipsis = item.ellipsis || "", rtl = item.dir === "rtl", lo = 0, hi = text5.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text5.slice(mid)) > limit)
        lo = mid + 1;
      else
        hi = mid;
    }
    return ellipsis + text5.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text5.slice(0, mid)) < limit)
        lo = mid;
      else
        hi = mid - 1;
    }
    return text5.slice(0, lo) + ellipsis;
  }
}
function fontFamily(item, quote) {
  var font4 = item.font;
  return (quote && font4 ? String(font4).replace(/"/g, "'") : font4) || "sans-serif";
}
function font(item, quote) {
  return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize(item) + "px " + fontFamily(item, quote);
}
function offset2(item) {
  var baseline3 = item.baseline, h4 = fontSize(item);
  return Math.round(baseline3 === "top" ? 0.79 * h4 : baseline3 === "middle" ? 0.3 * h4 : baseline3 === "bottom" ? -0.21 * h4 : baseline3 === "line-top" ? 0.29 * h4 + 0.5 * lineHeight(item) : baseline3 === "line-bottom" ? 0.29 * h4 - 0.5 * lineHeight(item) : 0);
}
function anchorPoint(item) {
  var x7 = item.x || 0, y7 = item.y || 0, r2 = item.radius || 0, t;
  if (r2) {
    t = (item.theta || 0) - HalfPi;
    x7 += r2 * Math.cos(t);
    y7 += r2 * Math.sin(t);
  }
  tempBounds.x1 = x7;
  tempBounds.y1 = y7;
  return tempBounds;
}
function attr(emit3, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset2(item), p = anchorPoint(item), x7 = p.x1, y7 = p.y1, a4 = item.angle || 0, t;
  emit3("text-anchor", textAlign[item.align] || "start");
  if (a4) {
    t = translate(x7, y7) + " " + rotate(a4);
    if (dx || dy)
      t += " " + translate(dx, dy);
  } else {
    t = translate(x7 + dx, y7 + dy);
  }
  emit3("transform", t);
}
function bound(bounds3, item, mode3) {
  var h4 = textMetrics.height(item), a4 = item.align, p = anchorPoint(item), x7 = p.x1, y7 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset2(item) - Math.round(0.8 * h4), tl3 = textLines(item), w5;
  if (isArray2(tl3)) {
    h4 += lineHeight(item) * (tl3.length - 1);
    w5 = tl3.reduce((w6, t) => Math.max(w6, textMetrics.width(item, t)), 0);
  } else {
    w5 = textMetrics.width(item, tl3);
  }
  if (a4 === "center") {
    dx -= w5 / 2;
  } else if (a4 === "right") {
    dx -= w5;
  } else
    ;
  bounds3.set(dx += x7, dy += y7, dx + w5, dy + h4);
  if (item.angle && !mode3) {
    bounds3.rotate(item.angle * DegToRad, x7, y7);
  } else if (mode3 === 2) {
    return bounds3.rotatedPoints(item.angle * DegToRad, x7, y7);
  }
  return bounds3;
}
function draw(context4, scene, bounds3) {
  visit(scene, (item) => {
    var opacity2 = item.opacity == null ? 1 : item.opacity, p, x7, y7, i, lh, tl3, str;
    if (bounds3 && !bounds3.intersects(item.bounds) || opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
      return;
    context4.font = font(item);
    context4.textAlign = item.align || "left";
    p = anchorPoint(item);
    x7 = p.x1, y7 = p.y1;
    if (item.angle) {
      context4.save();
      context4.translate(x7, y7);
      context4.rotate(item.angle * DegToRad);
      x7 = y7 = 0;
    }
    x7 += item.dx || 0;
    y7 += (item.dy || 0) + offset2(item);
    tl3 = textLines(item);
    blend(context4, item);
    if (isArray2(tl3)) {
      lh = lineHeight(item);
      for (i = 0; i < tl3.length; ++i) {
        str = textValue(item, tl3[i]);
        if (item.fill && fill(context4, item, opacity2)) {
          context4.fillText(str, x7, y7);
        }
        if (item.stroke && stroke(context4, item, opacity2)) {
          context4.strokeText(str, x7, y7);
        }
        y7 += lh;
      }
    } else {
      str = textValue(item, tl3);
      if (item.fill && fill(context4, item, opacity2)) {
        context4.fillText(str, x7, y7);
      }
      if (item.stroke && stroke(context4, item, opacity2)) {
        context4.strokeText(str, x7, y7);
      }
    }
    if (item.angle)
      context4.restore();
  });
}
function hit(context4, item, x7, y7, gx, gy) {
  if (item.fontSize <= 0)
    return false;
  if (!item.angle)
    return true;
  var p = anchorPoint(item), ax = p.x1, ay = p.y1, b3 = bound(tempBounds, item, 1), a4 = -item.angle * DegToRad, cos5 = Math.cos(a4), sin5 = Math.sin(a4), px3 = cos5 * gx - sin5 * gy + (ax - cos5 * ax + sin5 * ay), py3 = sin5 * gx + cos5 * gy + (ay - sin5 * ax - cos5 * ay);
  return b3.contains(px3, py3);
}
function intersectText(item, box) {
  const p = bound(tempBounds, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}
function boundItem(item, func, opt) {
  var type4 = Marks[item.mark.marktype], bound3 = func || type4.bound;
  if (type4.nested)
    item = item.mark;
  return bound3(item.bounds || (item.bounds = new Bounds()), item, opt);
}
function boundMark(mark, bounds3, opt) {
  var type4 = Marks[mark.marktype], bound3 = type4.bound, items2 = mark.items, hasItems = items2 && items2.length, i, n, item, b3;
  if (type4.nested) {
    if (hasItems) {
      item = items2[0];
    } else {
      DUMMY.mark = mark;
      item = DUMMY;
    }
    b3 = boundItem(item, bound3, opt);
    bounds3 = bounds3 && bounds3.union(b3) || b3;
    return bounds3;
  }
  bounds3 = bounds3 || mark.bounds && mark.bounds.clear() || new Bounds();
  if (hasItems) {
    for (i = 0, n = items2.length; i < n; ++i) {
      bounds3.union(boundItem(items2[i], bound3, opt));
    }
  }
  return mark.bounds = bounds3;
}
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}
function sceneFromJSON(json3) {
  const scene = typeof json3 === "string" ? JSON.parse(json3) : json3;
  return initialize(scene);
}
function initialize(scene) {
  var type4 = scene.marktype, items2 = scene.items, parent, i, n;
  if (items2) {
    for (i = 0, n = items2.length; i < n; ++i) {
      parent = type4 ? "mark" : "group";
      items2[i][parent] = scene;
      if (items2[i].zindex)
        items2[i][parent].zdirty = true;
      if ("group" === (type4 || parent))
        initialize(items2[i]);
    }
  }
  if (type4)
    boundMark(scene);
  return scene;
}
function Scenegraph(scene) {
  if (arguments.length) {
    this.root = sceneFromJSON(scene);
  } else {
    this.root = createMark({
      marktype: "group",
      name: "root",
      role: "frame"
    });
    this.root.items = [new GroupItem(this.root)];
  }
}
function createMark(def3, group6) {
  const mark = {
    bounds: new Bounds(),
    clip: !!def3.clip,
    group: group6,
    interactive: def3.interactive === false ? false : true,
    items: [],
    marktype: def3.marktype,
    name: def3.name || void 0,
    role: def3.role || void 0,
    zindex: def3.zindex || 0
  };
  if (def3.aria != null) {
    mark.aria = def3.aria;
  }
  if (def3.description) {
    mark.description = def3.description;
  }
  return mark;
}
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i)
    if (nodes[i].tagName.toLowerCase() === tag) {
      return nodes[i];
    }
}
function domChild(el, index8, tag, ns) {
  var a4 = el.childNodes[index8], b3;
  if (!a4 || a4.tagName.toLowerCase() !== tag.toLowerCase()) {
    b3 = a4 || null;
    a4 = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a4, b3);
  }
  return a4;
}
function domClear(el, index8) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index8)
    el.removeChild(nodes[--curr]);
  return el;
}
function cssClass(mark) {
  return "mark-" + mark.marktype + (mark.role ? " role-" + mark.role : "") + (mark.name ? " " + mark.name : "");
}
function point7(event3, el) {
  const rect4 = el.getBoundingClientRect();
  return [event3.clientX - rect4.left - (el.clientLeft || 0), event3.clientY - rect4.top - (el.clientTop || 0)];
}
function resolveItem(item, event3, el, origin) {
  var mark = item && item.mark, mdef, p;
  if (mark && (mdef = Marks[mark.marktype]).tip) {
    p = point7(event3, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark.items, p);
  }
  return item;
}
function Handler(customLoader, customTooltip) {
  this._active = null;
  this._handlers = {};
  this._loader = customLoader || loader();
  this._tooltip = customTooltip || defaultTooltip;
}
function defaultTooltip(handler, event3, item, value4) {
  handler.element().setAttribute("title", value4 || "");
}
function Renderer(loader3) {
  this._el = null;
  this._bgcolor = null;
  this._loader = new ResourceLoader(loader3);
}
function CanvasHandler(loader3, tooltip2) {
  Handler.call(this, loader3, tooltip2);
  this._down = null;
  this._touch = null;
  this._first = true;
  this._events = {};
}
function eventListenerCheck(handler, type4) {
  eventBundle(type4).forEach((_) => addEventListener(handler, _));
}
function addEventListener(handler, type4) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type4]) {
    handler._events[type4] = 1;
    canvas.addEventListener(type4, handler[type4] ? (evt) => handler[type4](evt) : (evt) => handler.fire(type4, evt));
  }
}
function move(moveEvent, overEvent, outEvent) {
  return function(evt) {
    const a4 = this._active, p = this.pickEvent(evt);
    if (p === a4) {
      this.fire(moveEvent, evt);
    } else {
      if (!a4 || !a4.exit) {
        this.fire(outEvent, evt);
      }
      this._active = p;
      this.fire(overEvent, evt);
      this.fire(moveEvent, evt);
    }
  };
}
function inactive(type4) {
  return function(evt) {
    this.fire(type4, evt);
    this._active = null;
  };
}
function devicePixelRatio() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
function resize(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context4 = canvas.getContext("2d"), ratio = inDOM ? pixelRatio : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key3 in opt) {
    context4[key3] = opt[key3];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context4.pixelRatio = ratio;
  context4.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
function CanvasRenderer(loader3) {
  Renderer.call(this, loader3);
  this._options = {};
  this._redraw = false;
  this._dirty = new Bounds();
  this._tempb = new Bounds();
}
function clipToBounds(g, b3, origin) {
  b3.expand(1).round();
  if (g.pixelRatio % 1) {
    b3.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b3.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b3.x1, b3.y1, b3.width(), b3.height());
  g.clip();
  return b3;
}
function SVGHandler(loader3, tooltip2) {
  Handler.call(this, loader3, tooltip2);
  const h4 = this;
  h4._hrefHandler = listener(h4, (evt, item) => {
    if (item && item.href)
      h4.handleHref(evt, item, item.href);
  });
  h4._tooltipHandler = listener(h4, (evt, item) => {
    h4.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
  });
}
function ariaItemAttributes(emit3, item) {
  const hide = item.aria === false;
  emit3(ARIA_HIDDEN, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode) {
      emit3(AriaEncode[prop], void 0);
    }
  } else {
    const type4 = item.mark.marktype;
    emit3(ARIA_LABEL, item.description);
    emit3(ARIA_ROLE, item.ariaRole || (type4 === "group" ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit3(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type4} mark`);
  }
}
function ariaMarkAttributes(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
}
function ariaMark(mark) {
  const type4 = mark.marktype;
  const recurse3 = type4 === "group" || type4 === "text" || mark.items.some((_) => _.description != null && _.aria !== false);
  return bundle(recurse3 ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type4} mark container`, mark.description);
}
function ariaGuide(mark, opt) {
  try {
    const item = mark.items[0], caption = opt.caption || (() => "");
    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption(item) {
  return array2(item.text).join(" ");
}
function axisCaption(item) {
  const datum2 = item.datum, orient3 = item.orient, title2 = datum2.title ? extractTitle(item) : null, ctx = item.context, scale8 = ctx.scales[datum2.scale].value, locale7 = ctx.dataflow.locale(), type4 = scale8.type, xy = orient3 === "left" || orient3 === "right" ? "Y" : "X";
  return `${xy}-axis` + (title2 ? ` titled '${title2}'` : "") + ` for a ${isDiscrete(type4) ? "discrete" : type4} scale with ${domainCaption(locale7, scale8, item)}`;
}
function legendCaption(item) {
  const datum2 = item.datum, title2 = datum2.title ? extractTitle(item) : null, type4 = `${datum2.type || ""} legend`.trim(), scales3 = datum2.scales, props = Object.keys(scales3), ctx = item.context, scale8 = ctx.scales[scales3[props[0]]].value, locale7 = ctx.dataflow.locale();
  return capitalize(type4) + (title2 ? ` titled '${title2}'` : "") + ` for ${channelCaption(props)} with ${domainCaption(locale7, scale8, item)}`;
}
function extractTitle(item) {
  try {
    return array2(peek2(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek2(props);
}
function capitalize(s3) {
  return s3.length ? s3[0].toUpperCase() + s3.slice(1) : s3;
}
function markup() {
  let buf = "", outer = "", inner = "";
  const stack3 = [], clear2 = () => outer = inner = "", push = (tag) => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear2();
    }
    stack3.push(tag);
  }, attr3 = (name4, value4) => {
    if (value4 != null)
      outer += ` ${name4}="${attrText(value4)}"`;
    return m2;
  }, m2 = {
    open(tag) {
      push(tag);
      outer = "<" + tag;
      for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        attrs[_key - 1] = arguments[_key];
      }
      for (const set8 of attrs) {
        for (const key3 in set8)
          attr3(key3, set8[key3]);
      }
      return m2;
    },
    close() {
      const tag = stack3.pop();
      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : "/>");
      } else {
        buf += `</${tag}>`;
      }
      clear2();
      return m2;
    },
    attr: attr3,
    text: (t) => (inner += innerText(t), m2),
    toString: () => buf
  };
  return m2;
}
function _serialize(m2, node) {
  m2.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m2.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children5 = node.childNodes;
    for (const child of children5) {
      child.nodeType === 3 ? m2.text(child.nodeValue) : _serialize(m2, child);
    }
  }
  return m2.close();
}
function SVGRenderer(loader3) {
  Renderer.call(this, loader3);
  this._dirtyID = 0;
  this._dirty = [];
  this._svg = null;
  this._root = null;
  this._defs = null;
}
function dirtyParents(item, id4) {
  for (; item && item.dirty !== id4; item = item.mark.group) {
    item.dirty = id4;
    if (item.mark && item.mark.dirty !== id4) {
      item.mark.dirty = id4;
    } else
      return;
  }
}
function updateGradient(el, grad, index8) {
  let i, n, stop2;
  if (grad.gradient === "radial") {
    let pt = domChild(el, index8++, "pattern", svgns);
    setAttributes(pt, {
      id: patternPrefix + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild(pt, 0, "rect", svgns);
    setAttributes(pt, {
      width: 1,
      height: 1,
      fill: `url(${href()}#${grad.id})`
    });
    el = domChild(el, index8++, "radialGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index8++, "linearGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop2 = domChild(el, i, "stop", svgns);
    stop2.setAttribute("offset", grad.stops[i].offset);
    stop2.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear(el, i);
  return index8;
}
function updateClipping(el, clip4, index8) {
  let mask;
  el = domChild(el, index8, "clipPath", svgns);
  el.setAttribute("id", clip4.id);
  if (clip4.path) {
    mask = domChild(el, 0, "path", svgns);
    mask.setAttribute("d", clip4.path);
  } else {
    mask = domChild(el, 0, "rect", svgns);
    setAttributes(mask, {
      x: 0,
      y: 0,
      width: clip4.width,
      height: clip4.height
    });
  }
  domClear(el, 1);
  return index8 + 1;
}
function recurse(renderer, el, group6) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit(group6, (item) => {
    prev = renderer.mark(el, item, prev);
    ++idx;
  });
  domClear(el, 1 + idx);
}
function bind(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate(doc, tag, svgns);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate(doc, "path", svgns);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, "g", svgns);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, "path", svgns);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
function emit(name4, value4, ns) {
  if (value4 === values[name4])
    return;
  if (ns) {
    setAttributeNS(element, name4, value4, ns);
  } else {
    setAttribute(element, name4, value4);
  }
  values[name4] = value4;
}
function setStyle(el, name4, value4) {
  if (value4 !== values[name4]) {
    if (value4 == null) {
      el.style.removeProperty(name4);
    } else {
      el.style.setProperty(name4, value4 + "");
    }
    values[name4] = value4;
  }
}
function setAttributes(el, attrs) {
  for (const key3 in attrs) {
    setAttribute(el, key3, attrs[key3]);
  }
}
function setAttribute(el, name4, value4) {
  if (value4 != null) {
    el.setAttribute(name4, value4);
  } else {
    el.removeAttribute(name4);
  }
}
function setAttributeNS(el, name4, value4, ns) {
  if (value4 != null) {
    el.setAttributeNS(ns, name4, value4);
  } else {
    el.removeAttributeNS(ns, name4);
  }
}
function href() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
function SVGStringRenderer(loader3) {
  Renderer.call(this, loader3);
  this._text = null;
  this._defs = {
    gradient: {},
    clipping: {}
  };
}
function style(s3, item, scene, tag, defs) {
  let styleList;
  if (item == null)
    return s3;
  if (tag === "bgrect" && scene.interactive === false) {
    s3["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s3["pointer-events"] = "none";
    }
    s3.display = "none";
    if (item.fill !== null)
      return s3;
  }
  if (tag === "image" && item.smooth === false) {
    styleList = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"];
  }
  if (tag === "text") {
    s3["font-family"] = fontFamily(item);
    s3["font-size"] = fontSize(item) + "px";
    s3["font-style"] = item.fontStyle;
    s3["font-variant"] = item.fontVariant;
    s3["font-weight"] = item.fontWeight;
  }
  for (const prop in stylesAttr) {
    let value4 = item[prop];
    const name4 = stylesAttr[prop];
    if (value4 === "transparent" && (name4 === "fill" || name4 === "stroke"))
      ;
    else if (value4 != null) {
      if (isGradient(value4)) {
        value4 = gradientRef(value4, defs.gradient, "");
      }
      s3[name4] = value4;
    }
  }
  for (const prop in stylesCss) {
    const value4 = item[prop];
    if (value4 != null) {
      styleList = styleList || [];
      styleList.push(`${stylesCss[prop]}: ${value4};`);
    }
  }
  if (styleList) {
    s3.style = styleList.join(" ");
  }
  return s3;
}
function boundClip(mark) {
  const clip4 = mark.clip;
  if (isFunction2(clip4)) {
    clip4(boundContext(clipBounds.clear()));
  } else if (clip4) {
    clipBounds.set(0, 0, mark.group.width, mark.group.height);
  } else
    return;
  mark.bounds.intersect(clipBounds);
}
var gradient_id, patternPrefix, lookup, paramCounts, commandPattern, numberPattern, spacePattern, flagPattern, DegToRad, Epsilon, HalfPi, Tau, HalfSqrt3, segmentCache, bezierCache, join, temp, Tan30, builtins, custom8, C2, x2, y2, w, h, xw, yh, sa, ea, pa, ir, or, cr, tl, tr, br, bl, sz, ts, def, type, arcShape, areavShape, areahShape, lineShape, rectShape, symbolShape, trailShape, clip_id, circleThreshold, bounds, lx, ly, rot, ma, mb, mc, md, add3, addL, addX, addY, px, py, addp, addpL, context$1, context, b, Empty2, arc, area, hitBackground, hitForeground, hitCorner, group3, metadata, image, line, path$2, rect, rule, shape, symbol, widthCache, textMetrics, textAlign, tempBounds, text, trail, Marks, DUMMY, keys, KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent, Events, TooltipShowEvent, TooltipHideEvent, HrefEvent, eventBundle, pixelRatio, base$1, viewBounds, listener, ARIA_HIDDEN, ARIA_LABEL, ARIA_ROLE, ARIA_ROLEDESCRIPTION, GRAPHICS_OBJECT, GRAPHICS_SYMBOL, bundle, AriaIgnore, AriaGuides, AriaEncode, innerText, attrText, serializeXML, stylesAttr, stylesCss, rootAttributes, RootIndex, xmlns, svgns, base, element, values, mark_extras, Canvas, PNG, SVG, None3, modules, clipBounds;
var init_vega_scenegraph_module = __esm({
  "node_modules/.pnpm/vega-scenegraph@4.10.2/node_modules/vega-scenegraph/build/vega-scenegraph.module.js"() {
    init_vega_util_module2();
    init_src12();
    init_src11();
    init_src11();
    init_vega_canvas_browser_module();
    init_vega_loader_browser_module();
    init_vega_scale_module();
    gradient_id = 0;
    patternPrefix = "p_";
    lookup = {
      "basis": {
        curve: basis_default
      },
      "basis-closed": {
        curve: basisClosed_default
      },
      "basis-open": {
        curve: basisOpen_default
      },
      "bundle": {
        curve: bundle_default,
        tension: "beta",
        value: 0.85
      },
      "cardinal": {
        curve: cardinal_default,
        tension: "tension",
        value: 0
      },
      "cardinal-open": {
        curve: cardinalOpen_default,
        tension: "tension",
        value: 0
      },
      "cardinal-closed": {
        curve: cardinalClosed_default,
        tension: "tension",
        value: 0
      },
      "catmull-rom": {
        curve: catmullRom_default,
        tension: "alpha",
        value: 0.5
      },
      "catmull-rom-closed": {
        curve: catmullRomClosed_default,
        tension: "alpha",
        value: 0.5
      },
      "catmull-rom-open": {
        curve: catmullRomOpen_default,
        tension: "alpha",
        value: 0.5
      },
      "linear": {
        curve: linear_default
      },
      "linear-closed": {
        curve: linearClosed_default
      },
      "monotone": {
        horizontal: monotoneY,
        vertical: monotoneX
      },
      "natural": {
        curve: natural_default
      },
      "step": {
        curve: step_default
      },
      "step-after": {
        curve: stepAfter
      },
      "step-before": {
        curve: stepBefore
      }
    };
    paramCounts = {
      m: 2,
      l: 2,
      h: 1,
      v: 1,
      z: 0,
      c: 6,
      s: 4,
      q: 4,
      t: 2,
      a: 7
    };
    commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
    numberPattern = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
    spacePattern = /^((\s+,?\s*)|(,\s*))/;
    flagPattern = /^[01]/;
    DegToRad = Math.PI / 180;
    Epsilon = 1e-14;
    HalfPi = Math.PI / 2;
    Tau = Math.PI * 2;
    HalfSqrt3 = Math.sqrt(3) / 2;
    segmentCache = {};
    bezierCache = {};
    join = [].join;
    temp = ["l", 0, 0, 0, 0, 0, 0, 0];
    Tan30 = 0.5773502691896257;
    builtins = {
      "circle": {
        draw: function(context4, size) {
          const r2 = Math.sqrt(size) / 2;
          context4.moveTo(r2, 0);
          context4.arc(0, 0, r2, 0, Tau);
        }
      },
      "cross": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, s3 = r2 / 2.5;
          context4.moveTo(-r2, -s3);
          context4.lineTo(-r2, s3);
          context4.lineTo(-s3, s3);
          context4.lineTo(-s3, r2);
          context4.lineTo(s3, r2);
          context4.lineTo(s3, s3);
          context4.lineTo(r2, s3);
          context4.lineTo(r2, -s3);
          context4.lineTo(s3, -s3);
          context4.lineTo(s3, -r2);
          context4.lineTo(-s3, -r2);
          context4.lineTo(-s3, -s3);
          context4.closePath();
        }
      },
      "diamond": {
        draw: function(context4, size) {
          const r2 = Math.sqrt(size) / 2;
          context4.moveTo(-r2, 0);
          context4.lineTo(0, -r2);
          context4.lineTo(r2, 0);
          context4.lineTo(0, r2);
          context4.closePath();
        }
      },
      "square": {
        draw: function(context4, size) {
          var w5 = Math.sqrt(size), x7 = -w5 / 2;
          context4.rect(x7, x7, w5, w5);
        }
      },
      "arrow": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, s3 = r2 / 7, t = r2 / 2.5, v = r2 / 8;
          context4.moveTo(-s3, r2);
          context4.lineTo(s3, r2);
          context4.lineTo(s3, -v);
          context4.lineTo(t, -v);
          context4.lineTo(0, -r2);
          context4.lineTo(-t, -v);
          context4.lineTo(-s3, -v);
          context4.closePath();
        }
      },
      "wedge": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt3 * r2, o = h4 - r2 * Tan30, b3 = r2 / 4;
          context4.moveTo(0, -h4 - o);
          context4.lineTo(-b3, h4 - o);
          context4.lineTo(b3, h4 - o);
          context4.closePath();
        }
      },
      "triangle": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt3 * r2, o = h4 - r2 * Tan30;
          context4.moveTo(0, -h4 - o);
          context4.lineTo(-r2, h4 - o);
          context4.lineTo(r2, h4 - o);
          context4.closePath();
        }
      },
      "triangle-up": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt3 * r2;
          context4.moveTo(0, -h4);
          context4.lineTo(-r2, h4);
          context4.lineTo(r2, h4);
          context4.closePath();
        }
      },
      "triangle-down": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt3 * r2;
          context4.moveTo(0, h4);
          context4.lineTo(-r2, -h4);
          context4.lineTo(r2, -h4);
          context4.closePath();
        }
      },
      "triangle-right": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt3 * r2;
          context4.moveTo(h4, 0);
          context4.lineTo(-h4, -r2);
          context4.lineTo(-h4, r2);
          context4.closePath();
        }
      },
      "triangle-left": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt3 * r2;
          context4.moveTo(-h4, 0);
          context4.lineTo(h4, -r2);
          context4.lineTo(h4, r2);
          context4.closePath();
        }
      },
      "stroke": {
        draw: function(context4, size) {
          const r2 = Math.sqrt(size) / 2;
          context4.moveTo(-r2, 0);
          context4.lineTo(r2, 0);
        }
      }
    };
    custom8 = {};
    C2 = 0.448084975506;
    x2 = (item) => item.x || 0;
    y2 = (item) => item.y || 0;
    w = (item) => item.width || 0;
    h = (item) => item.height || 0;
    xw = (item) => (item.x || 0) + (item.width || 0);
    yh = (item) => (item.y || 0) + (item.height || 0);
    sa = (item) => item.startAngle || 0;
    ea = (item) => item.endAngle || 0;
    pa = (item) => item.padAngle || 0;
    ir = (item) => item.innerRadius || 0;
    or = (item) => item.outerRadius || 0;
    cr = (item) => item.cornerRadius || 0;
    tl = (item) => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
    tr = (item) => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0;
    br = (item) => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
    bl = (item) => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
    sz = (item) => value$1(item.size, 64);
    ts = (item) => item.size || 1;
    def = (item) => !(item.defined === false);
    type = (item) => symbols2(item.shape || "circle");
    arcShape = arc_default().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr);
    areavShape = area_default().x(x2).y1(y2).y0(yh).defined(def);
    areahShape = area_default().y(y2).x1(x2).x0(xw).defined(def);
    lineShape = line_default().x(x2).y(y2).defined(def);
    rectShape = vg_rect().x(x2).y(y2).width(w).height(h).cornerRadius(tl, tr, br, bl);
    symbolShape = Symbol2().type(type).size(sz);
    trailShape = vg_trail().x(x2).y(y2).defined(def).size(ts);
    clip_id = 1;
    Bounds.prototype = {
      clone() {
        return new Bounds(this);
      },
      clear() {
        this.x1 = +Number.MAX_VALUE;
        this.y1 = +Number.MAX_VALUE;
        this.x2 = -Number.MAX_VALUE;
        this.y2 = -Number.MAX_VALUE;
        return this;
      },
      empty() {
        return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
      },
      equals(b3) {
        return this.x1 === b3.x1 && this.y1 === b3.y1 && this.x2 === b3.x2 && this.y2 === b3.y2;
      },
      set(x13, y13, x22, y22) {
        if (x22 < x13) {
          this.x2 = x13;
          this.x1 = x22;
        } else {
          this.x1 = x13;
          this.x2 = x22;
        }
        if (y22 < y13) {
          this.y2 = y13;
          this.y1 = y22;
        } else {
          this.y1 = y13;
          this.y2 = y22;
        }
        return this;
      },
      add(x7, y7) {
        if (x7 < this.x1)
          this.x1 = x7;
        if (y7 < this.y1)
          this.y1 = y7;
        if (x7 > this.x2)
          this.x2 = x7;
        if (y7 > this.y2)
          this.y2 = y7;
        return this;
      },
      expand(d) {
        this.x1 -= d;
        this.y1 -= d;
        this.x2 += d;
        this.y2 += d;
        return this;
      },
      round() {
        this.x1 = Math.floor(this.x1);
        this.y1 = Math.floor(this.y1);
        this.x2 = Math.ceil(this.x2);
        this.y2 = Math.ceil(this.y2);
        return this;
      },
      scale(s3) {
        this.x1 *= s3;
        this.y1 *= s3;
        this.x2 *= s3;
        this.y2 *= s3;
        return this;
      },
      translate(dx, dy) {
        this.x1 += dx;
        this.x2 += dx;
        this.y1 += dy;
        this.y2 += dy;
        return this;
      },
      rotate(angle2, x7, y7) {
        const p = this.rotatedPoints(angle2, x7, y7);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
      },
      rotatedPoints(angle2, x7, y7) {
        var {
          x1: x13,
          y1: y13,
          x2: x22,
          y2: y22
        } = this, cos5 = Math.cos(angle2), sin5 = Math.sin(angle2), cx = x7 - x7 * cos5 + y7 * sin5, cy = y7 - x7 * sin5 - y7 * cos5;
        return [cos5 * x13 - sin5 * y13 + cx, sin5 * x13 + cos5 * y13 + cy, cos5 * x13 - sin5 * y22 + cx, sin5 * x13 + cos5 * y22 + cy, cos5 * x22 - sin5 * y13 + cx, sin5 * x22 + cos5 * y13 + cy, cos5 * x22 - sin5 * y22 + cx, sin5 * x22 + cos5 * y22 + cy];
      },
      union(b3) {
        if (b3.x1 < this.x1)
          this.x1 = b3.x1;
        if (b3.y1 < this.y1)
          this.y1 = b3.y1;
        if (b3.x2 > this.x2)
          this.x2 = b3.x2;
        if (b3.y2 > this.y2)
          this.y2 = b3.y2;
        return this;
      },
      intersect(b3) {
        if (b3.x1 > this.x1)
          this.x1 = b3.x1;
        if (b3.y1 > this.y1)
          this.y1 = b3.y1;
        if (b3.x2 < this.x2)
          this.x2 = b3.x2;
        if (b3.y2 < this.y2)
          this.y2 = b3.y2;
        return this;
      },
      encloses(b3) {
        return b3 && this.x1 <= b3.x1 && this.x2 >= b3.x2 && this.y1 <= b3.y1 && this.y2 >= b3.y2;
      },
      alignsWith(b3) {
        return b3 && (this.x1 == b3.x1 || this.x2 == b3.x2 || this.y1 == b3.y1 || this.y2 == b3.y2);
      },
      intersects(b3) {
        return b3 && !(this.x2 < b3.x1 || this.x1 > b3.x2 || this.y2 < b3.y1 || this.y1 > b3.y2);
      },
      contains(x7, y7) {
        return !(x7 < this.x1 || x7 > this.x2 || y7 < this.y1 || y7 > this.y2);
      },
      width() {
        return this.x2 - this.x1;
      },
      height() {
        return this.y2 - this.y1;
      }
    };
    inherits2(GroupItem, Item);
    ResourceLoader.prototype = {
      pending() {
        return this._pending;
      },
      sanitizeURL(uri) {
        const loader3 = this;
        increment(loader3);
        return loader3._loader.sanitize(uri, {
          context: "href"
        }).then((opt) => {
          decrement(loader3);
          return opt;
        }).catch(() => {
          decrement(loader3);
          return null;
        });
      },
      loadImage(uri) {
        const loader3 = this, Image2 = domImage();
        increment(loader3);
        return loader3._loader.sanitize(uri, {
          context: "image"
        }).then((opt) => {
          const url = opt.href;
          if (!url || !Image2)
            throw {
              url
            };
          const img = new Image2();
          const cors = has2(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
          if (cors != null)
            img.crossOrigin = cors;
          img.onload = () => decrement(loader3);
          img.onerror = () => decrement(loader3);
          img.src = url;
          return img;
        }).catch((e3) => {
          decrement(loader3);
          return {
            complete: false,
            width: 0,
            height: 0,
            src: e3 && e3.url || ""
          };
        });
      },
      ready() {
        const loader3 = this;
        return new Promise((accept) => {
          function poll(value4) {
            if (!loader3.pending())
              accept(value4);
            else
              setTimeout(() => {
                poll(true);
              }, 10);
          }
          poll(false);
        });
      }
    };
    circleThreshold = Tau - 1e-8;
    add3 = (x7, y7) => bounds.add(x7, y7);
    addL = (x7, y7) => add3(lx = x7, ly = y7);
    addX = (x7) => add3(x7, bounds.y1);
    addY = (y7) => add3(bounds.x1, y7);
    px = (x7, y7) => ma * x7 + mc * y7;
    py = (x7, y7) => mb * x7 + md * y7;
    addp = (x7, y7) => add3(px(x7, y7), py(x7, y7));
    addpL = (x7, y7) => addL(px(x7, y7), py(x7, y7));
    context$1 = {
      beginPath() {
      },
      closePath() {
      },
      moveTo: addpL,
      lineTo: addpL,
      rect(x7, y7, w5, h4) {
        if (rot) {
          addp(x7 + w5, y7);
          addp(x7 + w5, y7 + h4);
          addp(x7, y7 + h4);
          addpL(x7, y7);
        } else {
          add3(x7 + w5, y7 + h4);
          addL(x7, y7);
        }
      },
      quadraticCurveTo(x13, y13, x22, y22) {
        const px1 = px(x13, y13), py1 = py(x13, y13), px22 = px(x22, y22), py22 = py(x22, y22);
        quadExtrema(lx, px1, px22, addX);
        quadExtrema(ly, py1, py22, addY);
        addL(px22, py22);
      },
      bezierCurveTo(x13, y13, x22, y22, x32, y32) {
        const px1 = px(x13, y13), py1 = py(x13, y13), px22 = px(x22, y22), py22 = py(x22, y22), px3 = px(x32, y32), py3 = py(x32, y32);
        cubicExtrema(lx, px1, px22, px3, addX);
        cubicExtrema(ly, py1, py22, py3, addY);
        addL(px3, py3);
      },
      arc(cx, cy, r2, sa3, ea3, ccw) {
        sa3 += rot;
        ea3 += rot;
        lx = r2 * Math.cos(ea3) + cx;
        ly = r2 * Math.sin(ea3) + cy;
        if (Math.abs(ea3 - sa3) > circleThreshold) {
          add3(cx - r2, cy - r2);
          add3(cx + r2, cy + r2);
        } else {
          const update3 = (a4) => add3(r2 * Math.cos(a4) + cx, r2 * Math.sin(a4) + cy);
          let s3, i;
          update3(sa3);
          update3(ea3);
          if (ea3 !== sa3) {
            sa3 = sa3 % Tau;
            if (sa3 < 0)
              sa3 += Tau;
            ea3 = ea3 % Tau;
            if (ea3 < 0)
              ea3 += Tau;
            if (ea3 < sa3) {
              ccw = !ccw;
              s3 = sa3;
              sa3 = ea3;
              ea3 = s3;
            }
            if (ccw) {
              ea3 -= Tau;
              s3 = sa3 - sa3 % HalfPi;
              for (i = 0; i < 4 && s3 > ea3; ++i, s3 -= HalfPi)
                update3(s3);
            } else {
              s3 = sa3 - sa3 % HalfPi + HalfPi;
              for (i = 0; i < 4 && s3 < ea3; ++i, s3 = s3 + HalfPi)
                update3(s3);
            }
          }
        }
      }
    };
    context = (context = domCanvas(1, 1)) ? context.getContext("2d") : null;
    b = new Bounds();
    Empty2 = [];
    arc = markItemPath("arc", arc$1);
    area = markMultiItemPath("area", area$1, pickArea);
    hitBackground = hitPath(rectanglePath);
    hitForeground = hitPath(rectanglePath, false);
    hitCorner = hitPath(rectanglePath, true);
    group3 = {
      type: "group",
      tag: "g",
      nested: false,
      attr: attr$5,
      bound: bound$5,
      draw: draw$4,
      pick,
      isect: intersectRect,
      content,
      background,
      foreground
    };
    metadata = {
      "xmlns": "http://www.w3.org/2000/svg",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "version": "1.1"
    };
    image = {
      type: "image",
      tag: "image",
      nested: false,
      attr: attr$4,
      bound: bound$4,
      draw: draw$3,
      pick: pick$1(),
      isect: truthy2,
      get: getImage,
      xOffset: imageXOffset,
      yOffset: imageYOffset
    };
    line = markMultiItemPath("line", line$1, pickLine);
    path$2 = {
      type: "path",
      tag: "path",
      nested: false,
      attr: attr$3,
      bound: bound$3,
      draw: drawAll(path$1),
      pick: pickPath(path$1),
      isect: intersectPath(path$1)
    };
    rect = {
      type: "rect",
      tag: "path",
      nested: false,
      attr: attr$2,
      bound: bound$2,
      draw: drawAll(draw$2),
      pick: pickPath(draw$2),
      isect: intersectRect
    };
    rule = {
      type: "rule",
      tag: "line",
      nested: false,
      attr: attr$1,
      bound: bound$1,
      draw: draw$1,
      pick: pick$1(hit$1),
      isect: intersectRule
    };
    shape = markItemPath("shape", shape$1);
    symbol = markItemPath("symbol", symbol$1, intersectPoint);
    widthCache = lruCache2();
    textMetrics = {
      height: fontSize,
      measureWidth,
      estimateWidth,
      width: estimateWidth,
      canvas: useCanvas
    };
    useCanvas(true);
    textAlign = {
      "left": "start",
      "center": "middle",
      "right": "end"
    };
    tempBounds = new Bounds();
    text = {
      type: "text",
      tag: "text",
      nested: false,
      attr,
      bound,
      draw,
      pick: pick$1(hit),
      isect: intersectText
    };
    trail = markMultiItemPath("trail", trail$1, pickTrail);
    Marks = {
      arc,
      area,
      group: group3,
      image,
      line,
      path: path$2,
      rect,
      rule,
      shape,
      symbol,
      text,
      trail
    };
    DUMMY = {
      mark: null
    };
    keys = [
      "marktype",
      "name",
      "role",
      "interactive",
      "clip",
      "items",
      "zindex",
      "x",
      "y",
      "width",
      "height",
      "align",
      "baseline",
      "fill",
      "fillOpacity",
      "opacity",
      "blend",
      "stroke",
      "strokeOpacity",
      "strokeWidth",
      "strokeCap",
      "strokeDash",
      "strokeDashOffset",
      "strokeForeground",
      "strokeOffset",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "cornerRadius",
      "padAngle",
      "cornerRadiusTopLeft",
      "cornerRadiusTopRight",
      "cornerRadiusBottomLeft",
      "cornerRadiusBottomRight",
      "interpolate",
      "tension",
      "orient",
      "defined",
      "url",
      "aspect",
      "smooth",
      "path",
      "scaleX",
      "scaleY",
      "x2",
      "y2",
      "size",
      "shape",
      "text",
      "angle",
      "theta",
      "radius",
      "dir",
      "dx",
      "dy",
      "ellipsis",
      "limit",
      "lineBreak",
      "lineHeight",
      "font",
      "fontSize",
      "fontWeight",
      "fontStyle",
      "fontVariant",
      "description",
      "aria",
      "ariaRole",
      "ariaRoleDescription"
    ];
    Scenegraph.prototype = {
      toJSON(indent) {
        return sceneToJSON(this.root, indent || 0);
      },
      mark(markdef, group6, index8) {
        group6 = group6 || this.root.items[0];
        const mark = createMark(markdef, group6);
        group6.items[index8] = mark;
        if (mark.zindex)
          mark.group.zdirty = true;
        return mark;
      }
    };
    Handler.prototype = {
      initialize(el, origin, obj) {
        this._el = el;
        this._obj = obj || null;
        return this.origin(origin);
      },
      element() {
        return this._el;
      },
      canvas() {
        return this._el && this._el.firstChild;
      },
      origin(origin) {
        if (arguments.length) {
          this._origin = origin || [0, 0];
          return this;
        } else {
          return this._origin.slice();
        }
      },
      scene(scene) {
        if (!arguments.length)
          return this._scene;
        this._scene = scene;
        return this;
      },
      on() {
      },
      off() {
      },
      _handlerIndex(h4, type4, handler) {
        for (let i = h4 ? h4.length : 0; --i >= 0; ) {
          if (h4[i].type === type4 && (!handler || h4[i].handler === handler)) {
            return i;
          }
        }
        return -1;
      },
      handlers(type4) {
        const h4 = this._handlers, a4 = [];
        if (type4) {
          a4.push(...h4[this.eventName(type4)]);
        } else {
          for (const k4 in h4) {
            a4.push(...h4[k4]);
          }
        }
        return a4;
      },
      eventName(name4) {
        const i = name4.indexOf(".");
        return i < 0 ? name4 : name4.slice(0, i);
      },
      handleHref(event3, item, href3) {
        this._loader.sanitize(href3, {
          context: "href"
        }).then((opt) => {
          const e3 = new MouseEvent(event3.type, event3), a4 = domCreate(null, "a");
          for (const name4 in opt)
            a4.setAttribute(name4, opt[name4]);
          a4.dispatchEvent(e3);
        }).catch(() => {
        });
      },
      handleTooltip(event3, item, show) {
        if (item && item.tooltip != null) {
          item = resolveItem(item, event3, this.canvas(), this._origin);
          const value4 = show && item && item.tooltip || null;
          this._tooltip.call(this._obj, this, event3, item, value4);
        }
      },
      getItemBoundingClientRect(item) {
        const el = this.canvas();
        if (!el)
          return;
        const rect4 = el.getBoundingClientRect(), origin = this._origin, bounds3 = item.bounds, width2 = bounds3.width(), height2 = bounds3.height();
        let x7 = bounds3.x1 + origin[0] + rect4.left, y7 = bounds3.y1 + origin[1] + rect4.top;
        while (item.mark && (item = item.mark.group)) {
          x7 += item.x || 0;
          y7 += item.y || 0;
        }
        return {
          x: x7,
          y: y7,
          width: width2,
          height: height2,
          left: x7,
          top: y7,
          right: x7 + width2,
          bottom: y7 + height2
        };
      }
    };
    Renderer.prototype = {
      initialize(el, width2, height2, origin, scaleFactor) {
        this._el = el;
        return this.resize(width2, height2, origin, scaleFactor);
      },
      element() {
        return this._el;
      },
      canvas() {
        return this._el && this._el.firstChild;
      },
      background(bgcolor) {
        if (arguments.length === 0)
          return this._bgcolor;
        this._bgcolor = bgcolor;
        return this;
      },
      resize(width2, height2, origin, scaleFactor) {
        this._width = width2;
        this._height = height2;
        this._origin = origin || [0, 0];
        this._scale = scaleFactor || 1;
        return this;
      },
      dirty() {
      },
      render(scene) {
        const r2 = this;
        r2._call = function() {
          r2._render(scene);
        };
        r2._call();
        r2._call = null;
        return r2;
      },
      _render() {
      },
      renderAsync(scene) {
        const r2 = this.render(scene);
        return this._ready ? this._ready.then(() => r2) : Promise.resolve(r2);
      },
      _load(method3, uri) {
        var r2 = this, p = r2._loader[method3](uri);
        if (!r2._ready) {
          const call = r2._call;
          r2._ready = r2._loader.ready().then((redraw) => {
            if (redraw)
              call();
            r2._ready = null;
          });
        }
        return p;
      },
      sanitizeURL(uri) {
        return this._load("sanitizeURL", uri);
      },
      loadImage(uri) {
        return this._load("loadImage", uri);
      }
    };
    KeyDownEvent = "keydown";
    KeyPressEvent = "keypress";
    KeyUpEvent = "keyup";
    DragEnterEvent = "dragenter";
    DragLeaveEvent = "dragleave";
    DragOverEvent = "dragover";
    MouseDownEvent = "mousedown";
    MouseUpEvent = "mouseup";
    MouseMoveEvent = "mousemove";
    MouseOutEvent = "mouseout";
    MouseOverEvent = "mouseover";
    ClickEvent = "click";
    DoubleClickEvent = "dblclick";
    WheelEvent = "wheel";
    MouseWheelEvent = "mousewheel";
    TouchStartEvent = "touchstart";
    TouchMoveEvent = "touchmove";
    TouchEndEvent = "touchend";
    Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
    TooltipShowEvent = MouseMoveEvent;
    TooltipHideEvent = MouseOutEvent;
    HrefEvent = ClickEvent;
    eventBundle = (type4) => type4 === TouchStartEvent || type4 === TouchMoveEvent || type4 === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type4];
    inherits2(CanvasHandler, Handler, {
      initialize(el, origin, obj) {
        this._canvas = el && domFind(el, "canvas");
        [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach((type4) => eventListenerCheck(this, type4));
        return Handler.prototype.initialize.call(this, el, origin, obj);
      },
      canvas() {
        return this._canvas;
      },
      context() {
        return this._canvas.getContext("2d");
      },
      events: Events,
      DOMMouseScroll(evt) {
        this.fire(MouseWheelEvent, evt);
      },
      mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),
      dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),
      mouseout: inactive(MouseOutEvent),
      dragleave: inactive(DragLeaveEvent),
      mousedown(evt) {
        this._down = this._active;
        this.fire(MouseDownEvent, evt);
      },
      click(evt) {
        if (this._down === this._active) {
          this.fire(ClickEvent, evt);
          this._down = null;
        }
      },
      touchstart(evt) {
        this._touch = this.pickEvent(evt.changedTouches[0]);
        if (this._first) {
          this._active = this._touch;
          this._first = false;
        }
        this.fire(TouchStartEvent, evt, true);
      },
      touchmove(evt) {
        this.fire(TouchMoveEvent, evt, true);
      },
      touchend(evt) {
        this.fire(TouchEndEvent, evt, true);
        this._touch = null;
      },
      fire(type4, evt, touch2) {
        const a4 = touch2 ? this._touch : this._active, h4 = this._handlers[type4];
        evt.vegaType = type4;
        if (type4 === HrefEvent && a4 && a4.href) {
          this.handleHref(evt, a4, a4.href);
        } else if (type4 === TooltipShowEvent || type4 === TooltipHideEvent) {
          this.handleTooltip(evt, a4, type4 !== TooltipHideEvent);
        }
        if (h4) {
          for (let i = 0, len = h4.length; i < len; ++i) {
            h4[i].handler.call(this._obj, evt, a4);
          }
        }
      },
      on(type4, handler) {
        const name4 = this.eventName(type4), h4 = this._handlers, i = this._handlerIndex(h4[name4], type4, handler);
        if (i < 0) {
          eventListenerCheck(this, type4);
          (h4[name4] || (h4[name4] = [])).push({
            type: type4,
            handler
          });
        }
        return this;
      },
      off(type4, handler) {
        const name4 = this.eventName(type4), h4 = this._handlers[name4], i = this._handlerIndex(h4, type4, handler);
        if (i >= 0) {
          h4.splice(i, 1);
        }
        return this;
      },
      pickEvent(evt) {
        const p = point7(evt, this._canvas), o = this._origin;
        return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
      },
      pick(scene, x7, y7, gx, gy) {
        const g = this.context(), mark = Marks[scene.marktype];
        return mark.pick.call(this, g, scene, x7, y7, gx, gy);
      }
    });
    pixelRatio = devicePixelRatio();
    base$1 = Renderer.prototype;
    viewBounds = (origin, width2, height2) => new Bounds().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
    inherits2(CanvasRenderer, Renderer, {
      initialize(el, width2, height2, origin, scaleFactor, options2) {
        this._options = options2 || {};
        this._canvas = this._options.externalContext ? null : domCanvas(1, 1, this._options.type);
        if (el && this._canvas) {
          domClear(el, 0).appendChild(this._canvas);
          this._canvas.setAttribute("class", "marks");
        }
        return base$1.initialize.call(this, el, width2, height2, origin, scaleFactor);
      },
      resize(width2, height2, origin, scaleFactor) {
        base$1.resize.call(this, width2, height2, origin, scaleFactor);
        if (this._canvas) {
          resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
        } else {
          const ctx = this._options.externalContext;
          if (!ctx)
            error2("CanvasRenderer is missing a valid canvas or context");
          ctx.scale(this._scale, this._scale);
          ctx.translate(this._origin[0], this._origin[1]);
        }
        this._redraw = true;
        return this;
      },
      canvas() {
        return this._canvas;
      },
      context() {
        return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
      },
      dirty(item) {
        const b3 = this._tempb.clear().union(item.bounds);
        let g = item.mark.group;
        while (g) {
          b3.translate(g.x || 0, g.y || 0);
          g = g.mark.group;
        }
        this._dirty.union(b3);
      },
      _render(scene) {
        const g = this.context(), o = this._origin, w5 = this._width, h4 = this._height, db = this._dirty, vb = viewBounds(o, w5, h4);
        g.save();
        const b3 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
        this.clear(-o[0], -o[1], w5, h4);
        this.draw(g, scene, b3);
        g.restore();
        db.clear();
        return this;
      },
      draw(ctx, scene, bounds3) {
        const mark = Marks[scene.marktype];
        if (scene.clip)
          clip(ctx, scene);
        mark.draw.call(this, ctx, scene, bounds3);
        if (scene.clip)
          ctx.restore();
      },
      clear(x7, y7, w5, h4) {
        const opt = this._options, g = this.context();
        if (opt.type !== "pdf" && !opt.externalContext) {
          g.clearRect(x7, y7, w5, h4);
        }
        if (this._bgcolor != null) {
          g.fillStyle = this._bgcolor;
          g.fillRect(x7, y7, w5, h4);
        }
      }
    });
    listener = (context4, handler) => (evt) => {
      let item = evt.target.__data__;
      item = Array.isArray(item) ? item[0] : item;
      evt.vegaType = evt.type;
      handler.call(context4._obj, evt, item);
    };
    inherits2(SVGHandler, Handler, {
      initialize(el, origin, obj) {
        let svg = this._svg;
        if (svg) {
          svg.removeEventListener(HrefEvent, this._hrefHandler);
          svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
          svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
        }
        this._svg = svg = el && domFind(el, "svg");
        if (svg) {
          svg.addEventListener(HrefEvent, this._hrefHandler);
          svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
          svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
        }
        return Handler.prototype.initialize.call(this, el, origin, obj);
      },
      canvas() {
        return this._svg;
      },
      on(type4, handler) {
        const name4 = this.eventName(type4), h4 = this._handlers, i = this._handlerIndex(h4[name4], type4, handler);
        if (i < 0) {
          const x7 = {
            type: type4,
            handler,
            listener: listener(this, handler)
          };
          (h4[name4] || (h4[name4] = [])).push(x7);
          if (this._svg) {
            this._svg.addEventListener(name4, x7.listener);
          }
        }
        return this;
      },
      off(type4, handler) {
        const name4 = this.eventName(type4), h4 = this._handlers[name4], i = this._handlerIndex(h4, type4, handler);
        if (i >= 0) {
          if (this._svg) {
            this._svg.removeEventListener(name4, h4[i].listener);
          }
          h4.splice(i, 1);
        }
        return this;
      }
    });
    ARIA_HIDDEN = "aria-hidden";
    ARIA_LABEL = "aria-label";
    ARIA_ROLE = "role";
    ARIA_ROLEDESCRIPTION = "aria-roledescription";
    GRAPHICS_OBJECT = "graphics-object";
    GRAPHICS_SYMBOL = "graphics-symbol";
    bundle = (role, roledesc, label) => ({
      [ARIA_ROLE]: role,
      [ARIA_ROLEDESCRIPTION]: roledesc,
      [ARIA_LABEL]: label || void 0
    });
    AriaIgnore = toSet2(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
    AriaGuides = {
      "axis": {
        desc: "axis",
        caption: axisCaption
      },
      "legend": {
        desc: "legend",
        caption: legendCaption
      },
      "title-text": {
        desc: "title",
        caption: (item) => `Title text '${titleCaption(item)}'`
      },
      "title-subtitle": {
        desc: "subtitle",
        caption: (item) => `Subtitle text '${titleCaption(item)}'`
      }
    };
    AriaEncode = {
      ariaRole: ARIA_ROLE,
      ariaRoleDescription: ARIA_ROLEDESCRIPTION,
      description: ARIA_LABEL
    };
    innerText = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    attrText = (val) => innerText(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
    serializeXML = (node) => _serialize(markup(), node) + "";
    stylesAttr = {
      fill: "fill",
      fillOpacity: "fill-opacity",
      stroke: "stroke",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      strokeCap: "stroke-linecap",
      strokeJoin: "stroke-linejoin",
      strokeDash: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeMiterLimit: "stroke-miterlimit",
      opacity: "opacity"
    };
    stylesCss = {
      blend: "mix-blend-mode"
    };
    rootAttributes = {
      "fill": "none",
      "stroke-miterlimit": 10
    };
    RootIndex = 0;
    xmlns = "http://www.w3.org/2000/xmlns/";
    svgns = metadata.xmlns;
    base = Renderer.prototype;
    inherits2(SVGRenderer, Renderer, {
      initialize(el, width2, height2, origin, scaleFactor) {
        this._defs = {};
        this._clearDefs();
        if (el) {
          this._svg = domChild(el, 0, "svg", svgns);
          this._svg.setAttributeNS(xmlns, "xmlns", svgns);
          this._svg.setAttributeNS(xmlns, "xmlns:xlink", metadata["xmlns:xlink"]);
          this._svg.setAttribute("version", metadata["version"]);
          this._svg.setAttribute("class", "marks");
          domClear(el, 1);
          this._root = domChild(this._svg, RootIndex, "g", svgns);
          setAttributes(this._root, rootAttributes);
          domClear(this._svg, RootIndex + 1);
        }
        this.background(this._bgcolor);
        return base.initialize.call(this, el, width2, height2, origin, scaleFactor);
      },
      background(bgcolor) {
        if (arguments.length && this._svg) {
          this._svg.style.setProperty("background-color", bgcolor);
        }
        return base.background.apply(this, arguments);
      },
      resize(width2, height2, origin, scaleFactor) {
        base.resize.call(this, width2, height2, origin, scaleFactor);
        if (this._svg) {
          setAttributes(this._svg, {
            width: this._width * this._scale,
            height: this._height * this._scale,
            viewBox: `0 0 ${this._width} ${this._height}`
          });
          this._root.setAttribute("transform", `translate(${this._origin})`);
        }
        this._dirty = [];
        return this;
      },
      canvas() {
        return this._svg;
      },
      svg() {
        const svg = this._svg, bg = this._bgcolor;
        if (!svg)
          return null;
        let node;
        if (bg) {
          svg.removeAttribute("style");
          node = domChild(svg, RootIndex, "rect", svgns);
          setAttributes(node, {
            width: this._width,
            height: this._height,
            fill: bg
          });
        }
        const text5 = serializeXML(svg);
        if (bg) {
          svg.removeChild(node);
          this._svg.style.setProperty("background-color", bg);
        }
        return text5;
      },
      _render(scene) {
        if (this._dirtyCheck()) {
          if (this._dirtyAll)
            this._clearDefs();
          this.mark(this._root, scene);
          domClear(this._root, 1);
        }
        this.defs();
        this._dirty = [];
        ++this._dirtyID;
        return this;
      },
      dirty(item) {
        if (item.dirty !== this._dirtyID) {
          item.dirty = this._dirtyID;
          this._dirty.push(item);
        }
      },
      isDirty(item) {
        return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
      },
      _dirtyCheck() {
        this._dirtyAll = true;
        const items2 = this._dirty;
        if (!items2.length || !this._dirtyID)
          return true;
        const id4 = ++this._dirtyID;
        let item, mark, type4, mdef, i, n, o;
        for (i = 0, n = items2.length; i < n; ++i) {
          item = items2[i];
          mark = item.mark;
          if (mark.marktype !== type4) {
            type4 = mark.marktype;
            mdef = Marks[type4];
          }
          if (mark.zdirty && mark.dirty !== id4) {
            this._dirtyAll = false;
            dirtyParents(item, id4);
            mark.items.forEach((i2) => {
              i2.dirty = id4;
            });
          }
          if (mark.zdirty)
            continue;
          if (item.exit) {
            if (mdef.nested && mark.items.length) {
              o = mark.items[0];
              if (o._svg)
                this._update(mdef, o._svg, o);
            } else if (item._svg) {
              o = item._svg.parentNode;
              if (o)
                o.removeChild(item._svg);
            }
            item._svg = null;
            continue;
          }
          item = mdef.nested ? mark.items[0] : item;
          if (item._update === id4)
            continue;
          if (!item._svg || !item._svg.ownerSVGElement) {
            this._dirtyAll = false;
            dirtyParents(item, id4);
          } else {
            this._update(mdef, item._svg, item);
          }
          item._update = id4;
        }
        return !this._dirtyAll;
      },
      mark(el, scene, prev) {
        if (!this.isDirty(scene)) {
          return scene._svg;
        }
        const svg = this._svg, mdef = Marks[scene.marktype], events4 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
        const parent = bind(scene, el, prev, "g", svg);
        parent.setAttribute("class", cssClass(scene));
        const aria2 = ariaMarkAttributes(scene);
        for (const key3 in aria2)
          setAttribute(parent, key3, aria2[key3]);
        if (!isGroup) {
          setAttribute(parent, "pointer-events", events4);
        }
        setAttribute(parent, "clip-path", scene.clip ? clip$1(this, scene, scene.group) : null);
        let sibling = null, i = 0;
        const process2 = (item) => {
          const dirty = this.isDirty(item), node = bind(item, parent, sibling, mdef.tag, svg);
          if (dirty) {
            this._update(mdef, node, item);
            if (isGroup)
              recurse(this, node, item);
          }
          sibling = node;
          ++i;
        };
        if (mdef.nested) {
          if (scene.items.length)
            process2(scene.items[0]);
        } else {
          visit(scene, process2);
        }
        domClear(parent, i);
        return parent;
      },
      _update(mdef, el, item) {
        element = el;
        values = el.__values__;
        ariaItemAttributes(emit, item);
        mdef.attr(emit, item, this);
        const extra = mark_extras[mdef.type];
        if (extra)
          extra.call(this, mdef, el, item);
        if (element)
          this.style(element, item);
      },
      style(el, item) {
        if (item == null)
          return;
        for (const prop in stylesAttr) {
          let value4 = prop === "font" ? fontFamily(item) : item[prop];
          if (value4 === values[prop])
            continue;
          const name4 = stylesAttr[prop];
          if (value4 == null) {
            el.removeAttribute(name4);
          } else {
            if (isGradient(value4)) {
              value4 = gradientRef(value4, this._defs.gradient, href());
            }
            el.setAttribute(name4, value4 + "");
          }
          values[prop] = value4;
        }
        for (const prop in stylesCss) {
          setStyle(el, stylesCss[prop], item[prop]);
        }
      },
      defs() {
        const svg = this._svg, defs = this._defs;
        let el = defs.el, index8 = 0;
        for (const id4 in defs.gradient) {
          if (!el)
            defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
          index8 = updateGradient(el, defs.gradient[id4], index8);
        }
        for (const id4 in defs.clipping) {
          if (!el)
            defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
          index8 = updateClipping(el, defs.clipping[id4], index8);
        }
        if (el) {
          index8 === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index8);
        }
      },
      _clearDefs() {
        const def3 = this._defs;
        def3.gradient = {};
        def3.clipping = {};
      }
    });
    element = null;
    values = null;
    mark_extras = {
      group(mdef, el, item) {
        const fg = element = el.childNodes[2];
        values = fg.__values__;
        mdef.foreground(emit, item, this);
        values = el.__values__;
        element = el.childNodes[1];
        mdef.content(emit, item, this);
        const bg = element = el.childNodes[0];
        mdef.background(emit, item, this);
        const value4 = item.mark.interactive === false ? "none" : null;
        if (value4 !== values.events) {
          setAttribute(fg, "pointer-events", value4);
          setAttribute(bg, "pointer-events", value4);
          values.events = value4;
        }
        if (item.strokeForeground && item.stroke) {
          const fill3 = item.fill;
          setAttribute(fg, "display", null);
          this.style(bg, item);
          setAttribute(bg, "stroke", null);
          if (fill3)
            item.fill = null;
          values = fg.__values__;
          this.style(fg, item);
          if (fill3)
            item.fill = fill3;
          element = null;
        } else {
          setAttribute(fg, "display", "none");
        }
      },
      image(mdef, el, item) {
        if (item.smooth === false) {
          setStyle(el, "image-rendering", "optimizeSpeed");
          setStyle(el, "image-rendering", "pixelated");
        } else {
          setStyle(el, "image-rendering", null);
        }
      },
      text(mdef, el, item) {
        const tl3 = textLines(item);
        let key3, value4, doc, lh;
        if (isArray2(tl3)) {
          value4 = tl3.map((_) => textValue(item, _));
          key3 = value4.join("\n");
          if (key3 !== values.text) {
            domClear(el, 0);
            doc = el.ownerDocument;
            lh = lineHeight(item);
            value4.forEach((t, i) => {
              const ts3 = domCreate(doc, "tspan", svgns);
              ts3.__data__ = item;
              ts3.textContent = t;
              if (i) {
                ts3.setAttribute("x", 0);
                ts3.setAttribute("dy", lh);
              }
              el.appendChild(ts3);
            });
            values.text = key3;
          }
        } else {
          value4 = textValue(item, tl3);
          if (value4 !== values.text) {
            el.textContent = value4;
            values.text = value4;
          }
        }
        setAttribute(el, "font-family", fontFamily(item));
        setAttribute(el, "font-size", fontSize(item) + "px");
        setAttribute(el, "font-style", item.fontStyle);
        setAttribute(el, "font-variant", item.fontVariant);
        setAttribute(el, "font-weight", item.fontWeight);
      }
    };
    inherits2(SVGStringRenderer, Renderer, {
      svg() {
        return this._text;
      },
      _render(scene) {
        const m2 = markup();
        m2.open("svg", extend2({}, metadata, {
          class: "marks",
          width: this._width * this._scale,
          height: this._height * this._scale,
          viewBox: `0 0 ${this._width} ${this._height}`
        }));
        const bg = this._bgcolor;
        if (bg && bg !== "transparent" && bg !== "none") {
          m2.open("rect", {
            width: this._width,
            height: this._height,
            fill: bg
          }).close();
        }
        m2.open("g", rootAttributes, {
          transform: "translate(" + this._origin + ")"
        });
        this.mark(m2, scene);
        m2.close();
        this.defs(m2);
        this._text = m2.close() + "";
        return this;
      },
      mark(m2, scene) {
        const mdef = Marks[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes, mdef.attr];
        m2.open("g", {
          "class": cssClass(scene),
          "clip-path": scene.clip ? clip$1(this, scene, scene.group) : null
        }, ariaMarkAttributes(scene), {
          "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
        });
        const process2 = (item) => {
          const href3 = this.href(item);
          if (href3)
            m2.open("a", href3);
          m2.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
          if (tag === "text") {
            const tl3 = textLines(item);
            if (isArray2(tl3)) {
              const attrs = {
                x: 0,
                dy: lineHeight(item)
              };
              for (let i = 0; i < tl3.length; ++i) {
                m2.open("tspan", i ? attrs : null).text(textValue(item, tl3[i])).close();
              }
            } else {
              m2.text(textValue(item, tl3));
            }
          } else if (tag === "g") {
            const fore = item.strokeForeground, fill3 = item.fill, stroke3 = item.stroke;
            if (fore && stroke3) {
              item.stroke = null;
            }
            m2.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
            m2.open("g", this.attr(scene, item, mdef.content));
            visit(item, (scene2) => this.mark(m2, scene2));
            m2.close();
            if (fore && stroke3) {
              if (fill3)
                item.fill = null;
              item.stroke = stroke3;
              m2.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
              if (fill3)
                item.fill = fill3;
            } else {
              m2.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
            }
          }
          m2.close();
          if (href3)
            m2.close();
        };
        if (mdef.nested) {
          if (scene.items && scene.items.length)
            process2(scene.items[0]);
        } else {
          visit(scene, process2);
        }
        return m2.close();
      },
      href(item) {
        const href3 = item.href;
        let attr3;
        if (href3) {
          if (attr3 = this._hrefs && this._hrefs[href3]) {
            return attr3;
          } else {
            this.sanitizeURL(href3).then((attr4) => {
              attr4["xlink:href"] = attr4.href;
              attr4.href = null;
              (this._hrefs || (this._hrefs = {}))[href3] = attr4;
            });
          }
        }
        return null;
      },
      attr(scene, item, attrs, tag) {
        const object2 = {}, emit3 = (name4, value4, ns, prefixed) => {
          object2[prefixed || name4] = value4;
        };
        if (Array.isArray(attrs)) {
          attrs.forEach((fn) => fn(emit3, item, this));
        } else {
          attrs(emit3, item, this);
        }
        if (tag) {
          style(object2, item, scene, tag, this._defs);
        }
        return object2;
      },
      defs(m2) {
        const gradient5 = this._defs.gradient, clipping = this._defs.clipping, count5 = Object.keys(gradient5).length + Object.keys(clipping).length;
        if (count5 === 0)
          return;
        m2.open("defs");
        for (const id4 in gradient5) {
          const def3 = gradient5[id4], stops = def3.stops;
          if (def3.gradient === "radial") {
            m2.open("pattern", {
              id: patternPrefix + id4,
              viewBox: "0,0,1,1",
              width: "100%",
              height: "100%",
              preserveAspectRatio: "xMidYMid slice"
            });
            m2.open("rect", {
              width: "1",
              height: "1",
              fill: "url(#" + id4 + ")"
            }).close();
            m2.close();
            m2.open("radialGradient", {
              id: id4,
              fx: def3.x1,
              fy: def3.y1,
              fr: def3.r1,
              cx: def3.x2,
              cy: def3.y2,
              r: def3.r2
            });
          } else {
            m2.open("linearGradient", {
              id: id4,
              x1: def3.x1,
              x2: def3.x2,
              y1: def3.y1,
              y2: def3.y2
            });
          }
          for (let i = 0; i < stops.length; ++i) {
            m2.open("stop", {
              offset: stops[i].offset,
              "stop-color": stops[i].color
            }).close();
          }
          m2.close();
        }
        for (const id4 in clipping) {
          const def3 = clipping[id4];
          m2.open("clipPath", {
            id: id4
          });
          if (def3.path) {
            m2.open("path", {
              d: def3.path
            }).close();
          } else {
            m2.open("rect", {
              x: 0,
              y: 0,
              width: def3.width,
              height: def3.height
            }).close();
          }
          m2.close();
        }
        m2.close();
      }
    });
    Canvas = "canvas";
    PNG = "png";
    SVG = "svg";
    None3 = "none";
    modules = {};
    modules[Canvas] = modules[PNG] = {
      renderer: CanvasRenderer,
      headless: CanvasRenderer,
      handler: CanvasHandler
    };
    modules[SVG] = {
      renderer: SVGRenderer,
      headless: SVGStringRenderer,
      handler: SVGHandler
    };
    modules[None3] = {};
    clipBounds = new Bounds();
  }
});

// node_modules/.pnpm/vega-view-transforms@4.5.9/node_modules/vega-view-transforms/build/vega-view-transforms.module.js
var vega_view_transforms_module_exports = {};
__export(vega_view_transforms_module_exports, {
  bound: () => Bound,
  identifier: () => Identifier,
  mark: () => Mark,
  overlap: () => Overlap,
  render: () => Render,
  viewlayout: () => ViewLayout
});
function Bound(params2) {
  Transform.call(this, null, params2);
}
function boundItem2(item, bound3, opt) {
  return bound3(item.bounds.clear(), item, opt);
}
function Identifier(params2) {
  Transform.call(this, 0, params2);
}
function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}
function Mark(params2) {
  Transform.call(this, null, params2);
}
function lookup$1(_) {
  const g = _.groups, p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}
function Overlap(params2) {
  Transform.call(this, null, params2);
}
function Render(params2) {
  Transform.call(this, null, params2);
}
function set3(item, property2, value4) {
  return item[property2] === value4 ? 0 : (item[property2] = value4, 1);
}
function isYAxis(mark) {
  var orient3 = mark.items[0].orient;
  return orient3 === Left || orient3 === Right;
}
function axisIndices(datum2) {
  let index8 = +datum2.grid;
  return [
    datum2.ticks ? index8++ : -1,
    datum2.labels ? index8++ : -1,
    index8 + +datum2.domain
  ];
}
function axisLayout(view, axis, width2, height2) {
  var item = axis.items[0], datum2 = item.datum, delta = item.translate != null ? item.translate : 0.5, orient3 = item.orient, indices = axisIndices(datum2), range7 = item.range, offset5 = item.offset, position2 = item.position, minExtent = item.minExtent, maxExtent = item.maxExtent, title2 = datum2.title && item.items[indices[2]].items[0], titlePadding = item.titlePadding, bounds3 = item.bounds, dl = title2 && multiLineOffset(title2), x7 = 0, y7 = 0, i, s3;
  tempBounds2.clear().union(bounds3);
  bounds3.clear();
  if ((i = indices[0]) > -1)
    bounds3.union(item.items[i].bounds);
  if ((i = indices[1]) > -1)
    bounds3.union(item.items[i].bounds);
  switch (orient3) {
    case Top:
      x7 = position2 || 0;
      y7 = -offset5;
      s3 = Math.max(minExtent, Math.min(maxExtent, -bounds3.y1));
      bounds3.add(0, -s3).add(range7, 0);
      if (title2)
        axisTitleLayout(view, title2, s3, titlePadding, dl, 0, -1, bounds3);
      break;
    case Left:
      x7 = -offset5;
      y7 = position2 || 0;
      s3 = Math.max(minExtent, Math.min(maxExtent, -bounds3.x1));
      bounds3.add(-s3, 0).add(0, range7);
      if (title2)
        axisTitleLayout(view, title2, s3, titlePadding, dl, 1, -1, bounds3);
      break;
    case Right:
      x7 = width2 + offset5;
      y7 = position2 || 0;
      s3 = Math.max(minExtent, Math.min(maxExtent, bounds3.x2));
      bounds3.add(0, 0).add(s3, range7);
      if (title2)
        axisTitleLayout(view, title2, s3, titlePadding, dl, 1, 1, bounds3);
      break;
    case Bottom:
      x7 = position2 || 0;
      y7 = height2 + offset5;
      s3 = Math.max(minExtent, Math.min(maxExtent, bounds3.y2));
      bounds3.add(0, 0).add(range7, s3);
      if (title2)
        axisTitleLayout(view, title2, s3, titlePadding, 0, 0, 1, bounds3);
      break;
    default:
      x7 = item.x;
      y7 = item.y;
  }
  boundStroke(bounds3.translate(x7, y7), item);
  if (set3(item, "x", x7 + delta) | set3(item, "y", y7 + delta)) {
    item.bounds = tempBounds2;
    view.dirty(item);
    item.bounds = bounds3;
    view.dirty(item);
  }
  return item.mark.bounds.clear().union(bounds3);
}
function axisTitleLayout(view, title2, offset5, pad6, dl, isYAxis2, sign5, bounds3) {
  const b3 = title2.bounds;
  if (title2.auto) {
    const v = sign5 * (offset5 + dl + pad6);
    let dx = 0, dy = 0;
    view.dirty(title2);
    isYAxis2 ? dx = (title2.x || 0) - (title2.x = v) : dy = (title2.y || 0) - (title2.y = v);
    title2.mark.bounds.clear().union(b3.translate(-dx, -dy));
    view.dirty(title2);
  }
  bounds3.union(b3);
}
function gridLayoutGroups(group6) {
  var groups4 = group6.items, n = groups4.length, i = 0, mark, items2;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; i < n; ++i) {
    mark = groups4[i];
    items2 = mark.items;
    if (mark.marktype === Group) {
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          break;
        case RowHeader:
          views.rowheaders.push(...items2);
          break;
        case RowFooter:
          views.rowfooters.push(...items2);
          break;
        case ColHeader:
          views.colheaders.push(...items2);
          break;
        case ColFooter:
          views.colfooters.push(...items2);
          break;
        case RowTitle:
          views.rowtitle = items2[0];
          break;
        case ColTitle:
          views.coltitle = items2[0];
          break;
        default:
          views.marks.push(...items2);
      }
    }
  }
  return views;
}
function bboxFlush(item) {
  return new Bounds().set(0, 0, item.width || 0, item.height || 0);
}
function bboxFull(item) {
  const b3 = item.bounds.clone();
  return b3.empty() ? b3.set(0, 0, 0, 0) : b3.translate(-(item.x || 0), -(item.y || 0));
}
function get4(opt, key3, d) {
  const v = isObject2(opt) ? opt[key3] : opt;
  return v != null ? v : d !== void 0 ? d : 0;
}
function offsetValue(v) {
  return v < 0 ? Math.ceil(-v) : 0;
}
function gridLayout(view, groups4, opt) {
  var dirty = !opt.nodirty, bbox = opt.bounds === Flush ? bboxFlush : bboxFull, bounds3 = tempBounds2.set(0, 0, 0, 0), alignCol = get4(opt.align, Column), alignRow = get4(opt.align, Row), padCol = get4(opt.padding, Column), padRow = get4(opt.padding, Row), ncols = opt.columns || groups4.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups4.length / ncols), n = groups4.length, xOffset = Array(n), xExtent = Array(ncols), xMax = 0, yOffset = Array(n), yExtent = Array(nrows), yMax = 0, dx = Array(n), dy = Array(n), boxes = Array(n), m2, i, c2, r2, b3, g, px3, py3, x7, y7, offset5;
  for (i = 0; i < ncols; ++i)
    xExtent[i] = 0;
  for (i = 0; i < nrows; ++i)
    yExtent[i] = 0;
  for (i = 0; i < n; ++i) {
    g = groups4[i];
    b3 = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c2 = i % ncols;
    r2 = ~~(i / ncols);
    xMax = Math.max(xMax, px3 = Math.ceil(b3.x2));
    yMax = Math.max(yMax, py3 = Math.ceil(b3.y2));
    xExtent[c2] = Math.max(xExtent[c2], px3);
    yExtent[r2] = Math.max(yExtent[r2], py3);
    xOffset[i] = padCol + offsetValue(b3.x1);
    yOffset[i] = padRow + offsetValue(b3.y1);
    if (dirty)
      view.dirty(groups4[i]);
  }
  for (i = 0; i < n; ++i) {
    if (i % ncols === 0)
      xOffset[i] = 0;
    if (i < ncols)
      yOffset[i] = 0;
  }
  if (alignCol === Each) {
    for (c2 = 1; c2 < ncols; ++c2) {
      for (offset5 = 0, i = c2; i < n; i += ncols) {
        if (offset5 < xOffset[i])
          offset5 = xOffset[i];
      }
      for (i = c2; i < n; i += ncols) {
        xOffset[i] = offset5 + xExtent[c2 - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset5 = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset5 < xOffset[i])
        offset5 = xOffset[i];
    }
    for (i = 0; i < n; ++i) {
      if (i % ncols)
        xOffset[i] = offset5 + xMax;
    }
  } else {
    for (alignCol = false, c2 = 1; c2 < ncols; ++c2) {
      for (i = c2; i < n; i += ncols) {
        xOffset[i] += xExtent[c2 - 1];
      }
    }
  }
  if (alignRow === Each) {
    for (r2 = 1; r2 < nrows; ++r2) {
      for (offset5 = 0, i = r2 * ncols, m2 = i + ncols; i < m2; ++i) {
        if (offset5 < yOffset[i])
          offset5 = yOffset[i];
      }
      for (i = r2 * ncols; i < m2; ++i) {
        yOffset[i] = offset5 + yExtent[r2 - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset5 = 0, i = ncols; i < n; ++i) {
      if (offset5 < yOffset[i])
        offset5 = yOffset[i];
    }
    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset5 + yMax;
    }
  } else {
    for (alignRow = false, r2 = 1; r2 < nrows; ++r2) {
      for (i = r2 * ncols, m2 = i + ncols; i < m2; ++i) {
        yOffset[i] += yExtent[r2 - 1];
      }
    }
  }
  for (x7 = 0, i = 0; i < n; ++i) {
    x7 = xOffset[i] + (i % ncols ? x7 : 0);
    dx[i] += x7 - groups4[i].x;
  }
  for (c2 = 0; c2 < ncols; ++c2) {
    for (y7 = 0, i = c2; i < n; i += ncols) {
      y7 += yOffset[i];
      dy[i] += y7 - groups4[i].y;
    }
  }
  if (alignCol && get4(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b3 = alignCol === All ? xMax : xExtent[i % ncols];
      x7 = b3 - boxes[i].x2 - groups4[i].x - dx[i];
      if (x7 > 0)
        dx[i] += x7 / 2;
    }
  }
  if (alignRow && get4(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b3 = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y7 = b3 - boxes[i].y2 - groups4[i].y - dy[i];
      if (y7 > 0)
        dy[i] += y7 / 2;
    }
  }
  for (i = 0; i < n; ++i) {
    bounds3.union(boxes[i].translate(dx[i], dy[i]));
  }
  x7 = get4(opt.anchor, X);
  y7 = get4(opt.anchor, Y);
  switch (get4(opt.anchor, Column)) {
    case End:
      x7 -= bounds3.width();
      break;
    case Middle:
      x7 -= bounds3.width() / 2;
  }
  switch (get4(opt.anchor, Row)) {
    case End:
      y7 -= bounds3.height();
      break;
    case Middle:
      y7 -= bounds3.height() / 2;
  }
  x7 = Math.round(x7);
  y7 = Math.round(y7);
  bounds3.clear();
  for (i = 0; i < n; ++i) {
    groups4[i].mark.bounds.clear();
  }
  for (i = 0; i < n; ++i) {
    g = groups4[i];
    g.x += dx[i] += x7;
    g.y += dy[i] += y7;
    bounds3.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty)
      view.dirty(g);
  }
  return bounds3;
}
function trellisLayout(view, group6, opt) {
  var views = gridLayoutGroups(group6), groups4 = views.marks, bbox = opt.bounds === Flush ? boundFlush : boundFull, off = opt.offset, ncols = opt.columns || groups4.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups4.length / ncols), cells = nrows * ncols, x7, y7, x22, y22, anchor, band5, offset5;
  const bounds3 = gridLayout(view, groups4, opt);
  if (bounds3.empty())
    bounds3.set(0, 0, 0, 0);
  if (views.rowheaders) {
    band5 = get4(opt.headerBand, Row, null);
    x7 = layoutHeaders(view, views.rowheaders, groups4, ncols, nrows, -get4(off, "rowHeader"), min4, 0, bbox, "x1", 0, ncols, 1, band5);
  }
  if (views.colheaders) {
    band5 = get4(opt.headerBand, Column, null);
    y7 = layoutHeaders(view, views.colheaders, groups4, ncols, ncols, -get4(off, "columnHeader"), min4, 1, bbox, "y1", 0, 1, ncols, band5);
  }
  if (views.rowfooters) {
    band5 = get4(opt.footerBand, Row, null);
    x22 = layoutHeaders(view, views.rowfooters, groups4, ncols, nrows, get4(off, "rowFooter"), max4, 0, bbox, "x2", ncols - 1, ncols, 1, band5);
  }
  if (views.colfooters) {
    band5 = get4(opt.footerBand, Column, null);
    y22 = layoutHeaders(view, views.colfooters, groups4, ncols, ncols, get4(off, "columnFooter"), max4, 1, bbox, "y2", cells - ncols, 1, ncols, band5);
  }
  if (views.rowtitle) {
    anchor = get4(opt.titleAnchor, Row);
    offset5 = get4(off, "rowTitle");
    offset5 = anchor === End ? x22 + offset5 : x7 - offset5;
    band5 = get4(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset5, 0, bounds3, band5);
  }
  if (views.coltitle) {
    anchor = get4(opt.titleAnchor, Column);
    offset5 = get4(off, "columnTitle");
    offset5 = anchor === End ? y22 + offset5 : y7 - offset5;
    band5 = get4(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset5, 1, bounds3, band5);
  }
}
function boundFlush(item, field4) {
  return field4 === "x1" ? item.x || 0 : field4 === "y1" ? item.y || 0 : field4 === "x2" ? (item.x || 0) + (item.width || 0) : field4 === "y2" ? (item.y || 0) + (item.height || 0) : void 0;
}
function boundFull(item, field4) {
  return item.bounds[field4];
}
function layoutHeaders(view, headers, groups4, ncols, limit, offset5, agg, isX2, bound3, bf, start, stride, back, band5) {
  var n = groups4.length, init2 = 0, edge = 0, i, j, k4, m2, b3, h4, g, x7, y7;
  if (!n)
    return init2;
  for (i = start; i < n; i += stride) {
    if (groups4[i])
      init2 = agg(init2, bound3(groups4[i], bf));
  }
  if (!headers.length)
    return init2;
  if (headers.length > limit) {
    view.warn("Grid headers exceed limit: " + limit);
    headers = headers.slice(0, limit);
  }
  init2 += offset5;
  for (j = 0, m2 = headers.length; j < m2; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  }
  for (i = start, j = 0, m2 = headers.length; j < m2; ++j, i += stride) {
    h4 = headers[j];
    b3 = h4.mark.bounds;
    for (k4 = i; k4 >= 0 && (g = groups4[k4]) == null; k4 -= back)
      ;
    if (isX2) {
      x7 = band5 == null ? g.x : Math.round(g.bounds.x1 + band5 * g.bounds.width());
      y7 = init2;
    } else {
      x7 = init2;
      y7 = band5 == null ? g.y : Math.round(g.bounds.y1 + band5 * g.bounds.height());
    }
    b3.union(h4.bounds.translate(x7 - (h4.x || 0), y7 - (h4.y || 0)));
    h4.x = x7;
    h4.y = y7;
    view.dirty(h4);
    edge = agg(edge, b3[bf]);
  }
  return edge;
}
function layoutTitle(view, g, offset5, isX2, bounds3, band5) {
  if (!g)
    return;
  view.dirty(g);
  var x7 = offset5, y7 = offset5;
  isX2 ? x7 = Math.round(bounds3.x1 + band5 * bounds3.width()) : y7 = Math.round(bounds3.y1 + band5 * bounds3.height());
  g.bounds.translate(x7 - (g.x || 0), y7 - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x7;
  g.y = y7;
  view.dirty(g);
}
function lookup2(config, orient3) {
  const opt = config[orient3] || {};
  return (key3, d) => opt[key3] != null ? opt[key3] : config[key3] != null ? config[key3] : d;
}
function offsets(legends, value4) {
  let max8 = -Infinity;
  legends.forEach((item) => {
    if (item.offset != null)
      max8 = Math.max(max8, item.offset);
  });
  return max8 > -Infinity ? max8 : value4;
}
function legendParams(g, orient3, config, xb, yb, w5, h4) {
  const _ = lookup2(config, orient3), offset5 = offsets(g, _("offset", 0)), anchor = _("anchor", Start), mult2 = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;
  const p = {
    align: Each,
    bounds: _("bounds", Flush),
    columns: _("direction") === "vertical" ? 1 : g.length,
    padding: _("margin", 8),
    center: _("center"),
    nodirty: true
  };
  switch (orient3) {
    case Left:
      p.anchor = {
        x: Math.floor(xb.x1) - offset5,
        column: End,
        y: mult2 * (h4 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Right:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset5,
        y: mult2 * (h4 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Top:
      p.anchor = {
        y: Math.floor(yb.y1) - offset5,
        row: End,
        x: mult2 * (w5 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case Bottom:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset5,
        x: mult2 * (w5 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case TopLeft:
      p.anchor = {
        x: offset5,
        y: offset5
      };
      break;
    case TopRight:
      p.anchor = {
        x: w5 - offset5,
        y: offset5,
        column: End
      };
      break;
    case BottomLeft:
      p.anchor = {
        x: offset5,
        y: h4 - offset5,
        row: End
      };
      break;
    case BottomRight:
      p.anchor = {
        x: w5 - offset5,
        y: h4 - offset5,
        column: End,
        row: End
      };
      break;
  }
  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0], datum2 = item.datum, orient3 = item.orient, bounds3 = item.bounds, x7 = item.x, y7 = item.y, w5, h4;
  item._bounds ? item._bounds.clear().union(bounds3) : item._bounds = bounds3.clone();
  bounds3.clear();
  legendGroupLayout(view, item, item.items[0].items[0]);
  bounds3 = legendBounds(item, bounds3);
  w5 = 2 * item.padding;
  h4 = 2 * item.padding;
  if (!bounds3.empty()) {
    w5 = Math.ceil(bounds3.width() + w5);
    h4 = Math.ceil(bounds3.height() + h4);
  }
  if (datum2.type === Symbols) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }
  if (orient3 !== None4) {
    item.x = x7 = 0;
    item.y = y7 = 0;
  }
  item.width = w5;
  item.height = h4;
  boundStroke(bounds3.set(x7, y7, x7 + w5, y7 + h4), item);
  item.mark.bounds.clear().union(bounds3);
  return item;
}
function legendBounds(item, b3) {
  item.items.forEach((_) => b3.union(_.bounds));
  b3.x1 = item.padding;
  b3.y1 = item.padding;
  return b3;
}
function legendGroupLayout(view, item, entry2) {
  var pad6 = item.padding, ex = pad6 - entry2.x, ey = pad6 - entry2.y;
  if (!item.datum.title) {
    if (ex || ey)
      translate2(view, entry2, ex, ey);
  } else {
    var title2 = item.items[1].items[0], anchor = title2.anchor, tpad = item.titlePadding || 0, tx = pad6 - title2.x, ty = pad6 - title2.y;
    switch (title2.orient) {
      case Left:
        ex += Math.ceil(title2.bounds.width()) + tpad;
        break;
      case Right:
      case Bottom:
        break;
      default:
        ey += title2.bounds.height() + tpad;
    }
    if (ex || ey)
      translate2(view, entry2, ex, ey);
    switch (title2.orient) {
      case Left:
        ty += legendTitleOffset(item, entry2, title2, anchor, 1, 1);
        break;
      case Right:
        tx += legendTitleOffset(item, entry2, title2, End, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry2, title2, anchor, 1, 1);
        break;
      case Bottom:
        tx += legendTitleOffset(item, entry2, title2, anchor, 0, 0);
        ty += legendTitleOffset(item, entry2, title2, End, -1, 0, 1) + tpad;
        break;
      default:
        tx += legendTitleOffset(item, entry2, title2, anchor, 0, 0);
    }
    if (tx || ty)
      translate2(view, title2, tx, ty);
    if ((tx = Math.round(title2.bounds.x1 - pad6)) < 0) {
      translate2(view, entry2, -tx, 0);
      translate2(view, title2, -tx, 0);
    }
  }
}
function legendTitleOffset(item, entry2, title2, anchor, y7, lr, noBar) {
  const grad = item.datum.type !== "symbol", vgrad = title2.datum.vgrad, e3 = grad && (lr || !vgrad) && !noBar ? entry2.items[0] : entry2, s3 = e3.bounds[y7 ? "y2" : "x2"] - item.padding, u = vgrad && lr ? s3 : 0, v = vgrad && lr ? 0 : s3, o = y7 <= 0 ? 0 : multiLineOffset(title2);
  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s3 - o));
}
function translate2(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}
function legendEntryLayout(entries3) {
  const widths = entries3.reduce((w5, g) => {
    w5[g.column] = Math.max(g.bounds.x2 - g.x, w5[g.column] || 0);
    return w5;
  }, {});
  entries3.forEach((g) => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}
function titleLayout(view, mark, width2, height2, viewBounds3) {
  var group6 = mark.items[0], frame2 = group6.frame, orient3 = group6.orient, anchor = group6.anchor, offset5 = group6.offset, padding3 = group6.padding, title2 = group6.items[0].items[0], subtitle = group6.items[1] && group6.items[1].items[0], end = orient3 === Left || orient3 === Right ? height2 : width2, start = 0, x7 = 0, y7 = 0, sx = 0, sy = 0, pos;
  if (frame2 !== Group) {
    orient3 === Left ? (start = viewBounds3.y2, end = viewBounds3.y1) : orient3 === Right ? (start = viewBounds3.y1, end = viewBounds3.y2) : (start = viewBounds3.x1, end = viewBounds3.x2);
  } else if (orient3 === Left) {
    start = height2, end = 0;
  }
  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;
  if (subtitle && subtitle.text) {
    switch (orient3) {
      case Top:
      case Bottom:
        sy = title2.bounds.height() + padding3;
        break;
      case Left:
        sx = title2.bounds.width() + padding3;
        break;
      case Right:
        sx = -title2.bounds.width() - padding3;
        break;
    }
    tempBounds2.clear().union(subtitle.bounds);
    tempBounds2.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));
    if (set3(subtitle, "x", sx) | set3(subtitle, "y", sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds2);
      subtitle.mark.bounds.clear().union(tempBounds2);
      view.dirty(subtitle);
    }
    tempBounds2.clear().union(subtitle.bounds);
  } else {
    tempBounds2.clear();
  }
  tempBounds2.union(title2.bounds);
  switch (orient3) {
    case Top:
      x7 = pos;
      y7 = viewBounds3.y1 - tempBounds2.height() - offset5;
      break;
    case Left:
      x7 = viewBounds3.x1 - tempBounds2.width() - offset5;
      y7 = pos;
      break;
    case Right:
      x7 = viewBounds3.x2 + tempBounds2.width() + offset5;
      y7 = pos;
      break;
    case Bottom:
      x7 = pos;
      y7 = viewBounds3.y2 + offset5;
      break;
    default:
      x7 = group6.x;
      y7 = group6.y;
  }
  if (set3(group6, "x", x7) | set3(group6, "y", y7)) {
    tempBounds2.translate(x7, y7);
    view.dirty(group6);
    group6.bounds.clear().union(tempBounds2);
    mark.bounds.clear().union(tempBounds2);
    view.dirty(group6);
  }
  return group6.bounds;
}
function ViewLayout(params2) {
  Transform.call(this, null, params2);
}
function shouldReflow(group6) {
  return group6 && group6.mark.role !== "legend-entry";
}
function layoutGroup(view, group6, _) {
  var items2 = group6.items, width2 = Math.max(0, group6.width || 0), height2 = Math.max(0, group6.height || 0), viewBounds3 = new Bounds().set(0, 0, width2, height2), xBounds = viewBounds3.clone(), yBounds = viewBounds3.clone(), legends = [], title2, mark, orient3, b3, i, n;
  for (i = 0, n = items2.length; i < n; ++i) {
    mark = items2[i];
    switch (mark.role) {
      case AxisRole:
        b3 = isYAxis(mark) ? xBounds : yBounds;
        b3.union(axisLayout(view, mark, width2, height2));
        break;
      case TitleRole:
        title2 = mark;
        break;
      case LegendRole:
        legends.push(legendLayout(view, mark));
        break;
      case FrameRole:
      case ScopeRole:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark.bounds);
        yBounds.union(mark.bounds);
        break;
      default:
        viewBounds3.union(mark.bounds);
    }
  }
  if (legends.length) {
    const l = {};
    legends.forEach((item) => {
      orient3 = item.orient || Right;
      if (orient3 !== None4)
        (l[orient3] || (l[orient3] = [])).push(item);
    });
    for (const orient4 in l) {
      const g = l[orient4];
      gridLayout(view, g, legendParams(g, orient4, _.legends, xBounds, yBounds, width2, height2));
    }
    legends.forEach((item) => {
      const b4 = item.bounds;
      if (!b4.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item);
        item.bounds = b4;
        view.dirty(item);
      }
      if (_.autosize && (_.autosize.type === Fit || _.autosize.type === FitX || _.autosize.type === FitY)) {
        switch (item.orient) {
          case Left:
          case Right:
            viewBounds3.add(b4.x1, 0).add(b4.x2, 0);
            break;
          case Top:
          case Bottom:
            viewBounds3.add(0, b4.y1).add(0, b4.y2);
        }
      } else {
        viewBounds3.union(b4);
      }
    });
  }
  viewBounds3.union(xBounds).union(yBounds);
  if (title2) {
    viewBounds3.union(titleLayout(view, title2, width2, height2, viewBounds3));
  }
  if (group6.clip) {
    viewBounds3.set(0, 0, group6.width || 0, group6.height || 0);
  }
  viewSizeLayout(view, group6, viewBounds3, _);
}
function viewSizeLayout(view, group6, viewBounds3, _) {
  const auto = _.autosize || {}, type4 = auto.type;
  if (view._autosize < 1 || !type4)
    return;
  let viewWidth2 = view._width, viewHeight2 = view._height, width2 = Math.max(0, group6.width || 0), left = Math.max(0, Math.ceil(-viewBounds3.x1)), height2 = Math.max(0, group6.height || 0), top = Math.max(0, Math.ceil(-viewBounds3.y1));
  const right = Math.max(0, Math.ceil(viewBounds3.x2 - width2)), bottom = Math.max(0, Math.ceil(viewBounds3.y2 - height2));
  if (auto.contains === Padding) {
    const padding3 = view.padding();
    viewWidth2 -= padding3.left + padding3.right;
    viewHeight2 -= padding3.top + padding3.bottom;
  }
  if (type4 === None4) {
    left = 0;
    top = 0;
    width2 = viewWidth2;
    height2 = viewHeight2;
  } else if (type4 === Fit) {
    width2 = Math.max(0, viewWidth2 - left - right);
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type4 === FitX) {
    width2 = Math.max(0, viewWidth2 - left - right);
    viewHeight2 = height2 + top + bottom;
  } else if (type4 === FitY) {
    viewWidth2 = width2 + left + right;
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type4 === Pad) {
    viewWidth2 = width2 + left + right;
    viewHeight2 = height2 + top + bottom;
  }
  view._resizeView(viewWidth2, viewHeight2, width2, height2, [left, top], auto.resize);
}
var Top, Left, Right, Bottom, TopLeft, TopRight, BottomLeft, BottomRight, Start, Middle, End, X, Y, Group, AxisRole, TitleRole, FrameRole, ScopeRole, LegendRole, RowHeader, RowFooter, RowTitle, ColHeader, ColFooter, ColTitle, Padding, Symbols, Fit, FitX, FitY, Pad, None4, All, Each, Flush, Column, Row, COUNTER_NAME, methods, intersect2, hasOverlap, hasBounds, boundTest, reset, reflow, tempBounds2, min4, max4;
var init_vega_view_transforms_module = __esm({
  "node_modules/.pnpm/vega-view-transforms@4.5.9/node_modules/vega-view-transforms/build/vega-view-transforms.module.js"() {
    init_vega_dataflow_module();
    init_vega_scenegraph_module();
    init_vega_util_module2();
    Top = "top";
    Left = "left";
    Right = "right";
    Bottom = "bottom";
    TopLeft = "top-left";
    TopRight = "top-right";
    BottomLeft = "bottom-left";
    BottomRight = "bottom-right";
    Start = "start";
    Middle = "middle";
    End = "end";
    X = "x";
    Y = "y";
    Group = "group";
    AxisRole = "axis";
    TitleRole = "title";
    FrameRole = "frame";
    ScopeRole = "scope";
    LegendRole = "legend";
    RowHeader = "row-header";
    RowFooter = "row-footer";
    RowTitle = "row-title";
    ColHeader = "column-header";
    ColFooter = "column-footer";
    ColTitle = "column-title";
    Padding = "padding";
    Symbols = "symbol";
    Fit = "fit";
    FitX = "fit-x";
    FitY = "fit-y";
    Pad = "pad";
    None4 = "none";
    All = "all";
    Each = "each";
    Flush = "flush";
    Column = "column";
    Row = "row";
    inherits2(Bound, Transform, {
      transform(_, pulse2) {
        const view = pulse2.dataflow, mark = _.mark, type4 = mark.marktype, entry2 = Marks[type4], bound3 = entry2.bound;
        let markBounds = mark.bounds, rebound;
        if (entry2.nested) {
          if (mark.items.length)
            view.dirty(mark.items[0]);
          markBounds = boundItem2(mark, bound3);
          mark.items.forEach((item) => {
            item.bounds.clear().union(markBounds);
          });
        } else if (type4 === Group || _.modified()) {
          pulse2.visit(pulse2.MOD, (item) => view.dirty(item));
          markBounds.clear();
          mark.items.forEach((item) => markBounds.union(boundItem2(item, bound3)));
          switch (mark.role) {
            case AxisRole:
            case LegendRole:
            case TitleRole:
              pulse2.reflow();
          }
        } else {
          rebound = pulse2.changed(pulse2.REM);
          pulse2.visit(pulse2.ADD, (item) => {
            markBounds.union(boundItem2(item, bound3));
          });
          pulse2.visit(pulse2.MOD, (item) => {
            rebound = rebound || markBounds.alignsWith(item.bounds);
            view.dirty(item);
            markBounds.union(boundItem2(item, bound3));
          });
          if (rebound) {
            markBounds.clear();
            mark.items.forEach((item) => markBounds.union(item.bounds));
          }
        }
        boundClip(mark);
        return pulse2.modifies("bounds");
      }
    });
    COUNTER_NAME = ":vega_identifier:";
    Identifier.Definition = {
      "type": "Identifier",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "as",
        "type": "string",
        "required": true
      }]
    };
    inherits2(Identifier, Transform, {
      transform(_, pulse2) {
        const counter = getCounter(pulse2.dataflow), as = _.as;
        let id4 = counter.value;
        pulse2.visit(pulse2.ADD, (t) => t[as] = t[as] || ++id4);
        counter.set(this.value = id4);
        return pulse2;
      }
    });
    inherits2(Mark, Transform, {
      transform(_, pulse2) {
        let mark = this.value;
        if (!mark) {
          mark = pulse2.dataflow.scenegraph().mark(_.markdef, lookup$1(_), _.index);
          mark.group.context = _.context;
          if (!_.context.group)
            _.context.group = mark.group;
          mark.source = this.source;
          mark.clip = _.clip;
          mark.interactive = _.interactive;
          this.value = mark;
        }
        const Init = mark.marktype === Group ? GroupItem : Item;
        pulse2.visit(pulse2.ADD, (item) => Init.call(item, mark));
        if (_.modified("clip") || _.modified("interactive")) {
          mark.clip = _.clip;
          mark.interactive = !!_.interactive;
          mark.zdirty = true;
          pulse2.reflow();
        }
        mark.items = pulse2.source;
        return pulse2;
      }
    });
    methods = {
      parity: (items2) => items2.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
      greedy: (items2, sep) => {
        let a4;
        return items2.filter((b3, i) => !i || !intersect2(a4.bounds, b3.bounds, sep) ? (a4 = b3, 1) : b3.opacity = 0);
      }
    };
    intersect2 = (a4, b3, sep) => sep > Math.max(b3.x1 - a4.x2, a4.x1 - b3.x2, b3.y1 - a4.y2, a4.y1 - b3.y2);
    hasOverlap = (items2, pad6) => {
      for (var i = 1, n = items2.length, a4 = items2[0].bounds, b3; i < n; a4 = b3, ++i) {
        if (intersect2(a4, b3 = items2[i].bounds, pad6))
          return true;
      }
    };
    hasBounds = (item) => {
      const b3 = item.bounds;
      return b3.width() > 1 && b3.height() > 1;
    };
    boundTest = (scale8, orient3, tolerance) => {
      var range7 = scale8.range(), b3 = new Bounds();
      if (orient3 === Top || orient3 === Bottom) {
        b3.set(range7[0], -Infinity, range7[1], Infinity);
      } else {
        b3.set(-Infinity, range7[0], Infinity, range7[1]);
      }
      b3.expand(tolerance || 1);
      return (item) => b3.encloses(item.bounds);
    };
    reset = (source5) => {
      source5.forEach((item) => item.opacity = 1);
      return source5;
    };
    reflow = (pulse2, _) => pulse2.reflow(_.modified()).modifies("opacity");
    inherits2(Overlap, Transform, {
      transform(_, pulse2) {
        const reduce5 = methods[_.method] || methods.parity, sep = _.separation || 0;
        let source5 = pulse2.materialize(pulse2.SOURCE).source, items2, test2;
        if (!source5 || !source5.length)
          return;
        if (!_.method) {
          if (_.modified("method")) {
            reset(source5);
            pulse2 = reflow(pulse2, _);
          }
          return pulse2;
        }
        source5 = source5.filter(hasBounds);
        if (!source5.length)
          return;
        if (_.sort) {
          source5 = source5.slice().sort(_.sort);
        }
        items2 = reset(source5);
        pulse2 = reflow(pulse2, _);
        if (items2.length >= 3 && hasOverlap(items2, sep)) {
          do {
            items2 = reduce5(items2, sep);
          } while (items2.length >= 3 && hasOverlap(items2, sep));
          if (items2.length < 3 && !peek2(source5).opacity) {
            if (items2.length > 1)
              peek2(items2).opacity = 0;
            peek2(source5).opacity = 1;
          }
        }
        if (_.boundScale && _.boundTolerance >= 0) {
          test2 = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
          source5.forEach((item) => {
            if (!test2(item))
              item.opacity = 0;
          });
        }
        const bounds3 = items2[0].mark.bounds.clear();
        source5.forEach((item) => {
          if (item.opacity)
            bounds3.union(item.bounds);
        });
        return pulse2;
      }
    });
    inherits2(Render, Transform, {
      transform(_, pulse2) {
        const view = pulse2.dataflow;
        pulse2.visit(pulse2.ALL, (item) => view.dirty(item));
        if (pulse2.fields && pulse2.fields["zindex"]) {
          const item = pulse2.source && pulse2.source[0];
          if (item)
            item.mark.zdirty = true;
        }
      }
    });
    tempBounds2 = new Bounds();
    min4 = (a4, b3) => Math.floor(Math.min(a4, b3));
    max4 = (a4, b3) => Math.ceil(Math.max(a4, b3));
    inherits2(ViewLayout, Transform, {
      transform(_, pulse2) {
        const view = pulse2.dataflow;
        _.mark.items.forEach((group6) => {
          if (_.layout)
            trellisLayout(view, group6, _.layout);
          layoutGroup(view, group6, _);
        });
        return shouldReflow(_.mark.group) ? pulse2.reflow() : pulse2;
      }
    });
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/init.js
function initRange2(domain4, range7) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain4);
      break;
    default:
      this.range(range7).domain(domain4);
      break;
  }
  return this;
}
function initInterpolator2(domain4, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain4 === "function")
        this.interpolator(domain4);
      else
        this.range(domain4);
      break;
    }
    default: {
      this.domain(domain4);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}
var init_init2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/init.js"() {
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/ordinal.js
function ordinal2() {
  var index8 = /* @__PURE__ */ new Map(), domain4 = [], range7 = [], unknown = implicit2;
  function scale8(d) {
    var key3 = d + "", i = index8.get(key3);
    if (!i) {
      if (unknown !== implicit2)
        return unknown;
      index8.set(key3, i = domain4.push(d));
    }
    return range7[(i - 1) % range7.length];
  }
  scale8.domain = function(_) {
    if (!arguments.length)
      return domain4.slice();
    domain4 = [], index8 = /* @__PURE__ */ new Map();
    for (const value4 of _) {
      const key3 = value4 + "";
      if (index8.has(key3))
        continue;
      index8.set(key3, domain4.push(value4));
    }
    return scale8;
  };
  scale8.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), scale8) : range7.slice();
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  scale8.copy = function() {
    return ordinal2(domain4, range7).unknown(unknown);
  };
  initRange2.apply(scale8, arguments);
  return scale8;
}
var implicit2;
var init_ordinal2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/ordinal.js"() {
    init_init2();
    implicit2 = Symbol("implicit");
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/band.js
var init_band2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/band.js"() {
    init_src9();
    init_init2();
    init_ordinal2();
  }
});

// node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/define.js
function define_default2(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend4(parent, definition3) {
  var prototype2 = Object.create(parent.prototype);
  for (var key3 in definition3)
    prototype2[key3] = definition3[key3];
  return prototype2;
}
var init_define2 = __esm({
  "node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/define.js"() {
  }
});

// node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/color.js
function Color2() {
}
function color_formatHex2() {
  return this.rgb().formatHex();
}
function color_formatHsl2() {
  return hslConvert2(this).formatHsl();
}
function color_formatRgb2() {
  return this.rgb().formatRgb();
}
function color3(format9) {
  var m2, l;
  format9 = (format9 + "").trim().toLowerCase();
  return (m2 = reHex2.exec(format9)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn2(m2) : l === 3 ? new Rgb2(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba2(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba2(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger2.exec(format9)) ? new Rgb2(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent2.exec(format9)) ? new Rgb2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger2.exec(format9)) ? rgba2(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent2.exec(format9)) ? rgba2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent2.exec(format9)) ? hsla2(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent2.exec(format9)) ? hsla2(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named2.hasOwnProperty(format9) ? rgbn2(named2[format9]) : format9 === "transparent" ? new Rgb2(NaN, NaN, NaN, 0) : null;
}
function rgbn2(n) {
  return new Rgb2(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba2(r2, g, b3, a4) {
  if (a4 <= 0)
    r2 = g = b3 = NaN;
  return new Rgb2(r2, g, b3, a4);
}
function rgbConvert2(o) {
  if (!(o instanceof Color2))
    o = color3(o);
  if (!o)
    return new Rgb2();
  o = o.rgb();
  return new Rgb2(o.r, o.g, o.b, o.opacity);
}
function rgb2(r2, g, b3, opacity2) {
  return arguments.length === 1 ? rgbConvert2(r2) : new Rgb2(r2, g, b3, opacity2 == null ? 1 : opacity2);
}
function Rgb2(r2, g, b3, opacity2) {
  this.r = +r2;
  this.g = +g;
  this.b = +b3;
  this.opacity = +opacity2;
}
function rgb_formatHex2() {
  return "#" + hex2(this.r) + hex2(this.g) + hex2(this.b);
}
function rgb_formatRgb2() {
  var a4 = this.opacity;
  a4 = isNaN(a4) ? 1 : Math.max(0, Math.min(1, a4));
  return (a4 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a4 === 1 ? ")" : ", " + a4 + ")");
}
function hex2(value4) {
  value4 = Math.max(0, Math.min(255, Math.round(value4) || 0));
  return (value4 < 16 ? "0" : "") + value4.toString(16);
}
function hsla2(h4, s3, l, a4) {
  if (a4 <= 0)
    h4 = s3 = l = NaN;
  else if (l <= 0 || l >= 1)
    h4 = s3 = NaN;
  else if (s3 <= 0)
    h4 = NaN;
  return new Hsl2(h4, s3, l, a4);
}
function hslConvert2(o) {
  if (o instanceof Hsl2)
    return new Hsl2(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color2))
    o = color3(o);
  if (!o)
    return new Hsl2();
  if (o instanceof Hsl2)
    return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b3 = o.b / 255, min8 = Math.min(r2, g, b3), max8 = Math.max(r2, g, b3), h4 = NaN, s3 = max8 - min8, l = (max8 + min8) / 2;
  if (s3) {
    if (r2 === max8)
      h4 = (g - b3) / s3 + (g < b3) * 6;
    else if (g === max8)
      h4 = (b3 - r2) / s3 + 2;
    else
      h4 = (r2 - g) / s3 + 4;
    s3 /= l < 0.5 ? max8 + min8 : 2 - max8 - min8;
    h4 *= 60;
  } else {
    s3 = l > 0 && l < 1 ? 0 : h4;
  }
  return new Hsl2(h4, s3, l, o.opacity);
}
function hsl3(h4, s3, l, opacity2) {
  return arguments.length === 1 ? hslConvert2(h4) : new Hsl2(h4, s3, l, opacity2 == null ? 1 : opacity2);
}
function Hsl2(h4, s3, l, opacity2) {
  this.h = +h4;
  this.s = +s3;
  this.l = +l;
  this.opacity = +opacity2;
}
function hsl2rgb2(h4, m1, m2) {
  return (h4 < 60 ? m1 + (m2 - m1) * h4 / 60 : h4 < 180 ? m2 : h4 < 240 ? m1 + (m2 - m1) * (240 - h4) / 60 : m1) * 255;
}
var darker2, brighter2, reI2, reN2, reP2, reHex2, reRgbInteger2, reRgbPercent2, reRgbaInteger2, reRgbaPercent2, reHslPercent2, reHslaPercent2, named2;
var init_color3 = __esm({
  "node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/color.js"() {
    init_define2();
    darker2 = 0.7;
    brighter2 = 1 / darker2;
    reI2 = "\\s*([+-]?\\d+)\\s*";
    reN2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
    reP2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
    reHex2 = /^#([0-9a-f]{3,8})$/;
    reRgbInteger2 = new RegExp("^rgb\\(" + [reI2, reI2, reI2] + "\\)$");
    reRgbPercent2 = new RegExp("^rgb\\(" + [reP2, reP2, reP2] + "\\)$");
    reRgbaInteger2 = new RegExp("^rgba\\(" + [reI2, reI2, reI2, reN2] + "\\)$");
    reRgbaPercent2 = new RegExp("^rgba\\(" + [reP2, reP2, reP2, reN2] + "\\)$");
    reHslPercent2 = new RegExp("^hsl\\(" + [reN2, reP2, reP2] + "\\)$");
    reHslaPercent2 = new RegExp("^hsla\\(" + [reN2, reP2, reP2, reN2] + "\\)$");
    named2 = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define_default2(Color2, color3, {
      copy: function(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex2,
      formatHex: color_formatHex2,
      formatHsl: color_formatHsl2,
      formatRgb: color_formatRgb2,
      toString: color_formatRgb2
    });
    define_default2(Rgb2, rgb2, extend4(Color2, {
      brighter: function(k4) {
        k4 = k4 == null ? brighter2 : Math.pow(brighter2, k4);
        return new Rgb2(this.r * k4, this.g * k4, this.b * k4, this.opacity);
      },
      darker: function(k4) {
        k4 = k4 == null ? darker2 : Math.pow(darker2, k4);
        return new Rgb2(this.r * k4, this.g * k4, this.b * k4, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex2,
      formatHex: rgb_formatHex2,
      formatRgb: rgb_formatRgb2,
      toString: rgb_formatRgb2
    }));
    define_default2(Hsl2, hsl3, extend4(Color2, {
      brighter: function(k4) {
        k4 = k4 == null ? brighter2 : Math.pow(brighter2, k4);
        return new Hsl2(this.h, this.s, this.l * k4, this.opacity);
      },
      darker: function(k4) {
        k4 = k4 == null ? darker2 : Math.pow(darker2, k4);
        return new Hsl2(this.h, this.s, this.l * k4, this.opacity);
      },
      rgb: function() {
        var h4 = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h4) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s3, m1 = 2 * l - m2;
        return new Rgb2(
          hsl2rgb2(h4 >= 240 ? h4 - 240 : h4 + 120, m1, m2),
          hsl2rgb2(h4, m1, m2),
          hsl2rgb2(h4 < 120 ? h4 + 240 : h4 - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a4 = this.opacity;
        a4 = isNaN(a4) ? 1 : Math.max(0, Math.min(1, a4));
        return (a4 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a4 === 1 ? ")" : ", " + a4 + ")");
      }
    }));
  }
});

// node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/math.js
var radians2, degrees3;
var init_math3 = __esm({
  "node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/math.js"() {
    radians2 = Math.PI / 180;
    degrees3 = 180 / Math.PI;
  }
});

// node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/lab.js
function labConvert2(o) {
  if (o instanceof Lab2)
    return new Lab2(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl2)
    return hcl2lab2(o);
  if (!(o instanceof Rgb2))
    o = rgbConvert2(o);
  var r2 = rgb2lrgb2(o.r), g = rgb2lrgb2(o.g), b3 = rgb2lrgb2(o.b), y7 = xyz2lab2((0.2225045 * r2 + 0.7168786 * g + 0.0606169 * b3) / Yn2), x7, z;
  if (r2 === g && g === b3)
    x7 = z = y7;
  else {
    x7 = xyz2lab2((0.4360747 * r2 + 0.3850649 * g + 0.1430804 * b3) / Xn2);
    z = xyz2lab2((0.0139322 * r2 + 0.0971045 * g + 0.7141733 * b3) / Zn2);
  }
  return new Lab2(116 * y7 - 16, 500 * (x7 - y7), 200 * (y7 - z), o.opacity);
}
function lab3(l, a4, b3, opacity2) {
  return arguments.length === 1 ? labConvert2(l) : new Lab2(l, a4, b3, opacity2 == null ? 1 : opacity2);
}
function Lab2(l, a4, b3, opacity2) {
  this.l = +l;
  this.a = +a4;
  this.b = +b3;
  this.opacity = +opacity2;
}
function xyz2lab2(t) {
  return t > t32 ? Math.pow(t, 1 / 3) : t / t22 + t06;
}
function lab2xyz2(t) {
  return t > t14 ? t * t * t : t22 * (t - t06);
}
function lrgb2rgb2(x7) {
  return 255 * (x7 <= 31308e-7 ? 12.92 * x7 : 1.055 * Math.pow(x7, 1 / 2.4) - 0.055);
}
function rgb2lrgb2(x7) {
  return (x7 /= 255) <= 0.04045 ? x7 / 12.92 : Math.pow((x7 + 0.055) / 1.055, 2.4);
}
function hclConvert2(o) {
  if (o instanceof Hcl2)
    return new Hcl2(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab2))
    o = labConvert2(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl2(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h4 = Math.atan2(o.b, o.a) * degrees3;
  return new Hcl2(h4 < 0 ? h4 + 360 : h4, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl3(h4, c2, l, opacity2) {
  return arguments.length === 1 ? hclConvert2(h4) : new Hcl2(h4, c2, l, opacity2 == null ? 1 : opacity2);
}
function Hcl2(h4, c2, l, opacity2) {
  this.h = +h4;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity2;
}
function hcl2lab2(o) {
  if (isNaN(o.h))
    return new Lab2(o.l, 0, 0, o.opacity);
  var h4 = o.h * radians2;
  return new Lab2(o.l, Math.cos(h4) * o.c, Math.sin(h4) * o.c, o.opacity);
}
var K2, Xn2, Yn2, Zn2, t06, t14, t22, t32;
var init_lab3 = __esm({
  "node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/lab.js"() {
    init_define2();
    init_color3();
    init_math3();
    K2 = 18;
    Xn2 = 0.96422;
    Yn2 = 1;
    Zn2 = 0.82521;
    t06 = 4 / 29;
    t14 = 6 / 29;
    t22 = 3 * t14 * t14;
    t32 = t14 * t14 * t14;
    define_default2(Lab2, lab3, extend4(Color2, {
      brighter: function(k4) {
        return new Lab2(this.l + K2 * (k4 == null ? 1 : k4), this.a, this.b, this.opacity);
      },
      darker: function(k4) {
        return new Lab2(this.l - K2 * (k4 == null ? 1 : k4), this.a, this.b, this.opacity);
      },
      rgb: function() {
        var y7 = (this.l + 16) / 116, x7 = isNaN(this.a) ? y7 : y7 + this.a / 500, z = isNaN(this.b) ? y7 : y7 - this.b / 200;
        x7 = Xn2 * lab2xyz2(x7);
        y7 = Yn2 * lab2xyz2(y7);
        z = Zn2 * lab2xyz2(z);
        return new Rgb2(
          lrgb2rgb2(3.1338561 * x7 - 1.6168667 * y7 - 0.4906146 * z),
          lrgb2rgb2(-0.9787684 * x7 + 1.9161415 * y7 + 0.033454 * z),
          lrgb2rgb2(0.0719453 * x7 - 0.2289914 * y7 + 1.4052427 * z),
          this.opacity
        );
      }
    }));
    define_default2(Hcl2, hcl3, extend4(Color2, {
      brighter: function(k4) {
        return new Hcl2(this.h, this.c, this.l + K2 * (k4 == null ? 1 : k4), this.opacity);
      },
      darker: function(k4) {
        return new Hcl2(this.h, this.c, this.l - K2 * (k4 == null ? 1 : k4), this.opacity);
      },
      rgb: function() {
        return hcl2lab2(this).rgb();
      }
    }));
  }
});

// node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/cubehelix.js
function cubehelixConvert2(o) {
  if (o instanceof Cubehelix2)
    return new Cubehelix2(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb2))
    o = rgbConvert2(o);
  var r2 = o.r / 255, g = o.g / 255, b3 = o.b / 255, l = (BC_DA2 * b3 + ED2 * r2 - EB2 * g) / (BC_DA2 + ED2 - EB2), bl3 = b3 - l, k4 = (E2 * (g - l) - C3 * bl3) / D2, s3 = Math.sqrt(k4 * k4 + bl3 * bl3) / (E2 * l * (1 - l)), h4 = s3 ? Math.atan2(k4, bl3) * degrees3 - 120 : NaN;
  return new Cubehelix2(h4 < 0 ? h4 + 360 : h4, s3, l, o.opacity);
}
function cubehelix3(h4, s3, l, opacity2) {
  return arguments.length === 1 ? cubehelixConvert2(h4) : new Cubehelix2(h4, s3, l, opacity2 == null ? 1 : opacity2);
}
function Cubehelix2(h4, s3, l, opacity2) {
  this.h = +h4;
  this.s = +s3;
  this.l = +l;
  this.opacity = +opacity2;
}
var A2, B2, C3, D2, E2, ED2, EB2, BC_DA2;
var init_cubehelix3 = __esm({
  "node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/cubehelix.js"() {
    init_define2();
    init_color3();
    init_math3();
    A2 = -0.14861;
    B2 = 1.78277;
    C3 = -0.29227;
    D2 = -0.90649;
    E2 = 1.97294;
    ED2 = E2 * D2;
    EB2 = E2 * B2;
    BC_DA2 = B2 * C3 - D2 * A2;
    define_default2(Cubehelix2, cubehelix3, extend4(Color2, {
      brighter: function(k4) {
        k4 = k4 == null ? brighter2 : Math.pow(brighter2, k4);
        return new Cubehelix2(this.h, this.s, this.l * k4, this.opacity);
      },
      darker: function(k4) {
        k4 = k4 == null ? darker2 : Math.pow(darker2, k4);
        return new Cubehelix2(this.h, this.s, this.l * k4, this.opacity);
      },
      rgb: function() {
        var h4 = isNaN(this.h) ? 0 : (this.h + 120) * radians2, l = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh4 = Math.cos(h4), sinh4 = Math.sin(h4);
        return new Rgb2(
          255 * (l + a4 * (A2 * cosh4 + B2 * sinh4)),
          255 * (l + a4 * (C3 * cosh4 + D2 * sinh4)),
          255 * (l + a4 * (E2 * cosh4)),
          this.opacity
        );
      }
    }));
  }
});

// node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/index.js
var init_src17 = __esm({
  "node_modules/.pnpm/d3-color@2.0.0/node_modules/d3-color/src/index.js"() {
    init_color3();
    init_lab3();
    init_cubehelix3();
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/basis.js
function basis2(t15, v0, v1, v2, v3) {
  var t23 = t15 * t15, t33 = t23 * t15;
  return ((1 - 3 * t15 + 3 * t23 - t33) * v0 + (4 - 6 * t23 + 3 * t33) * v1 + (1 + 3 * t15 + 3 * t23 - 3 * t33) * v2 + t33 * v3) / 6;
}
function basis_default3(values5) {
  var n = values5.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values5[i], v2 = values5[i + 1], v0 = i > 0 ? values5[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values5[i + 2] : 2 * v2 - v1;
    return basis2((t - i / n) * n, v0, v1, v2, v3);
  };
}
var init_basis3 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/basis.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default3(values5) {
  var n = values5.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values5[(i + n - 1) % n], v1 = values5[i % n], v2 = values5[(i + 1) % n], v3 = values5[(i + 2) % n];
    return basis2((t - i / n) * n, v0, v1, v2, v3);
  };
}
var init_basisClosed3 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/basisClosed.js"() {
    init_basis3();
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/constant.js
var constant_default4;
var init_constant6 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/constant.js"() {
    constant_default4 = (x7) => () => x7;
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/color.js
function linear4(a4, d) {
  return function(t) {
    return a4 + t * d;
  };
}
function exponential2(a4, b3, y7) {
  return a4 = Math.pow(a4, y7), b3 = Math.pow(b3, y7) - a4, y7 = 1 / y7, function(t) {
    return Math.pow(a4 + t * b3, y7);
  };
}
function hue2(a4, b3) {
  var d = b3 - a4;
  return d ? linear4(a4, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default4(isNaN(a4) ? b3 : a4);
}
function gamma2(y7) {
  return (y7 = +y7) === 1 ? nogamma2 : function(a4, b3) {
    return b3 - a4 ? exponential2(a4, b3, y7) : constant_default4(isNaN(a4) ? b3 : a4);
  };
}
function nogamma2(a4, b3) {
  var d = b3 - a4;
  return d ? linear4(a4, d) : constant_default4(isNaN(a4) ? b3 : a4);
}
var init_color4 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/color.js"() {
    init_constant6();
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/rgb.js
function rgbSpline2(spline) {
  return function(colors3) {
    var n = colors3.length, r2 = new Array(n), g = new Array(n), b3 = new Array(n), i, color7;
    for (i = 0; i < n; ++i) {
      color7 = rgb2(colors3[i]);
      r2[i] = color7.r || 0;
      g[i] = color7.g || 0;
      b3[i] = color7.b || 0;
    }
    r2 = spline(r2);
    g = spline(g);
    b3 = spline(b3);
    color7.opacity = 1;
    return function(t) {
      color7.r = r2(t);
      color7.g = g(t);
      color7.b = b3(t);
      return color7 + "";
    };
  };
}
var rgb_default2, rgbBasis2, rgbBasisClosed2;
var init_rgb2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/rgb.js"() {
    init_src17();
    init_basis3();
    init_basisClosed3();
    init_color4();
    rgb_default2 = function rgbGamma2(y7) {
      var color7 = gamma2(y7);
      function rgb3(start, end) {
        var r2 = color7((start = rgb2(start)).r, (end = rgb2(end)).r), g = color7(start.g, end.g), b3 = color7(start.b, end.b), opacity2 = nogamma2(start.opacity, end.opacity);
        return function(t) {
          start.r = r2(t);
          start.g = g(t);
          start.b = b3(t);
          start.opacity = opacity2(t);
          return start + "";
        };
      }
      rgb3.gamma = rgbGamma2;
      return rgb3;
    }(1);
    rgbBasis2 = rgbSpline2(basis_default3);
    rgbBasisClosed2 = rgbSpline2(basisClosed_default3);
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/numberArray.js
function numberArray_default2(a4, b3) {
  if (!b3)
    b3 = [];
  var n = a4 ? Math.min(b3.length, a4.length) : 0, c2 = b3.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c2[i] = a4[i] * (1 - t) + b3[i] * t;
    return c2;
  };
}
function isNumberArray2(x7) {
  return ArrayBuffer.isView(x7) && !(x7 instanceof DataView);
}
var init_numberArray2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/numberArray.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/array.js
function array_default3(a4, b3) {
  return (isNumberArray2(b3) ? numberArray_default2 : genericArray2)(a4, b3);
}
function genericArray2(a4, b3) {
  var nb = b3 ? b3.length : 0, na = a4 ? Math.min(nb, a4.length) : 0, x7 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x7[i] = value_default2(a4[i], b3[i]);
  for (; i < nb; ++i)
    c2[i] = b3[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c2[i] = x7[i](t);
    return c2;
  };
}
var init_array5 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/array.js"() {
    init_value2();
    init_numberArray2();
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/date.js
function date_default2(a4, b3) {
  var d = new Date();
  return a4 = +a4, b3 = +b3, function(t) {
    return d.setTime(a4 * (1 - t) + b3 * t), d;
  };
}
var init_date2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/date.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/number.js
function number_default3(a4, b3) {
  return a4 = +a4, b3 = +b3, function(t) {
    return a4 * (1 - t) + b3 * t;
  };
}
var init_number5 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/number.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/object.js
function object_default2(a4, b3) {
  var i = {}, c2 = {}, k4;
  if (a4 === null || typeof a4 !== "object")
    a4 = {};
  if (b3 === null || typeof b3 !== "object")
    b3 = {};
  for (k4 in b3) {
    if (k4 in a4) {
      i[k4] = value_default2(a4[k4], b3[k4]);
    } else {
      c2[k4] = b3[k4];
    }
  }
  return function(t) {
    for (k4 in i)
      c2[k4] = i[k4](t);
    return c2;
  };
}
var init_object2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/object.js"() {
    init_value2();
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/string.js
function zero5(b3) {
  return function() {
    return b3;
  };
}
function one4(b3) {
  return function(t) {
    return b3(t) + "";
  };
}
function string_default2(a4, b3) {
  var bi = reA2.lastIndex = reB2.lastIndex = 0, am, bm, bs, i = -1, s3 = [], q = [];
  a4 = a4 + "", b3 = b3 + "";
  while ((am = reA2.exec(a4)) && (bm = reB2.exec(b3))) {
    if ((bs = bm.index) > bi) {
      bs = b3.slice(bi, bs);
      if (s3[i])
        s3[i] += bs;
      else
        s3[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s3[i])
        s3[i] += bm;
      else
        s3[++i] = bm;
    } else {
      s3[++i] = null;
      q.push({ i, x: number_default3(am, bm) });
    }
    bi = reB2.lastIndex;
  }
  if (bi < b3.length) {
    bs = b3.slice(bi);
    if (s3[i])
      s3[i] += bs;
    else
      s3[++i] = bs;
  }
  return s3.length < 2 ? q[0] ? one4(q[0].x) : zero5(b3) : (b3 = q.length, function(t) {
    for (var i2 = 0, o; i2 < b3; ++i2)
      s3[(o = q[i2]).i] = o.x(t);
    return s3.join("");
  });
}
var reA2, reB2;
var init_string2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/string.js"() {
    init_number5();
    reA2 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
    reB2 = new RegExp(reA2.source, "g");
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/value.js
function value_default2(a4, b3) {
  var t = typeof b3, c2;
  return b3 == null || t === "boolean" ? constant_default4(b3) : (t === "number" ? number_default3 : t === "string" ? (c2 = color3(b3)) ? (b3 = c2, rgb_default2) : string_default2 : b3 instanceof color3 ? rgb_default2 : b3 instanceof Date ? date_default2 : isNumberArray2(b3) ? numberArray_default2 : Array.isArray(b3) ? genericArray2 : typeof b3.valueOf !== "function" && typeof b3.toString !== "function" || isNaN(b3) ? object_default2 : number_default3)(a4, b3);
}
var init_value2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/value.js"() {
    init_src17();
    init_rgb2();
    init_array5();
    init_date2();
    init_number5();
    init_object2();
    init_string2();
    init_constant6();
    init_numberArray2();
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/discrete.js
function discrete_default2(range7) {
  var n = range7.length;
  return function(t) {
    return range7[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var init_discrete2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/discrete.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/hue.js
function hue_default2(a4, b3) {
  var i = hue2(+a4, +b3);
  return function(t) {
    var x7 = i(t);
    return x7 - 360 * Math.floor(x7 / 360);
  };
}
var init_hue2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/hue.js"() {
    init_color4();
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/round.js
function round_default2(a4, b3) {
  return a4 = +a4, b3 = +b3, function(t) {
    return Math.round(a4 * (1 - t) + b3 * t);
  };
}
var init_round2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/round.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/transform/decompose.js
function decompose_default2(a4, b3, c2, d, e3, f) {
  var scaleX, scaleY2, skewX;
  if (scaleX = Math.sqrt(a4 * a4 + b3 * b3))
    a4 /= scaleX, b3 /= scaleX;
  if (skewX = a4 * c2 + b3 * d)
    c2 -= a4 * skewX, d -= b3 * skewX;
  if (scaleY2 = Math.sqrt(c2 * c2 + d * d))
    c2 /= scaleY2, d /= scaleY2, skewX /= scaleY2;
  if (a4 * d < b3 * c2)
    a4 = -a4, b3 = -b3, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f,
    rotate: Math.atan2(b3, a4) * degrees4,
    skewX: Math.atan(skewX) * degrees4,
    scaleX,
    scaleY: scaleY2
  };
}
var degrees4, identity7;
var init_decompose2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/transform/decompose.js"() {
    degrees4 = 180 / Math.PI;
    identity7 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/transform/parse.js
function parseCss2(value4) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value4 + "");
  return m2.isIdentity ? identity7 : decompose_default2(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg2(value4) {
  if (value4 == null)
    return identity7;
  if (!svgNode2)
    svgNode2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode2.setAttribute("transform", value4);
  if (!(value4 = svgNode2.transform.baseVal.consolidate()))
    return identity7;
  value4 = value4.matrix;
  return decompose_default2(value4.a, value4.b, value4.c, value4.d, value4.e, value4.f);
}
var svgNode2;
var init_parse2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/transform/parse.js"() {
    init_decompose2();
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform2(parse8, pxComma, pxParen, degParen) {
  function pop(s3) {
    return s3.length ? s3.pop() + " " : "";
  }
  function translate5(xa, ya, xb, yb, s3, q) {
    if (xa !== xb || ya !== yb) {
      var i = s3.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default3(xa, xb) }, { i: i - 2, x: number_default3(ya, yb) });
    } else if (xb || yb) {
      s3.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate3(a4, b3, s3, q) {
    if (a4 !== b3) {
      if (a4 - b3 > 180)
        b3 += 360;
      else if (b3 - a4 > 180)
        a4 += 360;
      q.push({ i: s3.push(pop(s3) + "rotate(", null, degParen) - 2, x: number_default3(a4, b3) });
    } else if (b3) {
      s3.push(pop(s3) + "rotate(" + b3 + degParen);
    }
  }
  function skewX(a4, b3, s3, q) {
    if (a4 !== b3) {
      q.push({ i: s3.push(pop(s3) + "skewX(", null, degParen) - 2, x: number_default3(a4, b3) });
    } else if (b3) {
      s3.push(pop(s3) + "skewX(" + b3 + degParen);
    }
  }
  function scale8(xa, ya, xb, yb, s3, q) {
    if (xa !== xb || ya !== yb) {
      var i = s3.push(pop(s3) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default3(xa, xb) }, { i: i - 2, x: number_default3(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s3.push(pop(s3) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a4, b3) {
    var s3 = [], q = [];
    a4 = parse8(a4), b3 = parse8(b3);
    translate5(a4.translateX, a4.translateY, b3.translateX, b3.translateY, s3, q);
    rotate3(a4.rotate, b3.rotate, s3, q);
    skewX(a4.skewX, b3.skewX, s3, q);
    scale8(a4.scaleX, a4.scaleY, b3.scaleX, b3.scaleY, s3, q);
    a4 = b3 = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s3[(o = q[i]).i] = o.x(t);
      return s3.join("");
    };
  };
}
var interpolateTransformCss2, interpolateTransformSvg2;
var init_transform3 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/transform/index.js"() {
    init_number5();
    init_parse2();
    interpolateTransformCss2 = interpolateTransform2(parseCss2, "px, ", "px)", "deg)");
    interpolateTransformSvg2 = interpolateTransform2(parseSvg2, ", ", ")", ")");
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/zoom.js
function cosh2(x7) {
  return ((x7 = Math.exp(x7)) + 1 / x7) / 2;
}
function sinh2(x7) {
  return ((x7 = Math.exp(x7)) - 1 / x7) / 2;
}
function tanh2(x7) {
  return ((x7 = Math.exp(2 * x7)) - 1) / (x7 + 1);
}
var epsilon23, zoom_default2;
var init_zoom2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/zoom.js"() {
    epsilon23 = 1e-12;
    zoom_default2 = function zoomRho2(rho, rho2, rho4) {
      function zoom3(p02, p1) {
        var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        if (d2 < epsilon23) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        } else {
          var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s3 = t * S, coshr0 = cosh2(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh2(rho * s3 + r0) - sinh2(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh2(rho * s3 + r0)
            ];
          };
        }
        i.duration = S * 1e3 * rho / Math.SQRT2;
        return i;
      }
      zoom3.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho2(_1, _2, _4);
      };
      return zoom3;
    }(Math.SQRT2, 2, 4);
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/hsl.js
function hsl4(hue3) {
  return function(start, end) {
    var h4 = hue3((start = hsl3(start)).h, (end = hsl3(end)).h), s3 = nogamma2(start.s, end.s), l = nogamma2(start.l, end.l), opacity2 = nogamma2(start.opacity, end.opacity);
    return function(t) {
      start.h = h4(t);
      start.s = s3(t);
      start.l = l(t);
      start.opacity = opacity2(t);
      return start + "";
    };
  };
}
var hsl_default2, hslLong2;
var init_hsl2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/hsl.js"() {
    init_src17();
    init_color4();
    hsl_default2 = hsl4(hue2);
    hslLong2 = hsl4(nogamma2);
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/lab.js
function lab4(start, end) {
  var l = nogamma2((start = lab3(start)).l, (end = lab3(end)).l), a4 = nogamma2(start.a, end.a), b3 = nogamma2(start.b, end.b), opacity2 = nogamma2(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a4(t);
    start.b = b3(t);
    start.opacity = opacity2(t);
    return start + "";
  };
}
var init_lab4 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/lab.js"() {
    init_src17();
    init_color4();
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/hcl.js
function hcl4(hue3) {
  return function(start, end) {
    var h4 = hue3((start = hcl3(start)).h, (end = hcl3(end)).h), c2 = nogamma2(start.c, end.c), l = nogamma2(start.l, end.l), opacity2 = nogamma2(start.opacity, end.opacity);
    return function(t) {
      start.h = h4(t);
      start.c = c2(t);
      start.l = l(t);
      start.opacity = opacity2(t);
      return start + "";
    };
  };
}
var hcl_default2, hclLong2;
var init_hcl2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/hcl.js"() {
    init_src17();
    init_color4();
    hcl_default2 = hcl4(hue2);
    hclLong2 = hcl4(nogamma2);
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/cubehelix.js
function cubehelix4(hue3) {
  return function cubehelixGamma(y7) {
    y7 = +y7;
    function cubehelix5(start, end) {
      var h4 = hue3((start = cubehelix3(start)).h, (end = cubehelix3(end)).h), s3 = nogamma2(start.s, end.s), l = nogamma2(start.l, end.l), opacity2 = nogamma2(start.opacity, end.opacity);
      return function(t) {
        start.h = h4(t);
        start.s = s3(t);
        start.l = l(Math.pow(t, y7));
        start.opacity = opacity2(t);
        return start + "";
      };
    }
    cubehelix5.gamma = cubehelixGamma;
    return cubehelix5;
  }(1);
}
var cubehelix_default2, cubehelixLong2;
var init_cubehelix4 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/cubehelix.js"() {
    init_src17();
    init_color4();
    cubehelix_default2 = cubehelix4(hue2);
    cubehelixLong2 = cubehelix4(nogamma2);
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/piecewise.js
function piecewise2(interpolate4, values5) {
  if (values5 === void 0)
    values5 = interpolate4, interpolate4 = value_default2;
  var i = 0, n = values5.length - 1, v = values5[0], I = new Array(n < 0 ? 0 : n);
  while (i < n)
    I[i] = interpolate4(v, v = values5[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}
var init_piecewise2 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/piecewise.js"() {
    init_value2();
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/quantize.js
function quantize_default3(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i)
    samples[i] = interpolator(i / (n - 1));
  return samples;
}
var init_quantize4 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/quantize.js"() {
  }
});

// node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/index.js
var src_exports4 = {};
__export(src_exports4, {
  interpolate: () => value_default2,
  interpolateArray: () => array_default3,
  interpolateBasis: () => basis_default3,
  interpolateBasisClosed: () => basisClosed_default3,
  interpolateCubehelix: () => cubehelix_default2,
  interpolateCubehelixLong: () => cubehelixLong2,
  interpolateDate: () => date_default2,
  interpolateDiscrete: () => discrete_default2,
  interpolateHcl: () => hcl_default2,
  interpolateHclLong: () => hclLong2,
  interpolateHsl: () => hsl_default2,
  interpolateHslLong: () => hslLong2,
  interpolateHue: () => hue_default2,
  interpolateLab: () => lab4,
  interpolateNumber: () => number_default3,
  interpolateNumberArray: () => numberArray_default2,
  interpolateObject: () => object_default2,
  interpolateRgb: () => rgb_default2,
  interpolateRgbBasis: () => rgbBasis2,
  interpolateRgbBasisClosed: () => rgbBasisClosed2,
  interpolateRound: () => round_default2,
  interpolateString: () => string_default2,
  interpolateTransformCss: () => interpolateTransformCss2,
  interpolateTransformSvg: () => interpolateTransformSvg2,
  interpolateZoom: () => zoom_default2,
  piecewise: () => piecewise2,
  quantize: () => quantize_default3
});
var init_src18 = __esm({
  "node_modules/.pnpm/d3-interpolate@2.0.1/node_modules/d3-interpolate/src/index.js"() {
    init_value2();
    init_array5();
    init_basis3();
    init_basisClosed3();
    init_date2();
    init_discrete2();
    init_hue2();
    init_number5();
    init_numberArray2();
    init_object2();
    init_round2();
    init_string2();
    init_transform3();
    init_zoom2();
    init_rgb2();
    init_hsl2();
    init_lab4();
    init_hcl2();
    init_cubehelix4();
    init_piecewise2();
    init_quantize4();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/constant.js
function constants2(x7) {
  return function() {
    return x7;
  };
}
var init_constant7 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/number.js
function number5(x7) {
  return +x7;
}
var init_number6 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/number.js"() {
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/continuous.js
function identity8(x7) {
  return x7;
}
function normalize2(a4, b3) {
  return (b3 -= a4 = +a4) ? function(x7) {
    return (x7 - a4) / b3;
  } : constants2(isNaN(b3) ? NaN : 0.5);
}
function clamper2(a4, b3) {
  var t;
  if (a4 > b3)
    t = a4, a4 = b3, b3 = t;
  return function(x7) {
    return Math.max(a4, Math.min(b3, x7));
  };
}
function bimap2(domain4, range7, interpolate4) {
  var d0 = domain4[0], d1 = domain4[1], r0 = range7[0], r1 = range7[1];
  if (d1 < d0)
    d0 = normalize2(d1, d0), r0 = interpolate4(r1, r0);
  else
    d0 = normalize2(d0, d1), r0 = interpolate4(r0, r1);
  return function(x7) {
    return r0(d0(x7));
  };
}
function polymap2(domain4, range7, interpolate4) {
  var j = Math.min(domain4.length, range7.length) - 1, d = new Array(j), r2 = new Array(j), i = -1;
  if (domain4[j] < domain4[0]) {
    domain4 = domain4.slice().reverse();
    range7 = range7.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize2(domain4[i], domain4[i + 1]);
    r2[i] = interpolate4(range7[i], range7[i + 1]);
  }
  return function(x7) {
    var i2 = bisect_default3(domain4, x7, 1, j) - 1;
    return r2[i2](d[i2](x7));
  };
}
function copy3(source5, target2) {
  return target2.domain(source5.domain()).range(source5.range()).interpolate(source5.interpolate()).clamp(source5.clamp()).unknown(source5.unknown());
}
function transformer4() {
  var domain4 = unit2, range7 = unit2, interpolate4 = value_default2, transform4, untransform, unknown, clamp3 = identity8, piecewise3, output3, input;
  function rescale() {
    var n = Math.min(domain4.length, range7.length);
    if (clamp3 !== identity8)
      clamp3 = clamper2(domain4[0], domain4[n - 1]);
    piecewise3 = n > 2 ? polymap2 : bimap2;
    output3 = input = null;
    return scale8;
  }
  function scale8(x7) {
    return x7 == null || isNaN(x7 = +x7) ? unknown : (output3 || (output3 = piecewise3(domain4.map(transform4), range7, interpolate4)))(transform4(clamp3(x7)));
  }
  scale8.invert = function(y7) {
    return clamp3(untransform((input || (input = piecewise3(range7, domain4.map(transform4), number_default3)))(y7)));
  };
  scale8.domain = function(_) {
    return arguments.length ? (domain4 = Array.from(_, number5), rescale()) : domain4.slice();
  };
  scale8.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), rescale()) : range7.slice();
  };
  scale8.rangeRound = function(_) {
    return range7 = Array.from(_), interpolate4 = round_default2, rescale();
  };
  scale8.clamp = function(_) {
    return arguments.length ? (clamp3 = _ ? true : identity8, rescale()) : clamp3 !== identity8;
  };
  scale8.interpolate = function(_) {
    return arguments.length ? (interpolate4 = _, rescale()) : interpolate4;
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  return function(t, u) {
    transform4 = t, untransform = u;
    return rescale();
  };
}
function continuous3() {
  return transformer4()(identity8, identity8);
}
var unit2;
var init_continuous2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/continuous.js"() {
    init_src9();
    init_src18();
    init_constant7();
    init_number6();
    unit2 = [0, 1];
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/tickFormat.js
function tickFormat3(start, stop2, count5, specifier) {
  var step = tickStep2(start, stop2, count5), precision;
  specifier = formatSpecifier2(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value4 = Math.max(Math.abs(start), Math.abs(stop2));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default2(step, value4)))
        specifier.precision = precision;
      return formatPrefix2(specifier, value4);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default2(step, Math.max(Math.abs(start), Math.abs(stop2)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default2(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format3(specifier);
}
var init_tickFormat2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/tickFormat.js"() {
    init_src9();
    init_src15();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/linear.js
function linearish2(scale8) {
  var domain4 = scale8.domain;
  scale8.ticks = function(count5) {
    var d = domain4();
    return ticks_default(d[0], d[d.length - 1], count5 == null ? 10 : count5);
  };
  scale8.tickFormat = function(count5, specifier) {
    var d = domain4();
    return tickFormat3(d[0], d[d.length - 1], count5 == null ? 10 : count5, specifier);
  };
  scale8.nice = function(count5) {
    if (count5 == null)
      count5 = 10;
    var d = domain4();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop2 = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop2 < start) {
      step = start, start = stop2, stop2 = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement2(start, stop2, count5);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop2;
        return domain4(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop2 = Math.ceil(stop2 / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop2 = Math.floor(stop2 * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale8;
  };
  return scale8;
}
function linear5() {
  var scale8 = continuous3();
  scale8.copy = function() {
    return copy3(scale8, linear5());
  };
  initRange2.apply(scale8, arguments);
  return linearish2(scale8);
}
var init_linear3 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/linear.js"() {
    init_src9();
    init_continuous2();
    init_init2();
    init_tickFormat2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/identity.js
function identity9(domain4) {
  var unknown;
  function scale8(x7) {
    return x7 == null || isNaN(x7 = +x7) ? unknown : x7;
  }
  scale8.invert = scale8;
  scale8.domain = scale8.range = function(_) {
    return arguments.length ? (domain4 = Array.from(_, number5), scale8) : domain4.slice();
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  scale8.copy = function() {
    return identity9(domain4).unknown(unknown);
  };
  domain4 = arguments.length ? Array.from(domain4, number5) : [0, 1];
  return linearish2(scale8);
}
var init_identity8 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/identity.js"() {
    init_linear3();
    init_number6();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/nice.js
function nice4(domain4, interval3) {
  domain4 = domain4.slice();
  var i0 = 0, i1 = domain4.length - 1, x07 = domain4[i0], x13 = domain4[i1], t;
  if (x13 < x07) {
    t = i0, i0 = i1, i1 = t;
    t = x07, x07 = x13, x13 = t;
  }
  domain4[i0] = interval3.floor(x07);
  domain4[i1] = interval3.ceil(x13);
  return domain4;
}
var init_nice4 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/nice.js"() {
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/log.js
function transformLog2(x7) {
  return Math.log(x7);
}
function transformExp2(x7) {
  return Math.exp(x7);
}
function transformLogn2(x7) {
  return -Math.log(-x7);
}
function transformExpn2(x7) {
  return -Math.exp(-x7);
}
function pow102(x7) {
  return isFinite(x7) ? +("1e" + x7) : x7 < 0 ? 0 : x7;
}
function powp2(base3) {
  return base3 === 10 ? pow102 : base3 === Math.E ? Math.exp : function(x7) {
    return Math.pow(base3, x7);
  };
}
function logp2(base3) {
  return base3 === Math.E ? Math.log : base3 === 10 && Math.log10 || base3 === 2 && Math.log2 || (base3 = Math.log(base3), function(x7) {
    return Math.log(x7) / base3;
  });
}
function reflect2(f) {
  return function(x7) {
    return -f(-x7);
  };
}
function loggish2(transform4) {
  var scale8 = transform4(transformLog2, transformExp2), domain4 = scale8.domain, base3 = 10, logs, pows;
  function rescale() {
    logs = logp2(base3), pows = powp2(base3);
    if (domain4()[0] < 0) {
      logs = reflect2(logs), pows = reflect2(pows);
      transform4(transformLogn2, transformExpn2);
    } else {
      transform4(transformLog2, transformExp2);
    }
    return scale8;
  }
  scale8.base = function(_) {
    return arguments.length ? (base3 = +_, rescale()) : base3;
  };
  scale8.domain = function(_) {
    return arguments.length ? (domain4(_), rescale()) : domain4();
  };
  scale8.ticks = function(count5) {
    var d = domain4(), u = d[0], v = d[d.length - 1], r2;
    if (r2 = v < u)
      i = u, u = v, v = i;
    var i = logs(u), j = logs(v), p, k4, t, n = count5 == null ? 10 : +count5, z = [];
    if (!(base3 % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0)
        for (; i <= j; ++i) {
          for (k4 = 1, p = pows(i); k4 < base3; ++k4) {
            t = p * k4;
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      else
        for (; i <= j; ++i) {
          for (k4 = base3 - 1, p = pows(i); k4 >= 1; --k4) {
            t = p * k4;
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      if (z.length * 2 < n)
        z = ticks_default(u, v, n);
    } else {
      z = ticks_default(i, j, Math.min(j - i, n)).map(pows);
    }
    return r2 ? z.reverse() : z;
  };
  scale8.tickFormat = function(count5, specifier) {
    if (specifier == null)
      specifier = base3 === 10 ? ".0e" : ",";
    if (typeof specifier !== "function")
      specifier = format3(specifier);
    if (count5 === Infinity)
      return specifier;
    if (count5 == null)
      count5 = 10;
    var k4 = Math.max(1, base3 * count5 / scale8.ticks().length);
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base3 < base3 - 0.5)
        i *= base3;
      return i <= k4 ? specifier(d) : "";
    };
  };
  scale8.nice = function() {
    return domain4(nice4(domain4(), {
      floor: function(x7) {
        return pows(Math.floor(logs(x7)));
      },
      ceil: function(x7) {
        return pows(Math.ceil(logs(x7)));
      }
    }));
  };
  return scale8;
}
function log4() {
  var scale8 = loggish2(transformer4()).domain([1, 10]);
  scale8.copy = function() {
    return copy3(scale8, log4()).base(scale8.base());
  };
  initRange2.apply(scale8, arguments);
  return scale8;
}
var init_log2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/log.js"() {
    init_src9();
    init_src15();
    init_nice4();
    init_continuous2();
    init_init2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/symlog.js
function transformSymlog2(c2) {
  return function(x7) {
    return Math.sign(x7) * Math.log1p(Math.abs(x7 / c2));
  };
}
function transformSymexp2(c2) {
  return function(x7) {
    return Math.sign(x7) * Math.expm1(Math.abs(x7)) * c2;
  };
}
function symlogish2(transform4) {
  var c2 = 1, scale8 = transform4(transformSymlog2(c2), transformSymexp2(c2));
  scale8.constant = function(_) {
    return arguments.length ? transform4(transformSymlog2(c2 = +_), transformSymexp2(c2)) : c2;
  };
  return linearish2(scale8);
}
function symlog3() {
  var scale8 = symlogish2(transformer4());
  scale8.copy = function() {
    return copy3(scale8, symlog3()).constant(scale8.constant());
  };
  return initRange2.apply(scale8, arguments);
}
var init_symlog2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/symlog.js"() {
    init_linear3();
    init_continuous2();
    init_init2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/pow.js
function transformPow2(exponent) {
  return function(x7) {
    return x7 < 0 ? -Math.pow(-x7, exponent) : Math.pow(x7, exponent);
  };
}
function transformSqrt2(x7) {
  return x7 < 0 ? -Math.sqrt(-x7) : Math.sqrt(x7);
}
function transformSquare2(x7) {
  return x7 < 0 ? -x7 * x7 : x7 * x7;
}
function powish2(transform4) {
  var scale8 = transform4(identity8, identity8), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform4(identity8, identity8) : exponent === 0.5 ? transform4(transformSqrt2, transformSquare2) : transform4(transformPow2(exponent), transformPow2(1 / exponent));
  }
  scale8.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish2(scale8);
}
function pow4() {
  var scale8 = powish2(transformer4());
  scale8.copy = function() {
    return copy3(scale8, pow4()).exponent(scale8.exponent());
  };
  initRange2.apply(scale8, arguments);
  return scale8;
}
function sqrt4() {
  return pow4.apply(null, arguments).exponent(0.5);
}
var init_pow2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/pow.js"() {
    init_linear3();
    init_continuous2();
    init_init2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/radial.js
var init_radial3 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/radial.js"() {
    init_continuous2();
    init_init2();
    init_linear3();
    init_number6();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/quantile.js
function quantile4() {
  var domain4 = [], range7 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range7.length);
    thresholds = new Array(n - 1);
    while (++i < n)
      thresholds[i - 1] = quantileSorted2(domain4, i / n);
    return scale8;
  }
  function scale8(x7) {
    return x7 == null || isNaN(x7 = +x7) ? unknown : range7[bisect_default3(thresholds, x7)];
  }
  scale8.invertExtent = function(y7) {
    var i = range7.indexOf(y7);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain4[0],
      i < thresholds.length ? thresholds[i] : domain4[domain4.length - 1]
    ];
  };
  scale8.domain = function(_) {
    if (!arguments.length)
      return domain4.slice();
    domain4 = [];
    for (let d of _)
      if (d != null && !isNaN(d = +d))
        domain4.push(d);
    domain4.sort(ascending_default);
    return rescale();
  };
  scale8.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), rescale()) : range7.slice();
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  scale8.quantiles = function() {
    return thresholds.slice();
  };
  scale8.copy = function() {
    return quantile4().domain(domain4).range(range7).unknown(unknown);
  };
  return initRange2.apply(scale8, arguments);
}
var init_quantile4 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/quantile.js"() {
    init_src9();
    init_init2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/quantize.js
function quantize2() {
  var x07 = 0, x13 = 1, n = 1, domain4 = [0.5], range7 = [0, 1], unknown;
  function scale8(x7) {
    return x7 != null && x7 <= x7 ? range7[bisect_default3(domain4, x7, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain4 = new Array(n);
    while (++i < n)
      domain4[i] = ((i + 1) * x13 - (i - n) * x07) / (n + 1);
    return scale8;
  }
  scale8.domain = function(_) {
    return arguments.length ? ([x07, x13] = _, x07 = +x07, x13 = +x13, rescale()) : [x07, x13];
  };
  scale8.range = function(_) {
    return arguments.length ? (n = (range7 = Array.from(_)).length - 1, rescale()) : range7.slice();
  };
  scale8.invertExtent = function(y7) {
    var i = range7.indexOf(y7);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x07, domain4[0]] : i >= n ? [domain4[n - 1], x13] : [domain4[i - 1], domain4[i]];
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : scale8;
  };
  scale8.thresholds = function() {
    return domain4.slice();
  };
  scale8.copy = function() {
    return quantize2().domain([x07, x13]).range(range7).unknown(unknown);
  };
  return initRange2.apply(linearish2(scale8), arguments);
}
var init_quantize5 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/quantize.js"() {
    init_src9();
    init_linear3();
    init_init2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/threshold.js
function threshold2() {
  var domain4 = [0.5], range7 = [0, 1], unknown, n = 1;
  function scale8(x7) {
    return x7 != null && x7 <= x7 ? range7[bisect_default3(domain4, x7, 0, n)] : unknown;
  }
  scale8.domain = function(_) {
    return arguments.length ? (domain4 = Array.from(_), n = Math.min(domain4.length, range7.length - 1), scale8) : domain4.slice();
  };
  scale8.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), n = Math.min(domain4.length, range7.length - 1), scale8) : range7.slice();
  };
  scale8.invertExtent = function(y7) {
    var i = range7.indexOf(y7);
    return [domain4[i - 1], domain4[i]];
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  scale8.copy = function() {
    return threshold2().domain(domain4).range(range7).unknown(unknown);
  };
  return initRange2.apply(scale8, arguments);
}
var init_threshold2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/threshold.js"() {
    init_src9();
    init_init2();
  }
});

// node_modules/.pnpm/d3-time-format@3.0.0/node_modules/d3-time-format/src/locale.js
function localDate3(d) {
  if (0 <= d.y && d.y < 100) {
    var date3 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date3.setFullYear(d.y);
    return date3;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate3(d) {
  if (0 <= d.y && d.y < 100) {
    var date3 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date3.setUTCFullYear(d.y);
    return date3;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate2(y7, m2, d) {
  return { y: y7, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale2(locale7) {
  var locale_dateTime = locale7.dateTime, locale_date = locale7.date, locale_time = locale7.time, locale_periods = locale7.periods, locale_weekdays = locale7.days, locale_shortWeekdays = locale7.shortDays, locale_months = locale7.months, locale_shortMonths = locale7.shortMonths;
  var periodRe = formatRe2(locale_periods), periodLookup = formatLookup2(locale_periods), weekdayRe = formatRe2(locale_weekdays), weekdayLookup = formatLookup2(locale_weekdays), shortWeekdayRe = formatRe2(locale_shortWeekdays), shortWeekdayLookup = formatLookup2(locale_shortWeekdays), monthRe = formatRe2(locale_months), monthLookup = formatLookup2(locale_months), shortMonthRe = formatRe2(locale_shortMonths), shortMonthLookup = formatLookup2(locale_shortMonths);
  var formats5 = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth2,
    "e": formatDayOfMonth2,
    "f": formatMicroseconds2,
    "g": formatYearISO2,
    "G": formatFullYearISO2,
    "H": formatHour242,
    "I": formatHour122,
    "j": formatDayOfYear2,
    "L": formatMilliseconds2,
    "m": formatMonthNumber2,
    "M": formatMinutes2,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp2,
    "s": formatUnixTimestampSeconds2,
    "S": formatSeconds2,
    "u": formatWeekdayNumberMonday2,
    "U": formatWeekNumberSunday2,
    "V": formatWeekNumberISO2,
    "w": formatWeekdayNumberSunday2,
    "W": formatWeekNumberMonday2,
    "x": null,
    "X": null,
    "y": formatYear3,
    "Y": formatFullYear2,
    "Z": formatZone2,
    "%": formatLiteralPercent2
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth2,
    "e": formatUTCDayOfMonth2,
    "f": formatUTCMicroseconds2,
    "g": formatUTCYearISO2,
    "G": formatUTCFullYearISO2,
    "H": formatUTCHour242,
    "I": formatUTCHour122,
    "j": formatUTCDayOfYear2,
    "L": formatUTCMilliseconds2,
    "m": formatUTCMonthNumber2,
    "M": formatUTCMinutes2,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp2,
    "s": formatUnixTimestampSeconds2,
    "S": formatUTCSeconds2,
    "u": formatUTCWeekdayNumberMonday2,
    "U": formatUTCWeekNumberSunday2,
    "V": formatUTCWeekNumberISO2,
    "w": formatUTCWeekdayNumberSunday2,
    "W": formatUTCWeekNumberMonday2,
    "x": null,
    "X": null,
    "y": formatUTCYear2,
    "Y": formatUTCFullYear2,
    "Z": formatUTCZone2,
    "%": formatLiteralPercent2
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth2,
    "e": parseDayOfMonth2,
    "f": parseMicroseconds2,
    "g": parseYear2,
    "G": parseFullYear2,
    "H": parseHour242,
    "I": parseHour242,
    "j": parseDayOfYear2,
    "L": parseMilliseconds2,
    "m": parseMonthNumber2,
    "M": parseMinutes2,
    "p": parsePeriod,
    "q": parseQuarter2,
    "Q": parseUnixTimestamp2,
    "s": parseUnixTimestampSeconds2,
    "S": parseSeconds2,
    "u": parseWeekdayNumberMonday2,
    "U": parseWeekNumberSunday2,
    "V": parseWeekNumberISO2,
    "w": parseWeekdayNumberSunday2,
    "W": parseWeekNumberMonday2,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear2,
    "Y": parseFullYear2,
    "Z": parseZone2,
    "%": parseLiteralPercent2
  };
  formats5.x = newFormat(locale_date, formats5);
  formats5.X = newFormat(locale_time, formats5);
  formats5.c = newFormat(locale_dateTime, formats5);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats6) {
    return function(date3) {
      var string = [], i = -1, j = 0, n = specifier.length, c2, pad6, format9;
      if (!(date3 instanceof Date))
        date3 = new Date(+date3);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad6 = pads2[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad6 = c2 === "e" ? " " : "0";
          if (format9 = formats6[c2])
            c2 = format9(date3, pad6);
          string.push(c2);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate2(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week2, day2;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week2 = utcDate3(newDate2(d.y, 0, 1)), day2 = week2.getUTCDay();
          week2 = day2 > 4 || day2 === 0 ? utcMonday2.ceil(week2) : utcMonday2(week2);
          week2 = utcDay_default.offset(week2, (d.V - 1) * 7);
          d.y = week2.getUTCFullYear();
          d.m = week2.getUTCMonth();
          d.d = week2.getUTCDate() + (d.w + 6) % 7;
        } else {
          week2 = localDate3(newDate2(d.y, 0, 1)), day2 = week2.getDay();
          week2 = day2 > 4 || day2 === 0 ? monday.ceil(week2) : monday(week2);
          week2 = day_default.offset(week2, (d.V - 1) * 7);
          d.y = week2.getFullYear();
          d.m = week2.getMonth();
          d.d = week2.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate3(newDate2(d.y, 0, 1)).getUTCDay() : localDate3(newDate2(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate3(d);
      }
      return localDate3(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m2 = string.length, c2, parse8;
    while (i < n) {
      if (j >= m2)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse8 = parses[c2 in pads2 ? specifier.charAt(i++) : c2];
        if (!parse8 || (j = parse8(d, string, j)) < 0)
          return -1;
      } else if (c2 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats5);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
function pad4(value4, fill3, width2) {
  var sign5 = value4 < 0 ? "-" : "", string = (sign5 ? -value4 : value4) + "", length4 = string.length;
  return sign5 + (length4 < width2 ? new Array(width2 - length4 + 1).join(fill3) + string : string);
}
function requote2(s3) {
  return s3.replace(requoteRe2, "\\$&");
}
function formatRe2(names) {
  return new RegExp("^(?:" + names.map(requote2).join("|") + ")", "i");
}
function formatLookup2(names) {
  return new Map(names.map((name4, i) => [name4.toLowerCase(), i]));
}
function parseWeekdayNumberSunday2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone2(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour242(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds2(d, string, i) {
  var n = numberRe2.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent2(d, string, i) {
  var n = percentRe2.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp2(d, string, i) {
  var n = numberRe2.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds2(d, string, i) {
  var n = numberRe2.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth2(d, p) {
  return pad4(d.getDate(), p, 2);
}
function formatHour242(d, p) {
  return pad4(d.getHours(), p, 2);
}
function formatHour122(d, p) {
  return pad4(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear2(d, p) {
  return pad4(1 + day_default.count(year_default(d), d), p, 3);
}
function formatMilliseconds2(d, p) {
  return pad4(d.getMilliseconds(), p, 3);
}
function formatMicroseconds2(d, p) {
  return formatMilliseconds2(d, p) + "000";
}
function formatMonthNumber2(d, p) {
  return pad4(d.getMonth() + 1, p, 2);
}
function formatMinutes2(d, p) {
  return pad4(d.getMinutes(), p, 2);
}
function formatSeconds2(d, p) {
  return pad4(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday2(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday2(d, p) {
  return pad4(sunday.count(year_default(d) - 1, d), p, 2);
}
function dISO2(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO2(d, p) {
  d = dISO2(d);
  return pad4(thursday.count(year_default(d), d) + (year_default(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday2(d) {
  return d.getDay();
}
function formatWeekNumberMonday2(d, p) {
  return pad4(monday.count(year_default(d) - 1, d), p, 2);
}
function formatYear3(d, p) {
  return pad4(d.getFullYear() % 100, p, 2);
}
function formatYearISO2(d, p) {
  d = dISO2(d);
  return pad4(d.getFullYear() % 100, p, 2);
}
function formatFullYear2(d, p) {
  return pad4(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO2(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad4(d.getFullYear() % 1e4, p, 4);
}
function formatZone2(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad4(z / 60 | 0, "0", 2) + pad4(z % 60, "0", 2);
}
function formatUTCDayOfMonth2(d, p) {
  return pad4(d.getUTCDate(), p, 2);
}
function formatUTCHour242(d, p) {
  return pad4(d.getUTCHours(), p, 2);
}
function formatUTCHour122(d, p) {
  return pad4(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear2(d, p) {
  return pad4(1 + utcDay_default.count(utcYear_default(d), d), p, 3);
}
function formatUTCMilliseconds2(d, p) {
  return pad4(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds2(d, p) {
  return formatUTCMilliseconds2(d, p) + "000";
}
function formatUTCMonthNumber2(d, p) {
  return pad4(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes2(d, p) {
  return pad4(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds2(d, p) {
  return pad4(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday2(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday2(d, p) {
  return pad4(utcSunday2.count(utcYear_default(d) - 1, d), p, 2);
}
function UTCdISO2(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday2(d) : utcThursday2.ceil(d);
}
function formatUTCWeekNumberISO2(d, p) {
  d = UTCdISO2(d);
  return pad4(utcThursday2.count(utcYear_default(d), d) + (utcYear_default(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday2(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday2(d, p) {
  return pad4(utcMonday2.count(utcYear_default(d) - 1, d), p, 2);
}
function formatUTCYear2(d, p) {
  return pad4(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO2(d, p) {
  d = UTCdISO2(d);
  return pad4(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear2(d, p) {
  return pad4(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO2(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday2(d) : utcThursday2.ceil(d);
  return pad4(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone2() {
  return "+0000";
}
function formatLiteralPercent2() {
  return "%";
}
function formatUnixTimestamp2(d) {
  return +d;
}
function formatUnixTimestampSeconds2(d) {
  return Math.floor(+d / 1e3);
}
var pads2, numberRe2, percentRe2, requoteRe2;
var init_locale4 = __esm({
  "node_modules/.pnpm/d3-time-format@3.0.0/node_modules/d3-time-format/src/locale.js"() {
    init_src10();
    pads2 = { "-": "", "_": " ", "0": "0" };
    numberRe2 = /^\s*\d+/;
    percentRe2 = /^%/;
    requoteRe2 = /[\\^$*+?|[\]().{}]/g;
  }
});

// node_modules/.pnpm/d3-time-format@3.0.0/node_modules/d3-time-format/src/defaultLocale.js
function defaultLocale5(definition3) {
  locale4 = formatLocale2(definition3);
  timeFormat2 = locale4.format;
  timeParse2 = locale4.parse;
  utcFormat2 = locale4.utcFormat;
  utcParse2 = locale4.utcParse;
  return locale4;
}
var locale4, timeFormat2, timeParse2, utcFormat2, utcParse2;
var init_defaultLocale4 = __esm({
  "node_modules/.pnpm/d3-time-format@3.0.0/node_modules/d3-time-format/src/defaultLocale.js"() {
    init_locale4();
    defaultLocale5({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
  }
});

// node_modules/.pnpm/d3-time-format@3.0.0/node_modules/d3-time-format/src/isoFormat.js
function formatIsoNative2(date3) {
  return date3.toISOString();
}
var isoSpecifier2, formatIso2;
var init_isoFormat2 = __esm({
  "node_modules/.pnpm/d3-time-format@3.0.0/node_modules/d3-time-format/src/isoFormat.js"() {
    init_defaultLocale4();
    isoSpecifier2 = "%Y-%m-%dT%H:%M:%S.%LZ";
    formatIso2 = Date.prototype.toISOString ? formatIsoNative2 : utcFormat2(isoSpecifier2);
  }
});

// node_modules/.pnpm/d3-time-format@3.0.0/node_modules/d3-time-format/src/isoParse.js
function parseIsoNative2(string) {
  var date3 = new Date(string);
  return isNaN(date3) ? null : date3;
}
var parseIso2;
var init_isoParse2 = __esm({
  "node_modules/.pnpm/d3-time-format@3.0.0/node_modules/d3-time-format/src/isoParse.js"() {
    init_isoFormat2();
    init_defaultLocale4();
    parseIso2 = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative2 : utcParse2(isoSpecifier2);
  }
});

// node_modules/.pnpm/d3-time-format@3.0.0/node_modules/d3-time-format/src/index.js
var init_src19 = __esm({
  "node_modules/.pnpm/d3-time-format@3.0.0/node_modules/d3-time-format/src/index.js"() {
    init_defaultLocale4();
    init_locale4();
    init_isoFormat2();
    init_isoParse2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/time.js
function date2(t) {
  return new Date(t);
}
function number6(t) {
  return t instanceof Date ? +t : +new Date(+t);
}
function calendar2(ticks3, tickInterval, year2, month2, week2, day2, hour2, minute2, second3, format9) {
  var scale8 = continuous3(), invert2 = scale8.invert, domain4 = scale8.domain;
  var formatMillisecond = format9(".%L"), formatSecond = format9(":%S"), formatMinute = format9("%I:%M"), formatHour = format9("%I %p"), formatDay = format9("%a %d"), formatWeek = format9("%b %d"), formatMonth = format9("%B"), formatYear5 = format9("%Y");
  function tickFormat5(date3) {
    return (second3(date3) < date3 ? formatMillisecond : minute2(date3) < date3 ? formatSecond : hour2(date3) < date3 ? formatMinute : day2(date3) < date3 ? formatHour : month2(date3) < date3 ? week2(date3) < date3 ? formatDay : formatWeek : year2(date3) < date3 ? formatMonth : formatYear5)(date3);
  }
  scale8.invert = function(y7) {
    return new Date(invert2(y7));
  };
  scale8.domain = function(_) {
    return arguments.length ? domain4(Array.from(_, number6)) : domain4().map(date2);
  };
  scale8.ticks = function(interval3) {
    var d = domain4();
    return ticks3(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
  };
  scale8.tickFormat = function(count5, specifier) {
    return specifier == null ? tickFormat5 : format9(specifier);
  };
  scale8.nice = function(interval3) {
    var d = domain4();
    if (!interval3 || typeof interval3.range !== "function")
      interval3 = tickInterval(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
    return interval3 ? domain4(nice4(d, interval3)) : scale8;
  };
  scale8.copy = function() {
    return copy3(scale8, calendar2(ticks3, tickInterval, year2, month2, week2, day2, hour2, minute2, second3, format9));
  };
  return scale8;
}
function time2() {
  return initRange2.apply(calendar2(timeTicks2, timeTickInterval2, year_default, month_default, sunday, day_default, hour_default, minute_default, second_default, timeFormat2).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var init_time2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/time.js"() {
    init_src10();
    init_src19();
    init_continuous2();
    init_init2();
    init_nice4();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/utcTime.js
function utcTime2() {
  return initRange2.apply(calendar2(utcTicks2, utcTickInterval2, utcYear_default, utcMonth_default, utcSunday2, utcDay_default, utcHour_default, utcMinute_default, second_default, utcFormat2).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
var init_utcTime2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/utcTime.js"() {
    init_src10();
    init_src19();
    init_time2();
    init_init2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/sequential.js
function transformer5() {
  var x07 = 0, x13 = 1, t07, t15, k10, transform4, interpolator = identity8, clamp3 = false, unknown;
  function scale8(x7) {
    return x7 == null || isNaN(x7 = +x7) ? unknown : interpolator(k10 === 0 ? 0.5 : (x7 = (transform4(x7) - t07) * k10, clamp3 ? Math.max(0, Math.min(1, x7)) : x7));
  }
  scale8.domain = function(_) {
    return arguments.length ? ([x07, x13] = _, t07 = transform4(x07 = +x07), t15 = transform4(x13 = +x13), k10 = t07 === t15 ? 0 : 1 / (t15 - t07), scale8) : [x07, x13];
  };
  scale8.clamp = function(_) {
    return arguments.length ? (clamp3 = !!_, scale8) : clamp3;
  };
  scale8.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale8) : interpolator;
  };
  function range7(interpolate4) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate4(r0, r1), scale8) : [interpolator(0), interpolator(1)];
    };
  }
  scale8.range = range7(value_default2);
  scale8.rangeRound = range7(round_default2);
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  return function(t) {
    transform4 = t, t07 = t(x07), t15 = t(x13), k10 = t07 === t15 ? 0 : 1 / (t15 - t07);
    return scale8;
  };
}
function copy4(source5, target2) {
  return target2.domain(source5.domain()).interpolator(source5.interpolator()).clamp(source5.clamp()).unknown(source5.unknown());
}
function sequential2() {
  var scale8 = linearish2(transformer5()(identity8));
  scale8.copy = function() {
    return copy4(scale8, sequential2());
  };
  return initInterpolator2.apply(scale8, arguments);
}
function sequentialLog2() {
  var scale8 = loggish2(transformer5()).domain([1, 10]);
  scale8.copy = function() {
    return copy4(scale8, sequentialLog2()).base(scale8.base());
  };
  return initInterpolator2.apply(scale8, arguments);
}
function sequentialSymlog2() {
  var scale8 = symlogish2(transformer5());
  scale8.copy = function() {
    return copy4(scale8, sequentialSymlog2()).constant(scale8.constant());
  };
  return initInterpolator2.apply(scale8, arguments);
}
function sequentialPow2() {
  var scale8 = powish2(transformer5());
  scale8.copy = function() {
    return copy4(scale8, sequentialPow2()).exponent(scale8.exponent());
  };
  return initInterpolator2.apply(scale8, arguments);
}
function sequentialSqrt2() {
  return sequentialPow2.apply(null, arguments).exponent(0.5);
}
var init_sequential2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/sequential.js"() {
    init_src18();
    init_continuous2();
    init_init2();
    init_linear3();
    init_log2();
    init_symlog2();
    init_pow2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/sequentialQuantile.js
var init_sequentialQuantile2 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/sequentialQuantile.js"() {
    init_src9();
    init_continuous2();
    init_init2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/diverging.js
function transformer6() {
  var x07 = 0, x13 = 0.5, x22 = 1, s3 = 1, t07, t15, t23, k10, k21, interpolator = identity8, transform4, clamp3 = false, unknown;
  function scale8(x7) {
    return isNaN(x7 = +x7) ? unknown : (x7 = 0.5 + ((x7 = +transform4(x7)) - t15) * (s3 * x7 < s3 * t15 ? k10 : k21), interpolator(clamp3 ? Math.max(0, Math.min(1, x7)) : x7));
  }
  scale8.domain = function(_) {
    return arguments.length ? ([x07, x13, x22] = _, t07 = transform4(x07 = +x07), t15 = transform4(x13 = +x13), t23 = transform4(x22 = +x22), k10 = t07 === t15 ? 0 : 0.5 / (t15 - t07), k21 = t15 === t23 ? 0 : 0.5 / (t23 - t15), s3 = t15 < t07 ? -1 : 1, scale8) : [x07, x13, x22];
  };
  scale8.clamp = function(_) {
    return arguments.length ? (clamp3 = !!_, scale8) : clamp3;
  };
  scale8.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale8) : interpolator;
  };
  function range7(interpolate4) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise2(interpolate4, [r0, r1, r2]), scale8) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale8.range = range7(value_default2);
  scale8.rangeRound = range7(round_default2);
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  return function(t) {
    transform4 = t, t07 = t(x07), t15 = t(x13), t23 = t(x22), k10 = t07 === t15 ? 0 : 0.5 / (t15 - t07), k21 = t15 === t23 ? 0 : 0.5 / (t23 - t15), s3 = t15 < t07 ? -1 : 1;
    return scale8;
  };
}
function diverging2() {
  var scale8 = linearish2(transformer6()(identity8));
  scale8.copy = function() {
    return copy4(scale8, diverging2());
  };
  return initInterpolator2.apply(scale8, arguments);
}
function divergingLog2() {
  var scale8 = loggish2(transformer6()).domain([0.1, 1, 10]);
  scale8.copy = function() {
    return copy4(scale8, divergingLog2()).base(scale8.base());
  };
  return initInterpolator2.apply(scale8, arguments);
}
function divergingSymlog2() {
  var scale8 = symlogish2(transformer6());
  scale8.copy = function() {
    return copy4(scale8, divergingSymlog2()).constant(scale8.constant());
  };
  return initInterpolator2.apply(scale8, arguments);
}
function divergingPow2() {
  var scale8 = powish2(transformer6());
  scale8.copy = function() {
    return copy4(scale8, divergingPow2()).exponent(scale8.exponent());
  };
  return initInterpolator2.apply(scale8, arguments);
}
function divergingSqrt2() {
  return divergingPow2.apply(null, arguments).exponent(0.5);
}
var init_diverging3 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/diverging.js"() {
    init_src18();
    init_continuous2();
    init_init2();
    init_linear3();
    init_log2();
    init_sequential2();
    init_symlog2();
    init_pow2();
  }
});

// node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/index.js
var init_src20 = __esm({
  "node_modules/.pnpm/d3-scale@3.3.0/node_modules/d3-scale/src/index.js"() {
    init_band2();
    init_identity8();
    init_linear3();
    init_log2();
    init_symlog2();
    init_ordinal2();
    init_pow2();
    init_radial3();
    init_quantile4();
    init_quantize5();
    init_threshold2();
    init_time2();
    init_utcTime2();
    init_sequential2();
    init_sequentialQuantile2();
    init_diverging3();
    init_tickFormat2();
  }
});

// node_modules/.pnpm/vega-scale@7.1.1/node_modules/vega-scale/build/vega-scale.module.js
function bandSpace2(count5, paddingInner2, paddingOuter2) {
  const space = count5 - paddingInner2 + paddingOuter2 * 2;
  return count5 ? space > 0 ? space : 1 : 0;
}
function invertRange2(scale8) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale8.invert(lo), scale8.invert(hi)];
  };
}
function invertRangeExtent2(scale8) {
  return function(_) {
    const range7 = scale8.range();
    let lo = _[0], hi = _[1], min8 = -1, max8, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min8 < 0)
          min8 = i;
        max8 = i;
      }
    }
    if (min8 < 0)
      return void 0;
    lo = scale8.invertExtent(range7[min8]);
    hi = scale8.invertExtent(range7[max8]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band4() {
  const scale8 = ordinal2().unknown(void 0), domain4 = scale8.domain, ordinalRange = scale8.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale8.unknown;
  function rescale() {
    const n = domain4().length, reverse6 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse6], space = bandSpace2(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse6 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values5 = range_default(n).map((i) => start + step * i);
    return ordinalRange(reverse6 ? values5.reverse() : values5);
  }
  scale8.domain = function(_) {
    if (arguments.length) {
      domain4(_);
      return rescale();
    } else {
      return domain4();
    }
  };
  scale8.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale8.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale8.bandwidth = function() {
    return bandwidth2;
  };
  scale8.step = function() {
    return step;
  };
  scale8.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale8.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale8.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale8.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale8.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale8.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse6 = range$1[1] < range$1[0], values5 = reverse6 ? ordinalRange().reverse() : ordinalRange(), n = values5.length - 1;
    let lo = +_[0], hi = +_[1], a4, b3, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values5[0] || lo > range$1[1 - reverse6])
      return;
    a4 = Math.max(0, bisectRight2(values5, lo) - 1);
    b3 = lo === hi ? a4 : bisectRight2(values5, hi) - 1;
    if (lo - values5[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse6) {
      t = a4;
      a4 = n - b3;
      b3 = n - t;
    }
    return a4 > b3 ? void 0 : domain4().slice(a4, b3 + 1);
  };
  scale8.invert = function(_) {
    const value4 = scale8.invertRange([_, _]);
    return value4 ? value4[0] : value4;
  };
  scale8.copy = function() {
    return band4().domain(domain4()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish2(scale8) {
  const copy6 = scale8.copy;
  scale8.padding = scale8.paddingOuter;
  delete scale8.paddingInner;
  scale8.copy = function() {
    return pointish2(copy6());
  };
  return scale8;
}
function point9() {
  return pointish2(band4().paddingInner(1));
}
function numbers5(_) {
  return map7.call(_, toNumber);
}
function scaleBinOrdinal2() {
  let domain4 = [], range7 = [];
  function scale8(x7) {
    return x7 == null || x7 !== x7 ? void 0 : range7[(bisect_default3(domain4, x7) - 1) % range7.length];
  }
  scale8.domain = function(_) {
    if (arguments.length) {
      domain4 = numbers5(_);
      return scale8;
    } else {
      return domain4.slice();
    }
  };
  scale8.range = function(_) {
    if (arguments.length) {
      range7 = slice5.call(_);
      return scale8;
    } else {
      return range7.slice();
    }
  };
  scale8.tickFormat = function(count5, specifier) {
    return tickFormat3(domain4[0], peek(domain4), count5 == null ? 10 : count5, specifier);
  };
  scale8.copy = function() {
    return scaleBinOrdinal2().domain(scale8.domain()).range(scale8.range());
  };
  return scale8;
}
function create2(type4, constructor, metadata3) {
  const ctr = function scale8() {
    const s3 = constructor();
    if (!s3.invertRange) {
      s3.invertRange = s3.invert ? invertRange2(s3) : s3.invertExtent ? invertRangeExtent2(s3) : void 0;
    }
    s3.type = type4;
    return s3;
  };
  ctr.metadata = toSet(array(metadata3));
  return ctr;
}
function scale3(type4, scale8, metadata3) {
  if (arguments.length > 1) {
    scales2[type4] = create2(type4, scale8, metadata3);
    return this;
  } else {
    return isValidScaleType2(type4) ? scales2[type4] : void 0;
  }
}
function isValidScaleType2(type4) {
  return has(scales2, type4);
}
function hasType2(key3, type4) {
  const s3 = scales2[key3];
  return s3 && s3.metadata[type4];
}
function isContinuous(key3) {
  return hasType2(key3, Continuous2);
}
function isDiscrete2(key3) {
  return hasType2(key3, Discrete2);
}
function isDiscretizing2(key3) {
  return hasType2(key3, Discretizing2);
}
function isLogarithmic2(key3) {
  return hasType2(key3, Log2);
}
function isTemporal2(key3) {
  return hasType2(key3, Temporal2);
}
function isInterpolating(key3) {
  return hasType2(key3, Interpolating2);
}
function isQuantile(key3) {
  return hasType2(key3, Quantile3);
}
function interpolateRange(interpolator, range7) {
  const start = range7[0], span3 = peek(range7) - start;
  return function(i) {
    return interpolator(start + i * span3);
  };
}
function interpolateColors2(colors3, type4, gamma3) {
  return piecewise2(interpolate2(type4 || "rgb", gamma3), colors3);
}
function quantizeInterpolator(interpolator, count5) {
  const samples = new Array(count5), n = count5 + 1;
  for (let i = 0; i < count5; )
    samples[i] = interpolator(++i / n);
  return samples;
}
function scaleFraction(scale$13, min8, max8) {
  const delta = max8 - min8;
  let i, t, s3;
  if (!delta || !Number.isFinite(delta)) {
    return constant(0.5);
  } else {
    i = (t = scale$13.type).indexOf("-");
    t = i < 0 ? t : t.slice(i + 1);
    s3 = scale3(t)().domain([min8, max8]).range([0, 1]);
    scaleProps.forEach((m2) => scale$13[m2] ? s3[m2](scale$13[m2]()) : 0);
    return s3;
  }
}
function interpolate2(type4, gamma3) {
  const interp = src_exports4[method2(type4)];
  return gamma3 != null && interp && interp.gamma ? interp.gamma(gamma3) : interp;
}
function method2(type4) {
  return "interpolate" + type4.toLowerCase().split("-").map((s3) => s3[0].toUpperCase() + s3.slice(1)).join("");
}
function colors2(palette) {
  const n = palette.length / 6 | 0, c2 = new Array(n);
  for (let i = 0; i < n; ) {
    c2[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c2;
}
function apply2(_, f) {
  for (const k4 in _)
    scheme2(k4, f(_[k4]));
}
function scheme2(name4, scheme4) {
  name4 = name4 && name4.toLowerCase();
  if (arguments.length > 1) {
    schemes2[name4] = scheme4;
    return this;
  } else {
    return schemes2[name4];
  }
}
function tickCount(scale8, count5, minStep) {
  let step;
  if (isNumber(count5)) {
    if (scale8.bins) {
      count5 = Math.max(count5, scale8.bins.length);
    }
    if (minStep != null) {
      count5 = Math.min(count5, Math.floor(span(scale8.domain()) / minStep || 1));
    }
  }
  if (isObject(count5)) {
    step = count5.step;
    count5 = count5.interval;
  }
  if (isString(count5)) {
    count5 = scale8.type === Time2 ? timeInterval3(count5) : scale8.type == UTC2 ? utcInterval2(count5) : error("Only time and utc scales accept interval strings.");
    if (step)
      count5 = count5.every(step);
  }
  return count5;
}
function validTicks2(scale8, ticks3, count5) {
  let range7 = scale8.range(), lo = range7[0], hi = peek(range7), cmp = ascending5;
  if (lo > hi) {
    range7 = hi;
    hi = lo;
    lo = range7;
    cmp = descending3;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks3 = ticks3.map((v) => [v, scale8(v)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count5 > 0 && ticks3.length > 1) {
    const endpoints = [ticks3[0], peek(ticks3)];
    while (ticks3.length > count5 && ticks3.length >= 3) {
      ticks3 = ticks3.filter((_, i) => !(i % 2));
    }
    if (ticks3.length < 3) {
      ticks3 = endpoints;
    }
  }
  return ticks3;
}
function tickValues2(scale8, count5) {
  return scale8.bins ? validTicks2(scale8, scale8.bins) : scale8.ticks ? scale8.ticks(count5) : scale8.domain();
}
function tickFormat4(locale7, scale8, count5, specifier, formatType, noSkip) {
  const type4 = scale8.type;
  let format9 = defaultFormatter2;
  if (type4 === Time2 || formatType === Time2) {
    format9 = locale7.timeFormat(specifier);
  } else if (type4 === UTC2 || formatType === UTC2) {
    format9 = locale7.utcFormat(specifier);
  } else if (isLogarithmic2(type4)) {
    const varfmt = locale7.formatFloat(specifier);
    if (noSkip || scale8.bins) {
      format9 = varfmt;
    } else {
      const test2 = tickLog2(scale8, count5, false);
      format9 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale8.tickFormat) {
    const d = scale8.domain();
    format9 = locale7.formatSpan(d[0], d[d.length - 1], count5, specifier);
  } else if (specifier) {
    format9 = locale7.format(specifier);
  }
  return format9;
}
function tickLog2(scale8, count5, values5) {
  const ticks3 = tickValues2(scale8, count5), base3 = scale8.base(), logb = Math.log(base3), k4 = Math.max(1, base3 * count5 / ticks3.length);
  const test2 = (d) => {
    let i = d / Math.pow(base3, Math.round(Math.log(d) / logb));
    if (i * base3 < base3 - 0.5)
      i *= base3;
    return i <= k4;
  };
  return values5 ? ticks3.filter(test2) : test2;
}
function labelValues2(scale8, count5) {
  return scale8.bins ? binValues2(scale8.bins) : scale8.type === Log2 ? tickLog2(scale8, count5, true) : symbols3[scale8.type] ? thresholdValues2(scale8[symbols3[scale8.type]]()) : tickValues2(scale8, count5);
}
function thresholdFormat2(locale7, scale8, specifier) {
  const _ = scale8[formats3[scale8.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale7.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues2(thresholds) {
  const values5 = [-Infinity].concat(thresholds);
  values5.max = Infinity;
  return values5;
}
function binValues2(bins2) {
  const values5 = bins2.slice(0, -1);
  values5.max = peek(bins2);
  return values5;
}
function labelFormat2(locale7, scale8, count5, type4, specifier, formatType, noSkip) {
  const format9 = formats3[scale8.type] && formatType !== Time2 && formatType !== UTC2 ? thresholdFormat2(locale7, scale8, specifier) : tickFormat4(locale7, scale8, count5, specifier, formatType, noSkip);
  return type4 === SymbolLegend2 && isDiscreteRange2(scale8) ? formatRange2(format9) : type4 === DiscreteLegend2 ? formatDiscrete2(format9) : formatPoint2(format9);
}
function labelFraction(scale8) {
  const domain4 = scale8.domain(), count5 = domain4.length - 1;
  let lo = +domain4[0], hi = +peek(domain4), span3 = hi - lo;
  if (scale8.type === Threshold2) {
    const adjust = count5 ? span3 / count5 : 0.1;
    lo -= adjust;
    hi += adjust;
    span3 = hi - lo;
  }
  return (value4) => (value4 - lo) / span3;
}
function format5(locale7, scale8, specifier, formatType) {
  const type4 = formatType || scale8.type;
  if (isString(specifier) && isTemporal2(type4)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type4 === Time2 ? locale7.timeFormat("%A, %d %B %Y, %X") : !specifier && type4 === UTC2 ? locale7.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat2(locale7, scale8, 5, null, specifier, formatType, true);
}
function domainCaption2(locale7, scale8, opt) {
  opt = opt || {};
  const max8 = Math.max(3, opt.maxlen || 7), fmt = format5(locale7, scale8, opt.format, opt.formatType);
  if (isDiscretizing2(scale8.type)) {
    const v = labelValues2(scale8).slice(1).map(fmt), n = v.length;
    return "".concat(n, " boundar").concat(n === 1 ? "y" : "ies", ": ").concat(v.join(", "));
  } else if (isDiscrete2(scale8.type)) {
    const d = scale8.domain(), n = d.length, v = n > max8 ? d.slice(0, max8 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return "".concat(n, " value").concat(n === 1 ? "" : "s", ": ").concat(v);
  } else {
    const d = scale8.domain();
    return "values from ".concat(fmt(d[0]), " to ").concat(fmt(peek(d)));
  }
}
var Identity2, Linear3, Log2, Pow2, Sqrt2, Symlog2, Time2, UTC2, Sequential2, Diverging2, Quantile3, Quantize2, Threshold2, Ordinal2, Point2, Band2, BinOrdinal2, Continuous2, Discrete2, Discretizing2, Interpolating2, Temporal2, map7, slice5, scales2, scaleProps, continuous4, discrete2, schemes2, SymbolLegend2, DiscreteLegend2, GradientLegend, defaultFormatter2, ascending5, descending3, symbols3, formats3, isDiscreteRange2, formatRange2, get5, formatDiscrete2, formatPoint2, formatValue2;
var init_vega_scale_module2 = __esm({
  "node_modules/.pnpm/vega-scale@7.1.1/node_modules/vega-scale/build/vega-scale.module.js"() {
    init_vega_util_module();
    init_src9();
    init_src20();
    init_src20();
    init_src18();
    init_src18();
    init_vega_time_module2();
    Identity2 = "identity";
    Linear3 = "linear";
    Log2 = "log";
    Pow2 = "pow";
    Sqrt2 = "sqrt";
    Symlog2 = "symlog";
    Time2 = "time";
    UTC2 = "utc";
    Sequential2 = "sequential";
    Diverging2 = "diverging";
    Quantile3 = "quantile";
    Quantize2 = "quantize";
    Threshold2 = "threshold";
    Ordinal2 = "ordinal";
    Point2 = "point";
    Band2 = "band";
    BinOrdinal2 = "bin-ordinal";
    Continuous2 = "continuous";
    Discrete2 = "discrete";
    Discretizing2 = "discretizing";
    Interpolating2 = "interpolating";
    Temporal2 = "temporal";
    map7 = Array.prototype.map;
    slice5 = Array.prototype.slice;
    scales2 = {};
    scale3(Identity2, identity9);
    scale3(Linear3, linear5, Continuous2);
    scale3(Log2, log4, [Continuous2, Log2]);
    scale3(Pow2, pow4, Continuous2);
    scale3(Sqrt2, sqrt4, Continuous2);
    scale3(Symlog2, symlog3, Continuous2);
    scale3(Time2, time2, [Continuous2, Temporal2]);
    scale3(UTC2, utcTime2, [Continuous2, Temporal2]);
    scale3(Sequential2, sequential2, [Continuous2, Interpolating2]);
    scale3("".concat(Sequential2, "-").concat(Linear3), sequential2, [Continuous2, Interpolating2]);
    scale3("".concat(Sequential2, "-").concat(Log2), sequentialLog2, [Continuous2, Interpolating2, Log2]);
    scale3("".concat(Sequential2, "-").concat(Pow2), sequentialPow2, [Continuous2, Interpolating2]);
    scale3("".concat(Sequential2, "-").concat(Sqrt2), sequentialSqrt2, [Continuous2, Interpolating2]);
    scale3("".concat(Sequential2, "-").concat(Symlog2), sequentialSymlog2, [Continuous2, Interpolating2]);
    scale3("".concat(Diverging2, "-").concat(Linear3), diverging2, [Continuous2, Interpolating2]);
    scale3("".concat(Diverging2, "-").concat(Log2), divergingLog2, [Continuous2, Interpolating2, Log2]);
    scale3("".concat(Diverging2, "-").concat(Pow2), divergingPow2, [Continuous2, Interpolating2]);
    scale3("".concat(Diverging2, "-").concat(Sqrt2), divergingSqrt2, [Continuous2, Interpolating2]);
    scale3("".concat(Diverging2, "-").concat(Symlog2), divergingSymlog2, [Continuous2, Interpolating2]);
    scale3(Quantile3, quantile4, [Discretizing2, Quantile3]);
    scale3(Quantize2, quantize2, Discretizing2);
    scale3(Threshold2, threshold2, Discretizing2);
    scale3(BinOrdinal2, scaleBinOrdinal2, [Discrete2, Discretizing2]);
    scale3(Ordinal2, ordinal2, Discrete2);
    scale3(Band2, band4, Discrete2);
    scale3(Point2, point9, Discrete2);
    scaleProps = ["clamp", "base", "constant", "exponent"];
    continuous4 = {
      blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
      greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
      greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
      oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
      purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
      reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
      blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
      bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
      greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
      orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
      purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
      purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
      purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
      redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
      yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
      yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
      yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
      blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
      brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
      purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
      purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
      redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
      redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
      yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
      redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
      redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
      pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
      spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
      viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
      magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
      inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
      plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
      cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
      rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
      sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
      turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
      browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
      tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
      teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
      warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
      goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
      goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
      goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
      lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
      lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
      lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
      lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
      lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
      darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
      darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
      darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
      darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
      darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
    };
    discrete2 = {
      category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
      category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
      category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
      category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
      tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
      tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
      accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
      dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
      paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
      pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
      pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
      set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
      set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
      set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
    };
    schemes2 = {};
    apply2(discrete2, colors2);
    apply2(continuous4, (_) => interpolateColors2(colors2(_)));
    SymbolLegend2 = "symbol";
    DiscreteLegend2 = "discrete";
    GradientLegend = "gradient";
    defaultFormatter2 = (value4) => isArray(value4) ? value4.map((v) => String(v)) : String(value4);
    ascending5 = (a4, b3) => a4[1] - b3[1];
    descending3 = (a4, b3) => b3[1] - a4[1];
    symbols3 = {
      [Quantile3]: "quantiles",
      [Quantize2]: "thresholds",
      [Threshold2]: "domain"
    };
    formats3 = {
      [Quantile3]: "quantiles",
      [Quantize2]: "domain"
    };
    isDiscreteRange2 = (scale8) => symbols3[scale8.type] || scale8.bins;
    formatRange2 = (format9) => (value4, index8, array9) => {
      const limit = get5(array9[index8 + 1], get5(array9.max, Infinity)), lo = formatValue2(value4, format9), hi = formatValue2(limit, format9);
      return lo && hi ? lo + "  " + hi : hi ? "< " + hi : " " + lo;
    };
    get5 = (value4, dflt) => value4 != null ? value4 : dflt;
    formatDiscrete2 = (format9) => (value4, index8) => index8 ? format9(value4) : null;
    formatPoint2 = (format9) => (value4) => format9(value4);
    formatValue2 = (value4, format9) => Number.isFinite(value4) ? format9(value4) : null;
  }
});

// node_modules/.pnpm/vega-encode@4.8.3/node_modules/vega-encode/build/vega-encode.module.js
var vega_encode_module_exports = {};
__export(vega_encode_module_exports, {
  axisticks: () => AxisTicks,
  datajoin: () => DataJoin,
  encode: () => Encode,
  legendentries: () => LegendEntries,
  linkpath: () => LinkPath,
  pie: () => Pie,
  scale: () => Scale,
  sortitems: () => SortItems,
  stack: () => Stack
});
function AxisTicks(params2) {
  Transform.call(this, null, params2);
}
function DataJoin(params2) {
  Transform.call(this, null, params2);
}
function defaultItemCreate() {
  return ingest$1({});
}
function newMap(key3) {
  const map11 = fastmap().test((t) => t.exit);
  map11.lookup = (t) => map11.get(key3(t));
  return map11;
}
function Encode(params2) {
  Transform.call(this, null, params2);
}
function LegendEntries(params2) {
  Transform.call(this, [], params2);
}
function LinkPath(params2) {
  Transform.call(this, {}, params2);
}
function Pie(params2) {
  Transform.call(this, null, params2);
}
function includeZero(scale8) {
  const type4 = scale8.type;
  return !scale8.bins && (type4 === Linear3 || type4 === Pow2 || type4 === Sqrt2);
}
function includePad(type4) {
  return isContinuous(type4) && type4 !== Sequential2;
}
function Scale(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
function scaleKey(_) {
  var t = _.type, d = "", n;
  if (t === Sequential2)
    return Sequential2 + "-" + Linear3;
  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? Sequential2 + "-" : n === 3 ? Diverging2 + "-" : "";
  }
  return (d + t || Linear3).toLowerCase();
}
function isContinuousColor(_) {
  const t = _.type;
  return isContinuous(t) && t !== Time2 && t !== UTC2 && (_.scheme || _.range && _.range.length && _.range.every(isString));
}
function configureDomain(scale8, _, df) {
  const raw = rawDomain(scale8, _.domainRaw, df);
  if (raw > -1)
    return raw;
  var domain4 = _.domain, type4 = scale8.type, zero10 = _.zero || _.zero === void 0 && includeZero(scale8), n, mid;
  if (!domain4)
    return 0;
  if (includePad(type4) && _.padding && domain4[0] !== peek(domain4)) {
    domain4 = padDomain(type4, domain4, _.range, _.padding, _.exponent, _.constant);
  }
  if (zero10 || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain4 = domain4.slice()).length - 1 || 1;
    if (zero10) {
      if (domain4[0] > 0)
        domain4[0] = 0;
      if (domain4[n] < 0)
        domain4[n] = 0;
    }
    if (_.domainMin != null)
      domain4[0] = _.domainMin;
    if (_.domainMax != null)
      domain4[n] = _.domainMax;
    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain4[n] ? n + 1 : mid < domain4[0] ? 0 : n;
      if (i !== n)
        df.warn("Scale domainMid exceeds domain min or max.", mid);
      domain4.splice(i, 0, mid);
    }
  }
  scale8.domain(domainCheck(type4, domain4, df));
  if (type4 === Ordinal2) {
    scale8.unknown(_.domainImplicit ? implicit2 : void 0);
  }
  if (_.nice && scale8.nice) {
    scale8.nice(_.nice !== true && tickCount(scale8, _.nice) || null);
  }
  return domain4.length;
}
function rawDomain(scale8, raw, df) {
  if (raw) {
    scale8.domain(domainCheck(scale8.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}
function padDomain(type4, domain4, range7, pad6, exponent, constant5) {
  var span3 = Math.abs(peek(range7) - range7[0]), frac = span3 / (span3 - 2 * pad6), d = type4 === Log2 ? zoomLog(domain4, null, frac) : type4 === Sqrt2 ? zoomPow(domain4, null, frac, 0.5) : type4 === Pow2 ? zoomPow(domain4, null, frac, exponent || 1) : type4 === Symlog2 ? zoomSymlog(domain4, null, frac, constant5 || 1) : zoomLinear(domain4, null, frac);
  domain4 = domain4.slice();
  domain4[0] = d[0];
  domain4[domain4.length - 1] = d[1];
  return domain4;
}
function domainCheck(type4, domain4, df) {
  if (isLogarithmic2(type4)) {
    var s3 = Math.abs(domain4.reduce((s4, v) => s4 + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));
    if (s3 !== domain4.length) {
      df.warn("Log scale domain includes zero: " + $(domain4));
    }
  }
  return domain4;
}
function configureBins(scale8, _, count5) {
  let bins2 = _.bins;
  if (bins2 && !isArray(bins2)) {
    const domain4 = scale8.domain(), lo = domain4[0], hi = peek(domain4), step = bins2.step;
    let start = bins2.start == null ? lo : bins2.start, stop2 = bins2.stop == null ? hi : bins2.stop;
    if (!step)
      error("Scale bins parameter missing step property.");
    if (start < lo)
      start = step * Math.ceil(lo / step);
    if (stop2 > hi)
      stop2 = step * Math.floor(hi / step);
    bins2 = range_default(start, stop2 + step / 2, step);
  }
  if (bins2) {
    scale8.bins = bins2;
  } else if (scale8.bins) {
    delete scale8.bins;
  }
  if (scale8.type === BinOrdinal2) {
    if (!bins2) {
      scale8.bins = scale8.domain();
    } else if (!_.domain && !_.domainRaw) {
      scale8.domain(bins2);
      count5 = bins2.length;
    }
  }
  return count5;
}
function configureRange(scale8, _, count5) {
  var type4 = scale8.type, round2 = _.round || false, range7 = _.range;
  if (_.rangeStep != null) {
    range7 = configureRangeStep(type4, _, count5);
  } else if (_.scheme) {
    range7 = configureScheme(type4, _, count5);
    if (isFunction(range7)) {
      if (scale8.interpolator) {
        return scale8.interpolator(range7);
      } else {
        error("Scale type ".concat(type4, " does not support interpolating color schemes."));
      }
    }
  }
  if (range7 && isInterpolating(type4)) {
    return scale8.interpolator(interpolateColors2(flip(range7, _.reverse), _.interpolate, _.interpolateGamma));
  }
  if (range7 && _.interpolate && scale8.interpolate) {
    scale8.interpolate(interpolate2(_.interpolate, _.interpolateGamma));
  } else if (isFunction(scale8.round)) {
    scale8.round(round2);
  } else if (isFunction(scale8.rangeRound)) {
    scale8.interpolate(round2 ? round_default2 : value_default2);
  }
  if (range7)
    scale8.range(flip(range7, _.reverse));
}
function configureRangeStep(type4, _, count5) {
  if (type4 !== Band2 && type4 !== Point2) {
    error("Only band and point scales support rangeStep.");
  }
  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0, inner = type4 === Point2 ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * bandSpace2(count5, inner, outer)];
}
function configureScheme(type4, _, count5) {
  var extent5 = _.schemeExtent, name4, scheme$1;
  if (isArray(_.scheme)) {
    scheme$1 = interpolateColors2(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name4 = _.scheme.toLowerCase();
    scheme$1 = scheme2(name4);
    if (!scheme$1)
      error("Unrecognized scheme name: ".concat(_.scheme));
  }
  count5 = type4 === Threshold2 ? count5 + 1 : type4 === BinOrdinal2 ? count5 - 1 : type4 === Quantile3 || type4 === Quantize2 ? +_.schemeCount || DEFAULT_COUNT : count5;
  return isInterpolating(type4) ? adjustScheme(scheme$1, extent5, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent5), count5) : type4 === Ordinal2 ? scheme$1 : scheme$1.slice(0, count5);
}
function adjustScheme(scheme4, extent5, reverse6) {
  return isFunction(scheme4) && (extent5 || reverse6) ? interpolateRange(scheme4, flip(extent5 || [0, 1], reverse6)) : scheme4;
}
function flip(array9, reverse6) {
  return reverse6 ? array9.slice().reverse() : array9;
}
function SortItems(params2) {
  Transform.call(this, null, params2);
}
function Stack(params2) {
  Transform.call(this, null, params2);
}
function stackCenter(group6, max8, field4, y07, y13) {
  var last = (max8 - group6.sum) / 2, m2 = group6.length, j = 0, t;
  for (; j < m2; ++j) {
    t = group6[j];
    t[y07] = last;
    t[y13] = last += Math.abs(field4(t));
  }
}
function stackNormalize(group6, max8, field4, y07, y13) {
  var scale8 = 1 / group6.sum, last = 0, m2 = group6.length, j = 0, v = 0, t;
  for (; j < m2; ++j) {
    t = group6[j];
    t[y07] = last;
    t[y13] = last = scale8 * (v += Math.abs(field4(t)));
  }
}
function stackZero(group6, max8, field4, y07, y13) {
  var lastPos = 0, lastNeg = 0, m2 = group6.length, j = 0, v, t;
  for (; j < m2; ++j) {
    t = group6[j];
    v = +field4(t);
    if (v < 0) {
      t[y07] = lastNeg;
      t[y13] = lastNeg += v;
    } else {
      t[y07] = lastPos;
      t[y13] = lastPos += v;
    }
  }
}
function partition2(data3, groupby, sort5, field4) {
  var groups4 = [], get8 = (f) => f(t), map11, i, n, m2, t, k4, g, s3, max8;
  if (groupby == null) {
    groups4.push(data3.slice());
  } else {
    for (map11 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k4 = groupby.map(get8);
      g = map11[k4];
      if (!g) {
        map11[k4] = g = [];
        groups4.push(g);
      }
      g.push(t);
    }
  }
  for (k4 = 0, max8 = 0, m2 = groups4.length; k4 < m2; ++k4) {
    g = groups4[k4];
    for (i = 0, s3 = 0, n = g.length; i < n; ++i) {
      s3 += Math.abs(field4(g[i]));
    }
    g.sum = s3;
    if (s3 > max8)
      max8 = s3;
    if (sort5)
      g.sort(sort5);
  }
  groups4.max = max8;
  return groups4;
}
var sourceX, sourceY, targetX, targetY, line2, lineR, arc2, arcR, curve, curveR, orthoX, orthoY, orthoR, diagonalX, diagonalY, diagonalR, Paths, DEFAULT_COUNT, SKIP2, Zero, Center, Normalize, DefOutput;
var init_vega_encode_module = __esm({
  "node_modules/.pnpm/vega-encode@4.8.3/node_modules/vega-encode/build/vega-encode.module.js"() {
    init_vega_dataflow_module();
    init_vega_scale_module2();
    init_vega_util_module();
    init_src9();
    init_src18();
    inherits(AxisTicks, Transform, {
      transform(_, pulse2) {
        if (this.value && !_.modified()) {
          return pulse2.StopPropagation;
        }
        var locale7 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), ticks3 = this.value, scale8 = _.scale, tally = _.count == null ? _.values ? _.values.length : 10 : _.count, count5 = tickCount(scale8, tally, _.minstep), format9 = _.format || tickFormat4(locale7, scale8, count5, _.formatSpecifier, _.formatType, !!_.values), values5 = _.values ? validTicks2(scale8, _.values, count5) : tickValues2(scale8, count5);
        if (ticks3)
          out.rem = ticks3;
        ticks3 = values5.map((value4, i) => ingest$1({
          index: i / (values5.length - 1 || 1),
          value: value4,
          label: format9(value4)
        }));
        if (_.extra && ticks3.length) {
          ticks3.push(ingest$1({
            index: -1,
            extra: {
              value: ticks3[0].value
            },
            label: ""
          }));
        }
        out.source = ticks3;
        out.add = ticks3;
        this.value = ticks3;
        return out;
      }
    });
    inherits(DataJoin, Transform, {
      transform(_, pulse2) {
        var df = pulse2.dataflow, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), item = _.item || defaultItemCreate, key3 = _.key || tupleid, map11 = this.value;
        if (isArray(out.encode)) {
          out.encode = null;
        }
        if (map11 && (_.modified("key") || pulse2.modified(key3))) {
          error("DataJoin does not support modified key function or fields.");
        }
        if (!map11) {
          pulse2 = pulse2.addAll();
          this.value = map11 = newMap(key3);
        }
        pulse2.visit(pulse2.ADD, (t) => {
          const k4 = key3(t);
          let x7 = map11.get(k4);
          if (x7) {
            if (x7.exit) {
              map11.empty--;
              out.add.push(x7);
            } else {
              out.mod.push(x7);
            }
          } else {
            x7 = item(t);
            map11.set(k4, x7);
            out.add.push(x7);
          }
          x7.datum = t;
          x7.exit = false;
        });
        pulse2.visit(pulse2.MOD, (t) => {
          const k4 = key3(t), x7 = map11.get(k4);
          if (x7) {
            x7.datum = t;
            out.mod.push(x7);
          }
        });
        pulse2.visit(pulse2.REM, (t) => {
          const k4 = key3(t), x7 = map11.get(k4);
          if (t === x7.datum && !x7.exit) {
            out.rem.push(x7);
            x7.exit = true;
            ++map11.empty;
          }
        });
        if (pulse2.changed(pulse2.ADD_MOD))
          out.modifies("datum");
        if (pulse2.clean() || _.clean && map11.empty > df.cleanThreshold) {
          df.runAfter(map11.clean);
        }
        return out;
      }
    });
    inherits(Encode, Transform, {
      transform(_, pulse2) {
        var out = pulse2.fork(pulse2.ADD_REM), fmod = _.mod || false, encoders = _.encoders, encode2 = pulse2.encode;
        if (isArray(encode2)) {
          if (out.changed() || encode2.every((e3) => encoders[e3])) {
            encode2 = encode2[0];
            out.encode = null;
          } else {
            return pulse2.StopPropagation;
          }
        }
        var reenter = encode2 === "enter", update3 = encoders.update || falsy, enter = encoders.enter || falsy, exit = encoders.exit || falsy, set8 = (encode2 && !reenter ? encoders[encode2] : update3) || falsy;
        if (pulse2.changed(pulse2.ADD)) {
          pulse2.visit(pulse2.ADD, (t) => {
            enter(t, _);
            update3(t, _);
          });
          out.modifies(enter.output);
          out.modifies(update3.output);
          if (set8 !== falsy && set8 !== update3) {
            pulse2.visit(pulse2.ADD, (t) => {
              set8(t, _);
            });
            out.modifies(set8.output);
          }
        }
        if (pulse2.changed(pulse2.REM) && exit !== falsy) {
          pulse2.visit(pulse2.REM, (t) => {
            exit(t, _);
          });
          out.modifies(exit.output);
        }
        if (reenter || set8 !== falsy) {
          const flag2 = pulse2.MOD | (_.modified() ? pulse2.REFLOW : 0);
          if (reenter) {
            pulse2.visit(flag2, (t) => {
              const mod = enter(t, _) || fmod;
              if (set8(t, _) || mod)
                out.mod.push(t);
            });
            if (out.mod.length)
              out.modifies(enter.output);
          } else {
            pulse2.visit(flag2, (t) => {
              if (set8(t, _) || fmod)
                out.mod.push(t);
            });
          }
          if (out.mod.length)
            out.modifies(set8.output);
        }
        return out.changed() ? out : pulse2.StopPropagation;
      }
    });
    inherits(LegendEntries, Transform, {
      transform(_, pulse2) {
        if (this.value != null && !_.modified()) {
          return pulse2.StopPropagation;
        }
        var locale7 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), items2 = this.value, type4 = _.type || SymbolLegend2, scale8 = _.scale, limit = +_.limit, count5 = tickCount(scale8, _.count == null ? 5 : _.count, _.minstep), lskip = !!_.values || type4 === SymbolLegend2, format9 = _.format || labelFormat2(locale7, scale8, count5, type4, _.formatSpecifier, _.formatType, lskip), values5 = _.values || labelValues2(scale8, count5), domain4, fraction, size, offset5, ellipsis;
        if (items2)
          out.rem = items2;
        if (type4 === SymbolLegend2) {
          if (limit && values5.length > limit) {
            pulse2.dataflow.warn("Symbol legend count exceeds limit, filtering items.");
            items2 = values5.slice(0, limit - 1);
            ellipsis = true;
          } else {
            items2 = values5;
          }
          if (isFunction(size = _.size)) {
            if (!_.values && scale8(items2[0]) === 0) {
              items2 = items2.slice(1);
            }
            offset5 = items2.reduce((max8, value4) => Math.max(max8, size(value4, _)), 0);
          } else {
            size = constant(offset5 = size || 8);
          }
          items2 = items2.map((value4, index8) => ingest$1({
            index: index8,
            label: format9(value4, index8, items2),
            value: value4,
            offset: offset5,
            size: size(value4, _)
          }));
          if (ellipsis) {
            ellipsis = values5[items2.length];
            items2.push(ingest$1({
              index: items2.length,
              label: "".concat(values5.length - items2.length, " entries"),
              value: ellipsis,
              offset: offset5,
              size: size(ellipsis, _)
            }));
          }
        } else if (type4 === GradientLegend) {
          domain4 = scale8.domain(), fraction = scaleFraction(scale8, domain4[0], peek(domain4));
          if (values5.length < 3 && !_.values && domain4[0] !== peek(domain4)) {
            values5 = [domain4[0], peek(domain4)];
          }
          items2 = values5.map((value4, index8) => ingest$1({
            index: index8,
            label: format9(value4, index8, values5),
            value: value4,
            perc: fraction(value4)
          }));
        } else {
          size = values5.length - 1;
          fraction = labelFraction(scale8);
          items2 = values5.map((value4, index8) => ingest$1({
            index: index8,
            label: format9(value4, index8, values5),
            value: value4,
            perc: index8 ? fraction(value4) : 0,
            perc2: index8 === size ? 1 : fraction(values5[index8 + 1])
          }));
        }
        out.source = items2;
        out.add = items2;
        this.value = items2;
        return out;
      }
    });
    sourceX = (t) => t.source.x;
    sourceY = (t) => t.source.y;
    targetX = (t) => t.target.x;
    targetY = (t) => t.target.y;
    LinkPath.Definition = {
      "type": "LinkPath",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "sourceX",
        "type": "field",
        "default": "source.x"
      }, {
        "name": "sourceY",
        "type": "field",
        "default": "source.y"
      }, {
        "name": "targetX",
        "type": "field",
        "default": "target.x"
      }, {
        "name": "targetY",
        "type": "field",
        "default": "target.y"
      }, {
        "name": "orient",
        "type": "enum",
        "default": "vertical",
        "values": ["horizontal", "vertical", "radial"]
      }, {
        "name": "shape",
        "type": "enum",
        "default": "line",
        "values": ["line", "arc", "curve", "diagonal", "orthogonal"]
      }, {
        "name": "require",
        "type": "signal"
      }, {
        "name": "as",
        "type": "string",
        "default": "path"
      }]
    };
    inherits(LinkPath, Transform, {
      transform(_, pulse2) {
        var sx = _.sourceX || sourceX, sy = _.sourceY || sourceY, tx = _.targetX || targetX, ty = _.targetY || targetY, as = _.as || "path", orient3 = _.orient || "vertical", shape3 = _.shape || "line", path5 = Paths.get(shape3 + "-" + orient3) || Paths.get(shape3);
        if (!path5) {
          error("LinkPath unsupported type: " + _.shape + (_.orient ? "-" + _.orient : ""));
        }
        pulse2.visit(pulse2.SOURCE, (t) => {
          t[as] = path5(sx(t), sy(t), tx(t), ty(t));
        });
        return pulse2.reflow(_.modified()).modifies(as);
      }
    });
    line2 = (sx, sy, tx, ty) => "M" + sx + "," + sy + "L" + tx + "," + ty;
    lineR = (sa3, sr, ta, tr3) => line2(sr * Math.cos(sa3), sr * Math.sin(sa3), tr3 * Math.cos(ta), tr3 * Math.sin(ta));
    arc2 = (sx, sy, tx, ty) => {
      var dx = tx - sx, dy = ty - sy, rr = Math.sqrt(dx * dx + dy * dy) / 2, ra = 180 * Math.atan2(dy, dx) / Math.PI;
      return "M" + sx + "," + sy + "A" + rr + "," + rr + " " + ra + " 0 1 " + tx + "," + ty;
    };
    arcR = (sa3, sr, ta, tr3) => arc2(sr * Math.cos(sa3), sr * Math.sin(sa3), tr3 * Math.cos(ta), tr3 * Math.sin(ta));
    curve = (sx, sy, tx, ty) => {
      const dx = tx - sx, dy = ty - sy, ix = 0.2 * (dx + dy), iy = 0.2 * (dy - dx);
      return "M" + sx + "," + sy + "C" + (sx + ix) + "," + (sy + iy) + " " + (tx + iy) + "," + (ty - ix) + " " + tx + "," + ty;
    };
    curveR = (sa3, sr, ta, tr3) => curve(sr * Math.cos(sa3), sr * Math.sin(sa3), tr3 * Math.cos(ta), tr3 * Math.sin(ta));
    orthoX = (sx, sy, tx, ty) => "M" + sx + "," + sy + "V" + ty + "H" + tx;
    orthoY = (sx, sy, tx, ty) => "M" + sx + "," + sy + "H" + tx + "V" + ty;
    orthoR = (sa3, sr, ta, tr3) => {
      const sc = Math.cos(sa3), ss = Math.sin(sa3), tc = Math.cos(ta), ts3 = Math.sin(ta), sf = Math.abs(ta - sa3) > Math.PI ? ta <= sa3 : ta > sa3;
      return "M" + sr * sc + "," + sr * ss + "A" + sr + "," + sr + " 0 0," + (sf ? 1 : 0) + " " + sr * tc + "," + sr * ts3 + "L" + tr3 * tc + "," + tr3 * ts3;
    };
    diagonalX = (sx, sy, tx, ty) => {
      const m2 = (sx + tx) / 2;
      return "M" + sx + "," + sy + "C" + m2 + "," + sy + " " + m2 + "," + ty + " " + tx + "," + ty;
    };
    diagonalY = (sx, sy, tx, ty) => {
      const m2 = (sy + ty) / 2;
      return "M" + sx + "," + sy + "C" + sx + "," + m2 + " " + tx + "," + m2 + " " + tx + "," + ty;
    };
    diagonalR = (sa3, sr, ta, tr3) => {
      const sc = Math.cos(sa3), ss = Math.sin(sa3), tc = Math.cos(ta), ts3 = Math.sin(ta), mr = (sr + tr3) / 2;
      return "M" + sr * sc + "," + sr * ss + "C" + mr * sc + "," + mr * ss + " " + mr * tc + "," + mr * ts3 + " " + tr3 * tc + "," + tr3 * ts3;
    };
    Paths = fastmap({
      "line": line2,
      "line-radial": lineR,
      "arc": arc2,
      "arc-radial": arcR,
      "curve": curve,
      "curve-radial": curveR,
      "orthogonal-horizontal": orthoX,
      "orthogonal-vertical": orthoY,
      "orthogonal-radial": orthoR,
      "diagonal-horizontal": diagonalX,
      "diagonal-vertical": diagonalY,
      "diagonal-radial": diagonalR
    });
    Pie.Definition = {
      "type": "Pie",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "startAngle",
        "type": "number",
        "default": 0
      }, {
        "name": "endAngle",
        "type": "number",
        "default": 6.283185307179586
      }, {
        "name": "sort",
        "type": "boolean",
        "default": false
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["startAngle", "endAngle"]
      }]
    };
    inherits(Pie, Transform, {
      transform(_, pulse2) {
        var as = _.as || ["startAngle", "endAngle"], startAngle = as[0], endAngle = as[1], field4 = _.field || one, start = _.startAngle || 0, stop2 = _.endAngle != null ? _.endAngle : 2 * Math.PI, data3 = pulse2.source, values5 = data3.map(field4), n = values5.length, a4 = start, k4 = (stop2 - start) / sum2(values5), index8 = range_default(n), i, t, v;
        if (_.sort) {
          index8.sort((a5, b3) => values5[a5] - values5[b3]);
        }
        for (i = 0; i < n; ++i) {
          v = values5[index8[i]];
          t = data3[index8[i]];
          t[startAngle] = a4;
          t[endAngle] = a4 += v * k4;
        }
        this.value = values5;
        return pulse2.reflow(_.modified()).modifies(as);
      }
    });
    DEFAULT_COUNT = 5;
    SKIP2 = toSet(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
    inherits(Scale, Transform, {
      transform(_, pulse2) {
        var df = pulse2.dataflow, scale$13 = this.value, key3 = scaleKey(_);
        if (!scale$13 || key3 !== scale$13.type) {
          this.value = scale$13 = scale3(key3)();
        }
        for (key3 in _)
          if (!SKIP2[key3]) {
            if (key3 === "padding" && includePad(scale$13.type))
              continue;
            isFunction(scale$13[key3]) ? scale$13[key3](_[key3]) : df.warn("Unsupported scale property: " + key3);
          }
        configureRange(scale$13, _, configureBins(scale$13, _, configureDomain(scale$13, _, df)));
        return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
      }
    });
    inherits(SortItems, Transform, {
      transform(_, pulse2) {
        const mod = _.modified("sort") || pulse2.changed(pulse2.ADD) || pulse2.modified(_.sort.fields) || pulse2.modified("datum");
        if (mod)
          pulse2.source.sort(stableCompare(_.sort));
        this.modified(mod);
        return pulse2;
      }
    });
    Zero = "zero";
    Center = "center";
    Normalize = "normalize";
    DefOutput = ["y0", "y1"];
    Stack.Definition = {
      "type": "Stack",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "sort",
        "type": "compare"
      }, {
        "name": "offset",
        "type": "enum",
        "default": Zero,
        "values": [Zero, Center, Normalize]
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": DefOutput
      }]
    };
    inherits(Stack, Transform, {
      transform(_, pulse2) {
        var as = _.as || DefOutput, y07 = as[0], y13 = as[1], sort5 = stableCompare(_.sort), field4 = _.field || one, stack3 = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero, groups4, i, n, max8;
        groups4 = partition2(pulse2.source, _.groupby, sort5, field4);
        for (i = 0, n = groups4.length, max8 = groups4.max; i < n; ++i) {
          stack3(groups4[i], max8, field4, y07, y13);
        }
        return pulse2.reflow(_.modified()).modifies(as);
      }
    });
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/math.js
function acos2(x7) {
  return x7 > 1 ? 0 : x7 < -1 ? pi3 : Math.acos(x7);
}
function asin2(x7) {
  return x7 > 1 ? halfPi2 : x7 < -1 ? -halfPi2 : Math.asin(x7);
}
var epsilon4, epsilon24, pi3, halfPi2, quarterPi, tau3, degrees5, radians3, abs2, atan, atan22, cos2, ceil, exp3, hypot, log5, pow5, sin2, sign2, sqrt5, tan;
var init_math4 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/math.js"() {
    epsilon4 = 1e-6;
    epsilon24 = 1e-12;
    pi3 = Math.PI;
    halfPi2 = pi3 / 2;
    quarterPi = pi3 / 4;
    tau3 = pi3 * 2;
    degrees5 = 180 / pi3;
    radians3 = pi3 / 180;
    abs2 = Math.abs;
    atan = Math.atan;
    atan22 = Math.atan2;
    cos2 = Math.cos;
    ceil = Math.ceil;
    exp3 = Math.exp;
    hypot = Math.hypot;
    log5 = Math.log;
    pow5 = Math.pow;
    sin2 = Math.sin;
    sign2 = Math.sign || function(x7) {
      return x7 > 0 ? 1 : x7 < 0 ? -1 : 0;
    };
    sqrt5 = Math.sqrt;
    tan = Math.tan;
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/noop.js
function noop2() {
}
var init_noop2 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/noop.js"() {
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream2) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream2);
  }
}
function streamLine(coordinates, stream2, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream2.lineStart();
  while (++i < n)
    coordinate = coordinates[i], stream2.point(coordinate[0], coordinate[1], coordinate[2]);
  stream2.lineEnd();
}
function streamPolygon(coordinates, stream2) {
  var i = -1, n = coordinates.length;
  stream2.polygonStart();
  while (++i < n)
    streamLine(coordinates[i], stream2, 1);
  stream2.polygonEnd();
}
function stream_default(object2, stream2) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream2);
  } else {
    streamGeometry(object2, stream2);
  }
}
var streamObjectType, streamGeometryType;
var init_stream = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/stream.js"() {
    streamObjectType = {
      Feature: function(object2, stream2) {
        streamGeometry(object2.geometry, stream2);
      },
      FeatureCollection: function(object2, stream2) {
        var features = object2.features, i = -1, n = features.length;
        while (++i < n)
          streamGeometry(features[i].geometry, stream2);
      }
    };
    streamGeometryType = {
      Sphere: function(object2, stream2) {
        stream2.sphere();
      },
      Point: function(object2, stream2) {
        object2 = object2.coordinates;
        stream2.point(object2[0], object2[1], object2[2]);
      },
      MultiPoint: function(object2, stream2) {
        var coordinates = object2.coordinates, i = -1, n = coordinates.length;
        while (++i < n)
          object2 = coordinates[i], stream2.point(object2[0], object2[1], object2[2]);
      },
      LineString: function(object2, stream2) {
        streamLine(object2.coordinates, stream2, 0);
      },
      MultiLineString: function(object2, stream2) {
        var coordinates = object2.coordinates, i = -1, n = coordinates.length;
        while (++i < n)
          streamLine(coordinates[i], stream2, 0);
      },
      Polygon: function(object2, stream2) {
        streamPolygon(object2.coordinates, stream2);
      },
      MultiPolygon: function(object2, stream2) {
        var coordinates = object2.coordinates, i = -1, n = coordinates.length;
        while (++i < n)
          streamPolygon(coordinates[i], stream2);
      },
      GeometryCollection: function(object2, stream2) {
        var geometries = object2.geometries, i = -1, n = geometries.length;
        while (++i < n)
          streamGeometry(geometries[i], stream2);
      }
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/area.js
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaRingEnd() {
  areaPoint(lambda00, phi00);
}
function areaPointFirst(lambda, phi2) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians3, phi2 *= radians3;
  lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);
}
function areaPoint(lambda, phi2) {
  lambda *= radians3, phi2 *= radians3;
  phi2 = phi2 / 2 + quarterPi;
  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k4 = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k4 * cos2(adLambda), v = k4 * sdLambda * sin2(adLambda);
  areaRingSum.add(atan22(v, u));
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}
function area_default2(object2) {
  areaSum = new Adder2();
  stream_default(object2, areaStream);
  return areaSum * 2;
}
var areaRingSum, areaSum, lambda00, phi00, lambda0, cosPhi0, sinPhi0, areaStream;
var init_area2 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/area.js"() {
    init_src9();
    init_math4();
    init_noop2();
    init_stream();
    areaRingSum = new Adder2();
    areaSum = new Adder2();
    areaStream = {
      point: noop2,
      lineStart: noop2,
      lineEnd: noop2,
      polygonStart: function() {
        areaRingSum = new Adder2();
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum;
        areaSum.add(areaRing < 0 ? tau3 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop2;
      },
      sphere: function() {
        areaSum.add(tau3);
      }
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a4, b3) {
  return a4[0] * b3[0] + a4[1] * b3[1] + a4[2] * b3[2];
}
function cartesianCross(a4, b3) {
  return [a4[1] * b3[2] - a4[2] * b3[1], a4[2] * b3[0] - a4[0] * b3[2], a4[0] * b3[1] - a4[1] * b3[0]];
}
function cartesianAddInPlace(a4, b3) {
  a4[0] += b3[0], a4[1] += b3[1], a4[2] += b3[2];
}
function cartesianScale(vector, k4) {
  return [vector[0] * k4, vector[1] * k4, vector[2] * k4];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt5(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}
var init_cartesian = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/cartesian.js"() {
    init_math4();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/bounds.js
function boundsPoint(lambda, phi2) {
  ranges.push(range2 = [lambda02 = lambda, lambda1 = lambda]);
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
}
function linePoint(lambda, phi2) {
  var p = cartesian([lambda * radians3, phi2 * radians3]);
  if (p0) {
    var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign5 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees5 * sign5, phii, antimeridian = abs2(delta) > 180;
    if (antimeridian ^ (sign5 * lambda2 < lambdai && lambdai < sign5 * lambda)) {
      phii = inflection[1] * degrees5;
      if (phii > phi1)
        phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign5 * lambda2 < lambdai && lambdai < sign5 * lambda)) {
      phii = -inflection[1] * degrees5;
      if (phii < phi0)
        phi0 = phii;
    } else {
      if (phi2 < phi0)
        phi0 = phi2;
      if (phi2 > phi1)
        phi1 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda02, lambda) > angle(lambda02, lambda1))
          lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda02, lambda1))
          lambda02 = lambda;
      }
    } else {
      if (lambda1 >= lambda02) {
        if (lambda < lambda02)
          lambda02 = lambda;
        if (lambda > lambda1)
          lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1))
            lambda02 = lambda;
        }
      }
    }
  } else {
    ranges.push(range2 = [lambda02 = lambda, lambda1 = lambda]);
  }
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
  p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream.point = linePoint;
}
function boundsLineEnd() {
  range2[0] = lambda02, range2[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}
function boundsRingPoint(lambda, phi2) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda002 = lambda, phi002 = phi2;
  }
  areaStream.point(lambda, phi2);
  linePoint(lambda, phi2);
}
function boundsRingStart() {
  areaStream.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda002, phi002);
  areaStream.lineEnd();
  if (abs2(deltaSum) > epsilon4)
    lambda02 = -(lambda1 = 180);
  range2[0] = lambda02, range2[1] = lambda1;
  p0 = null;
}
function angle(lambda03, lambda12) {
  return (lambda12 -= lambda03) < 0 ? lambda12 + 360 : lambda12;
}
function rangeCompare(a4, b3) {
  return a4[0] - b3[0];
}
function rangeContains(range7, x7) {
  return range7[0] <= range7[1] ? range7[0] <= x7 && x7 <= range7[1] : x7 < range7[0] || range7[1] < x7;
}
function bounds_default(feature2) {
  var i, n, a4, b3, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
  ranges = [];
  stream_default(feature2, boundsStream);
  if (n = ranges.length) {
    ranges.sort(rangeCompare);
    for (i = 1, a4 = ranges[0], merged = [a4]; i < n; ++i) {
      b3 = ranges[i];
      if (rangeContains(a4, b3[0]) || rangeContains(a4, b3[1])) {
        if (angle(a4[0], b3[1]) > angle(a4[0], a4[1]))
          a4[1] = b3[1];
        if (angle(b3[0], a4[1]) > angle(a4[0], a4[1]))
          a4[0] = b3[0];
      } else {
        merged.push(a4 = b3);
      }
    }
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a4 = merged[n]; i <= n; a4 = b3, ++i) {
      b3 = merged[i];
      if ((delta = angle(a4[1], b3[0])) > deltaMax)
        deltaMax = delta, lambda02 = b3[0], lambda1 = a4[1];
    }
  }
  ranges = range2 = null;
  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
}
var lambda02, phi0, lambda1, phi1, lambda2, lambda002, phi002, p0, deltaSum, ranges, range2, boundsStream;
var init_bounds = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/bounds.js"() {
    init_src9();
    init_area2();
    init_cartesian();
    init_math4();
    init_stream();
    boundsStream = {
      point: boundsPoint,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream.point = boundsRingPoint;
        boundsStream.lineStart = boundsRingStart;
        boundsStream.lineEnd = boundsRingEnd;
        deltaSum = new Adder2();
        areaStream.polygonStart();
      },
      polygonEnd: function() {
        areaStream.polygonEnd();
        boundsStream.point = boundsPoint;
        boundsStream.lineStart = boundsLineStart;
        boundsStream.lineEnd = boundsLineEnd;
        if (areaRingSum < 0)
          lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon4)
          phi1 = 90;
        else if (deltaSum < -epsilon4)
          phi0 = -90;
        range2[0] = lambda02, range2[1] = lambda1;
      },
      sphere: function() {
        lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/centroid.js
function centroidPoint(lambda, phi2) {
  lambda *= radians3, phi2 *= radians3;
  var cosPhi = cos2(phi2);
  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));
}
function centroidPointCartesian(x7, y7, z) {
  ++W0;
  X0 += (x7 - X0) / W0;
  Y0 += (y7 - Y0) / W0;
  Z0 += (z - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians3, phi2 *= radians3;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians3, phi2 *= radians3;
  var cosPhi = cos2(phi2), x7 = cosPhi * cos2(lambda), y7 = cosPhi * sin2(lambda), z = sin2(phi2), w5 = atan22(sqrt5((w5 = y0 * z - z0 * y7) * w5 + (w5 = z0 * x7 - x0 * z) * w5 + (w5 = x0 * y7 - y0 * x7) * w5), x0 * x7 + y0 * y7 + z0 * z);
  W1 += w5;
  X1 += w5 * (x0 + (x0 = x7));
  Y1 += w5 * (y0 + (y0 = y7));
  Z1 += w5 * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda003, phi003);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda003 = lambda, phi003 = phi2;
  lambda *= radians3, phi2 *= radians3;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians3, phi2 *= radians3;
  var cosPhi = cos2(phi2), x7 = cosPhi * cos2(lambda), y7 = cosPhi * sin2(lambda), z = sin2(phi2), cx = y0 * z - z0 * y7, cy = z0 * x7 - x0 * z, cz = x0 * y7 - y0 * x7, m2 = hypot(cx, cy, cz), w5 = asin2(m2), v = m2 && -w5 / m2;
  X2.add(v * cx);
  Y2.add(v * cy);
  Z2.add(v * cz);
  W1 += w5;
  X1 += w5 * (x0 + (x0 = x7));
  Y1 += w5 * (y0 + (y0 = y7));
  Z1 += w5 * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object2) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
  X2 = new Adder2();
  Y2 = new Adder2();
  Z2 = new Adder2();
  stream_default(object2, centroidStream);
  var x7 = +X2, y7 = +Y2, z = +Z2, m2 = hypot(x7, y7, z);
  if (m2 < epsilon24) {
    x7 = X1, y7 = Y1, z = Z1;
    if (W1 < epsilon4)
      x7 = X0, y7 = Y0, z = Z0;
    m2 = hypot(x7, y7, z);
    if (m2 < epsilon24)
      return [NaN, NaN];
  }
  return [atan22(y7, x7) * degrees5, asin2(z / m2) * degrees5];
}
var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda003, phi003, x0, y0, z0, centroidStream;
var init_centroid = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/centroid.js"() {
    init_src9();
    init_math4();
    init_noop2();
    init_stream();
    centroidStream = {
      sphere: noop2,
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      }
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/constant.js
var init_constant8 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/compose.js
function compose_default(a4, b3) {
  function compose(x7, y7) {
    return x7 = a4(x7, y7), b3(x7[0], x7[1]);
  }
  if (a4.invert && b3.invert)
    compose.invert = function(x7, y7) {
      return x7 = b3.invert(x7, y7), x7 && a4.invert(x7[0], x7[1]);
    };
  return compose;
}
var init_compose = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/compose.js"() {
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  return [abs2(lambda) > pi3 ? lambda + Math.round(-lambda / tau3) * tau3 : lambda, phi2];
}
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi3 ? lambda - tau3 : lambda < -pi3 ? lambda + tau3 : lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x7 = cos2(lambda) * cosPhi, y7 = sin2(lambda) * cosPhi, z = sin2(phi2), k4 = z * cosDeltaPhi + x7 * sinDeltaPhi;
    return [
      atan22(y7 * cosDeltaGamma - k4 * sinDeltaGamma, x7 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k4 * cosDeltaGamma + y7 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x7 = cos2(lambda) * cosPhi, y7 = sin2(lambda) * cosPhi, z = sin2(phi2), k4 = z * cosDeltaGamma - y7 * sinDeltaGamma;
    return [
      atan22(y7 * cosDeltaGamma + z * sinDeltaGamma, x7 * cosDeltaPhi + k4 * sinDeltaPhi),
      asin2(k4 * cosDeltaPhi - x7 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate3) {
  rotate3 = rotateRadians(rotate3[0] * radians3, rotate3[1] * radians3, rotate3.length > 2 ? rotate3[2] * radians3 : 0);
  function forward(coordinates) {
    coordinates = rotate3(coordinates[0] * radians3, coordinates[1] * radians3);
    return coordinates[0] *= degrees5, coordinates[1] *= degrees5, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate3.invert(coordinates[0] * radians3, coordinates[1] * radians3);
    return coordinates[0] *= degrees5, coordinates[1] *= degrees5, coordinates;
  };
  return forward;
}
var init_rotation = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/rotation.js"() {
    init_compose();
    init_math4();
    rotationIdentity.invert = rotationIdentity;
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/circle.js
function circleStream(stream2, radius2, delta, direction, t07, t15) {
  if (!delta)
    return;
  var cosRadius = cos2(radius2), sinRadius = sin2(radius2), step = direction * delta;
  if (t07 == null) {
    t07 = radius2 + direction * tau3;
    t15 = radius2 - step / 2;
  } else {
    t07 = circleRadius(cosRadius, t07);
    t15 = circleRadius(cosRadius, t15);
    if (direction > 0 ? t07 < t15 : t07 > t15)
      t07 += direction * tau3;
  }
  for (var point16, t = t07; direction > 0 ? t > t15 : t < t15; t -= step) {
    point16 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream2.point(point16[0], point16[1]);
  }
}
function circleRadius(cosRadius, point16) {
  point16 = cartesian(point16), point16[0] -= cosRadius;
  cartesianNormalizeInPlace(point16);
  var radius2 = acos2(-point16[1]);
  return ((-point16[2] < 0 ? -radius2 : radius2) + tau3 - epsilon4) % tau3;
}
var init_circle2 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/circle.js"() {
    init_cartesian();
    init_constant8();
    init_math4();
    init_rotation();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line5;
  return {
    point: function(x7, y7, m2) {
      line5.push([x7, y7, m2]);
    },
    lineStart: function() {
      lines.push(line5 = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line5 = null;
      return result;
    }
  };
}
var init_buffer = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/buffer.js"() {
    init_noop2();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a4, b3) {
  return abs2(a4[0] - b3[0]) < epsilon4 && abs2(a4[1] - b3[1]) < epsilon4;
}
var init_pointEqual = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/pointEqual.js"() {
    init_math4();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point16, points2, other, entry2) {
  this.x = point16;
  this.z = points2;
  this.o = other;
  this.e = entry2;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments3, compareIntersection2, startInside, interpolate4, stream2) {
  var subject = [], clip4 = [], i, n;
  segments3.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p02 = segment[0], p1 = segment[n2], x7;
    if (pointEqual_default(p02, p1)) {
      if (!p02[2] && !p1[2]) {
        stream2.lineStart();
        for (i = 0; i < n2; ++i)
          stream2.point((p02 = segment[i])[0], p02[1]);
        stream2.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon4;
    }
    subject.push(x7 = new Intersection(p02, segment, null, true));
    clip4.push(x7.o = new Intersection(p02, null, x7, false));
    subject.push(x7 = new Intersection(p1, segment, null, false));
    clip4.push(x7.o = new Intersection(p1, null, x7, true));
  });
  if (!subject.length)
    return;
  clip4.sort(compareIntersection2);
  link2(subject);
  link2(clip4);
  for (i = 0, n = clip4.length; i < n; ++i) {
    clip4[i].e = startInside = !startInside;
  }
  var start = subject[0], points2, point16;
  while (1) {
    var current2 = start, isSubject = true;
    while (current2.v)
      if ((current2 = current2.n) === start)
        return;
    points2 = current2.z;
    stream2.lineStart();
    do {
      current2.v = current2.o.v = true;
      if (current2.e) {
        if (isSubject) {
          for (i = 0, n = points2.length; i < n; ++i)
            stream2.point((point16 = points2[i])[0], point16[1]);
        } else {
          interpolate4(current2.x, current2.n.x, 1, stream2);
        }
        current2 = current2.n;
      } else {
        if (isSubject) {
          points2 = current2.p.z;
          for (i = points2.length - 1; i >= 0; --i)
            stream2.point((point16 = points2[i])[0], point16[1]);
        } else {
          interpolate4(current2.x, current2.p.x, -1, stream2);
        }
        current2 = current2.p;
      }
      current2 = current2.o;
      points2 = current2.z;
      isSubject = !isSubject;
    } while (!current2.v);
    stream2.lineEnd();
  }
}
function link2(array9) {
  if (!(n = array9.length))
    return;
  var n, i = 0, a4 = array9[0], b3;
  while (++i < n) {
    a4.n = b3 = array9[i];
    b3.p = a4;
    a4 = b3;
  }
  a4.n = b3 = array9[0];
  b3.p = a4;
}
var init_rejoin = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/rejoin.js"() {
    init_pointEqual();
    init_math4();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/polygonContains.js
function longitude(point16) {
  if (abs2(point16[0]) <= pi3)
    return point16[0];
  else
    return sign2(point16[0]) * ((abs2(point16[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point16) {
  var lambda = longitude(point16), phi2 = point16[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  var sum6 = new Adder2();
  if (sinPhi === 1)
    phi2 = halfPi2 + epsilon4;
  else if (sinPhi === -1)
    phi2 = -halfPi2 - epsilon4;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m2 = (ring = polygon[i]).length))
      continue;
    var ring, m2, point0 = ring[m2 - 1], lambda03 = longitude(point0), phi03 = point0[1] / 2 + quarterPi, sinPhi02 = sin2(phi03), cosPhi02 = cos2(phi03);
    for (var j = 0; j < m2; ++j, lambda03 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi12), cosPhi1 = cos2(phi12), delta = lambda12 - lambda03, sign5 = delta >= 0 ? 1 : -1, absDelta = sign5 * delta, antimeridian = absDelta > pi3, k4 = sinPhi02 * sinPhi1;
      sum6.add(atan22(k4 * sign5 * sin2(absDelta), cosPhi02 * cosPhi1 + k4 * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign5 * tau3 : delta;
      if (antimeridian ^ lambda03 >= lambda ^ lambda12 >= lambda) {
        var arc5 = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc5);
        var intersection4 = cartesianCross(normal, arc5);
        cartesianNormalizeInPlace(intersection4);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection4[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc5[0] || arc5[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon4 || angle2 < epsilon4 && sum6 < -epsilon24) ^ winding & 1;
}
var init_polygonContains = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/polygonContains.js"() {
    init_src9();
    init_cartesian();
    init_math4();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate4, start) {
  return function(sink) {
    var line5 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments3, ring;
    var clip4 = {
      point: point16,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip4.point = pointRing;
        clip4.lineStart = ringStart;
        clip4.lineEnd = ringEnd;
        segments3 = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip4.point = point16;
        clip4.lineStart = lineStart;
        clip4.lineEnd = lineEnd;
        segments3 = merge3(segments3);
        var startInside = polygonContains_default(polygon, start);
        if (segments3.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments3, compareIntersection, startInside, interpolate4, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate4(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments3 = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate4(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point16(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line5.point(lambda, phi2);
    }
    function lineStart() {
      clip4.point = pointLine;
      line5.lineStart();
    }
    function lineEnd() {
      clip4.point = point16;
      line5.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m2, segment, point17;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m2; ++i)
            sink.point((point17 = segment[i])[0], point17[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments3.push(ringSegments.filter(validSegment));
    }
    return clip4;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a4, b3) {
  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi2 - epsilon4 : halfPi2 - a4[1]) - ((b3 = b3.x)[0] < 0 ? b3[1] - halfPi2 - epsilon4 : halfPi2 - b3[1]);
}
var init_clip = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/index.js"() {
    init_buffer();
    init_rejoin();
    init_math4();
    init_polygonContains();
    init_src9();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/antimeridian.js
function clipAntimeridianLine(stream2) {
  var lambda03 = NaN, phi03 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream2.lineStart();
      clean = 1;
    },
    point: function(lambda12, phi12) {
      var sign1 = lambda12 > 0 ? pi3 : -pi3, delta = abs2(lambda12 - lambda03);
      if (abs2(delta - pi3) < epsilon4) {
        stream2.point(lambda03, phi03 = (phi03 + phi12) / 2 > 0 ? halfPi2 : -halfPi2);
        stream2.point(sign0, phi03);
        stream2.lineEnd();
        stream2.lineStart();
        stream2.point(sign1, phi03);
        stream2.point(lambda12, phi03);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda03 - sign0) < epsilon4)
          lambda03 -= sign0 * epsilon4;
        if (abs2(lambda12 - sign1) < epsilon4)
          lambda12 -= sign1 * epsilon4;
        phi03 = clipAntimeridianIntersect(lambda03, phi03, lambda12, phi12);
        stream2.point(sign0, phi03);
        stream2.lineEnd();
        stream2.lineStart();
        stream2.point(sign1, phi03);
        clean = 0;
      }
      stream2.point(lambda03 = lambda12, phi03 = phi12);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream2.lineEnd();
      lambda03 = phi03 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda03, phi03, lambda12, phi12) {
  var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin2(lambda03 - lambda12);
  return abs2(sinLambda0Lambda1) > epsilon4 ? atan((sin2(phi03) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi02 = cos2(phi03)) * sin2(lambda03)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi03 + phi12) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream2) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi2;
    stream2.point(-pi3, phi2);
    stream2.point(0, phi2);
    stream2.point(pi3, phi2);
    stream2.point(pi3, 0);
    stream2.point(pi3, -phi2);
    stream2.point(0, -phi2);
    stream2.point(-pi3, -phi2);
    stream2.point(-pi3, 0);
    stream2.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon4) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction * lambda / 2;
    stream2.point(-lambda, phi2);
    stream2.point(0, phi2);
    stream2.point(lambda, phi2);
  } else {
    stream2.point(to[0], to[1]);
  }
}
var antimeridian_default;
var init_antimeridian = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/antimeridian.js"() {
    init_clip();
    init_math4();
    antimeridian_default = clip_default(
      function() {
        return true;
      },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi3, -halfPi2]
    );
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius2) {
  var cr3 = cos2(radius2), delta = 6 * radians3, smallRadius = cr3 > 0, notHemisphere = abs2(cr3) > epsilon4;
  function interpolate4(from, to, direction, stream2) {
    circleStream(stream2, radius2, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr3;
  }
  function clipLine(stream2) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v = visible(lambda, phi2), c2 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v))
          stream2.lineStart();
        if (v !== v0) {
          point22 = intersect6(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream2.lineStart();
            point22 = intersect6(point1, point0);
            stream2.point(point22[0], point22[1]);
          } else {
            point22 = intersect6(point0, point1);
            stream2.point(point22[0], point22[1], 2);
            stream2.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c2 & c0) && (t = intersect6(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream2.lineStart();
              stream2.point(t[0][0], t[0][1]);
              stream2.point(t[1][0], t[1][1]);
              stream2.lineEnd();
            } else {
              stream2.point(t[1][0], t[1][1]);
              stream2.lineEnd();
              stream2.lineStart();
              stream2.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual_default(point0, point1))) {
          stream2.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c2;
      },
      lineEnd: function() {
        if (v0)
          stream2.lineEnd();
        point0 = null;
      },
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect6(a4, b3, two) {
    var pa3 = cartesian(a4), pb = cartesian(b3);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa3, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a4;
    var c1 = cr3 * n2n2 / determinant, c2 = -cr3 * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A6 = cartesianScale(n1, c1), B4 = cartesianScale(n2, c2);
    cartesianAddInPlace(A6, B4);
    var u = n1xn2, w5 = cartesianDot(A6, u), uu = cartesianDot(u, u), t23 = w5 * w5 - uu * (cartesianDot(A6, A6) - 1);
    if (t23 < 0)
      return;
    var t = sqrt5(t23), q = cartesianScale(u, (-w5 - t) / uu);
    cartesianAddInPlace(q, A6);
    q = spherical(q);
    if (!two)
      return q;
    var lambda03 = a4[0], lambda12 = b3[0], phi03 = a4[1], phi12 = b3[1], z;
    if (lambda12 < lambda03)
      z = lambda03, lambda03 = lambda12, lambda12 = z;
    var delta2 = lambda12 - lambda03, polar = abs2(delta2 - pi3) < epsilon4, meridian = polar || delta2 < epsilon4;
    if (!polar && phi12 < phi03)
      z = phi03, phi03 = phi12, phi12 = z;
    if (meridian ? polar ? phi03 + phi12 > 0 ^ q[1] < (abs2(q[0] - lambda03) < epsilon4 ? phi03 : phi12) : phi03 <= q[1] && q[1] <= phi12 : delta2 > pi3 ^ (lambda03 <= q[0] && q[0] <= lambda12)) {
      var q1 = cartesianScale(u, (-w5 + t) / uu);
      cartesianAddInPlace(q1, A6);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r2 = smallRadius ? radius2 : pi3 - radius2, code2 = 0;
    if (lambda < -r2)
      code2 |= 1;
    else if (lambda > r2)
      code2 |= 2;
    if (phi2 < -r2)
      code2 |= 4;
    else if (phi2 > r2)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate4, smallRadius ? [0, -radius2] : [-pi3, radius2 - pi3]);
}
var init_circle3 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/circle.js"() {
    init_cartesian();
    init_circle2();
    init_math4();
    init_pointEqual();
    init_clip();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/line.js
function line_default2(a4, b3, x07, y07, x13, y13) {
  var ax = a4[0], ay = a4[1], bx = b3[0], by = b3[1], t07 = 0, t15 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x07 - ax;
  if (!dx && r2 > 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t07)
      return;
    if (r2 < t15)
      t15 = r2;
  } else if (dx > 0) {
    if (r2 > t15)
      return;
    if (r2 > t07)
      t07 = r2;
  }
  r2 = x13 - ax;
  if (!dx && r2 < 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t15)
      return;
    if (r2 > t07)
      t07 = r2;
  } else if (dx > 0) {
    if (r2 < t07)
      return;
    if (r2 < t15)
      t15 = r2;
  }
  r2 = y07 - ay;
  if (!dy && r2 > 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t07)
      return;
    if (r2 < t15)
      t15 = r2;
  } else if (dy > 0) {
    if (r2 > t15)
      return;
    if (r2 > t07)
      t07 = r2;
  }
  r2 = y13 - ay;
  if (!dy && r2 < 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t15)
      return;
    if (r2 > t07)
      t07 = r2;
  } else if (dy > 0) {
    if (r2 < t07)
      return;
    if (r2 < t15)
      t15 = r2;
  }
  if (t07 > 0)
    a4[0] = ax + t07 * dx, a4[1] = ay + t07 * dy;
  if (t15 < 1)
    b3[0] = ax + t15 * dx, b3[1] = ay + t15 * dy;
  return true;
}
var init_line2 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/line.js"() {
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/rectangle.js
function clipRectangle(x07, y07, x13, y13) {
  function visible(x7, y7) {
    return x07 <= x7 && x7 <= x13 && y07 <= y7 && y7 <= y13;
  }
  function interpolate4(from, to, direction, stream2) {
    var a4 = 0, a1 = 0;
    if (from == null || (a4 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream2.point(a4 === 0 || a4 === 3 ? x07 : x13, a4 > 1 ? y13 : y07);
      while ((a4 = (a4 + direction + 4) % 4) !== a1);
    } else {
      stream2.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs2(p[0] - x07) < epsilon4 ? direction > 0 ? 0 : 3 : abs2(p[0] - x13) < epsilon4 ? direction > 0 ? 2 : 1 : abs2(p[1] - y07) < epsilon4 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a4, b3) {
    return comparePoint(a4.x, b3.x);
  }
  function comparePoint(a4, b3) {
    var ca = corner(a4, 1), cb = corner(b3, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b3[1] - a4[1] : ca === 1 ? a4[0] - b3[0] : ca === 2 ? a4[1] - b3[1] : b3[0] - a4[0];
  }
  return function(stream2) {
    var activeStream = stream2, bufferStream = buffer_default(), segments3, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point16,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point16(x7, y7) {
      if (visible(x7, y7))
        activeStream.point(x7, y7);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m2 = ring2.length, point17 = ring2[0], a0, a1, b0 = point17[0], b1 = point17[1]; j < m2; ++j) {
          a0 = b0, a1 = b1, point17 = ring2[j], b0 = point17[0], b1 = point17[1];
          if (a1 <= y13) {
            if (b1 > y13 && (b0 - a0) * (y13 - a1) > (b1 - a1) * (x07 - a0))
              ++winding;
          } else {
            if (b1 <= y13 && (b0 - a0) * (y13 - a1) < (b1 - a1) * (x07 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments3 = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments3 = merge3(segments3)).length;
      if (cleanInside || visible2) {
        stream2.polygonStart();
        if (cleanInside) {
          stream2.lineStart();
          interpolate4(null, null, 1, stream2);
          stream2.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments3, compareIntersection2, startInside, interpolate4, stream2);
        }
        stream2.polygonEnd();
      }
      activeStream = stream2, segments3 = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint2;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments3) {
        linePoint2(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments3.push(bufferStream.result());
      }
      clipStream.point = point16;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint2(x7, y7) {
      var v = visible(x7, y7);
      if (polygon)
        ring.push([x7, y7]);
      if (first) {
        x__ = x7, y__ = y7, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x7, y7);
        }
      } else {
        if (v && v_)
          activeStream.point(x7, y7);
        else {
          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b3 = [x7 = Math.max(clipMin, Math.min(clipMax, x7)), y7 = Math.max(clipMin, Math.min(clipMax, y7))];
          if (line_default2(a4, b3, x07, y07, x13, y13)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a4[0], a4[1]);
            }
            activeStream.point(b3[0], b3[1]);
            if (!v)
              activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x7, y7);
            clean = false;
          }
        }
      }
      x_ = x7, y_ = y7, v_ = v;
    }
    return clipStream;
  };
}
var clipMax, clipMin;
var init_rectangle = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/rectangle.js"() {
    init_math4();
    init_buffer();
    init_line2();
    init_rejoin();
    init_src9();
    clipMax = 1e9;
    clipMin = -clipMax;
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/extent.js
var init_extent3 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/clip/extent.js"() {
    init_rectangle();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/length.js
var init_length = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/length.js"() {
    init_src9();
    init_math4();
    init_noop2();
    init_stream();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/distance.js
var init_distance = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/distance.js"() {
    init_length();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/contains.js
var init_contains = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/contains.js"() {
    init_polygonContains();
    init_distance();
    init_math4();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/graticule.js
function graticuleX(y07, y13, dy) {
  var y7 = range_default(y07, y13 - epsilon4, dy).concat(y13);
  return function(x7) {
    return y7.map(function(y8) {
      return [x7, y8];
    });
  };
}
function graticuleY(x07, x13, dx) {
  var x7 = range_default(x07, x13 - epsilon4, dx).concat(x13);
  return function(y7) {
    return x7.map(function(x8) {
      return [x8, y7];
    });
  };
}
function graticule() {
  var x13, x07, X13, X03, y13, y07, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x7, y7, X4, Y4, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range_default(ceil(X03 / DX) * DX, X13, DX).map(X4).concat(range_default(ceil(Y03 / DY) * DY, Y13, DY).map(Y4)).concat(range_default(ceil(x07 / dx) * dx, x13, dx).filter(function(x8) {
      return abs2(x8 % DX) > epsilon4;
    }).map(x7)).concat(range_default(ceil(y07 / dy) * dy, y13, dy).filter(function(y8) {
      return abs2(y8 % DY) > epsilon4;
    }).map(y7));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X4(X03).concat(
          Y4(Y13).slice(1),
          X4(X13).reverse().slice(1),
          Y4(Y03).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length)
      return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length)
      return [[X03, Y03], [X13, Y13]];
    X03 = +_[0][0], X13 = +_[1][0];
    Y03 = +_[0][1], Y13 = +_[1][1];
    if (X03 > X13)
      _ = X03, X03 = X13, X13 = _;
    if (Y03 > Y13)
      _ = Y03, Y03 = Y13, Y13 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length)
      return [[x07, y07], [x13, y13]];
    x07 = +_[0][0], x13 = +_[1][0];
    y07 = +_[0][1], y13 = +_[1][1];
    if (x07 > x13)
      _ = x07, x07 = x13, x13 = _;
    if (y07 > y13)
      _ = y07, y07 = y13, y13 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length)
      return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length)
      return precision;
    precision = +_;
    x7 = graticuleX(y07, y13, 90);
    y7 = graticuleY(x07, x13, precision);
    X4 = graticuleX(Y03, Y13, 90);
    Y4 = graticuleY(X03, X13, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon4], [180, 90 - epsilon4]]).extentMinor([[-180, -80 - epsilon4], [180, 80 + epsilon4]]);
}
var init_graticule = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/graticule.js"() {
    init_src9();
    init_math4();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/interpolate.js
var init_interpolate = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/interpolate.js"() {
    init_math4();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/identity.js
var identity_default6;
var init_identity9 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/identity.js"() {
    identity_default6 = (x7) => x7;
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/area.js
function areaRingStart2() {
  areaStream2.point = areaPointFirst2;
}
function areaPointFirst2(x7, y7) {
  areaStream2.point = areaPoint2;
  x00 = x02 = x7, y00 = y02 = y7;
}
function areaPoint2(x7, y7) {
  areaRingSum2.add(y02 * x7 - x02 * y7);
  x02 = x7, y02 = y7;
}
function areaRingEnd2() {
  areaPoint2(x00, y00);
}
var areaSum2, areaRingSum2, x00, y00, x02, y02, areaStream2, area_default3;
var init_area3 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/area.js"() {
    init_src9();
    init_math4();
    init_noop2();
    areaSum2 = new Adder2();
    areaRingSum2 = new Adder2();
    areaStream2 = {
      point: noop2,
      lineStart: noop2,
      lineEnd: noop2,
      polygonStart: function() {
        areaStream2.lineStart = areaRingStart2;
        areaStream2.lineEnd = areaRingEnd2;
      },
      polygonEnd: function() {
        areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
        areaSum2.add(abs2(areaRingSum2));
        areaRingSum2 = new Adder2();
      },
      result: function() {
        var area5 = areaSum2 / 2;
        areaSum2 = new Adder2();
        return area5;
      }
    };
    area_default3 = areaStream2;
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/bounds.js
function boundsPoint2(x7, y7) {
  if (x7 < x03)
    x03 = x7;
  if (x7 > x1)
    x1 = x7;
  if (y7 < y03)
    y03 = y7;
  if (y7 > y1)
    y1 = y7;
}
var x03, y03, x1, y1, boundsStream2, bounds_default2;
var init_bounds2 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/bounds.js"() {
    init_noop2();
    x03 = Infinity;
    y03 = x03;
    x1 = -x03;
    y1 = x1;
    boundsStream2 = {
      point: boundsPoint2,
      lineStart: noop2,
      lineEnd: noop2,
      polygonStart: noop2,
      polygonEnd: noop2,
      result: function() {
        var bounds3 = [[x03, y03], [x1, y1]];
        x1 = y1 = -(y03 = x03 = Infinity);
        return bounds3;
      }
    };
    bounds_default2 = boundsStream2;
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/centroid.js
function centroidPoint2(x7, y7) {
  X02 += x7;
  Y02 += y7;
  ++Z02;
}
function centroidLineStart2() {
  centroidStream2.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x7, y7) {
  centroidStream2.point = centroidPointLine;
  centroidPoint2(x04 = x7, y04 = y7);
}
function centroidPointLine(x7, y7) {
  var dx = x7 - x04, dy = y7 - y04, z = sqrt5(dx * dx + dy * dy);
  X12 += z * (x04 + x7) / 2;
  Y12 += z * (y04 + y7) / 2;
  Z12 += z;
  centroidPoint2(x04 = x7, y04 = y7);
}
function centroidLineEnd2() {
  centroidStream2.point = centroidPoint2;
}
function centroidRingStart2() {
  centroidStream2.point = centroidPointFirstRing;
}
function centroidRingEnd2() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x7, y7) {
  centroidStream2.point = centroidPointRing;
  centroidPoint2(x002 = x04 = x7, y002 = y04 = y7);
}
function centroidPointRing(x7, y7) {
  var dx = x7 - x04, dy = y7 - y04, z = sqrt5(dx * dx + dy * dy);
  X12 += z * (x04 + x7) / 2;
  Y12 += z * (y04 + y7) / 2;
  Z12 += z;
  z = y04 * x7 - x04 * y7;
  X22 += z * (x04 + x7);
  Y22 += z * (y04 + y7);
  Z22 += z * 3;
  centroidPoint2(x04 = x7, y04 = y7);
}
var X02, Y02, Z02, X12, Y12, Z12, X22, Y22, Z22, x002, y002, x04, y04, centroidStream2, centroid_default2;
var init_centroid2 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/centroid.js"() {
    init_math4();
    X02 = 0;
    Y02 = 0;
    Z02 = 0;
    X12 = 0;
    Y12 = 0;
    Z12 = 0;
    X22 = 0;
    Y22 = 0;
    Z22 = 0;
    centroidStream2 = {
      point: centroidPoint2,
      lineStart: centroidLineStart2,
      lineEnd: centroidLineEnd2,
      polygonStart: function() {
        centroidStream2.lineStart = centroidRingStart2;
        centroidStream2.lineEnd = centroidRingEnd2;
      },
      polygonEnd: function() {
        centroidStream2.point = centroidPoint2;
        centroidStream2.lineStart = centroidLineStart2;
        centroidStream2.lineEnd = centroidLineEnd2;
      },
      result: function() {
        var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
        X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
        return centroid;
      }
    };
    centroid_default2 = centroidStream2;
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/context.js
function PathContext(context4) {
  this._context = context4;
}
var init_context = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/context.js"() {
    init_math4();
    init_noop2();
    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._context.closePath();
        this._point = NaN;
      },
      point: function(x7, y7) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x7, y7);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x7, y7);
            break;
          }
          default: {
            this._context.moveTo(x7 + this._radius, y7);
            this._context.arc(x7, y7, this._radius, 0, tau3);
            break;
          }
        }
      },
      result: noop2
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/measure.js
function lengthPointFirst(x7, y7) {
  lengthStream.point = lengthPoint;
  x003 = x05 = x7, y003 = y05 = y7;
}
function lengthPoint(x7, y7) {
  x05 -= x7, y05 -= y7;
  lengthSum.add(sqrt5(x05 * x05 + y05 * y05));
  x05 = x7, y05 = y7;
}
var lengthSum, lengthRing, x003, y003, x05, y05, lengthStream, measure_default;
var init_measure = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/measure.js"() {
    init_src9();
    init_math4();
    init_noop2();
    lengthSum = new Adder2();
    lengthStream = {
      point: noop2,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing)
          lengthPoint(x003, y003);
        lengthStream.point = noop2;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length4 = +lengthSum;
        lengthSum = new Adder2();
        return length4;
      }
    };
    measure_default = lengthStream;
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/string.js
function PathString() {
  this._string = [];
}
function circle(radius2) {
  return "m0," + radius2 + "a" + radius2 + "," + radius2 + " 0 1,1 0," + -2 * radius2 + "a" + radius2 + "," + radius2 + " 0 1,1 0," + 2 * radius2 + "z";
}
var init_string3 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/string.js"() {
    PathString.prototype = {
      _radius: 4.5,
      _circle: circle(4.5),
      pointRadius: function(_) {
        if ((_ = +_) !== this._radius)
          this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0)
          this._string.push("Z");
        this._point = NaN;
      },
      point: function(x7, y7) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x7, ",", y7);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x7, ",", y7);
            break;
          }
          default: {
            if (this._circle == null)
              this._circle = circle(this._radius);
            this._string.push("M", x7, ",", y7, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/index.js
function path_default(projection3, context4) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path5(object2) {
    if (object2) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path5.area = function(object2) {
    stream_default(object2, projectionStream(area_default3));
    return area_default3.result();
  };
  path5.measure = function(object2) {
    stream_default(object2, projectionStream(measure_default));
    return measure_default.result();
  };
  path5.bounds = function(object2) {
    stream_default(object2, projectionStream(bounds_default2));
    return bounds_default2.result();
  };
  path5.centroid = function(object2) {
    stream_default(object2, projectionStream(centroid_default2));
    return centroid_default2.result();
  };
  path5.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection3 = null, identity_default6) : (projection3 = _).stream, path5) : projection3;
  };
  path5.context = function(_) {
    if (!arguments.length)
      return context4;
    contextStream = _ == null ? (context4 = null, new PathString()) : new PathContext(context4 = _);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path5;
  };
  path5.pointRadius = function(_) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path5;
  };
  return path5.projection(projection3).context(context4);
}
var init_path3 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/path/index.js"() {
    init_identity9();
    init_stream();
    init_area3();
    init_bounds2();
    init_centroid2();
    init_context();
    init_measure();
    init_string3();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/transform.js
function transformer7(methods2) {
  return function(stream2) {
    var s3 = new TransformStream();
    for (var key3 in methods2)
      s3[key3] = methods2[key3];
    s3.stream = stream2;
    return s3;
  };
}
function TransformStream() {
}
var init_transform4 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/transform.js"() {
    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x7, y7) {
        this.stream.point(x7, y7);
      },
      sphere: function() {
        this.stream.sphere();
      },
      lineStart: function() {
        this.stream.lineStart();
      },
      lineEnd: function() {
        this.stream.lineEnd();
      },
      polygonStart: function() {
        this.stream.polygonStart();
      },
      polygonEnd: function() {
        this.stream.polygonEnd();
      }
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object2) {
  var clip4 = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip4 != null)
    projection3.clipExtent(null);
  stream_default(object2, projection3.stream(bounds_default2));
  fitBounds(bounds_default2.result());
  if (clip4 != null)
    projection3.clipExtent(clip4);
  return projection3;
}
function fitExtent(projection3, extent5, object2) {
  return fit(projection3, function(b3) {
    var w5 = extent5[1][0] - extent5[0][0], h4 = extent5[1][1] - extent5[0][1], k4 = Math.min(w5 / (b3[1][0] - b3[0][0]), h4 / (b3[1][1] - b3[0][1])), x7 = +extent5[0][0] + (w5 - k4 * (b3[1][0] + b3[0][0])) / 2, y7 = +extent5[0][1] + (h4 - k4 * (b3[1][1] + b3[0][1])) / 2;
    projection3.scale(150 * k4).translate([x7, y7]);
  }, object2);
}
function fitSize(projection3, size, object2) {
  return fitExtent(projection3, [[0, 0], size], object2);
}
function fitWidth(projection3, width2, object2) {
  return fit(projection3, function(b3) {
    var w5 = +width2, k4 = w5 / (b3[1][0] - b3[0][0]), x7 = (w5 - k4 * (b3[1][0] + b3[0][0])) / 2, y7 = -k4 * b3[0][1];
    projection3.scale(150 * k4).translate([x7, y7]);
  }, object2);
}
function fitHeight(projection3, height2, object2) {
  return fit(projection3, function(b3) {
    var h4 = +height2, k4 = h4 / (b3[1][1] - b3[0][1]), x7 = -k4 * b3[0][0], y7 = (h4 - k4 * (b3[1][1] + b3[0][1])) / 2;
    projection3.scale(150 * k4).translate([x7, y7]);
  }, object2);
}
var init_fit = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/fit.js"() {
    init_stream();
    init_bounds2();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/resample.js
function resample_default(project3, delta2) {
  return +delta2 ? resample(project3, delta2) : resampleNone(project3);
}
function resampleNone(project3) {
  return transformer7({
    point: function(x7, y7) {
      x7 = project3(x7, y7);
      this.stream.point(x7[0], x7[1]);
    }
  });
}
function resample(project3, delta2) {
  function resampleLineTo(x07, y07, lambda03, a0, b0, c0, x13, y13, lambda12, a1, b1, c1, depth, stream2) {
    var dx = x13 - x07, dy = y13 - y07, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a4 = a0 + a1, b3 = b0 + b1, c2 = c0 + c1, m2 = sqrt5(a4 * a4 + b3 * b3 + c2 * c2), phi2 = asin2(c2 /= m2), lambda22 = abs2(abs2(c2) - 1) < epsilon4 || abs2(lambda03 - lambda12) < epsilon4 ? (lambda03 + lambda12) / 2 : atan22(b3, a4), p = project3(lambda22, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x07, dy2 = y22 - y07, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x07, y07, lambda03, a0, b0, c0, x22, y22, lambda22, a4 /= m2, b3 /= m2, c2, depth, stream2);
        stream2.point(x22, y22);
        resampleLineTo(x22, y22, lambda22, a4, b3, c2, x13, y13, lambda12, a1, b1, c1, depth, stream2);
      }
    }
  }
  return function(stream2) {
    var lambda004, x004, y004, a00, b00, c00, lambda03, x07, y07, a0, b0, c0;
    var resampleStream = {
      point: point16,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream2.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream2.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point16(x7, y7) {
      x7 = project3(x7, y7);
      stream2.point(x7[0], x7[1]);
    }
    function lineStart() {
      x07 = NaN;
      resampleStream.point = linePoint2;
      stream2.lineStart();
    }
    function linePoint2(lambda, phi2) {
      var c2 = cartesian([lambda, phi2]), p = project3(lambda, phi2);
      resampleLineTo(x07, y07, lambda03, a0, b0, c0, x07 = p[0], y07 = p[1], lambda03 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth, stream2);
      stream2.point(x07, y07);
    }
    function lineEnd() {
      resampleStream.point = point16;
      stream2.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint2(lambda004 = lambda, phi2), x004 = x07, y004 = y07, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint2;
    }
    function ringEnd() {
      resampleLineTo(x07, y07, lambda03, a0, b0, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream2);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}
var maxDepth, cosMinDistance;
var init_resample = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/resample.js"() {
    init_cartesian();
    init_math4();
    init_transform4();
    maxDepth = 16;
    cosMinDistance = cos2(30 * radians3);
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/index.js
function transformRotate(rotate3) {
  return transformer7({
    point: function(x7, y7) {
      var r2 = rotate3(x7, y7);
      return this.stream.point(r2[0], r2[1]);
    }
  });
}
function scaleTranslate(k4, dx, dy, sx, sy) {
  function transform4(x7, y7) {
    x7 *= sx;
    y7 *= sy;
    return [dx + k4 * x7, dy - k4 * y7];
  }
  transform4.invert = function(x7, y7) {
    return [(x7 - dx) / k4 * sx, (dy - y7) / k4 * sy];
  };
  return transform4;
}
function scaleTranslateRotate(k4, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k4, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k4, b3 = sinAlpha * k4, ai = cosAlpha / k4, bi = sinAlpha / k4, ci = (sinAlpha * dy - cosAlpha * dx) / k4, fi = (sinAlpha * dx + cosAlpha * dy) / k4;
  function transform4(x7, y7) {
    x7 *= sx;
    y7 *= sy;
    return [a4 * x7 - b3 * y7 + dx, dy - b3 * x7 - a4 * y7];
  }
  transform4.invert = function(x7, y7) {
    return [sx * (ai * x7 - bi * y7 + ci), sy * (fi - bi * x7 - ai * y7)];
  };
  return transform4;
}
function projection(project3) {
  return projectionMutator(function() {
    return project3;
  })();
}
function projectionMutator(projectAt) {
  var project3, k4 = 150, x7 = 480, y7 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate3, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x07 = null, y07, x13, y13, postclip = identity_default6, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache3, cacheStream;
  function projection3(point16) {
    return projectRotateTransform(point16[0] * radians3, point16[1] * radians3);
  }
  function invert2(point16) {
    point16 = projectRotateTransform.invert(point16[0], point16[1]);
    return point16 && [point16[0] * degrees5, point16[1] * degrees5];
  }
  projection3.stream = function(stream2) {
    return cache3 && cacheStream === stream2 ? cache3 : cache3 = transformRadians(transformRotate(rotate3)(preclip(projectResample(postclip(cacheStream = stream2)))));
  };
  projection3.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset3()) : preclip;
  };
  projection3.postclip = function(_) {
    return arguments.length ? (postclip = _, x07 = y07 = x13 = y13 = null, reset3()) : postclip;
  };
  projection3.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians3) : (theta = null, antimeridian_default), reset3()) : theta * degrees5;
  };
  projection3.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x07 = y07 = x13 = y13 = null, identity_default6) : clipRectangle(x07 = +_[0][0], y07 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reset3()) : x07 == null ? null : [[x07, y07], [x13, y13]];
  };
  projection3.scale = function(_) {
    return arguments.length ? (k4 = +_, recenter()) : k4;
  };
  projection3.translate = function(_) {
    return arguments.length ? (x7 = +_[0], y7 = +_[1], recenter()) : [x7, y7];
  };
  projection3.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians3, phi2 = _[1] % 360 * radians3, recenter()) : [lambda * degrees5, phi2 * degrees5];
  };
  projection3.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians3, deltaPhi = _[1] % 360 * radians3, deltaGamma = _.length > 2 ? _[2] % 360 * radians3 : 0, recenter()) : [deltaLambda * degrees5, deltaPhi * degrees5, deltaGamma * degrees5];
  };
  projection3.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians3, recenter()) : alpha * degrees5;
  };
  projection3.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset3()) : sqrt5(delta2);
  };
  projection3.fitExtent = function(extent5, object2) {
    return fitExtent(projection3, extent5, object2);
  };
  projection3.fitSize = function(size, object2) {
    return fitSize(projection3, size, object2);
  };
  projection3.fitWidth = function(width2, object2) {
    return fitWidth(projection3, width2, object2);
  };
  projection3.fitHeight = function(height2, object2) {
    return fitHeight(projection3, height2, object2);
  };
  function recenter() {
    var center = scaleTranslateRotate(k4, 0, 0, sx, sy, alpha).apply(null, project3(lambda, phi2)), transform4 = scaleTranslateRotate(k4, x7 - center[0], y7 - center[1], sx, sy, alpha);
    rotate3 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project3, transform4);
    projectRotateTransform = compose_default(rotate3, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset3();
  }
  function reset3() {
    cache3 = cacheStream = null;
    return projection3;
  }
  return function() {
    project3 = projectAt.apply(this, arguments);
    projection3.invert = project3.invert && invert2;
    return recenter();
  };
}
var transformRadians;
var init_projection = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/index.js"() {
    init_antimeridian();
    init_circle3();
    init_rectangle();
    init_compose();
    init_identity9();
    init_math4();
    init_rotation();
    init_transform4();
    init_fit();
    init_resample();
    transformRadians = transformer7({
      point: function(x7, y7) {
        this.stream.point(x7 * radians3, y7 * radians3);
      }
    });
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi03 = 0, phi12 = pi3 / 3, m2 = projectionMutator(projectAt), p = m2(phi03, phi12);
  p.parallels = function(_) {
    return arguments.length ? m2(phi03 = _[0] * radians3, phi12 = _[1] * radians3) : [phi03 * degrees5, phi12 * degrees5];
  };
  return p;
}
var init_conic = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/conic.js"() {
    init_math4();
    init_projection();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi03) {
  var cosPhi02 = cos2(phi03);
  function forward(lambda, phi2) {
    return [lambda * cosPhi02, sin2(phi2) / cosPhi02];
  }
  forward.invert = function(x7, y7) {
    return [x7 / cosPhi02, asin2(y7 * cosPhi02)];
  };
  return forward;
}
var init_cylindricalEqualArea = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/cylindricalEqualArea.js"() {
    init_math4();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y07, y13) {
  var sy0 = sin2(y07), n = (sy0 + sin2(y13)) / 2;
  if (abs2(n) < epsilon4)
    return cylindricalEqualAreaRaw(y07);
  var c2 = 1 + sy0 * (2 * n - sy0), r0 = sqrt5(c2) / n;
  function project3(x7, y7) {
    var r2 = sqrt5(c2 - 2 * n * sin2(y7)) / n;
    return [r2 * sin2(x7 *= n), r0 - r2 * cos2(x7)];
  }
  project3.invert = function(x7, y7) {
    var r0y = r0 - y7, l = atan22(x7, abs2(r0y)) * sign2(r0y);
    if (r0y * n < 0)
      l -= pi3 * sign2(x7) * sign2(r0y);
    return [l / n, asin2((c2 - (x7 * x7 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project3;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}
var init_conicEqualArea = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/conicEqualArea.js"() {
    init_math4();
    init_conic();
    init_cylindricalEqualArea();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
var init_albers = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/albers.js"() {
    init_conicEqualArea();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x7, y7) {
      var i = -1;
      while (++i < n)
        streams[i].point(x7, y7);
    },
    sphere: function() {
      var i = -1;
      while (++i < n)
        streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache3, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point16, pointStream = { point: function(x7, y7) {
    point16 = [x7, y7];
  } };
  function albersUsa(coordinates) {
    var x7 = coordinates[0], y7 = coordinates[1];
    return point16 = null, (lower48Point.point(x7, y7), point16) || (alaskaPoint.point(x7, y7), point16) || (hawaiiPoint.point(x7, y7), point16);
  }
  albersUsa.invert = function(coordinates) {
    var k4 = lower48.scale(), t = lower48.translate(), x7 = (coordinates[0] - t[0]) / k4, y7 = (coordinates[1] - t[1]) / k4;
    return (y7 >= 0.12 && y7 < 0.234 && x7 >= -0.425 && x7 < -0.214 ? alaska : y7 >= 0.166 && y7 < 0.234 && x7 >= -0.214 && x7 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream2) {
    return cache3 && cacheStream === stream2 ? cache3 : cache3 = multiplex([lower48.stream(cacheStream = stream2), alaska.stream(stream2), hawaii.stream(stream2)]);
  };
  albersUsa.precision = function(_) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset3();
  };
  albersUsa.scale = function(_) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_) {
    if (!arguments.length)
      return lower48.translate();
    var k4 = lower48.scale(), x7 = +_[0], y7 = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x7 - 0.455 * k4, y7 - 0.238 * k4], [x7 + 0.455 * k4, y7 + 0.238 * k4]]).stream(pointStream);
    alaskaPoint = alaska.translate([x7 - 0.307 * k4, y7 + 0.201 * k4]).clipExtent([[x7 - 0.425 * k4 + epsilon4, y7 + 0.12 * k4 + epsilon4], [x7 - 0.214 * k4 - epsilon4, y7 + 0.234 * k4 - epsilon4]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x7 - 0.205 * k4, y7 + 0.212 * k4]).clipExtent([[x7 - 0.214 * k4 + epsilon4, y7 + 0.166 * k4 + epsilon4], [x7 - 0.115 * k4 - epsilon4, y7 + 0.234 * k4 - epsilon4]]).stream(pointStream);
    return reset3();
  };
  albersUsa.fitExtent = function(extent5, object2) {
    return fitExtent(albersUsa, extent5, object2);
  };
  albersUsa.fitSize = function(size, object2) {
    return fitSize(albersUsa, size, object2);
  };
  albersUsa.fitWidth = function(width2, object2) {
    return fitWidth(albersUsa, width2, object2);
  };
  albersUsa.fitHeight = function(height2, object2) {
    return fitHeight(albersUsa, height2, object2);
  };
  function reset3() {
    cache3 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}
var init_albersUsa = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/albersUsa.js"() {
    init_math4();
    init_albers();
    init_conicEqualArea();
    init_fit();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale8) {
  return function(x7, y7) {
    var cx = cos2(x7), cy = cos2(y7), k4 = scale8(cx * cy);
    if (k4 === Infinity)
      return [2, 0];
    return [
      k4 * cy * sin2(x7),
      k4 * sin2(y7)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x7, y7) {
    var z = sqrt5(x7 * x7 + y7 * y7), c2 = angle2(z), sc = sin2(c2), cc = cos2(c2);
    return [
      atan22(x7 * sc, z * cc),
      asin2(z && y7 * sc / z)
    ];
  };
}
var init_azimuthal = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/azimuthal.js"() {
    init_math4();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/azimuthalEqualArea.js
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}
var azimuthalEqualAreaRaw;
var init_azimuthalEqualArea = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/azimuthalEqualArea.js"() {
    init_math4();
    init_azimuthal();
    init_projection();
    azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt5(2 / (1 + cxcy));
    });
    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin2(z / 2);
    });
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/azimuthalEquidistant.js
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}
var azimuthalEquidistantRaw;
var init_azimuthalEquidistant = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/azimuthalEquidistant.js"() {
    init_math4();
    init_azimuthal();
    init_projection();
    azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
      return (c2 = acos2(c2)) && c2 / sin2(c2);
    });
    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log5(tan((halfPi2 + phi2) / 2))];
}
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project3) {
  var m2 = projection(project3), center = m2.center, scale8 = m2.scale, translate5 = m2.translate, clipExtent = m2.clipExtent, x07 = null, y07, x13, y13;
  m2.scale = function(_) {
    return arguments.length ? (scale8(_), reclip()) : scale8();
  };
  m2.translate = function(_) {
    return arguments.length ? (translate5(_), reclip()) : translate5();
  };
  m2.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };
  m2.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x07 = y07 = x13 = y13 = null : (x07 = +_[0][0], y07 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reclip()) : x07 == null ? null : [[x07, y07], [x13, y13]];
  };
  function reclip() {
    var k4 = pi3 * scale8(), t = m2(rotation_default(m2.rotate()).invert([0, 0]));
    return clipExtent(x07 == null ? [[t[0] - k4, t[1] - k4], [t[0] + k4, t[1] + k4]] : project3 === mercatorRaw ? [[Math.max(t[0] - k4, x07), y07], [Math.min(t[0] + k4, x13), y13]] : [[x07, Math.max(t[1] - k4, y07)], [x13, Math.min(t[1] + k4, y13)]]);
  }
  return reclip();
}
var init_mercator = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/mercator.js"() {
    init_math4();
    init_rotation();
    init_projection();
    mercatorRaw.invert = function(x7, y7) {
      return [x7, 2 * atan(exp3(y7)) - halfPi2];
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/conicConformal.js
function tany(y7) {
  return tan((halfPi2 + y7) / 2);
}
function conicConformalRaw(y07, y13) {
  var cy0 = cos2(y07), n = y07 === y13 ? sin2(y07) : log5(cy0 / cos2(y13)) / log5(tany(y13) / tany(y07)), f = cy0 * pow5(tany(y07), n) / n;
  if (!n)
    return mercatorRaw;
  function project3(x7, y7) {
    if (f > 0) {
      if (y7 < -halfPi2 + epsilon4)
        y7 = -halfPi2 + epsilon4;
    } else {
      if (y7 > halfPi2 - epsilon4)
        y7 = halfPi2 - epsilon4;
    }
    var r2 = f / pow5(tany(y7), n);
    return [r2 * sin2(n * x7), f - r2 * cos2(n * x7)];
  }
  project3.invert = function(x7, y7) {
    var fy = f - y7, r2 = sign2(n) * sqrt5(x7 * x7 + fy * fy), l = atan22(x7, abs2(fy)) * sign2(fy);
    if (fy * n < 0)
      l -= pi3 * sign2(x7) * sign2(fy);
    return [l / n, 2 * atan(pow5(f / r2, 1 / n)) - halfPi2];
  };
  return project3;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}
var init_conicConformal = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/conicConformal.js"() {
    init_math4();
    init_conic();
    init_mercator();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}
var init_equirectangular = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/equirectangular.js"() {
    init_projection();
    equirectangularRaw.invert = equirectangularRaw;
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y07, y13) {
  var cy0 = cos2(y07), n = y07 === y13 ? sin2(y07) : (cy0 - cos2(y13)) / (y13 - y07), g = cy0 / n + y07;
  if (abs2(n) < epsilon4)
    return equirectangularRaw;
  function project3(x7, y7) {
    var gy = g - y7, nx = n * x7;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project3.invert = function(x7, y7) {
    var gy = g - y7, l = atan22(x7, abs2(gy)) * sign2(gy);
    if (gy * n < 0)
      l -= pi3 * sign2(x7) * sign2(gy);
    return [l / n, g - sign2(n) * sqrt5(x7 * x7 + gy * gy)];
  };
  return project3;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}
var init_conicEquidistant = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/conicEquidistant.js"() {
    init_math4();
    init_conic();
    init_equirectangular();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/equalEarth.js
function equalEarthRaw(lambda, phi2) {
  var l = asin2(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A22 * l2 + l6 * (A3 + A4 * l2))
  ];
}
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}
var A1, A22, A3, A4, M, iterations;
var init_equalEarth = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/equalEarth.js"() {
    init_projection();
    init_math4();
    A1 = 1.340264;
    A22 = -0.081106;
    A3 = 893e-6;
    A4 = 3796e-6;
    M = sqrt5(3) / 2;
    iterations = 12;
    equalEarthRaw.invert = function(x7, y7) {
      var l = y7, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A22 * l2 + l6 * (A3 + A4 * l2)) - y7;
        fpy = A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs2(delta) < epsilon24)
          break;
      }
      return [
        M * x7 * (A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
        asin2(sin2(l) / M)
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x7, y7) {
  var cy = cos2(y7), k4 = cos2(x7) * cy;
  return [cy * sin2(x7) / k4, sin2(y7) / k4];
}
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}
var init_gnomonic = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/gnomonic.js"() {
    init_math4();
    init_azimuthal();
    init_projection();
    gnomonicRaw.invert = azimuthalInvert(atan);
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/identity.js
function identity_default7() {
  var k4 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa3, x07 = null, y07, x13, y13, kx4 = 1, ky3 = 1, transform4 = transformer7({
    point: function(x7, y7) {
      var p = projection3([x7, y7]);
      this.stream.point(p[0], p[1]);
    }
  }), postclip = identity_default6, cache3, cacheStream;
  function reset3() {
    kx4 = k4 * sx;
    ky3 = k4 * sy;
    cache3 = cacheStream = null;
    return projection3;
  }
  function projection3(p) {
    var x7 = p[0] * kx4, y7 = p[1] * ky3;
    if (alpha) {
      var t = y7 * ca - x7 * sa3;
      x7 = x7 * ca + y7 * sa3;
      y7 = t;
    }
    return [x7 + tx, y7 + ty];
  }
  projection3.invert = function(p) {
    var x7 = p[0] - tx, y7 = p[1] - ty;
    if (alpha) {
      var t = y7 * ca + x7 * sa3;
      x7 = x7 * ca - y7 * sa3;
      y7 = t;
    }
    return [x7 / kx4, y7 / ky3];
  };
  projection3.stream = function(stream2) {
    return cache3 && cacheStream === stream2 ? cache3 : cache3 = transform4(postclip(cacheStream = stream2));
  };
  projection3.postclip = function(_) {
    return arguments.length ? (postclip = _, x07 = y07 = x13 = y13 = null, reset3()) : postclip;
  };
  projection3.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x07 = y07 = x13 = y13 = null, identity_default6) : clipRectangle(x07 = +_[0][0], y07 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reset3()) : x07 == null ? null : [[x07, y07], [x13, y13]];
  };
  projection3.scale = function(_) {
    return arguments.length ? (k4 = +_, reset3()) : k4;
  };
  projection3.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset3()) : [tx, ty];
  };
  projection3.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians3, sa3 = sin2(alpha), ca = cos2(alpha), reset3()) : alpha * degrees5;
  };
  projection3.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset3()) : sx < 0;
  };
  projection3.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset3()) : sy < 0;
  };
  projection3.fitExtent = function(extent5, object2) {
    return fitExtent(projection3, extent5, object2);
  };
  projection3.fitSize = function(size, object2) {
    return fitSize(projection3, size, object2);
  };
  projection3.fitWidth = function(width2, object2) {
    return fitWidth(projection3, width2, object2);
  };
  projection3.fitHeight = function(height2, object2) {
    return fitHeight(projection3, height2, object2);
  };
  return projection3;
}
var init_identity10 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/identity.js"() {
    init_rectangle();
    init_identity9();
    init_transform4();
    init_fit();
    init_math4();
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}
var init_naturalEarth1 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/naturalEarth1.js"() {
    init_projection();
    init_math4();
    naturalEarth1Raw.invert = function(x7, y7) {
      var phi2 = y7, i = 25, delta;
      do {
        var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
        phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y7) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
      } while (abs2(delta) > epsilon4 && --i > 0);
      return [
        x7 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
        phi2
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x7, y7) {
  return [cos2(y7) * sin2(x7), sin2(y7)];
}
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon4);
}
var init_orthographic = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/orthographic.js"() {
    init_math4();
    init_azimuthal();
    init_projection();
    orthographicRaw.invert = azimuthalInvert(asin2);
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x7, y7) {
  var cy = cos2(y7), k4 = 1 + cos2(x7) * cy;
  return [cy * sin2(x7) / k4, sin2(y7) / k4];
}
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}
var init_stereographic = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/stereographic.js"() {
    init_math4();
    init_azimuthal();
    init_projection();
    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log5(tan((halfPi2 + phi2) / 2)), -lambda];
}
function transverseMercator_default() {
  var m2 = mercatorProjection(transverseMercatorRaw), center = m2.center, rotate3 = m2.rotate;
  m2.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };
  m2.rotate = function(_) {
    return arguments.length ? rotate3([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate3(), [_[0], _[1], _[2] - 90]);
  };
  return rotate3([0, 0, 90]).scale(159.155);
}
var init_transverseMercator = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/projection/transverseMercator.js"() {
    init_math4();
    init_mercator();
    transverseMercatorRaw.invert = function(x7, y7) {
      return [-y7, 2 * atan(exp3(x7)) - halfPi2];
    };
  }
});

// node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/index.js
var init_src21 = __esm({
  "node_modules/.pnpm/d3-geo@2.0.2/node_modules/d3-geo/src/index.js"() {
    init_area2();
    init_bounds();
    init_centroid();
    init_circle2();
    init_antimeridian();
    init_circle3();
    init_extent3();
    init_rectangle();
    init_contains();
    init_distance();
    init_graticule();
    init_interpolate();
    init_length();
    init_path3();
    init_albers();
    init_albersUsa();
    init_azimuthalEqualArea();
    init_azimuthalEquidistant();
    init_conicConformal();
    init_conicEqualArea();
    init_conicEquidistant();
    init_equalEarth();
    init_equirectangular();
    init_gnomonic();
    init_identity10();
    init_projection();
    init_mercator();
    init_naturalEarth1();
    init_orthographic();
    init_stereographic();
    init_transverseMercator();
    init_rotation();
    init_stream();
    init_transform4();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/math.js
function sinci(x7) {
  return x7 ? x7 / Math.sin(x7) : 1;
}
function asin3(x7) {
  return x7 > 1 ? halfPi3 : x7 < -1 ? -halfPi3 : Math.asin(x7);
}
function acos3(x7) {
  return x7 > 1 ? 0 : x7 < -1 ? pi4 : Math.acos(x7);
}
function sqrt6(x7) {
  return x7 > 0 ? Math.sqrt(x7) : 0;
}
function tanh3(x7) {
  x7 = exp4(2 * x7);
  return (x7 - 1) / (x7 + 1);
}
function sinh3(x7) {
  return (exp4(x7) - exp4(-x7)) / 2;
}
function cosh3(x7) {
  return (exp4(x7) + exp4(-x7)) / 2;
}
function arsinh(x7) {
  return log6(x7 + sqrt6(x7 * x7 + 1));
}
function arcosh(x7) {
  return log6(x7 + sqrt6(x7 * x7 - 1));
}
var abs3, atan3, atan23, cos3, exp4, floor2, log6, max5, min5, pow6, sign3, sin3, tan2, epsilon5, epsilon25, pi4, halfPi3, quarterPi2, sqrt1_2, sqrt22, sqrtPi, tau4, degrees6, radians4;
var init_math5 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/math.js"() {
    abs3 = Math.abs;
    atan3 = Math.atan;
    atan23 = Math.atan2;
    cos3 = Math.cos;
    exp4 = Math.exp;
    floor2 = Math.floor;
    log6 = Math.log;
    max5 = Math.max;
    min5 = Math.min;
    pow6 = Math.pow;
    sign3 = Math.sign || function(x7) {
      return x7 > 0 ? 1 : x7 < 0 ? -1 : 0;
    };
    sin3 = Math.sin;
    tan2 = Math.tan;
    epsilon5 = 1e-6;
    epsilon25 = 1e-12;
    pi4 = Math.PI;
    halfPi3 = pi4 / 2;
    quarterPi2 = pi4 / 4;
    sqrt1_2 = Math.SQRT1_2;
    sqrt22 = sqrt6(2);
    sqrtPi = sqrt6(pi4);
    tau4 = pi4 * 2;
    degrees6 = 180 / pi4;
    radians4 = pi4 / 180;
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/airy.js
var init_airy = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/airy.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/aitoff.js
function aitoffRaw(x7, y7) {
  var cosy = cos3(y7), sincia = sinci(acos3(cosy * cos3(x7 /= 2)));
  return [2 * cosy * sin3(x7) * sincia, sin3(y7) * sincia];
}
var init_aitoff = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/aitoff.js"() {
    init_src21();
    init_math5();
    aitoffRaw.invert = function(x7, y7) {
      if (x7 * x7 + 4 * y7 * y7 > pi4 * pi4 + epsilon5)
        return;
      var x13 = x7, y13 = y7, i = 25;
      do {
        var sinx = sin3(x13), sinx_2 = sin3(x13 / 2), cosx_2 = cos3(x13 / 2), siny = sin3(y13), cosy = cos3(y13), sin_2y = sin3(2 * y13), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c2 = 1 - cos2y * cosx_2 * cosx_2, e3 = c2 ? acos3(cosy * cosx_2) * sqrt6(f = 1 / c2) : f = 0, f, fx = 2 * e3 * cosy * sinx_2 - x7, fy = e3 * siny - y7, dxdx = f * (cos2y * sin2x_2 + e3 * cosy * cosx_2 * sin2y), dxdy = f * (0.5 * sinx * sin_2y - e3 * 2 * siny * sinx_2), dydx = f * 0.25 * (sin_2y * sinx_2 - e3 * siny * cos2y * sinx), dydy = f * (sin2y * cosx_2 + e3 * sin2x_2 * cosy), z = dxdy * dydx - dydy * dxdx;
        if (!z)
          break;
        var dx = (fy * dxdy - fx * dydy) / z, dy = (fx * dydx - fy * dxdx) / z;
        x13 -= dx, y13 -= dy;
      } while ((abs3(dx) > epsilon5 || abs3(dy) > epsilon5) && --i > 0);
      return [x13, y13];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/armadillo.js
var init_armadillo = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/armadillo.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/august.js
function augustRaw(lambda, phi2) {
  var tanPhi = tan2(phi2 / 2), k4 = sqrt6(1 - tanPhi * tanPhi), c2 = 1 + k4 * cos3(lambda /= 2), x7 = sin3(lambda) * k4 / c2, y7 = tanPhi / c2, x22 = x7 * x7, y22 = y7 * y7;
  return [
    4 / 3 * x7 * (3 + x22 - 3 * y22),
    4 / 3 * y7 * (3 + 3 * x22 - y22)
  ];
}
var init_august = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/august.js"() {
    init_src21();
    init_math5();
    augustRaw.invert = function(x7, y7) {
      x7 *= 3 / 8, y7 *= 3 / 8;
      if (!x7 && abs3(y7) > 1)
        return null;
      var x22 = x7 * x7, y22 = y7 * y7, s3 = 1 + x22 + y22, sin3Eta = sqrt6((s3 - sqrt6(s3 * s3 - 4 * y7 * y7)) / 2), eta = asin3(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs3(y7 / sin3Eta)) / 3 : arsinh(abs3(x7)) / 3, cosEta = cos3(eta), coshXi = cosh3(xi), d = coshXi * coshXi - cosEta * cosEta;
      return [
        sign3(x7) * 2 * atan23(sinh3(xi) * cosEta, 0.25 - d),
        sign3(y7) * 2 * atan23(coshXi * sin3(eta), 0.25 + d)
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/baker.js
function bakerRaw(lambda, phi2) {
  var phi03 = abs3(phi2);
  return phi03 < quarterPi2 ? [lambda, log6(tan2(quarterPi2 + phi2 / 2))] : [lambda * cos3(phi03) * (2 * sqrt22 - 1 / sin3(phi03)), sign3(phi2) * (2 * sqrt22 * (phi03 - quarterPi2) - log6(tan2(phi03 / 2)))];
}
var sqrt8, phi02;
var init_baker = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/baker.js"() {
    init_src21();
    init_math5();
    sqrt8 = sqrt6(8);
    phi02 = log6(1 + sqrt22);
    bakerRaw.invert = function(x7, y7) {
      if ((y07 = abs3(y7)) < phi02)
        return [x7, 2 * atan3(exp4(y7)) - halfPi3];
      var phi2 = quarterPi2, i = 25, delta, y07;
      do {
        var cosPhi_2 = cos3(phi2 / 2), tanPhi_2 = tan2(phi2 / 2);
        phi2 -= delta = (sqrt8 * (phi2 - quarterPi2) - log6(tanPhi_2) - y07) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
      } while (abs3(delta) > epsilon25 && --i > 0);
      return [x7 / (cos3(phi2) * (sqrt8 - 1 / sin3(phi2))), sign3(y7) * phi2];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/berghaus.js
var init_berghaus = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/berghaus.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/hammer.js
function hammerQuarticAuthalicRaw(lambda, phi2) {
  return [
    lambda * cos3(phi2) / cos3(phi2 /= 2),
    2 * sin3(phi2)
  ];
}
var init_hammer = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/hammer.js"() {
    init_src21();
    init_math5();
    hammerQuarticAuthalicRaw.invert = function(x7, y7) {
      var phi2 = 2 * asin3(y7 / 2);
      return [
        x7 * cos3(phi2 / 2) / cos3(phi2),
        phi2
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/newton.js
function solve(f, y7, x7) {
  var steps = 100, delta, f0, f1;
  x7 = x7 === void 0 ? 0 : +x7;
  y7 = +y7;
  do {
    f0 = f(x7);
    f1 = f(x7 + epsilon5);
    if (f0 === f1)
      f1 = f0 + epsilon5;
    x7 -= delta = -1 * epsilon5 * (f0 - y7) / (f0 - f1);
  } while (steps-- > 0 && abs3(delta) > epsilon5);
  return steps < 0 ? NaN : x7;
}
var init_newton = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/newton.js"() {
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/bertin.js
var init_bertin = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/bertin.js"() {
    init_src21();
    init_hammer();
    init_math5();
    init_newton();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/mollweide.js
function mollweideBromleyTheta(cp, phi2) {
  var cpsinPhi = cp * sin3(phi2), i = 30, delta;
  do
    phi2 -= delta = (phi2 + sin3(phi2) - cpsinPhi) / (1 + cos3(phi2));
  while (abs3(delta) > epsilon5 && --i > 0);
  return phi2 / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi2) {
    return [cx * lambda * cos3(phi2 = mollweideBromleyTheta(cp, phi2)), cy * sin3(phi2)];
  }
  forward.invert = function(x7, y7) {
    return y7 = asin3(y7 / cy), [x7 / (cx * cos3(y7)), asin3((2 * y7 + sin3(2 * y7)) / cp)];
  };
  return forward;
}
function mollweide_default() {
  return projection(mollweideRaw).scale(169.529);
}
var mollweideRaw;
var init_mollweide = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/mollweide.js"() {
    init_src21();
    init_math5();
    mollweideRaw = mollweideBromleyRaw(sqrt22 / halfPi3, sqrt22, pi4);
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/boggs.js
function boggsRaw(lambda, phi2) {
  var theta = mollweideBromleyTheta(pi4, phi2);
  return [k2 * lambda / (1 / cos3(phi2) + w2 / cos3(theta)), (phi2 + sqrt22 * sin3(theta)) / k2];
}
var k2, w2;
var init_boggs = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/boggs.js"() {
    init_src21();
    init_mollweide();
    init_math5();
    k2 = 2.00276;
    w2 = 1.11072;
    boggsRaw.invert = function(x7, y7) {
      var ky3 = k2 * y7, theta = y7 < 0 ? -quarterPi2 : quarterPi2, i = 25, delta, phi2;
      do {
        phi2 = ky3 - sqrt22 * sin3(theta);
        theta -= delta = (sin3(2 * theta) + 2 * theta - pi4 * sin3(phi2)) / (2 * cos3(2 * theta) + 2 + pi4 * cos3(phi2) * sqrt22 * cos3(theta));
      } while (abs3(delta) > epsilon5 && --i > 0);
      phi2 = ky3 - sqrt22 * sin3(theta);
      return [x7 * (1 / cos3(phi2) + w2 / cos3(theta)) / k2, phi2];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/parallel1.js
var init_parallel1 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/parallel1.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/sinusoidal.js
function sinusoidalRaw(lambda, phi2) {
  return [lambda * cos3(phi2), phi2];
}
var init_sinusoidal = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/sinusoidal.js"() {
    init_src21();
    init_math5();
    sinusoidalRaw.invert = function(x7, y7) {
      return [x7 / cos3(y7), y7];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/bonne.js
var init_bonne = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/bonne.js"() {
    init_parallel1();
    init_math5();
    init_sinusoidal();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/bottomley.js
var init_bottomley = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/bottomley.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/bromley.js
var bromleyRaw;
var init_bromley = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/bromley.js"() {
    init_src21();
    init_math5();
    init_mollweide();
    bromleyRaw = mollweideBromleyRaw(1, 4 / pi4, pi4);
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/chamberlin.js
var init_chamberlin = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/chamberlin.js"() {
    init_src21();
    init_math5();
    init_newton();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/collignon.js
function collignonRaw(lambda, phi2) {
  var alpha = sqrt6(1 - sin3(phi2));
  return [2 / sqrtPi * lambda * alpha, sqrtPi * (1 - alpha)];
}
var init_collignon = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/collignon.js"() {
    init_src21();
    init_math5();
    collignonRaw.invert = function(x7, y7) {
      var lambda = (lambda = y7 / sqrtPi - 1) * lambda;
      return [lambda > 0 ? x7 * sqrt6(pi4 / lambda) / 2 : 0, asin3(1 - lambda)];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/craig.js
var init_craig = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/craig.js"() {
    init_math5();
    init_parallel1();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/craster.js
function crasterRaw(lambda, phi2) {
  return [sqrt34 * lambda * (2 * cos3(2 * phi2 / 3) - 1) / sqrtPi, sqrt34 * sqrtPi * sin3(phi2 / 3)];
}
var sqrt34;
var init_craster = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/craster.js"() {
    init_src21();
    init_math5();
    sqrt34 = sqrt6(3);
    crasterRaw.invert = function(x7, y7) {
      var phi2 = 3 * asin3(y7 / (sqrt34 * sqrtPi));
      return [sqrtPi * x7 / (sqrt34 * (2 * cos3(2 * phi2 / 3) - 1)), phi2];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/cylindricalEqualArea.js
function cylindricalEqualAreaRaw2(phi03) {
  var cosPhi02 = cos3(phi03);
  function forward(lambda, phi2) {
    return [lambda * cosPhi02, sin3(phi2) / cosPhi02];
  }
  forward.invert = function(x7, y7) {
    return [x7 / cosPhi02, asin3(y7 * cosPhi02)];
  };
  return forward;
}
var init_cylindricalEqualArea2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/cylindricalEqualArea.js"() {
    init_math5();
    init_parallel1();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/cylindricalStereographic.js
var init_cylindricalStereographic = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/cylindricalStereographic.js"() {
    init_math5();
    init_parallel1();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert1.js
function eckert1Raw(lambda, phi2) {
  var alpha = sqrt6(8 / (3 * pi4));
  return [
    alpha * lambda * (1 - abs3(phi2) / pi4),
    alpha * phi2
  ];
}
var init_eckert1 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert1.js"() {
    init_src21();
    init_math5();
    eckert1Raw.invert = function(x7, y7) {
      var alpha = sqrt6(8 / (3 * pi4)), phi2 = y7 / alpha;
      return [
        x7 / (alpha * (1 - abs3(phi2) / pi4)),
        phi2
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert2.js
function eckert2Raw(lambda, phi2) {
  var alpha = sqrt6(4 - 3 * sin3(abs3(phi2)));
  return [
    2 / sqrt6(6 * pi4) * lambda * alpha,
    sign3(phi2) * sqrt6(2 * pi4 / 3) * (2 - alpha)
  ];
}
var init_eckert2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert2.js"() {
    init_src21();
    init_math5();
    eckert2Raw.invert = function(x7, y7) {
      var alpha = 2 - abs3(y7) / sqrt6(2 * pi4 / 3);
      return [
        x7 * sqrt6(6 * pi4) / (2 * alpha),
        sign3(y7) * asin3((4 - alpha * alpha) / 3)
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert3.js
function eckert3Raw(lambda, phi2) {
  var k4 = sqrt6(pi4 * (4 + pi4));
  return [
    2 / k4 * lambda * (1 + sqrt6(1 - 4 * phi2 * phi2 / (pi4 * pi4))),
    4 / k4 * phi2
  ];
}
var init_eckert3 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert3.js"() {
    init_src21();
    init_math5();
    eckert3Raw.invert = function(x7, y7) {
      var k4 = sqrt6(pi4 * (4 + pi4)) / 2;
      return [
        x7 * k4 / (1 + sqrt6(1 - y7 * y7 * (4 + pi4) / (4 * pi4))),
        y7 * k4 / 2
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert4.js
function eckert4Raw(lambda, phi2) {
  var k4 = (2 + halfPi3) * sin3(phi2);
  phi2 /= 2;
  for (var i = 0, delta = Infinity; i < 10 && abs3(delta) > epsilon5; i++) {
    var cosPhi = cos3(phi2);
    phi2 -= delta = (phi2 + sin3(phi2) * (cosPhi + 2) - k4) / (2 * cosPhi * (1 + cosPhi));
  }
  return [
    2 / sqrt6(pi4 * (4 + pi4)) * lambda * (1 + cos3(phi2)),
    2 * sqrt6(pi4 / (4 + pi4)) * sin3(phi2)
  ];
}
var init_eckert4 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert4.js"() {
    init_src21();
    init_math5();
    eckert4Raw.invert = function(x7, y7) {
      var A6 = y7 * sqrt6((4 + pi4) / pi4) / 2, k4 = asin3(A6), c2 = cos3(k4);
      return [
        x7 / (2 / sqrt6(pi4 * (4 + pi4)) * (1 + c2)),
        asin3((k4 + A6 * (c2 + 2)) / (2 + halfPi3))
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert5.js
function eckert5Raw(lambda, phi2) {
  return [
    lambda * (1 + cos3(phi2)) / sqrt6(2 + pi4),
    2 * phi2 / sqrt6(2 + pi4)
  ];
}
var init_eckert5 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert5.js"() {
    init_src21();
    init_math5();
    eckert5Raw.invert = function(x7, y7) {
      var k4 = sqrt6(2 + pi4), phi2 = y7 * k4 / 2;
      return [
        k4 * x7 / (1 + cos3(phi2)),
        phi2
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert6.js
function eckert6Raw(lambda, phi2) {
  var k4 = (1 + halfPi3) * sin3(phi2);
  for (var i = 0, delta = Infinity; i < 10 && abs3(delta) > epsilon5; i++) {
    phi2 -= delta = (phi2 + sin3(phi2) - k4) / (1 + cos3(phi2));
  }
  k4 = sqrt6(2 + pi4);
  return [
    lambda * (1 + cos3(phi2)) / k4,
    2 * phi2 / k4
  ];
}
var init_eckert6 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eckert6.js"() {
    init_src21();
    init_math5();
    eckert6Raw.invert = function(x7, y7) {
      var j = 1 + halfPi3, k4 = sqrt6(j / 2);
      return [
        x7 * 2 * k4 / (1 + cos3(y7 *= k4)),
        asin3((y7 + sin3(y7)) / j)
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eisenlohr.js
function eisenlohrRaw(lambda, phi2) {
  var s0 = sin3(lambda /= 2), c0 = cos3(lambda), k4 = sqrt6(cos3(phi2)), c1 = cos3(phi2 /= 2), t = sin3(phi2) / (c1 + sqrt22 * c0 * k4), c2 = sqrt6(2 / (1 + t * t)), v = sqrt6((sqrt22 * c1 + (c0 + s0) * k4) / (sqrt22 * c1 + (c0 - s0) * k4));
  return [
    eisenlohrK * (c2 * (v - 1 / v) - 2 * log6(v)),
    eisenlohrK * (c2 * t * (v + 1 / v) - 2 * atan3(t))
  ];
}
var eisenlohrK;
var init_eisenlohr = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/eisenlohr.js"() {
    init_src21();
    init_august();
    init_math5();
    eisenlohrK = 3 + 2 * sqrt22;
    eisenlohrRaw.invert = function(x7, y7) {
      if (!(p = augustRaw.invert(x7 / 1.2, y7 * 1.065)))
        return null;
      var lambda = p[0], phi2 = p[1], i = 20, p;
      x7 /= eisenlohrK, y7 /= eisenlohrK;
      do {
        var _0 = lambda / 2, _1 = phi2 / 2, s0 = sin3(_0), c0 = cos3(_0), s1 = sin3(_1), c1 = cos3(_1), cos1 = cos3(phi2), k4 = sqrt6(cos1), t = s1 / (c1 + sqrt22 * c0 * k4), t23 = t * t, c2 = sqrt6(2 / (1 + t23)), v0 = sqrt22 * c1 + (c0 + s0) * k4, v1 = sqrt22 * c1 + (c0 - s0) * k4, v2 = v0 / v1, v = sqrt6(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c2 * vm1v - 2 * log6(v) - x7, fy = c2 * t * vp1v - 2 * atan3(t) - y7, deltatDeltaLambda = s1 && sqrt1_2 * k4 * s0 * t23 / s1, deltatDeltaPhi = (sqrt22 * c0 * c1 + k4) / (2 * (c1 + sqrt22 * c0 * k4) * (c1 + sqrt22 * c0 * k4) * k4), deltacDeltat = -0.5 * t * c2 * c2 * c2, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A6 = (A6 = 2 * c1 + sqrt22 * k4 * (c0 - s0)) * A6 * v, deltavDeltaLambda = (sqrt22 * c0 * c1 * k4 + cos1) / A6, deltavDeltaPhi = -(sqrt22 * s0 * s1) / (k4 * A6), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c2 * (deltavDeltaLambda + deltavDeltaLambda / v2), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c2 * (deltavDeltaPhi + deltavDeltaPhi / v2), deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t23) + c2 * vp1v * deltatDeltaLambda + c2 * t * (deltavDeltaLambda - deltavDeltaLambda / v2), deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t23) + c2 * vp1v * deltatDeltaPhi + c2 * t * (deltavDeltaPhi - deltavDeltaPhi / v2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
        if (!denominator)
          break;
        var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
        lambda -= deltaLambda;
        phi2 = max5(-halfPi3, min5(halfPi3, phi2 - deltaPhi));
      } while ((abs3(deltaLambda) > epsilon5 || abs3(deltaPhi) > epsilon5) && --i > 0);
      return abs3(abs3(phi2) - halfPi3) < epsilon5 ? [0, phi2] : i && [lambda, phi2];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/fahey.js
function faheyRaw(lambda, phi2) {
  var t = tan2(phi2 / 2);
  return [lambda * faheyK * sqrt6(1 - t * t), (1 + faheyK) * t];
}
var faheyK;
var init_fahey = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/fahey.js"() {
    init_src21();
    init_math5();
    faheyK = cos3(35 * radians4);
    faheyRaw.invert = function(x7, y7) {
      var t = y7 / (1 + faheyK);
      return [x7 && x7 / (faheyK * sqrt6(1 - t * t)), 2 * atan3(t)];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/foucaut.js
function foucautRaw(lambda, phi2) {
  var k4 = phi2 / 2, cosk = cos3(k4);
  return [2 * lambda / sqrtPi * cos3(phi2) * cosk * cosk, sqrtPi * tan2(k4)];
}
var init_foucaut = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/foucaut.js"() {
    init_src21();
    init_math5();
    foucautRaw.invert = function(x7, y7) {
      var k4 = atan3(y7 / sqrtPi), cosk = cos3(k4), phi2 = 2 * k4;
      return [x7 * sqrtPi / 2 / (cos3(phi2) * cosk * cosk), phi2];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/foucautSinusoidal.js
var init_foucautSinusoidal = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/foucautSinusoidal.js"() {
    init_src21();
    init_math5();
    init_newton();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/gilbert.js
var init_gilbert = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/gilbert.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/gingery.js
var init_gingery = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/gingery.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburgPolyconic.js
function ginzburgPolyconic_default(a4, b3, c2, d, e3, f, g, h4) {
  if (arguments.length < 8)
    h4 = 0;
  function forward(lambda, phi2) {
    if (!phi2)
      return [a4 * lambda / pi4, 0];
    var phi22 = phi2 * phi2, xB = a4 + phi22 * (b3 + phi22 * (c2 + phi22 * d)), yB = phi2 * (e3 - 1 + phi22 * (f - h4 + phi22 * g)), m2 = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin3(xB / m2) / pi4;
    return [m2 * sin3(alpha), phi2 * (1 + phi22 * h4) + m2 * (1 - cos3(alpha))];
  }
  forward.invert = function(x7, y7) {
    var lambda = pi4 * x7 / a4, phi2 = y7, deltaLambda, deltaPhi, i = 50;
    do {
      var phi22 = phi2 * phi2, xB = a4 + phi22 * (b3 + phi22 * (c2 + phi22 * d)), yB = phi2 * (e3 - 1 + phi22 * (f - h4 + phi22 * g)), p = xB * xB + yB * yB, q = 2 * yB, m2 = p / q, m22 = m2 * m2, dAlphadLambda = asin3(xB / m2) / pi4, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b3 + phi22 * (4 * c2 + phi22 * 6 * d)) * phi2, dyBdPhi = e3 + phi22 * (3 * f + phi22 * 5 * g), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q), cosAlpha = cos3(alpha), sinAlpha = sin3(alpha), mcosAlpha = m2 * cosAlpha, msinAlpha = m2 * sinAlpha, dAlphadPhi = lambda / pi4 * (1 / sqrt6(1 - xB2 / m22)) * (dxBdPhi * m2 - xB * dmdPhi) / m22, fx = msinAlpha - x7, fy = phi2 * (1 + phi22 * h4) + m2 - mcosAlpha - y7, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
      if (!denominator)
        break;
      lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
      phi2 -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    } while ((abs3(deltaLambda) > epsilon5 || abs3(deltaPhi) > epsilon5) && --i > 0);
    return [lambda, phi2];
  };
  return forward;
}
var init_ginzburgPolyconic = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburgPolyconic.js"() {
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburg4.js
var ginzburg4Raw;
var init_ginzburg4 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburg4.js"() {
    init_src21();
    init_ginzburgPolyconic();
    ginzburg4Raw = ginzburgPolyconic_default(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburg5.js
var ginzburg5Raw;
var init_ginzburg5 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburg5.js"() {
    init_src21();
    init_ginzburgPolyconic();
    ginzburg5Raw = ginzburgPolyconic_default(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburg6.js
var ginzburg6Raw;
var init_ginzburg6 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburg6.js"() {
    init_src21();
    init_ginzburgPolyconic();
    init_math5();
    ginzburg6Raw = ginzburgPolyconic_default(5 / 6 * pi4, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburg8.js
function ginzburg8Raw(lambda, phi2) {
  var lambda22 = lambda * lambda, phi22 = phi2 * phi2;
  return [
    lambda * (1 - 0.162388 * phi22) * (0.87 - 952426e-9 * lambda22 * lambda22),
    phi2 * (1 + phi22 / 12)
  ];
}
var init_ginzburg8 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburg8.js"() {
    init_src21();
    init_math5();
    ginzburg8Raw.invert = function(x7, y7) {
      var lambda = x7, phi2 = y7, i = 50, delta;
      do {
        var phi22 = phi2 * phi2;
        phi2 -= delta = (phi2 * (1 + phi22 / 12) - y7) / (1 + phi22 / 4);
      } while (abs3(delta) > epsilon5 && --i > 0);
      i = 50;
      x7 /= 1 - 0.162388 * phi22;
      do {
        var lambda4 = (lambda4 = lambda * lambda) * lambda4;
        lambda -= delta = (lambda * (0.87 - 952426e-9 * lambda4) - x7) / (0.87 - 476213e-8 * lambda4);
      } while (abs3(delta) > epsilon5 && --i > 0);
      return [lambda, phi2];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburg9.js
var ginzburg9Raw;
var init_ginzburg9 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/ginzburg9.js"() {
    init_src21();
    init_ginzburgPolyconic();
    ginzburg9Raw = ginzburgPolyconic_default(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/square.js
var init_square3 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/square.js"() {
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/gringorten.js
function gringortenRaw(lambda, phi2) {
  var sLambda = sign3(lambda), sPhi = sign3(phi2), cosPhi = cos3(phi2), x7 = cos3(lambda) * cosPhi, y7 = sin3(lambda) * cosPhi, z = sin3(sPhi * phi2);
  lambda = abs3(atan23(y7, z));
  phi2 = asin3(x7);
  if (abs3(lambda - halfPi3) > epsilon5)
    lambda %= halfPi3;
  var point16 = gringortenHexadecant(lambda > pi4 / 4 ? halfPi3 - lambda : lambda, phi2);
  if (lambda > pi4 / 4)
    z = point16[0], point16[0] = -point16[1], point16[1] = -z;
  return point16[0] *= sLambda, point16[1] *= -sPhi, point16;
}
function gringortenHexadecant(lambda, phi2) {
  if (phi2 === halfPi3)
    return [0, 0];
  var sinPhi = sin3(phi2), r2 = sinPhi * sinPhi, r22 = r2 * r2, j = 1 + r22, k4 = 1 + 3 * r22, q = 1 - r22, z = asin3(1 / sqrt6(j)), v = q + r2 * j * z, p2 = (1 - sinPhi) / v, p = sqrt6(p2), a22 = p2 * j, a4 = sqrt6(a22), h4 = p * q, x7, i;
  if (lambda === 0)
    return [0, -(h4 + r2 * a4)];
  var cosPhi = cos3(phi2), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r2 + z * k4) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = q * dpdPhi - 2 * r2 * p * drdPhi, dra2dPhi = r2 * j * dp2dPhi + p2 * k4 * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda12 = 4 * lambda / pi4, delta;
  if (lambda > 0.222 * pi4 || phi2 < pi4 / 4 && lambda > 0.175 * pi4) {
    x7 = (h4 + r2 * sqrt6(a22 * (1 + r22) - h4 * h4)) / (1 + r22);
    if (lambda > pi4 / 4)
      return [x7, x7];
    var x13 = x7, x07 = 0.5 * x7;
    x7 = 0.5 * (x07 + x13), i = 50;
    do {
      var g = sqrt6(a22 - x7 * x7), f = x7 * (zeta + mu * g) + nu * asin3(x7 / a4) - lambda12;
      if (!f)
        break;
      if (f < 0)
        x07 = x7;
      else
        x13 = x7;
      x7 = 0.5 * (x07 + x13);
    } while (abs3(x13 - x07) > epsilon5 && --i > 0);
  } else {
    x7 = epsilon5, i = 25;
    do {
      var x22 = x7 * x7, g2 = sqrt6(a22 - x22), zetaMug = zeta + mu * g2, f2 = x7 * zetaMug + nu * asin3(x7 / a4) - lambda12, df = zetaMug + (nu - mu * x22) / g2;
      x7 -= delta = g2 ? f2 / df : 0;
    } while (abs3(delta) > epsilon5 && --i > 0);
  }
  return [x7, -h4 - r2 * sqrt6(a22 - x7 * x7)];
}
function gringortenHexadecantInvert(x7, y7) {
  var x07 = 0, x13 = 1, r2 = 0.5, i = 50;
  while (true) {
    var r22 = r2 * r2, sinPhi = sqrt6(r2), z = asin3(1 / sqrt6(1 + r22)), v = 1 - r22 + r2 * (1 + r22) * z, p2 = (1 - sinPhi) / v, p = sqrt6(p2), a22 = p2 * (1 + r22), h4 = p * (1 - r22), g2 = a22 - x7 * x7, g = sqrt6(g2), y07 = y7 + h4 + r2 * g;
    if (abs3(x13 - x07) < epsilon25 || --i === 0 || y07 === 0)
      break;
    if (y07 > 0)
      x07 = r2;
    else
      x13 = r2;
    r2 = 0.5 * (x07 + x13);
  }
  if (!i)
    return null;
  var phi2 = asin3(sinPhi), cosPhi = cos3(phi2), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r2 + z * (1 + 3 * r22)) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = (1 - r22) * dpdPhi - 2 * r2 * p * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r2 * (1 + r22) * dp2dPhi + p2 * (1 + 3 * r22) * drdPhi);
  return [pi4 / 4 * (x7 * (zeta + mu * g) + nu * asin3(x7 / sqrt6(a22))), phi2];
}
var init_gringorten = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/gringorten.js"() {
    init_src21();
    init_math5();
    init_square3();
    gringortenRaw.invert = function(x7, y7) {
      if (abs3(x7) > 1)
        x7 = sign3(x7) * 2 - x7;
      if (abs3(y7) > 1)
        y7 = sign3(y7) * 2 - y7;
      var sx = sign3(x7), sy = sign3(y7), x07 = -sx * x7, y07 = -sy * y7, t = y07 / x07 < 1, p = gringortenHexadecantInvert(t ? y07 : x07, t ? x07 : y07), lambda = p[0], phi2 = p[1], cosPhi = cos3(phi2);
      if (t)
        lambda = -halfPi3 - lambda;
      return [sx * (atan23(sin3(lambda) * cosPhi, -sin3(phi2)) + pi4), sy * asin3(cos3(lambda) * cosPhi)];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/elliptic.js
function ellipticJi(u, v, m2) {
  var a4, b3, c2;
  if (!u) {
    b3 = ellipticJ(v, 1 - m2);
    return [
      [0, b3[0] / b3[1]],
      [1 / b3[1], 0],
      [b3[2] / b3[1], 0]
    ];
  }
  a4 = ellipticJ(u, m2);
  if (!v)
    return [[a4[0], 0], [a4[1], 0], [a4[2], 0]];
  b3 = ellipticJ(v, 1 - m2);
  c2 = b3[1] * b3[1] + m2 * a4[0] * a4[0] * b3[0] * b3[0];
  return [
    [a4[0] * b3[2] / c2, a4[1] * a4[2] * b3[0] * b3[1] / c2],
    [a4[1] * b3[1] / c2, -a4[0] * a4[2] * b3[0] * b3[2] / c2],
    [a4[2] * b3[1] * b3[2] / c2, -m2 * a4[0] * a4[1] * b3[0] / c2]
  ];
}
function ellipticJ(u, m2) {
  var ai, b3, phi2, t, twon;
  if (m2 < epsilon5) {
    t = sin3(u);
    b3 = cos3(u);
    ai = m2 * (u - t * b3) / 4;
    return [
      t - ai * b3,
      b3 + ai * t,
      1 - m2 * t * t / 2,
      u - ai
    ];
  }
  if (m2 >= 1 - epsilon5) {
    ai = (1 - m2) / 4;
    b3 = cosh3(u);
    t = tanh3(u);
    phi2 = 1 / b3;
    twon = b3 * sinh3(u);
    return [
      t + ai * (twon - u) / (b3 * b3),
      phi2 - ai * t * phi2 * (twon - u),
      phi2 + ai * t * phi2 * (twon + u),
      2 * atan3(exp4(u)) - halfPi3 + ai * (twon - u) / b3
    ];
  }
  var a4 = [1, 0, 0, 0, 0, 0, 0, 0, 0], c2 = [sqrt6(m2), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;
  b3 = sqrt6(1 - m2);
  twon = 1;
  while (abs3(c2[i] / a4[i]) > epsilon5 && i < 8) {
    ai = a4[i++];
    c2[i] = (ai - b3) / 2;
    a4[i] = (ai + b3) / 2;
    b3 = sqrt6(ai * b3);
    twon *= 2;
  }
  phi2 = twon * a4[i] * u;
  do {
    t = c2[i] * sin3(b3 = phi2) / a4[i];
    phi2 = (asin3(t) + phi2) / 2;
  } while (--i);
  return [sin3(phi2), t = cos3(phi2), t / cos3(phi2 - b3), phi2];
}
function ellipticFi(phi2, psi, m2) {
  var r2 = abs3(phi2), i = abs3(psi), sinhPsi = sinh3(i);
  if (r2) {
    var cscPhi = 1 / sin3(r2), cotPhi2 = 1 / (tan2(r2) * tan2(r2)), b3 = -(cotPhi2 + m2 * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m2), c2 = (m2 - 1) * cotPhi2, cotLambda2 = (-b3 + sqrt6(b3 * b3 - 4 * c2)) / 2;
    return [
      ellipticF(atan3(1 / sqrt6(cotLambda2)), m2) * sign3(phi2),
      ellipticF(atan3(sqrt6((cotLambda2 / cotPhi2 - 1) / m2)), 1 - m2) * sign3(psi)
    ];
  }
  return [
    0,
    ellipticF(atan3(sinhPsi), 1 - m2) * sign3(psi)
  ];
}
function ellipticF(phi2, m2) {
  if (!m2)
    return phi2;
  if (m2 === 1)
    return log6(tan2(phi2 / 2 + quarterPi2));
  var a4 = 1, b3 = sqrt6(1 - m2), c2 = sqrt6(m2);
  for (var i = 0; abs3(c2) > epsilon5; i++) {
    if (phi2 % pi4) {
      var dPhi = atan3(b3 * tan2(phi2) / a4);
      if (dPhi < 0)
        dPhi += pi4;
      phi2 += dPhi + ~~(phi2 / pi4) * pi4;
    } else
      phi2 += phi2;
    c2 = (a4 + b3) / 2;
    b3 = sqrt6(a4 * b3);
    c2 = ((a4 = c2) - b3) / 2;
  }
  return phi2 / (pow6(2, i) * a4);
}
var init_elliptic = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/elliptic.js"() {
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/guyou.js
function guyouRaw(lambda, phi2) {
  var k_ = (sqrt22 - 1) / (sqrt22 + 1), k4 = sqrt6(1 - k_ * k_), K5 = ellipticF(halfPi3, k4 * k4), f = -1, psi = log6(tan2(pi4 / 4 + abs3(phi2) / 2)), r2 = exp4(f * psi) / sqrt6(k_), at = guyouComplexAtan(r2 * cos3(f * lambda), r2 * sin3(f * lambda)), t = ellipticFi(at[0], at[1], k4 * k4);
  return [-t[1], (phi2 >= 0 ? 1 : -1) * (0.5 * K5 - t[0])];
}
function guyouComplexAtan(x7, y7) {
  var x22 = x7 * x7, y_1 = y7 + 1, t = 1 - x22 - y7 * y7;
  return [
    0.5 * ((x7 >= 0 ? halfPi3 : -halfPi3) - atan23(t, 2 * x7)),
    -0.25 * log6(t * t + 4 * x22) + 0.5 * log6(y_1 * y_1 + x22)
  ];
}
function guyouComplexDivide(a4, b3) {
  var denominator = b3[0] * b3[0] + b3[1] * b3[1];
  return [
    (a4[0] * b3[0] + a4[1] * b3[1]) / denominator,
    (a4[1] * b3[0] - a4[0] * b3[1]) / denominator
  ];
}
var init_guyou = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/guyou.js"() {
    init_src21();
    init_elliptic();
    init_math5();
    init_square3();
    guyouRaw.invert = function(x7, y7) {
      var k_ = (sqrt22 - 1) / (sqrt22 + 1), k4 = sqrt6(1 - k_ * k_), K5 = ellipticF(halfPi3, k4 * k4), f = -1, j = ellipticJi(0.5 * K5 - y7, -x7, k4 * k4), tn = guyouComplexDivide(j[0], j[1]), lambda = atan23(tn[1], tn[0]) / f;
      return [
        lambda,
        2 * atan3(exp4(0.5 / f * log6(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi3
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/hammerRetroazimuthal.js
var init_hammerRetroazimuthal = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/hammerRetroazimuthal.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/healpix.js
var K3, healpixParallel, healpixLambert;
var init_healpix = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/healpix.js"() {
    init_src9();
    init_src21();
    init_collignon();
    init_cylindricalEqualArea2();
    init_math5();
    K3 = 3;
    healpixParallel = asin3(1 - 1 / K3) * degrees6;
    healpixLambert = cylindricalEqualAreaRaw2(0);
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/hill.js
var init_hill = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/hill.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/sinuMollweide.js
function sinuMollweideRaw(lambda, phi2) {
  return phi2 > -sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi2), lambda[1] += sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi2);
}
var sinuMollweidePhi, sinuMollweideY;
var init_sinuMollweide = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/sinuMollweide.js"() {
    init_src21();
    init_mollweide();
    init_sinusoidal();
    sinuMollweidePhi = 0.7109889596207567;
    sinuMollweideY = 0.0528035274542;
    sinuMollweideRaw.invert = function(x7, y7) {
      return y7 > -sinuMollweidePhi ? mollweideRaw.invert(x7, y7 - sinuMollweideY) : sinusoidalRaw.invert(x7, y7);
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/homolosine.js
function homolosineRaw(lambda, phi2) {
  return abs3(phi2) > sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi2), lambda[1] -= phi2 > 0 ? sinuMollweideY : -sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi2);
}
var init_homolosine = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/homolosine.js"() {
    init_src21();
    init_math5();
    init_mollweide();
    init_sinusoidal();
    init_sinuMollweide();
    homolosineRaw.invert = function(x7, y7) {
      return abs3(y7) > sinuMollweidePhi ? mollweideRaw.invert(x7, y7 + (y7 > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidalRaw.invert(x7, y7);
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/hufnagel.js
var init_hufnagel = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/hufnagel.js"() {
    init_src21();
    init_math5();
    init_newton();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/integrate.js
var init_integrate = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/integrate.js"() {
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/hyperelliptical.js
var init_hyperelliptical = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/hyperelliptical.js"() {
    init_src21();
    init_math5();
    init_integrate();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/index.js
var init_interrupted = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/index.js"() {
    init_src9();
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/boggs.js
var init_boggs2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/boggs.js"() {
    init_boggs();
    init_interrupted();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/homolosine.js
var init_homolosine2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/homolosine.js"() {
    init_homolosine();
    init_interrupted();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/mollweide.js
var init_mollweide2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/mollweide.js"() {
    init_mollweide();
    init_interrupted();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js
var init_mollweideHemispheres = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js"() {
    init_mollweide();
    init_interrupted();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js
var init_sinuMollweide2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js"() {
    init_sinuMollweide();
    init_interrupted();
    init_newton();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/sinusoidal.js
var init_sinusoidal2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/sinusoidal.js"() {
    init_sinusoidal();
    init_interrupted();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/kavrayskiy7.js
function kavrayskiy7Raw(lambda, phi2) {
  return [3 / tau4 * lambda * sqrt6(pi4 * pi4 / 3 - phi2 * phi2), phi2];
}
var init_kavrayskiy7 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/kavrayskiy7.js"() {
    init_src21();
    init_math5();
    kavrayskiy7Raw.invert = function(x7, y7) {
      return [tau4 / 3 * x7 / sqrt6(pi4 * pi4 / 3 - y7 * y7), y7];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/lagrange.js
var init_lagrange = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/lagrange.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/larrivee.js
function larriveeRaw(lambda, phi2) {
  return [
    lambda * (1 + sqrt6(cos3(phi2))) / 2,
    phi2 / (cos3(phi2 / 2) * cos3(lambda / 6))
  ];
}
var pi_sqrt2;
var init_larrivee = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/larrivee.js"() {
    init_src21();
    init_math5();
    pi_sqrt2 = pi4 / sqrt22;
    larriveeRaw.invert = function(x7, y7) {
      var x07 = abs3(x7), y07 = abs3(y7), lambda = epsilon5, phi2 = halfPi3;
      if (y07 < pi_sqrt2)
        phi2 *= y07 / pi_sqrt2;
      else
        lambda += 6 * acos3(pi_sqrt2 / y07);
      for (var i = 0; i < 25; i++) {
        var sinPhi = sin3(phi2), sqrtcosPhi = sqrt6(cos3(phi2)), sinPhi_2 = sin3(phi2 / 2), cosPhi_2 = cos3(phi2 / 2), sinLambda_6 = sin3(lambda / 6), cosLambda_6 = cos3(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x07, f1 = phi2 / (cosPhi_2 * cosLambda_6) - y07, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi2 * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = phi2 / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
        phi2 -= dPhi;
        lambda -= dLambda;
        if (abs3(dPhi) < epsilon5 && abs3(dLambda) < epsilon5)
          break;
      }
      return [x7 < 0 ? -lambda : lambda, y7 < 0 ? -phi2 : phi2];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/laskowski.js
function laskowskiRaw(lambda, phi2) {
  var lambda22 = lambda * lambda, phi22 = phi2 * phi2;
  return [
    lambda * (0.975534 + phi22 * (-0.119161 + lambda22 * -0.0143059 + phi22 * -0.0547009)),
    phi2 * (1.00384 + lambda22 * (0.0802894 + phi22 * -0.02855 + lambda22 * 199025e-9) + phi22 * (0.0998909 + phi22 * -0.0491032))
  ];
}
var init_laskowski = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/laskowski.js"() {
    init_src21();
    init_math5();
    laskowskiRaw.invert = function(x7, y7) {
      var lambda = sign3(x7) * pi4, phi2 = y7 / 2, i = 50;
      do {
        var lambda22 = lambda * lambda, phi22 = phi2 * phi2, lambdaPhi = lambda * phi2, fx = lambda * (0.975534 + phi22 * (-0.119161 + lambda22 * -0.0143059 + phi22 * -0.0547009)) - x7, fy = phi2 * (1.00384 + lambda22 * (0.0802894 + phi22 * -0.02855 + lambda22 * 199025e-9) + phi22 * (0.0998909 + phi22 * -0.0491032)) - y7, deltaxDeltaLambda = 0.975534 - phi22 * (0.119161 + 3 * lambda22 * 0.0143059 + phi22 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi22 + 2 * 0.0143059 * lambda22), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 199025e-9 * lambda22 + 2 * -0.02855 * phi22), deltayDeltaPhi = 1.00384 + lambda22 * (0.0802894 + 199025e-9 * lambda22) + phi22 * (3 * (0.0998909 - 0.02855 * lambda22) - 5 * 0.0491032 * phi22), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
        lambda -= deltaLambda, phi2 -= deltaPhi;
      } while ((abs3(deltaLambda) > epsilon5 || abs3(deltaPhi) > epsilon5) && --i > 0);
      return i && [lambda, phi2];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/littrow.js
function littrowRaw(lambda, phi2) {
  return [
    sin3(lambda) / cos3(phi2),
    tan2(phi2) * cos3(lambda)
  ];
}
var init_littrow = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/littrow.js"() {
    init_src21();
    init_math5();
    littrowRaw.invert = function(x7, y7) {
      var x22 = x7 * x7, y22 = y7 * y7, y2_1 = y22 + 1, x2_y2_1 = x22 + y2_1, cosPhi = x7 ? sqrt1_2 * sqrt6((x2_y2_1 - sqrt6(x2_y2_1 * x2_y2_1 - 4 * x22)) / x22) : 1 / sqrt6(y2_1);
      return [
        asin3(x7 * cosPhi),
        sign3(y7) * acos3(cosPhi)
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/loximuthal.js
var init_loximuthal = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/loximuthal.js"() {
    init_parallel1();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/miller.js
function millerRaw(lambda, phi2) {
  return [lambda, 1.25 * log6(tan2(quarterPi2 + 0.4 * phi2))];
}
var init_miller = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/miller.js"() {
    init_src21();
    init_math5();
    millerRaw.invert = function(x7, y7) {
      return [x7, 2.5 * atan3(exp4(0.8 * y7)) - 0.625 * pi4];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/modifiedStereographic.js
var init_modifiedStereographic = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/modifiedStereographic.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js
function mtFlatPolarParabolicRaw(lambda, phi2) {
  var theta = asin3(7 * sin3(phi2) / (3 * sqrt62));
  return [
    sqrt62 * lambda * (2 * cos3(2 * theta / 3) - 1) / sqrt7,
    9 * sin3(theta / 3) / sqrt7
  ];
}
var sqrt62, sqrt7;
var init_mtFlatPolarParabolic = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js"() {
    init_src21();
    init_math5();
    sqrt62 = sqrt6(6);
    sqrt7 = sqrt6(7);
    mtFlatPolarParabolicRaw.invert = function(x7, y7) {
      var theta = 3 * asin3(y7 * sqrt7 / 9);
      return [
        x7 * sqrt7 / (sqrt62 * (2 * cos3(2 * theta / 3) - 1)),
        asin3(sin3(theta) * 3 * sqrt62 / 7)
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js
function mtFlatPolarQuarticRaw(lambda, phi2) {
  var k4 = (1 + sqrt1_2) * sin3(phi2), theta = phi2;
  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (sin3(theta / 2) + sin3(theta) - k4) / (0.5 * cos3(theta / 2) + cos3(theta));
    if (abs3(delta) < epsilon5)
      break;
  }
  return [
    lambda * (1 + 2 * cos3(theta) / cos3(theta / 2)) / (3 * sqrt22),
    2 * sqrt6(3) * sin3(theta / 2) / sqrt6(2 + sqrt22)
  ];
}
var init_mtFlatPolarQuartic = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js"() {
    init_src21();
    init_math5();
    mtFlatPolarQuarticRaw.invert = function(x7, y7) {
      var sinTheta_2 = y7 * sqrt6(2 + sqrt22) / (2 * sqrt6(3)), theta = 2 * asin3(sinTheta_2);
      return [
        3 * sqrt22 * x7 / (1 + 2 * cos3(theta) / cos3(theta / 2)),
        asin3((sinTheta_2 + sin3(theta)) / (1 + sqrt1_2))
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js
function mtFlatPolarSinusoidalRaw(lambda, phi2) {
  var A6 = sqrt6(6 / (4 + pi4)), k4 = (1 + pi4 / 4) * sin3(phi2), theta = phi2 / 2;
  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (theta / 2 + sin3(theta) - k4) / (0.5 + cos3(theta));
    if (abs3(delta) < epsilon5)
      break;
  }
  return [
    A6 * (0.5 + cos3(theta)) * lambda / 1.5,
    A6 * theta
  ];
}
var init_mtFlatPolarSinusoidal = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js"() {
    init_src21();
    init_math5();
    mtFlatPolarSinusoidalRaw.invert = function(x7, y7) {
      var A6 = sqrt6(6 / (4 + pi4)), theta = y7 / A6;
      if (abs3(abs3(theta) - halfPi3) < epsilon5)
        theta = theta < 0 ? -halfPi3 : halfPi3;
      return [
        1.5 * x7 / (A6 * (0.5 + cos3(theta))),
        asin3((theta / 2 + sin3(theta)) / (1 + pi4 / 4))
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/naturalEarth2.js
function naturalEarth2Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22, phi6 = phi22 * phi4;
  return [
    lambda * (0.84719 - 0.13063 * phi22 + phi6 * phi6 * (-0.04515 + 0.05494 * phi22 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi2 * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi22 - 396e-5 * phi4))
  ];
}
var init_naturalEarth2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/naturalEarth2.js"() {
    init_src21();
    init_math5();
    naturalEarth2Raw.invert = function(x7, y7) {
      var phi2 = y7, i = 25, delta, phi22, phi4, phi6;
      do {
        phi22 = phi2 * phi2;
        phi4 = phi22 * phi22;
        phi2 -= delta = (phi2 * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi22 - 396e-5 * phi4)) - y7) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi22 + 13 * -396e-5 * phi4));
      } while (abs3(delta) > epsilon25 && --i > 0);
      phi22 = phi2 * phi2;
      phi4 = phi22 * phi22;
      phi6 = phi22 * phi4;
      return [
        x7 / (0.84719 - 0.13063 * phi22 + phi6 * phi6 * (-0.04515 + 0.05494 * phi22 - 0.02326 * phi4 + 331e-5 * phi6)),
        phi2
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/nellHammer.js
function nellHammerRaw(lambda, phi2) {
  return [
    lambda * (1 + cos3(phi2)) / 2,
    2 * (phi2 - tan2(phi2 / 2))
  ];
}
var init_nellHammer = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/nellHammer.js"() {
    init_src21();
    init_math5();
    nellHammerRaw.invert = function(x7, y7) {
      var p = y7 / 2;
      for (var i = 0, delta = Infinity; i < 10 && abs3(delta) > epsilon5; ++i) {
        var c2 = cos3(y7 / 2);
        y7 -= delta = (y7 - tan2(y7 / 2) - p) / (1 - 0.5 / (c2 * c2));
      }
      return [
        2 * x7 / (1 + cos3(y7)),
        y7
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/quarticAuthalic.js
var init_quarticAuthalic = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/interrupted/quarticAuthalic.js"() {
    init_hammer();
    init_interrupted();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/nicolosi.js
function nicolosiRaw(lambda, phi2) {
  var sinPhi = sin3(phi2), q = cos3(phi2), s3 = sign3(lambda);
  if (lambda === 0 || abs3(phi2) === halfPi3)
    return [0, phi2];
  else if (phi2 === 0)
    return [lambda, 0];
  else if (abs3(lambda) === halfPi3)
    return [lambda * q, halfPi3 * sinPhi];
  var b3 = pi4 / (2 * lambda) - 2 * lambda / pi4, c2 = 2 * phi2 / pi4, d = (1 - c2 * c2) / (sinPhi - c2);
  var b22 = b3 * b3, d2 = d * d, b2d2 = 1 + b22 / d2, d2b2 = 1 + d2 / b22;
  var M2 = (b3 * sinPhi / d - b3 / 2) / b2d2, N = (d2 * sinPhi / b22 + d / 2) / d2b2, m2 = M2 * M2 + q * q / b2d2, n = N * N - (d2 * sinPhi * sinPhi / b22 + d * sinPhi - 1) / d2b2;
  return [
    halfPi3 * (M2 + sqrt6(m2) * s3),
    halfPi3 * (N + sqrt6(n < 0 ? 0 : n) * sign3(-phi2 * b3) * s3)
  ];
}
var init_nicolosi = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/nicolosi.js"() {
    init_src21();
    init_math5();
    init_newton();
    nicolosiRaw.invert = function(x7, y7) {
      x7 /= halfPi3;
      y7 /= halfPi3;
      var x22 = x7 * x7, y22 = y7 * y7, x2y2 = x22 + y22, pi22 = pi4 * pi4;
      return [
        x7 ? (x2y2 - 1 + sqrt6((1 - x2y2) * (1 - x2y2) + 4 * x22)) / (2 * x7) * halfPi3 : 0,
        solve(function(phi2) {
          return x2y2 * (pi4 * sin3(phi2) - 2 * phi2) * pi4 + 4 * phi2 * phi2 * (y7 - sin3(phi2)) + 2 * pi4 * phi2 - pi22 * y7;
        }, 0)
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/patterson.js
function pattersonRaw(lambda, phi2) {
  var phi22 = phi2 * phi2;
  return [
    lambda,
    phi2 * (pattersonK1 + phi22 * phi22 * (pattersonK2 + phi22 * (pattersonK3 + pattersonK4 * phi22)))
  ];
}
var pattersonK1, pattersonK2, pattersonK3, pattersonK4, pattersonC1, pattersonC2, pattersonC3, pattersonC4, pattersonYmax;
var init_patterson = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/patterson.js"() {
    init_src21();
    init_math5();
    pattersonK1 = 1.0148;
    pattersonK2 = 0.23185;
    pattersonK3 = -0.14499;
    pattersonK4 = 0.02406;
    pattersonC1 = pattersonK1;
    pattersonC2 = 5 * pattersonK2;
    pattersonC3 = 7 * pattersonK3;
    pattersonC4 = 9 * pattersonK4;
    pattersonYmax = 1.790857183;
    pattersonRaw.invert = function(x7, y7) {
      if (y7 > pattersonYmax)
        y7 = pattersonYmax;
      else if (y7 < -pattersonYmax)
        y7 = -pattersonYmax;
      var yc = y7, delta;
      do {
        var y22 = yc * yc;
        yc -= delta = (yc * (pattersonK1 + y22 * y22 * (pattersonK2 + y22 * (pattersonK3 + pattersonK4 * y22))) - y7) / (pattersonC1 + y22 * y22 * (pattersonC2 + y22 * (pattersonC3 + pattersonC4 * y22)));
      } while (abs3(delta) > epsilon5);
      return [x7, yc];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyconic.js
function polyconicRaw(lambda, phi2) {
  if (abs3(phi2) < epsilon5)
    return [lambda, 0];
  var tanPhi = tan2(phi2), k4 = lambda * sin3(phi2);
  return [
    sin3(k4) / tanPhi,
    phi2 + (1 - cos3(k4)) / tanPhi
  ];
}
var init_polyconic = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyconic.js"() {
    init_src21();
    init_math5();
    polyconicRaw.invert = function(x7, y7) {
      if (abs3(y7) < epsilon5)
        return [x7, 0];
      var k4 = x7 * x7 + y7 * y7, phi2 = y7 * 0.5, i = 10, delta;
      do {
        var tanPhi = tan2(phi2), secPhi = 1 / cos3(phi2), j = k4 - 2 * y7 * phi2 + phi2 * phi2;
        phi2 -= delta = (tanPhi * j + 2 * (phi2 - y7)) / (2 + j * secPhi * secPhi + 2 * (phi2 - y7) * tanPhi);
      } while (abs3(delta) > epsilon5 && --i > 0);
      tanPhi = tan2(phi2);
      return [
        (abs3(y7) < abs3(phi2 + 1 / tanPhi) ? asin3(x7 * tanPhi) : sign3(y7) * sign3(x7) * (acos3(abs3(x7 * tanPhi)) + halfPi3)) / sin3(phi2),
        phi2
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/matrix.js
var init_matrix = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/matrix.js"() {
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/index.js
var init_polyhedral = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/index.js"() {
    init_src21();
    init_math5();
    init_matrix();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/octahedron.js
var octahedron, octahedron_default;
var init_octahedron = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/octahedron.js"() {
    octahedron = [
      [0, 90],
      [-90, 0],
      [0, 0],
      [90, 0],
      [180, 0],
      [0, -90]
    ];
    octahedron_default = [
      [0, 2, 1],
      [0, 3, 2],
      [5, 1, 2],
      [5, 2, 3],
      [0, 1, 4],
      [0, 4, 3],
      [5, 4, 1],
      [5, 3, 4]
    ].map(function(face) {
      return face.map(function(i) {
        return octahedron[i];
      });
    });
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/butterfly.js
var init_butterfly = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/butterfly.js"() {
    init_src21();
    init_math5();
    init_polyhedral();
    init_octahedron();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/collignon.js
function collignonK(a4, b3) {
  var p = collignonRaw(a4, b3);
  return [p[0] * kx2, p[1]];
}
var kx2;
var init_collignon2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/collignon.js"() {
    init_src21();
    init_collignon();
    init_math5();
    init_polyhedral();
    init_octahedron();
    kx2 = 2 / sqrt6(3);
    collignonK.invert = function(x7, y7) {
      return collignonRaw.invert(x7 / kx2, y7);
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/waterman.js
var init_waterman = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/polyhedral/waterman.js"() {
    init_src21();
    init_math5();
    init_polyhedral();
    init_octahedron();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/noop.js
var init_noop3 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/noop.js"() {
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/project/clockwise.js
var init_clockwise = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/project/clockwise.js"() {
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/project/contains.js
var init_contains2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/project/contains.js"() {
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/project/index.js
var init_project = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/project/index.js"() {
    init_src21();
    init_noop3();
    init_clockwise();
    init_contains2();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/quincuncial/index.js
var init_quincuncial = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/quincuncial/index.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/quincuncial/gringorten.js
var init_gringorten2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/quincuncial/gringorten.js"() {
    init_gringorten();
    init_quincuncial();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/quincuncial/peirce.js
var init_peirce = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/quincuncial/peirce.js"() {
    init_guyou();
    init_quincuncial();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/quantize.js
var init_quantize6 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/quantize.js"() {
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/rectangularPolyconic.js
var init_rectangularPolyconic = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/rectangularPolyconic.js"() {
    init_math5();
    init_parallel1();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/robinson.js
function robinsonRaw(lambda, phi2) {
  var i = min5(18, abs3(phi2) * 36 / pi4), i0 = floor2(i), di = i - i0, ax = (k4 = K4[i0])[0], ay = k4[1], bx = (k4 = K4[++i0])[0], by = k4[1], cx = (k4 = K4[min5(19, ++i0)])[0], cy = k4[1], k4;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    (phi2 > 0 ? halfPi3 : -halfPi3) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}
var K4;
var init_robinson = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/robinson.js"() {
    init_src21();
    init_math5();
    K4 = [
      [0.9986, -0.062],
      [1, 0],
      [0.9986, 0.062],
      [0.9954, 0.124],
      [0.99, 0.186],
      [0.9822, 0.248],
      [0.973, 0.31],
      [0.96, 0.372],
      [0.9427, 0.434],
      [0.9216, 0.4958],
      [0.8962, 0.5571],
      [0.8679, 0.6176],
      [0.835, 0.6769],
      [0.7986, 0.7346],
      [0.7597, 0.7903],
      [0.7186, 0.8435],
      [0.6732, 0.8936],
      [0.6213, 0.9394],
      [0.5722, 0.9761],
      [0.5322, 1]
    ];
    K4.forEach(function(d) {
      d[1] *= 1.0144;
    });
    robinsonRaw.invert = function(x7, y7) {
      var yy = y7 / halfPi3, phi2 = yy * 90, i = min5(18, abs3(phi2 / 5)), i0 = max5(0, floor2(i));
      do {
        var ay = K4[i0][1], by = K4[i0 + 1][1], cy = K4[min5(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (abs3(yy) - by) / u, c2 = v / u, di = t * (1 - c2 * t * (1 - 2 * c2 * t));
        if (di >= 0 || i0 === 1) {
          phi2 = (y7 >= 0 ? 5 : -5) * (di + i);
          var j = 50, delta;
          do {
            i = min5(18, abs3(phi2) / 5);
            i0 = floor2(i);
            di = i - i0;
            ay = K4[i0][1];
            by = K4[i0 + 1][1];
            cy = K4[min5(19, i0 + 2)][1];
            phi2 -= (delta = (y7 >= 0 ? halfPi3 : -halfPi3) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y7) * degrees6;
          } while (abs3(delta) > epsilon25 && --j > 0);
          break;
        }
      } while (--i0 >= 0);
      var ax = K4[i0][0], bx = K4[i0 + 1][0], cx = K4[min5(19, i0 + 2)][0];
      return [
        x7 / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
        phi2 * radians4
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/satellite.js
var init_satellite = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/satellite.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/stitch.js
var epsilon6, x06, x0e, x12, x1e, y06, y0e, y12, y1e;
var init_stitch2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/stitch.js"() {
    epsilon6 = 1e-4;
    x06 = -180;
    x0e = x06 + epsilon6;
    x12 = 180;
    x1e = x12 - epsilon6;
    y06 = -90;
    y0e = y06 + epsilon6;
    y12 = 90;
    y1e = y12 - epsilon6;
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/times.js
function timesRaw(lambda, phi2) {
  var t = tan2(phi2 / 2), s3 = sin3(quarterPi2 * t);
  return [
    lambda * (0.74482 - 0.34588 * s3 * s3),
    1.70711 * t
  ];
}
var init_times2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/times.js"() {
    init_src21();
    init_math5();
    timesRaw.invert = function(x7, y7) {
      var t = y7 / 1.70711, s3 = sin3(quarterPi2 * t);
      return [
        x7 / (0.74482 - 0.34588 * s3 * s3),
        2 * atan3(t)
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/twoPoint.js
var init_twoPoint = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/twoPoint.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/twoPointAzimuthal.js
var init_twoPointAzimuthal = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/twoPointAzimuthal.js"() {
    init_src21();
    init_math5();
    init_twoPoint();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/twoPointEquidistant.js
var init_twoPointEquidistant = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/twoPointEquidistant.js"() {
    init_src21();
    init_math5();
    init_twoPoint();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/vanDerGrinten.js
function vanDerGrintenRaw(lambda, phi2) {
  if (abs3(phi2) < epsilon5)
    return [lambda, 0];
  var sinTheta = abs3(phi2 / halfPi3), theta = asin3(sinTheta);
  if (abs3(lambda) < epsilon5 || abs3(abs3(phi2) - halfPi3) < epsilon5)
    return [0, sign3(phi2) * pi4 * tan2(theta / 2)];
  var cosTheta = cos3(theta), A6 = abs3(pi4 / lambda - lambda / pi4) / 2, A23 = A6 * A6, G = cosTheta / (sinTheta + cosTheta - 1), P = G * (2 / sinTheta - 1), P2 = P * P, P2_A2 = P2 + A23, G_P2 = G - P2, Q = A23 + G;
  return [
    sign3(lambda) * pi4 * (A6 * G_P2 + sqrt6(A23 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2,
    sign3(phi2) * pi4 * (P * Q - A6 * sqrt6((A23 + 1) * P2_A2 - Q * Q)) / P2_A2
  ];
}
var init_vanDerGrinten = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/vanDerGrinten.js"() {
    init_src21();
    init_math5();
    vanDerGrintenRaw.invert = function(x7, y7) {
      if (abs3(y7) < epsilon5)
        return [x7, 0];
      if (abs3(x7) < epsilon5)
        return [0, halfPi3 * sin3(2 * atan3(y7 / pi4))];
      var x22 = (x7 /= pi4) * x7, y22 = (y7 /= pi4) * y7, x2_y2 = x22 + y22, z = x2_y2 * x2_y2, c1 = -abs3(y7) * (1 + x2_y2), c2 = c1 - 2 * y22 + x22, c3 = -2 * c1 + 1 + 2 * y22 + z, d = y22 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * sqrt6(-a1 / 3), theta1 = acos3(3 * d / (a1 * m1)) / 3;
      return [
        pi4 * (x2_y2 - 1 + sqrt6(1 + 2 * (x22 - y22) + z)) / (2 * x7),
        sign3(y7) * pi4 * (-m1 * cos3(theta1 + pi4 / 3) - c2 / (3 * c3))
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/vanDerGrinten2.js
function vanDerGrinten2Raw(lambda, phi2) {
  if (abs3(phi2) < epsilon5)
    return [lambda, 0];
  var sinTheta = abs3(phi2 / halfPi3), theta = asin3(sinTheta);
  if (abs3(lambda) < epsilon5 || abs3(abs3(phi2) - halfPi3) < epsilon5)
    return [0, sign3(phi2) * pi4 * tan2(theta / 2)];
  var cosTheta = cos3(theta), A6 = abs3(pi4 / lambda - lambda / pi4) / 2, A23 = A6 * A6, x13 = cosTheta * (sqrt6(1 + A23) - A6 * cosTheta) / (1 + A23 * sinTheta * sinTheta);
  return [
    sign3(lambda) * pi4 * x13,
    sign3(phi2) * pi4 * sqrt6(1 - x13 * (2 * A6 + x13))
  ];
}
var init_vanDerGrinten2 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/vanDerGrinten2.js"() {
    init_src21();
    init_math5();
    vanDerGrinten2Raw.invert = function(x7, y7) {
      if (!x7)
        return [0, halfPi3 * sin3(2 * atan3(y7 / pi4))];
      var x13 = abs3(x7 / pi4), A6 = (1 - x13 * x13 - (y7 /= pi4) * y7) / (2 * x13), A23 = A6 * A6, B4 = sqrt6(A23 + 1);
      return [
        sign3(x7) * pi4 * (B4 - A6),
        sign3(y7) * halfPi3 * sin3(2 * atan23(sqrt6((1 - 2 * A6 * x13) * (A6 + B4) - x13), sqrt6(B4 + A6 + x13)))
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/vanDerGrinten3.js
function vanDerGrinten3Raw(lambda, phi2) {
  if (abs3(phi2) < epsilon5)
    return [lambda, 0];
  var sinTheta = phi2 / halfPi3, theta = asin3(sinTheta);
  if (abs3(lambda) < epsilon5 || abs3(abs3(phi2) - halfPi3) < epsilon5)
    return [0, pi4 * tan2(theta / 2)];
  var A6 = (pi4 / lambda - lambda / pi4) / 2, y13 = sinTheta / (1 + cos3(theta));
  return [
    pi4 * (sign3(lambda) * sqrt6(A6 * A6 + 1 - y13 * y13) - A6),
    pi4 * y13
  ];
}
var init_vanDerGrinten3 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/vanDerGrinten3.js"() {
    init_src21();
    init_math5();
    vanDerGrinten3Raw.invert = function(x7, y7) {
      if (!y7)
        return [x7, 0];
      var y13 = y7 / pi4, A6 = (pi4 * pi4 * (1 - y13 * y13) - x7 * x7) / (2 * pi4 * x7);
      return [
        x7 ? pi4 * (sign3(x7) * sqrt6(A6 * A6 + 1) - A6) : 0,
        halfPi3 * sin3(2 * atan3(y13))
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/vanDerGrinten4.js
function vanDerGrinten4Raw(lambda, phi2) {
  if (!phi2)
    return [lambda, 0];
  var phi03 = abs3(phi2);
  if (!lambda || phi03 === halfPi3)
    return [0, phi2];
  var B4 = phi03 / halfPi3, B22 = B4 * B4, C5 = (8 * B4 - B22 * (B22 + 2) - 5) / (2 * B22 * (B4 - 1)), C22 = C5 * C5, BC = B4 * C5, B_C2 = B22 + C22 + 2 * BC, B_3C = B4 + 3 * C5, lambda03 = lambda / halfPi3, lambda12 = lambda03 + 1 / lambda03, D3 = sign3(abs3(lambda) - halfPi3) * sqrt6(lambda12 * lambda12 - 4), D22 = D3 * D3, F = B_C2 * (B22 + C22 * D22 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C22) + 12 * BC * C22 + 4 * C22 * C22), x13 = (D3 * (B_C2 + C22 - 1) + 2 * sqrt6(F)) / (4 * B_C2 + D22);
  return [
    sign3(lambda) * halfPi3 * x13,
    sign3(phi2) * halfPi3 * sqrt6(1 + D3 * abs3(x13) - x13 * x13)
  ];
}
var init_vanDerGrinten4 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/vanDerGrinten4.js"() {
    init_src21();
    init_math5();
    vanDerGrinten4Raw.invert = function(x7, y7) {
      var delta;
      if (!x7 || !y7)
        return [x7, y7];
      var sy = sign3(y7);
      y7 = abs3(y7) / pi4;
      var x13 = sign3(x7) * x7 / halfPi3, D3 = (x13 * x13 - 1 + 4 * y7 * y7) / abs3(x13), D22 = D3 * D3, B4 = y7 * (2 - (y7 > 0.5 ? min5(y7, abs3(x7)) : 0)), r2 = x7 * x7 + y7 * y7, i = 50;
      do {
        var B22 = B4 * B4, C5 = (8 * B4 - B22 * (B22 + 2) - 5) / (2 * B22 * (B4 - 1)), C_ = (3 * B4 - B22 * B4 - 10) / (2 * B22 * B4), C22 = C5 * C5, BC = B4 * C5, B_C = B4 + C5, B_C2 = B_C * B_C, B_3C = B4 + 3 * C5, F = B_C2 * (B22 + C22 * D22 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C22) + C22 * (12 * BC + 4 * C22)), F_ = -2 * B_C * (4 * BC * C22 + (1 - 4 * B22 + 3 * B22 * B22) * (1 + C_) + C22 * (-6 + 14 * B22 - D22 + (-8 + 8 * B22 - 2 * D22) * C_) + BC * (-8 + 12 * B22 + (-10 + 10 * B22 - D22) * C_)), sqrtF = sqrt6(F), f = D3 * (B_C2 + C22 - 1) + 2 * sqrtF - x13 * (4 * B_C2 + D22), f_ = D3 * (2 * C5 * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D3 * (-1 + C22 + B_C2) + 2 * sqrtF) * (1 + C_) / (D22 + 4 * B_C2);
        B4 -= delta = f / f_;
      } while (delta * r2 * r2 > epsilon5 && --i > 0);
      return [
        sign3(x7) * (sqrt6(D3 * D3 + 4) + D3) * pi4 / 4,
        sy * halfPi3 * B4
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/wagner.js
var init_wagner = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/wagner.js"() {
    init_src21();
    init_math5();
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/wagner4.js
var A5, B3, wagner4Raw;
var init_wagner4 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/wagner4.js"() {
    init_src21();
    init_math5();
    init_mollweide();
    A5 = 4 * pi4 + 3 * sqrt6(3);
    B3 = 2 * sqrt6(2 * pi4 * sqrt6(3) / A5);
    wagner4Raw = mollweideBromleyRaw(B3 * sqrt6(3) / pi4, B3, A5 / 6);
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/wagner6.js
function wagner6Raw(lambda, phi2) {
  return [lambda * sqrt6(1 - 3 * phi2 * phi2 / (pi4 * pi4)), phi2];
}
var init_wagner6 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/wagner6.js"() {
    init_src21();
    init_math5();
    wagner6Raw.invert = function(x7, y7) {
      return [x7 / sqrt6(1 - 3 * y7 * y7 / (pi4 * pi4)), y7];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/wiechel.js
function wiechelRaw(lambda, phi2) {
  var cosPhi = cos3(phi2), sinPhi = cos3(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos3(lambda = atan23(sin3(lambda) * cosPhi, -sin3(phi2))), sinLambda = sin3(lambda);
  cosPhi = sqrt6(1 - sinPhi * sinPhi);
  return [
    sinLambda * cosPhi - cosLambda * sin1_Phi,
    -cosLambda * cosPhi - sinLambda * sin1_Phi
  ];
}
var init_wiechel = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/wiechel.js"() {
    init_src21();
    init_math5();
    wiechelRaw.invert = function(x7, y7) {
      var w5 = (x7 * x7 + y7 * y7) / -2, k4 = sqrt6(-w5 * (2 + w5)), b3 = y7 * w5 + x7 * k4, a4 = x7 * w5 - y7 * k4, D3 = sqrt6(a4 * a4 + b3 * b3);
      return [
        atan23(k4 * b3, D3 * (1 + w5)),
        D3 ? -asin3(k4 * a4 / D3) : 0
      ];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/winkel3.js
function winkel3Raw(lambda, phi2) {
  var coordinates = aitoffRaw(lambda, phi2);
  return [
    (coordinates[0] + lambda / halfPi3) / 2,
    (coordinates[1] + phi2) / 2
  ];
}
var init_winkel3 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/winkel3.js"() {
    init_src21();
    init_aitoff();
    init_math5();
    winkel3Raw.invert = function(x7, y7) {
      var lambda = x7, phi2 = y7, i = 25;
      do {
        var cosphi = cos3(phi2), sinphi = sin3(phi2), sin_2phi = sin3(2 * phi2), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin3(lambda), coslambda_2 = cos3(lambda / 2), sinlambda_2 = sin3(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C5 = 1 - cos2phi * coslambda_2 * coslambda_2, E3 = C5 ? acos3(cosphi * coslambda_2) * sqrt6(F = 1 / C5) : F = 0, F, fx = 0.5 * (2 * E3 * cosphi * sinlambda_2 + lambda / halfPi3) - x7, fy = 0.5 * (E3 * sinphi + phi2) - y7, dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E3 * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi3, dxdphi = F * (sinlambda * sin_2phi / 4 - E3 * sinphi * sinlambda_2), dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E3 * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F * (sin2phi * coslambda_2 + E3 * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
        lambda -= dlambda, phi2 -= dphi;
      } while ((abs3(dlambda) > epsilon5 || abs3(dphi) > epsilon5) && --i > 0);
      return [lambda, phi2];
    };
  }
});

// node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/index.js
var init_src22 = __esm({
  "node_modules/.pnpm/d3-geo-projection@3.0.0/node_modules/d3-geo-projection/src/index.js"() {
    init_airy();
    init_aitoff();
    init_armadillo();
    init_august();
    init_baker();
    init_berghaus();
    init_bertin();
    init_boggs();
    init_bonne();
    init_bottomley();
    init_bromley();
    init_chamberlin();
    init_collignon();
    init_craig();
    init_craster();
    init_cylindricalEqualArea2();
    init_cylindricalStereographic();
    init_eckert1();
    init_eckert2();
    init_eckert3();
    init_eckert4();
    init_eckert5();
    init_eckert6();
    init_eisenlohr();
    init_fahey();
    init_foucaut();
    init_foucautSinusoidal();
    init_gilbert();
    init_gingery();
    init_ginzburg4();
    init_ginzburg5();
    init_ginzburg6();
    init_ginzburg8();
    init_ginzburg9();
    init_gringorten();
    init_guyou();
    init_hammer();
    init_hammerRetroazimuthal();
    init_healpix();
    init_hill();
    init_homolosine();
    init_hufnagel();
    init_hyperelliptical();
    init_interrupted();
    init_boggs2();
    init_homolosine2();
    init_mollweide2();
    init_mollweideHemispheres();
    init_sinuMollweide2();
    init_sinusoidal2();
    init_kavrayskiy7();
    init_lagrange();
    init_larrivee();
    init_laskowski();
    init_littrow();
    init_loximuthal();
    init_miller();
    init_modifiedStereographic();
    init_mollweide();
    init_mtFlatPolarParabolic();
    init_mtFlatPolarQuartic();
    init_mtFlatPolarSinusoidal();
    init_naturalEarth2();
    init_nellHammer();
    init_quarticAuthalic();
    init_nicolosi();
    init_patterson();
    init_polyconic();
    init_polyhedral();
    init_butterfly();
    init_collignon2();
    init_waterman();
    init_project();
    init_gringorten2();
    init_peirce();
    init_quantize6();
    init_quincuncial();
    init_rectangularPolyconic();
    init_robinson();
    init_satellite();
    init_sinuMollweide();
    init_sinusoidal();
    init_stitch2();
    init_times2();
    init_twoPointAzimuthal();
    init_twoPointEquidistant();
    init_vanDerGrinten();
    init_vanDerGrinten2();
    init_vanDerGrinten3();
    init_vanDerGrinten4();
    init_wagner();
    init_wagner4();
    init_wagner6();
    init_wiechel();
    init_winkel3();
  }
});

// node_modules/.pnpm/vega-projection@1.4.5/node_modules/vega-projection/build/vega-projection.module.js
function create3(type4, constructor) {
  return function projection3() {
    const p = constructor();
    p.type = type4;
    p.path = path_default().projection(p);
    p.copy = p.copy || function() {
      const c2 = projection3();
      projectionProperties.forEach((prop) => {
        if (p[prop])
          c2[prop](p[prop]());
      });
      c2.path.pointRadius(p.path.pointRadius());
      return c2;
    };
    return p;
  };
}
function projection2(type4, proj) {
  if (!type4 || typeof type4 !== "string") {
    throw new Error("Projection type must be a name string.");
  }
  type4 = type4.toLowerCase();
  if (arguments.length > 1) {
    projections[type4] = create3(type4, proj);
    return this;
  } else {
    return projections[type4] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
var defaultPath, projectionProperties, projections;
var init_vega_projection_module = __esm({
  "node_modules/.pnpm/vega-projection@1.4.5/node_modules/vega-projection/build/vega-projection.module.js"() {
    init_src21();
    init_src22();
    defaultPath = path_default();
    projectionProperties = [
      "clipAngle",
      "clipExtent",
      "scale",
      "translate",
      "center",
      "rotate",
      "parallels",
      "precision",
      "reflectX",
      "reflectY",
      "coefficient",
      "distance",
      "fraction",
      "lobes",
      "parallel",
      "radius",
      "ratio",
      "spacing",
      "tilt"
    ];
    projections = {
      albers: albers_default,
      albersusa: albersUsa_default,
      azimuthalequalarea: azimuthalEqualArea_default,
      azimuthalequidistant: azimuthalEquidistant_default,
      conicconformal: conicConformal_default,
      conicequalarea: conicEqualArea_default,
      conicequidistant: conicEquidistant_default,
      equalEarth: equalEarth_default,
      equirectangular: equirectangular_default,
      gnomonic: gnomonic_default,
      identity: identity_default7,
      mercator: mercator_default,
      mollweide: mollweide_default,
      naturalEarth1: naturalEarth1_default,
      orthographic: orthographic_default,
      stereographic: stereographic_default,
      transversemercator: transverseMercator_default
    };
    for (const key3 in projections) {
      projection2(key3, projections[key3]);
    }
  }
});

// node_modules/.pnpm/vega-geo@4.3.8/node_modules/vega-geo/build/vega-geo.module.js
var vega_geo_module_exports = {};
__export(vega_geo_module_exports, {
  contour: () => Contour,
  geojson: () => GeoJSON,
  geopath: () => GeoPath,
  geopoint: () => GeoPoint,
  geoshape: () => GeoShape,
  graticule: () => Graticule,
  heatmap: () => Heatmap,
  isocontour: () => Isocontour,
  kde2d: () => KDE2D,
  projection: () => Projection
});
function noop3() {
}
function contours() {
  var dx = 1, dy = 1, smooth = smoothLinear;
  function contours2(values5, tz) {
    return tz.map((value4) => contour(values5, value4));
  }
  function contour(values5, value4) {
    var polygons = [], holes = [];
    isorings(values5, value4, (ring) => {
      smooth(ring, values5, value4);
      if (area2(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach((hole) => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value: value4,
      coordinates: polygons
    };
  }
  function isorings(values5, value4, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x7, y7, t07, t15, t23, t33;
    x7 = y7 = -1;
    t15 = values5[0] >= value4;
    cases[t15 << 1].forEach(stitch);
    while (++x7 < dx - 1) {
      t07 = t15, t15 = values5[x7 + 1] >= value4;
      cases[t07 | t15 << 1].forEach(stitch);
    }
    cases[t15 << 0].forEach(stitch);
    while (++y7 < dy - 1) {
      x7 = -1;
      t15 = values5[y7 * dx + dx] >= value4;
      t23 = values5[y7 * dx] >= value4;
      cases[t15 << 1 | t23 << 2].forEach(stitch);
      while (++x7 < dx - 1) {
        t07 = t15, t15 = values5[y7 * dx + dx + x7 + 1] >= value4;
        t33 = t23, t23 = values5[y7 * dx + x7 + 1] >= value4;
        cases[t07 | t15 << 1 | t23 << 2 | t33 << 3].forEach(stitch);
      }
      cases[t15 | t23 << 3].forEach(stitch);
    }
    x7 = -1;
    t23 = values5[y7 * dx] >= value4;
    cases[t23 << 2].forEach(stitch);
    while (++x7 < dx - 1) {
      t33 = t23, t23 = values5[y7 * dx + x7 + 1] >= value4;
      cases[t23 << 2 | t33 << 3].forEach(stitch);
    }
    cases[t23 << 3].forEach(stitch);
    function stitch(line5) {
      var start = [line5[0][0] + x7, line5[0][1] + y7], end = [line5[1][0] + x7, line5[1][1] + y7], startIndex = index8(start), endIndex = index8(end), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }
  function index8(point16) {
    return point16[0] * 2 + point16[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values5, value4) {
    ring.forEach((point16) => {
      var x7 = point16[0], y7 = point16[1], xt = x7 | 0, yt = y7 | 0, v0, v1 = values5[yt * dx + xt];
      if (x7 > 0 && x7 < dx && xt === x7) {
        v0 = values5[yt * dx + xt - 1];
        point16[0] = x7 + (value4 - v0) / (v1 - v0) - 0.5;
      }
      if (y7 > 0 && y7 < dy && yt === y7) {
        v0 = values5[(yt - 1) * dx + xt];
        point16[1] = y7 + (value4 - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours2.contour = contour;
  contours2.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
    if (!(_0 >= 0 && _1 >= 0))
      error("invalid size");
    return dx = _0, dy = _1, contours2;
  };
  contours2.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop3, contours2) : smooth === smoothLinear;
  };
  return contours2;
}
function area2(ring) {
  var i = 0, n = ring.length, area5 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n)
    area5 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area5;
}
function contains(ring, hole) {
  var i = -1, n = hole.length, c2;
  while (++i < n)
    if (c2 = ringContains(ring, hole[i]))
      return c2;
  return 0;
}
function ringContains(ring, point16) {
  var x7 = point16[0], y7 = point16[1], contains3 = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi7 = ring[i], xi = pi7[0], yi = pi7[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi7, pj, point16))
      return 0;
    if (yi > y7 !== yj > y7 && x7 < (xj - xi) * (y7 - yi) / (yj - yi) + xi)
      contains3 = -contains3;
  }
  return contains3;
}
function segmentContains(a4, b3, c2) {
  var i;
  return collinear(a4, b3, c2) && within(a4[i = +(a4[0] === b3[0])], c2[i], b3[i]);
}
function collinear(a4, b3, c2) {
  return (b3[0] - a4[0]) * (c2[1] - a4[1]) === (c2[0] - a4[0]) * (b3[1] - a4[1]);
}
function within(p, q, r2) {
  return p <= q && q <= r2 || r2 <= q && q <= p;
}
function quantize3(k4, nice7, zero10) {
  return function(values5) {
    var ex = extent(values5), start = zero10 ? Math.min(ex[0], 0) : ex[0], stop2 = ex[1], span3 = stop2 - start, step = nice7 ? tickStep2(start, stop2, k4) : span3 / (k4 + 1);
    return range_default(start + step, stop2, step);
  };
}
function Isocontour(params2) {
  Transform.call(this, null, params2);
}
function levels(values5, f, _) {
  const q = quantize3(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== "shared" ? q : q(values5.map((t) => max2(f(t).values)));
}
function transformPaths(paths, grid, datum2, _) {
  let s3 = _.scale || grid.scale, t = _.translate || grid.translate;
  if (isFunction(s3))
    s3 = s3(datum2, _);
  if (isFunction(t))
    t = t(datum2, _);
  if ((s3 === 1 || s3 == null) && !t)
    return;
  const sx = (isNumber(s3) ? s3 : s3[0]) || 1, sy = (isNumber(s3) ? s3 : s3[1]) || 1, tx = t && t[0] || 0, ty = t && t[1] || 0;
  paths.forEach(transform2(grid, sx, sy, tx, ty));
}
function transform2(grid, sx, sy, tx, ty) {
  const x13 = grid.x1 || 0, y13 = grid.y1 || 0, flip2 = sx * sy < 0;
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    if (flip2)
      coordinates.reverse();
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x13) * sx + tx;
    coordinates[1] = (coordinates[1] - y13) * sy + ty;
  }
  return function(geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}
function radius(bw, data3, f) {
  const v = bw >= 0 ? bw : estimateBandwidth(data3, f);
  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
}
function number7(_) {
  return isFunction(_) ? _ : constant(+_);
}
function density2D() {
  var x7 = (d) => d[0], y7 = (d) => d[1], weight = one, bandwidth2 = [-1, -1], dx = 960, dy = 500, k4 = 2;
  function density(data3, counts) {
    const rx = radius(bandwidth2[0], data3, x7) >> k4, ry = radius(bandwidth2[1], data3, y7) >> k4, ox = rx ? rx + 2 : 0, oy = ry ? ry + 2 : 0, n = 2 * ox + (dx >> k4), m2 = 2 * oy + (dy >> k4), values0 = new Float32Array(n * m2), values1 = new Float32Array(n * m2);
    let values5 = values0;
    data3.forEach((d) => {
      const xi = ox + (+x7(d) >> k4), yi = oy + (+y7(d) >> k4);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m2) {
        values0[xi + yi * n] += +weight(d);
      }
    });
    if (rx > 0 && ry > 0) {
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m2, values0, values1, rx);
      blurX(n, m2, values1, values0, rx);
      blurX(n, m2, values0, values1, rx);
      values5 = values1;
    } else if (ry > 0) {
      blurY(n, m2, values0, values1, ry);
      blurY(n, m2, values1, values0, ry);
      blurY(n, m2, values0, values1, ry);
      values5 = values1;
    }
    const s3 = counts ? Math.pow(2, -2 * k4) : 1 / sum2(values5);
    for (let i = 0, sz3 = n * m2; i < sz3; ++i)
      values5[i] *= s3;
    return {
      values: values5,
      scale: 1 << k4,
      width: n,
      height: m2,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k4),
      y2: oy + (dy >> k4)
    };
  }
  density.x = function(_) {
    return arguments.length ? (x7 = number7(_), density) : x7;
  };
  density.y = function(_) {
    return arguments.length ? (y7 = number7(_), density) : y7;
  };
  density.weight = function(_) {
    return arguments.length ? (weight = number7(_), density) : weight;
  };
  density.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = +_[0], _1 = +_[1];
    if (!(_0 >= 0 && _1 >= 0))
      error("invalid size");
    return dx = _0, dy = _1, density;
  };
  density.cellSize = function(_) {
    if (!arguments.length)
      return 1 << k4;
    if (!((_ = +_) >= 1))
      error("invalid cell size");
    k4 = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };
  density.bandwidth = function(_) {
    if (!arguments.length)
      return bandwidth2;
    _ = array(_);
    if (_.length === 1)
      _ = [+_[0], +_[0]];
    if (_.length !== 2)
      error("invalid bandwidth");
    return bandwidth2 = _, density;
  };
  return density;
}
function blurX(n, m2, source5, target2, r2) {
  const w5 = (r2 << 1) + 1;
  for (let j = 0; j < m2; ++j) {
    for (let i = 0, sr = 0; i < n + r2; ++i) {
      if (i < n) {
        sr += source5[i + j * n];
      }
      if (i >= r2) {
        if (i >= w5) {
          sr -= source5[i - w5 + j * n];
        }
        target2[i - r2 + j * n] = sr / Math.min(i + 1, n - 1 + w5 - i, w5);
      }
    }
  }
}
function blurY(n, m2, source5, target2, r2) {
  const w5 = (r2 << 1) + 1;
  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m2 + r2; ++j) {
      if (j < m2) {
        sr += source5[i + j * n];
      }
      if (j >= r2) {
        if (j >= w5) {
          sr -= source5[i + (j - w5) * n];
        }
        target2[i + (j - r2) * n] = sr / Math.min(j + 1, m2 - 1 + w5 - j, w5);
      }
    }
  }
}
function KDE2D(params2) {
  Transform.call(this, null, params2);
}
function params(obj, _) {
  PARAMS.forEach((param2) => _[param2] != null ? obj[param2](_[param2]) : 0);
  return obj;
}
function partition3(data3, groupby) {
  var groups4 = [], get8 = (f) => f(t), map11, i, n, t, k4, g;
  if (groupby == null) {
    groups4.push(data3);
  } else {
    for (map11 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k4 = groupby.map(get8);
      g = map11[k4];
      if (!g) {
        map11[k4] = g = [];
        g.dims = k4;
        groups4.push(g);
      }
      g.push(t);
    }
  }
  return groups4;
}
function Contour(params2) {
  Transform.call(this, null, params2);
}
function GeoJSON(params2) {
  Transform.call(this, null, params2);
}
function GeoPath(params2) {
  Transform.call(this, null, params2);
}
function initPath(path5, pointRadius) {
  const prev = path5.pointRadius();
  path5.context(null);
  if (pointRadius != null) {
    path5.pointRadius(pointRadius);
  }
  return prev;
}
function GeoPoint(params2) {
  Transform.call(this, null, params2);
}
function GeoShape(params2) {
  Transform.call(this, null, params2);
}
function shapeGenerator(path5, field4, pointRadius) {
  const shape3 = pointRadius == null ? (_) => path5(field4(_)) : (_) => {
    var prev = path5.pointRadius(), value4 = path5.pointRadius(pointRadius)(field4(_));
    path5.pointRadius(prev);
    return value4;
  };
  shape3.context = (_) => {
    path5.context(_);
    return shape3;
  };
  return shape3;
}
function Graticule(params2) {
  Transform.call(this, [], params2);
  this.generator = graticule();
}
function Heatmap(params2) {
  Transform.call(this, null, params2);
}
function color_(color7, _) {
  let f;
  if (isFunction(color7)) {
    f = (obj) => rgb2(color7(obj, _));
    f.dep = dependency(color7);
  } else {
    f = constant(rgb2(color7 || "#888"));
  }
  return f;
}
function opacity_(opacity2, _) {
  let f;
  if (isFunction(opacity2)) {
    f = (obj) => opacity2(obj, _);
    f.dep = dependency(opacity2);
  } else if (opacity2) {
    f = constant(opacity2);
  } else {
    f = (obj) => obj.$value / obj.$max || 0;
    f.dep = true;
  }
  return f;
}
function dependency(f) {
  if (!isFunction(f))
    return false;
  const set8 = toSet(accessorFields(f));
  return set8.$x || set8.$y || set8.$value || set8.$max;
}
function toCanvas(grid, obj, color7, opacity2) {
  const n = grid.width, m2 = grid.height, x13 = grid.x1 || 0, y13 = grid.y1 || 0, x22 = grid.x2 || n, y22 = grid.y2 || m2, val = grid.values, value4 = val ? (i) => val[i] : zero, can = domCanvas(x22 - x13, y22 - y13), ctx = can.getContext("2d"), img = ctx.getImageData(0, 0, x22 - x13, y22 - y13), pix = img.data;
  for (let j = y13, k4 = 0; j < y22; ++j) {
    obj.$y = j - y13;
    for (let i = x13, r2 = j * n; i < x22; ++i, k4 += 4) {
      obj.$x = i - x13;
      obj.$value = value4(i + r2);
      const v = color7(obj);
      pix[k4 + 0] = v.r;
      pix[k4 + 1] = v.g;
      pix[k4 + 2] = v.b;
      pix[k4 + 3] = ~~(255 * opacity2(obj));
    }
  }
  ctx.putImageData(img, 0, 0);
  return can;
}
function Projection(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
function fit2(proj, _) {
  const data3 = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data3) : _.size ? proj.fitSize(_.size, data3) : 0;
}
function create4(type4) {
  const constructor = projection2((type4 || "mercator").toLowerCase());
  if (!constructor)
    error("Unrecognized projection type: " + type4);
  return constructor();
}
function set4(proj, key3, value4) {
  if (isFunction(proj[key3]))
    proj[key3](value4);
}
function collectGeoJSON(data3) {
  data3 = array(data3);
  return data3.length === 1 ? data3[0] : {
    type: FeatureCollection,
    features: data3.reduce((a4, f) => a4.concat(featurize(f)), [])
  };
}
function featurize(f) {
  return f.type === FeatureCollection ? f.features : array(f).filter((d) => d != null).map((d) => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}
var cases, PARAMS, Feature, FeatureCollection, MultiPoint;
var init_vega_geo_module = __esm({
  "node_modules/.pnpm/vega-geo@4.3.8/node_modules/vega-geo/build/vega-geo.module.js"() {
    init_vega_dataflow_module();
    init_vega_util_module();
    init_src9();
    init_vega_statistics_module();
    init_vega_projection_module();
    init_src21();
    init_src17();
    init_vega_canvas_browser_module();
    cases = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
    Isocontour.Definition = {
      "type": "Isocontour",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "thresholds",
        "type": "number",
        "array": true
      }, {
        "name": "levels",
        "type": "number"
      }, {
        "name": "nice",
        "type": "boolean",
        "default": false
      }, {
        "name": "resolve",
        "type": "enum",
        "values": ["shared", "independent"],
        "default": "independent"
      }, {
        "name": "zero",
        "type": "boolean",
        "default": true
      }, {
        "name": "smooth",
        "type": "boolean",
        "default": true
      }, {
        "name": "scale",
        "type": "number",
        "expr": true
      }, {
        "name": "translate",
        "type": "number",
        "array": true,
        "expr": true
      }, {
        "name": "as",
        "type": "string",
        "null": true,
        "default": "contour"
      }]
    };
    inherits(Isocontour, Transform, {
      transform(_, pulse2) {
        if (this.value && !pulse2.changed() && !_.modified()) {
          return pulse2.StopPropagation;
        }
        var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source5 = pulse2.materialize(pulse2.SOURCE).source, field4 = _.field || identity, contour = contours().smooth(_.smooth !== false), tz = _.thresholds || levels(source5, field4, _), as = _.as === null ? null : _.as || "contour", values5 = [];
        source5.forEach((t) => {
          const grid = field4(t);
          const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values));
          transformPaths(paths, grid, t, _);
          paths.forEach((p) => {
            values5.push(rederive(t, ingest$1(as != null ? {
              [as]: p
            } : p)));
          });
        });
        if (this.value)
          out.rem = this.value;
        this.value = out.source = out.add = values5;
        return out;
      }
    });
    KDE2D.Definition = {
      "type": "KDE2D",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2,
        "required": true
      }, {
        "name": "x",
        "type": "field",
        "required": true
      }, {
        "name": "y",
        "type": "field",
        "required": true
      }, {
        "name": "weight",
        "type": "field"
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "cellSize",
        "type": "number"
      }, {
        "name": "bandwidth",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "counts",
        "type": "boolean",
        "default": false
      }, {
        "name": "as",
        "type": "string",
        "default": "grid"
      }]
    };
    PARAMS = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
    inherits(KDE2D, Transform, {
      transform(_, pulse2) {
        if (this.value && !pulse2.changed() && !_.modified())
          return pulse2.StopPropagation;
        var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source5 = pulse2.materialize(pulse2.SOURCE).source, groups4 = partition3(source5, _.groupby), names = (_.groupby || []).map(accessorName), kde2 = params(density2D(), _), as = _.as || "grid", values5 = [];
        function set8(t, vals2) {
          for (let i = 0; i < names.length; ++i)
            t[names[i]] = vals2[i];
          return t;
        }
        values5 = groups4.map((g) => ingest$1(set8({
          [as]: kde2(g, _.counts)
        }, g.dims)));
        if (this.value)
          out.rem = this.value;
        this.value = out.source = out.add = values5;
        return out;
      }
    });
    Contour.Definition = {
      "type": "Contour",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2,
        "required": true
      }, {
        "name": "values",
        "type": "number",
        "array": true
      }, {
        "name": "x",
        "type": "field"
      }, {
        "name": "y",
        "type": "field"
      }, {
        "name": "weight",
        "type": "field"
      }, {
        "name": "cellSize",
        "type": "number"
      }, {
        "name": "bandwidth",
        "type": "number"
      }, {
        "name": "count",
        "type": "number"
      }, {
        "name": "nice",
        "type": "boolean",
        "default": false
      }, {
        "name": "thresholds",
        "type": "number",
        "array": true
      }, {
        "name": "smooth",
        "type": "boolean",
        "default": true
      }]
    };
    inherits(Contour, Transform, {
      transform(_, pulse2) {
        if (this.value && !pulse2.changed() && !_.modified()) {
          return pulse2.StopPropagation;
        }
        var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), contour = contours().smooth(_.smooth !== false), values5 = _.values, thresh = _.thresholds || quantize3(_.count || 10, _.nice, !!values5), size = _.size, grid, post2;
        if (!values5) {
          values5 = pulse2.materialize(pulse2.SOURCE).source;
          grid = params(density2D(), _)(values5, true);
          post2 = transform2(grid, grid.scale || 1, grid.scale || 1, 0, 0);
          size = [grid.width, grid.height];
          values5 = grid.values;
        }
        thresh = isArray(thresh) ? thresh : thresh(values5);
        values5 = contour.size(size)(values5, thresh);
        if (post2)
          values5.forEach(post2);
        if (this.value)
          out.rem = this.value;
        this.value = out.source = out.add = (values5 || []).map(ingest$1);
        return out;
      }
    });
    Feature = "Feature";
    FeatureCollection = "FeatureCollection";
    MultiPoint = "MultiPoint";
    GeoJSON.Definition = {
      "type": "GeoJSON",
      "metadata": {},
      "params": [{
        "name": "fields",
        "type": "field",
        "array": true,
        "length": 2
      }, {
        "name": "geojson",
        "type": "field"
      }]
    };
    inherits(GeoJSON, Transform, {
      transform(_, pulse2) {
        var features = this._features, points2 = this._points, fields = _.fields, lon = fields && fields[0], lat = fields && fields[1], geojson = _.geojson || !fields && identity, flag2 = pulse2.ADD, mod;
        mod = _.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(geojson)) || lon && pulse2.modified(accessorFields(lon)) || lat && pulse2.modified(accessorFields(lat));
        if (!this.value || mod) {
          flag2 = pulse2.SOURCE;
          this._features = features = [];
          this._points = points2 = [];
        }
        if (geojson) {
          pulse2.visit(flag2, (t) => features.push(geojson(t)));
        }
        if (lon && lat) {
          pulse2.visit(flag2, (t) => {
            var x7 = lon(t), y7 = lat(t);
            if (x7 != null && y7 != null && (x7 = +x7) === x7 && (y7 = +y7) === y7) {
              points2.push([x7, y7]);
            }
          });
          features = features.concat({
            type: Feature,
            geometry: {
              type: MultiPoint,
              coordinates: points2
            }
          });
        }
        this.value = {
          type: FeatureCollection,
          features
        };
      }
    });
    GeoPath.Definition = {
      "type": "GeoPath",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "projection",
        "type": "projection"
      }, {
        "name": "field",
        "type": "field"
      }, {
        "name": "pointRadius",
        "type": "number",
        "expr": true
      }, {
        "name": "as",
        "type": "string",
        "default": "path"
      }]
    };
    inherits(GeoPath, Transform, {
      transform(_, pulse2) {
        var out = pulse2.fork(pulse2.ALL), path5 = this.value, field4 = _.field || identity, as = _.as || "path", flag2 = out.SOURCE;
        if (!path5 || _.modified()) {
          this.value = path5 = getProjectionPath(_.projection);
          out.materialize().reflow();
        } else {
          flag2 = field4 === identity || pulse2.modified(field4.fields) ? out.ADD_MOD : out.ADD;
        }
        const prev = initPath(path5, _.pointRadius);
        out.visit(flag2, (t) => t[as] = path5(field4(t)));
        path5.pointRadius(prev);
        return out.modifies(as);
      }
    });
    GeoPoint.Definition = {
      "type": "GeoPoint",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "projection",
        "type": "projection",
        "required": true
      }, {
        "name": "fields",
        "type": "field",
        "array": true,
        "required": true,
        "length": 2
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 2,
        "default": ["x", "y"]
      }]
    };
    inherits(GeoPoint, Transform, {
      transform(_, pulse2) {
        var proj = _.projection, lon = _.fields[0], lat = _.fields[1], as = _.as || ["x", "y"], x7 = as[0], y7 = as[1], mod;
        function set8(t) {
          const xy = proj([lon(t), lat(t)]);
          if (xy) {
            t[x7] = xy[0];
            t[y7] = xy[1];
          } else {
            t[x7] = void 0;
            t[y7] = void 0;
          }
        }
        if (_.modified()) {
          pulse2 = pulse2.materialize().reflow(true).visit(pulse2.SOURCE, set8);
        } else {
          mod = pulse2.modified(lon.fields) || pulse2.modified(lat.fields);
          pulse2.visit(mod ? pulse2.ADD_MOD : pulse2.ADD, set8);
        }
        return pulse2.modifies(as);
      }
    });
    GeoShape.Definition = {
      "type": "GeoShape",
      "metadata": {
        "modifies": true,
        "nomod": true
      },
      "params": [{
        "name": "projection",
        "type": "projection"
      }, {
        "name": "field",
        "type": "field",
        "default": "datum"
      }, {
        "name": "pointRadius",
        "type": "number",
        "expr": true
      }, {
        "name": "as",
        "type": "string",
        "default": "shape"
      }]
    };
    inherits(GeoShape, Transform, {
      transform(_, pulse2) {
        var out = pulse2.fork(pulse2.ALL), shape3 = this.value, as = _.as || "shape", flag2 = out.ADD;
        if (!shape3 || _.modified()) {
          this.value = shape3 = shapeGenerator(getProjectionPath(_.projection), _.field || field("datum"), _.pointRadius);
          out.materialize().reflow();
          flag2 = out.SOURCE;
        }
        out.visit(flag2, (t) => t[as] = shape3);
        return out.modifies(as);
      }
    });
    Graticule.Definition = {
      "type": "Graticule",
      "metadata": {
        "changes": true,
        "generates": true
      },
      "params": [{
        "name": "extent",
        "type": "array",
        "array": true,
        "length": 2,
        "content": {
          "type": "number",
          "array": true,
          "length": 2
        }
      }, {
        "name": "extentMajor",
        "type": "array",
        "array": true,
        "length": 2,
        "content": {
          "type": "number",
          "array": true,
          "length": 2
        }
      }, {
        "name": "extentMinor",
        "type": "array",
        "array": true,
        "length": 2,
        "content": {
          "type": "number",
          "array": true,
          "length": 2
        }
      }, {
        "name": "step",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "stepMajor",
        "type": "number",
        "array": true,
        "length": 2,
        "default": [90, 360]
      }, {
        "name": "stepMinor",
        "type": "number",
        "array": true,
        "length": 2,
        "default": [10, 10]
      }, {
        "name": "precision",
        "type": "number",
        "default": 2.5
      }]
    };
    inherits(Graticule, Transform, {
      transform(_, pulse2) {
        var src = this.value, gen = this.generator, t;
        if (!src.length || _.modified()) {
          for (const prop in _) {
            if (isFunction(gen[prop])) {
              gen[prop](_[prop]);
            }
          }
        }
        t = gen();
        if (src.length) {
          pulse2.mod.push(replace(src[0], t));
        } else {
          pulse2.add.push(ingest$1(t));
        }
        src[0] = t;
        return pulse2;
      }
    });
    Heatmap.Definition = {
      "type": "heatmap",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "color",
        "type": "string",
        "expr": true
      }, {
        "name": "opacity",
        "type": "number",
        "expr": true
      }, {
        "name": "resolve",
        "type": "enum",
        "values": ["shared", "independent"],
        "default": "independent"
      }, {
        "name": "as",
        "type": "string",
        "default": "image"
      }]
    };
    inherits(Heatmap, Transform, {
      transform(_, pulse2) {
        if (!pulse2.changed() && !_.modified()) {
          return pulse2.StopPropagation;
        }
        var source5 = pulse2.materialize(pulse2.SOURCE).source, shared = _.resolve === "shared", field4 = _.field || identity, opacity2 = opacity_(_.opacity, _), color7 = color_(_.color, _), as = _.as || "image", obj = {
          $x: 0,
          $y: 0,
          $value: 0,
          $max: shared ? max2(source5.map((t) => max2(field4(t).values))) : 0
        };
        source5.forEach((t) => {
          const v = field4(t);
          const o = extend({}, t, obj);
          if (!shared)
            o.$max = max2(v.values || []);
          t[as] = toCanvas(v, o, color7.dep ? color7 : constant(color7(o)), opacity2.dep ? opacity2 : constant(opacity2(o)));
        });
        return pulse2.reflow(true).modifies(as);
      }
    });
    inherits(Projection, Transform, {
      transform(_, pulse2) {
        let proj = this.value;
        if (!proj || _.modified("type")) {
          this.value = proj = create4(_.type);
          projectionProperties.forEach((prop) => {
            if (_[prop] != null)
              set4(proj, prop, _[prop]);
          });
        } else {
          projectionProperties.forEach((prop) => {
            if (_.modified(prop))
              set4(proj, prop, _[prop]);
          });
        }
        if (_.pointRadius != null)
          proj.path.pointRadius(_.pointRadius);
        if (_.fit)
          fit2(proj, _);
        return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
      }
    });
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/center.js
function center_default(x7, y7) {
  var nodes, strength = 1;
  if (x7 == null)
    x7 = 0;
  if (y7 == null)
    y7 = 0;
  function force() {
    var i, n = nodes.length, node, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n - x7) * strength, sy = (sy / n - y7) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_) {
    nodes = _;
  };
  force.x = function(_) {
    return arguments.length ? (x7 = +_, force) : x7;
  };
  force.y = function(_) {
    return arguments.length ? (y7 = +_, force) : y7;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  return force;
}
var init_center = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/center.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x7 = +this._x.call(null, d), y7 = +this._y.call(null, d);
  return add4(this.cover(x7, y7), x7, y7, d);
}
function add4(tree, x7, y7, d) {
  if (isNaN(x7) || isNaN(y7))
    return tree;
  var parent, node = tree._root, leaf = { data: d }, x07 = tree._x0, y07 = tree._y0, x13 = tree._x1, y13 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x7 >= (xm = (x07 + x13) / 2))
      x07 = xm;
    else
      x13 = xm;
    if (bottom = y7 >= (ym = (y07 + y13) / 2))
      y07 = ym;
    else
      y13 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right]))
      return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x7 === xp && y7 === yp)
    return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x7 >= (xm = (x07 + x13) / 2))
      x07 = xm;
    else
      x13 = xm;
    if (bottom = y7 >= (ym = (y07 + y13) / 2))
      y07 = ym;
    else
      y13 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data3) {
  var d, i, n = data3.length, x7, y7, xz = new Array(n), yz = new Array(n), x07 = Infinity, y07 = Infinity, x13 = -Infinity, y13 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x7 = +this._x.call(null, d = data3[i])) || isNaN(y7 = +this._y.call(null, d)))
      continue;
    xz[i] = x7;
    yz[i] = y7;
    if (x7 < x07)
      x07 = x7;
    if (x7 > x13)
      x13 = x7;
    if (y7 < y07)
      y07 = y7;
    if (y7 > y13)
      y13 = y7;
  }
  if (x07 > x13 || y07 > y13)
    return this;
  this.cover(x07, y07).cover(x13, y13);
  for (i = 0; i < n; ++i) {
    add4(this, xz[i], yz[i], data3[i]);
  }
  return this;
}
var init_add = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/add.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/cover.js
function cover_default(x7, y7) {
  if (isNaN(x7 = +x7) || isNaN(y7 = +y7))
    return this;
  var x07 = this._x0, y07 = this._y0, x13 = this._x1, y13 = this._y1;
  if (isNaN(x07)) {
    x13 = (x07 = Math.floor(x7)) + 1;
    y13 = (y07 = Math.floor(y7)) + 1;
  } else {
    var z = x13 - x07 || 1, node = this._root, parent, i;
    while (x07 > x7 || x7 >= x13 || y07 > y7 || y7 >= y13) {
      i = (y7 < y07) << 1 | x7 < x07;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x13 = x07 + z, y13 = y07 + z;
          break;
        case 1:
          x07 = x13 - z, y13 = y07 + z;
          break;
        case 2:
          x13 = x07 + z, y07 = y13 - z;
          break;
        case 3:
          x07 = x13 - z, y07 = y13 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x07;
  this._y0 = y07;
  this._x1 = x13;
  this._y1 = y13;
  return this;
}
var init_cover = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/cover.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/data.js
function data_default() {
  var data3 = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data3.push(node.data);
      while (node = node.next);
  });
  return data3;
}
var init_data = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/data.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/extent.js
function extent_default3(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
var init_extent4 = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/extent.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/quad.js
function quad_default(node, x07, y07, x13, y13) {
  this.node = node;
  this.x0 = x07;
  this.y0 = y07;
  this.x1 = x13;
  this.y1 = y13;
}
var init_quad = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/quad.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/find.js
function find_default(x7, y7, radius2) {
  var data3, x07 = this._x0, y07 = this._y0, x13, y13, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node)
    quads.push(new quad_default(node, x07, y07, x32, y32));
  if (radius2 == null)
    radius2 = Infinity;
  else {
    x07 = x7 - radius2, y07 = y7 - radius2;
    x32 = x7 + radius2, y32 = y7 + radius2;
    radius2 *= radius2;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x13 = q.x0) > x32 || (y13 = q.y0) > y32 || (x22 = q.x1) < x07 || (y22 = q.y1) < y07)
      continue;
    if (node.length) {
      var xm = (x13 + x22) / 2, ym = (y13 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x13, ym, xm, y22),
        new quad_default(node[1], xm, y13, x22, ym),
        new quad_default(node[0], x13, y13, xm, ym)
      );
      if (i = (y7 >= ym) << 1 | x7 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x7 - +this._x.call(null, node.data), dy = y7 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius2) {
        var d = Math.sqrt(radius2 = d2);
        x07 = x7 - d, y07 = y7 - d;
        x32 = x7 + d, y32 = y7 + d;
        data3 = node.data;
      }
    }
  }
  return data3;
}
var init_find = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/find.js"() {
    init_quad();
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/remove.js
function remove_default(d) {
  if (isNaN(x7 = +this._x.call(null, d)) || isNaN(y7 = +this._y.call(null, d)))
    return this;
  var parent, node = this._root, retainer, previous, next, x07 = this._x0, y07 = this._y0, x13 = this._x1, y13 = this._y1, x7, y7, xm, ym, right, bottom, i, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x7 >= (xm = (x07 + x13) / 2))
        x07 = xm;
      else
        x13 = xm;
      if (bottom = y7 >= (ym = (y07 + y13) / 2))
        y07 = ym;
      else
        y13 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j = i;
    }
  while (node.data !== d)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data3) {
  for (var i = 0, n = data3.length; i < n; ++i)
    this.remove(data3[i]);
  return this;
}
var init_remove = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/remove.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}
var init_root = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/root.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}
var init_size = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/size.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x07, y07, x13, y13;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x07 = q.x0, y07 = q.y0, x13 = q.x1, y13 = q.y1) && node.length) {
      var xm = (x07 + x13) / 2, ym = (y07 + y13) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x13, y13));
      if (child = node[2])
        quads.push(new quad_default(child, x07, ym, xm, y13));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y07, x13, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x07, y07, xm, ym));
    }
  }
  return this;
}
var init_visit = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/visit.js"() {
    init_quad();
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x07 = q.x0, y07 = q.y0, x13 = q.x1, y13 = q.y1, xm = (x07 + x13) / 2, ym = (y07 + y13) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x07, y07, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y07, x13, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x07, ym, xm, y13));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x13, y13));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}
var init_visitAfter = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/visitAfter.js"() {
    init_quad();
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}
var init_x = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/x.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}
var init_y = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/y.js"() {
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x7, y7) {
  var tree = new Quadtree(x7 == null ? defaultX : x7, y7 == null ? defaultY : y7, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x7, y7, x07, y07, x13, y13) {
  this._x = x7;
  this._y = y7;
  this._x0 = x07;
  this._y0 = y07;
  this._x1 = x13;
  this._y1 = y13;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy6 = { data: leaf.data }, next = copy6;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy6;
}
var treeProto;
var init_quadtree = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/quadtree.js"() {
    init_add();
    init_cover();
    init_data();
    init_extent4();
    init_find();
    init_remove();
    init_root();
    init_size();
    init_visit();
    init_visitAfter();
    init_x();
    init_y();
    treeProto = quadtree.prototype = Quadtree.prototype;
    treeProto.copy = function() {
      var copy6 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
      if (!node)
        return copy6;
      if (!node.length)
        return copy6._root = leaf_copy(node), copy6;
      nodes = [{ source: node, target: copy6._root = new Array(4) }];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length)
              nodes.push({ source: child, target: node.target[i] = new Array(4) });
            else
              node.target[i] = leaf_copy(child);
          }
        }
      }
      return copy6;
    };
    treeProto.add = add_default;
    treeProto.addAll = addAll;
    treeProto.cover = cover_default;
    treeProto.data = data_default;
    treeProto.extent = extent_default3;
    treeProto.find = find_default;
    treeProto.remove = remove_default;
    treeProto.removeAll = removeAll;
    treeProto.root = root_default;
    treeProto.size = size_default;
    treeProto.visit = visit_default;
    treeProto.visitAfter = visitAfter_default;
    treeProto.x = x_default;
    treeProto.y = y_default;
  }
});

// node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/index.js
var init_src23 = __esm({
  "node_modules/.pnpm/d3-quadtree@2.0.0/node_modules/d3-quadtree/src/index.js"() {
    init_quadtree();
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/constant.js
function constant_default6(x7) {
  return function() {
    return x7;
  };
}
var init_constant9 = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/jiggle.js
function jiggle_default(random3) {
  return (random3() - 0.5) * 1e-6;
}
var init_jiggle = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/jiggle.js"() {
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/collide.js
function x3(d) {
  return d.x + d.vx;
}
function y3(d) {
  return d.y + d.vy;
}
function collide_default(radius2) {
  var nodes, radii, random3, strength = 1, iterations2 = 1;
  if (typeof radius2 !== "function")
    radius2 = constant_default6(radius2 == null ? 1 : +radius2);
  function force() {
    var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k4 = 0; k4 < iterations2; ++k4) {
      tree = quadtree(nodes, x3, y3).visitAfter(prepare2);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply3);
      }
    }
    function apply3(quad2, x07, y07, x13, y13) {
      var data3 = quad2.data, rj = quad2.r, r2 = ri + rj;
      if (data3) {
        if (data3.index > node.index) {
          var x7 = xi - data3.x - data3.vx, y7 = yi - data3.y - data3.vy, l = x7 * x7 + y7 * y7;
          if (l < r2 * r2) {
            if (x7 === 0)
              x7 = jiggle_default(random3), l += x7 * x7;
            if (y7 === 0)
              y7 = jiggle_default(random3), l += y7 * y7;
            l = (r2 - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x7 *= l) * (r2 = (rj *= rj) / (ri2 + rj));
            node.vy += (y7 *= l) * r2;
            data3.vx -= x7 * (r2 = 1 - r2);
            data3.vy -= y7 * r2;
          }
        }
        return;
      }
      return x07 > xi + r2 || x13 < xi - r2 || y07 > yi + r2 || y13 < yi - r2;
    }
  }
  function prepare2(quad2) {
    if (quad2.data)
      return quad2.r = radii[quad2.data.index];
    for (var i = quad2.r = 0; i < 4; ++i) {
      if (quad2[i] && quad2[i].r > quad2.r) {
        quad2.r = quad2[i].r;
      }
    }
  }
  function initialize4() {
    if (!nodes)
      return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i)
      node = nodes[i], radii[node.index] = +radius2(node, i, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random3 = _random;
    initialize4();
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force) : iterations2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  force.radius = function(_) {
    return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant_default6(+_), initialize4(), force) : radius2;
  };
  return force;
}
var init_collide = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/collide.js"() {
    init_src23();
    init_constant9();
    init_jiggle();
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/link.js
function index3(d) {
  return d.index;
}
function find2(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id4 = index3, strength = defaultStrength, strengths, distance = constant_default6(30), distances, nodes, count5, bias, random3, iterations2 = 1;
  if (links == null)
    links = [];
  function defaultStrength(link3) {
    return 1 / Math.min(count5[link3.source.index], count5[link3.target.index]);
  }
  function force(alpha) {
    for (var k4 = 0, n = links.length; k4 < iterations2; ++k4) {
      for (var i = 0, link3, source5, target2, x7, y7, l, b3; i < n; ++i) {
        link3 = links[i], source5 = link3.source, target2 = link3.target;
        x7 = target2.x + target2.vx - source5.x - source5.vx || jiggle_default(random3);
        y7 = target2.y + target2.vy - source5.y - source5.vy || jiggle_default(random3);
        l = Math.sqrt(x7 * x7 + y7 * y7);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x7 *= l, y7 *= l;
        target2.vx -= x7 * (b3 = bias[i]);
        target2.vy -= y7 * b3;
        source5.vx += x7 * (b3 = 1 - b3);
        source5.vy += y7 * b3;
      }
    }
  }
  function initialize4() {
    if (!nodes)
      return;
    var i, n = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i2) => [id4(d, i2, nodes), d])), link3;
    for (i = 0, count5 = new Array(n); i < m2; ++i) {
      link3 = links[i], link3.index = i;
      if (typeof link3.source !== "object")
        link3.source = find2(nodeById, link3.source);
      if (typeof link3.target !== "object")
        link3.target = find2(nodeById, link3.target);
      count5[link3.source.index] = (count5[link3.source.index] || 0) + 1;
      count5[link3.target.index] = (count5[link3.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m2); i < m2; ++i) {
      link3 = links[i], bias[i] = count5[link3.source.index] / (count5[link3.source.index] + count5[link3.target.index]);
    }
    strengths = new Array(m2), initializeStrength();
    distances = new Array(m2), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random3 = _random;
    initialize4();
  };
  force.links = function(_) {
    return arguments.length ? (links = _, initialize4(), force) : links;
  };
  force.id = function(_) {
    return arguments.length ? (id4 = _, force) : id4;
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force) : iterations2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default6(+_), initializeStrength(), force) : strength;
  };
  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default6(+_), initializeDistance(), force) : distance;
  };
  return force;
}
var init_link2 = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/link.js"() {
    init_constant9();
    init_jiggle();
  }
});

// node_modules/.pnpm/d3-dispatch@2.0.0/node_modules/d3-dispatch/src/dispatch.js
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types4) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name4 = "", i = t.indexOf(".");
    if (i >= 0)
      name4 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types4.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name: name4 };
  });
}
function get6(type4, name4) {
  for (var i = 0, n = type4.length, c2; i < n; ++i) {
    if ((c2 = type4[i]).name === name4) {
      return c2.value;
    }
  }
}
function set5(type4, name4, callback) {
  for (var i = 0, n = type4.length; i < n; ++i) {
    if (type4[i].name === name4) {
      type4[i] = noop4, type4 = type4.slice(0, i).concat(type4.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type4.push({ name: name4, value: callback });
  return type4;
}
var noop4, dispatch_default;
var init_dispatch = __esm({
  "node_modules/.pnpm/d3-dispatch@2.0.0/node_modules/d3-dispatch/src/dispatch.js"() {
    noop4 = { value: () => {
    } };
    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
        if (arguments.length < 2) {
          while (++i < n)
            if ((t = (typename = T[i]).type) && (t = get6(_[t], typename.name)))
              return t;
          return;
        }
        if (callback != null && typeof callback !== "function")
          throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type)
            _[t] = set5(_[t], typename.name, callback);
          else if (callback == null)
            for (t in _)
              _[t] = set5(_[t], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy6 = {}, _ = this._;
        for (var t in _)
          copy6[t] = _[t].slice();
        return new Dispatch(copy6);
      },
      call: function(type4, that) {
        if ((n = arguments.length - 2) > 0)
          for (var args = new Array(n), i = 0, n, t; i < n; ++i)
            args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type4))
          throw new Error("unknown type: " + type4);
        for (t = this._[type4], i = 0, n = t.length; i < n; ++i)
          t[i].value.apply(that, args);
      },
      apply: function(type4, that, args) {
        if (!this._.hasOwnProperty(type4))
          throw new Error("unknown type: " + type4);
        for (var t = this._[type4], i = 0, n = t.length; i < n; ++i)
          t[i].value.apply(that, args);
      }
    };
    dispatch_default = dispatch;
  }
});

// node_modules/.pnpm/d3-dispatch@2.0.0/node_modules/d3-dispatch/src/index.js
var init_src24 = __esm({
  "node_modules/.pnpm/d3-dispatch@2.0.0/node_modules/d3-dispatch/src/index.js"() {
    init_dispatch();
  }
});

// node_modules/.pnpm/d3-timer@2.0.0/node_modules/d3-timer/src/timer.js
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
function timer(callback, delay, time4) {
  var t = new Timer();
  t.restart(callback, delay, time4);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e3;
  while (t) {
    if ((e3 = clockNow - t._time) >= 0)
      t._call.call(null, e3);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t07, t15 = taskHead, t23, time4 = Infinity;
  while (t15) {
    if (t15._call) {
      if (time4 > t15._time)
        time4 = t15._time;
      t07 = t15, t15 = t15._next;
    } else {
      t23 = t15._next, t15._next = null;
      t15 = t07 ? t07._next = t23 : taskHead = t23;
    }
  }
  taskTail = t07;
  sleep(time4);
}
function sleep(time4) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time4 - clockNow;
  if (delay > 24) {
    if (time4 < Infinity)
      timeout = setTimeout(wake, time4 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
var frame, timeout, interval, pokeDelay, taskHead, taskTail, clockLast, clockNow, clockSkew, clock, setFrame;
var init_timer = __esm({
  "node_modules/.pnpm/d3-timer@2.0.0/node_modules/d3-timer/src/timer.js"() {
    frame = 0;
    timeout = 0;
    interval = 0;
    pokeDelay = 1e3;
    clockLast = 0;
    clockNow = 0;
    clockSkew = 0;
    clock = typeof performance === "object" && performance.now ? performance : Date;
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
      setTimeout(f, 17);
    };
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time4) {
        if (typeof callback !== "function")
          throw new TypeError("callback is not a function");
        time4 = (time4 == null ? now() : +time4) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail)
            taskTail._next = this;
          else
            taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time4;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
  }
});

// node_modules/.pnpm/d3-timer@2.0.0/node_modules/d3-timer/src/timeout.js
var init_timeout = __esm({
  "node_modules/.pnpm/d3-timer@2.0.0/node_modules/d3-timer/src/timeout.js"() {
    init_timer();
  }
});

// node_modules/.pnpm/d3-timer@2.0.0/node_modules/d3-timer/src/interval.js
function interval_default(callback, delay, time4) {
  var t = new Timer(), total = delay;
  if (delay == null)
    return t.restart(callback, delay, time4), t;
  t._restart = t.restart;
  t.restart = function(callback2, delay2, time5) {
    delay2 = +delay2, time5 = time5 == null ? now() : +time5;
    t._restart(function tick2(elapsed) {
      elapsed += total;
      t._restart(tick2, total += delay2, time5);
      callback2(elapsed);
    }, delay2, time5);
  };
  t.restart(callback, delay, time4);
  return t;
}
var init_interval3 = __esm({
  "node_modules/.pnpm/d3-timer@2.0.0/node_modules/d3-timer/src/interval.js"() {
    init_timer();
  }
});

// node_modules/.pnpm/d3-timer@2.0.0/node_modules/d3-timer/src/index.js
var init_src25 = __esm({
  "node_modules/.pnpm/d3-timer@2.0.0/node_modules/d3-timer/src/index.js"() {
    init_timer();
    init_timeout();
    init_interval3();
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/lcg.js
function lcg_default() {
  let s3 = 1;
  return () => (s3 = (a2 * s3 + c) % m) / m;
}
var a2, c, m;
var init_lcg = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/lcg.js"() {
    a2 = 1664525;
    c = 1013904223;
    m = 4294967296;
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/simulation.js
function x4(d) {
  return d.x;
}
function y4(d) {
  return d.y;
}
function simulation_default(nodes) {
  var simulation2, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event3 = dispatch_default("tick", "end"), random3 = lcg_default();
  if (nodes == null)
    nodes = [];
  function step() {
    tick2();
    event3.call("tick", simulation2);
    if (alpha < alphaMin) {
      stepper.stop();
      event3.call("end", simulation2);
    }
  }
  function tick2(iterations2) {
    var i, n = nodes.length, node;
    if (iterations2 === void 0)
      iterations2 = 1;
    for (var k4 = 0; k4 < iterations2; ++k4) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation2;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius2 = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;
        node.x = radius2 * Math.cos(angle2);
        node.y = radius2 * Math.sin(angle2);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random3);
    return force;
  }
  initializeNodes();
  return simulation2 = {
    tick: tick2,
    restart: function() {
      return stepper.restart(step), simulation2;
    },
    stop: function() {
      return stepper.stop(), simulation2;
    },
    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation2) : nodes;
    },
    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation2) : alpha;
    },
    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation2) : alphaMin;
    },
    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation2) : +alphaDecay;
    },
    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation2) : alphaTarget;
    },
    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation2) : 1 - velocityDecay;
    },
    randomSource: function(_) {
      return arguments.length ? (random3 = _, forces.forEach(initializeForce), simulation2) : random3;
    },
    force: function(name4, _) {
      return arguments.length > 1 ? (_ == null ? forces.delete(name4) : forces.set(name4, initializeForce(_)), simulation2) : forces.get(name4);
    },
    find: function(x7, y7, radius2) {
      var i = 0, n = nodes.length, dx, dy, d2, node, closest;
      if (radius2 == null)
        radius2 = Infinity;
      else
        radius2 *= radius2;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x7 - node.x;
        dy = y7 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius2)
          closest = node, radius2 = d2;
      }
      return closest;
    },
    on: function(name4, _) {
      return arguments.length > 1 ? (event3.on(name4, _), simulation2) : event3.on(name4);
    }
  };
}
var initialRadius, initialAngle;
var init_simulation = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/simulation.js"() {
    init_src24();
    init_src25();
    init_lcg();
    initialRadius = 10;
    initialAngle = Math.PI * (3 - Math.sqrt(5));
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random3, alpha, strength = constant_default6(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, x4, y4).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i)
      node = nodes[i], tree.visit(apply3);
  }
  function initialize4() {
    if (!nodes)
      return;
    var i, n = nodes.length, node2;
    strengths = new Array(n);
    for (i = 0; i < n; ++i)
      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(quad2) {
    var strength2 = 0, q, c2, weight = 0, x7, y7, i;
    if (quad2.length) {
      for (x7 = y7 = i = 0; i < 4; ++i) {
        if ((q = quad2[i]) && (c2 = Math.abs(q.value))) {
          strength2 += q.value, weight += c2, x7 += c2 * q.x, y7 += c2 * q.y;
        }
      }
      quad2.x = x7 / weight;
      quad2.y = y7 / weight;
    } else {
      q = quad2;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad2.value = strength2;
  }
  function apply3(quad2, x13, _, x22) {
    if (!quad2.value)
      return true;
    var x7 = quad2.x - node.x, y7 = quad2.y - node.y, w5 = x22 - x13, l = x7 * x7 + y7 * y7;
    if (w5 * w5 / theta2 < l) {
      if (l < distanceMax2) {
        if (x7 === 0)
          x7 = jiggle_default(random3), l += x7 * x7;
        if (y7 === 0)
          y7 = jiggle_default(random3), l += y7 * y7;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
        node.vx += x7 * quad2.value * alpha / l;
        node.vy += y7 * quad2.value * alpha / l;
      }
      return true;
    } else if (quad2.length || l >= distanceMax2)
      return;
    if (quad2.data !== node || quad2.next) {
      if (x7 === 0)
        x7 = jiggle_default(random3), l += x7 * x7;
      if (y7 === 0)
        y7 = jiggle_default(random3), l += y7 * y7;
      if (l < distanceMin2)
        l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad2.data !== node) {
        w5 = strengths[quad2.data.index] * alpha / l;
        node.vx += x7 * w5;
        node.vy += y7 * w5;
      }
    while (quad2 = quad2.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random3 = _random;
    initialize4();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default6(+_), initialize4(), force) : strength;
  };
  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };
  return force;
}
var init_manyBody = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/manyBody.js"() {
    init_src23();
    init_constant9();
    init_jiggle();
    init_simulation();
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/radial.js
var init_radial4 = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/radial.js"() {
    init_constant9();
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/x.js
function x_default2(x7) {
  var strength = constant_default6(0.1), nodes, strengths, xz;
  if (typeof x7 !== "function")
    x7 = constant_default6(x7 == null ? 0 : +x7);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }
  function initialize4() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x7(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize4();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default6(+_), initialize4(), force) : strength;
  };
  force.x = function(_) {
    return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default6(+_), initialize4(), force) : x7;
  };
  return force;
}
var init_x2 = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/x.js"() {
    init_constant9();
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/y.js
function y_default2(y7) {
  var strength = constant_default6(0.1), nodes, strengths, yz;
  if (typeof y7 !== "function")
    y7 = constant_default6(y7 == null ? 0 : +y7);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }
  function initialize4() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y7(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize4();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default6(+_), initialize4(), force) : strength;
  };
  force.y = function(_) {
    return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default6(+_), initialize4(), force) : y7;
  };
  return force;
}
var init_y2 = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/y.js"() {
    init_constant9();
  }
});

// node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/index.js
var init_src26 = __esm({
  "node_modules/.pnpm/d3-force@2.1.1/node_modules/d3-force/src/index.js"() {
    init_center();
    init_collide();
    init_link2();
    init_manyBody();
    init_radial4();
    init_simulation();
    init_x2();
    init_y2();
  }
});

// node_modules/.pnpm/vega-force@4.0.7/node_modules/vega-force/build/vega-force.module.js
var vega_force_module_exports = {};
__export(vega_force_module_exports, {
  force: () => Force
});
function Force(params2) {
  Transform.call(this, null, params2);
}
function rerun(df, op) {
  return () => df.touch(op).run();
}
function simulation(nodes, _) {
  const sim = simulation_default(nodes), stop2 = sim.stop, restart = sim.restart;
  let stopped = false;
  sim.stopped = () => stopped;
  sim.restart = () => (stopped = false, restart());
  sim.stop = () => (stopped = true, stop2());
  return setup(sim, _, true).on("end", () => stopped = true);
}
function setup(sim, _, init2, pulse2) {
  var f = array(_.forces), i, n, p, name4;
  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p))
      sim[p](_[p]);
  }
  for (i = 0, n = f.length; i < n; ++i) {
    name4 = Forces + i;
    p = init2 || _.modified(Forces, i) ? getForce(f[i]) : pulse2 && modified(f[i], pulse2) ? sim.force(name4) : null;
    if (p)
      sim.force(name4, p);
  }
  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null);
  }
  sim.numForces = f.length;
  return sim;
}
function modified(f, pulse2) {
  var k4, v;
  for (k4 in f) {
    if (isFunction(v = f[k4]) && pulse2.modified(accessorFields(v)))
      return 1;
  }
  return 0;
}
function getForce(_) {
  var f, p;
  if (!has(ForceMap, _.force)) {
    error("Unrecognized force: " + _.force);
  }
  f = ForceMap[_.force]();
  for (p in _) {
    if (isFunction(f[p]))
      setForceParam(f[p], _[p], _);
  }
  return f;
}
function setForceParam(f, v, _) {
  f(isFunction(v) ? (d) => v(d, _) : v);
}
var ForceMap, Forces, ForceParams, ForceConfig, ForceOutput;
var init_vega_force_module = __esm({
  "node_modules/.pnpm/vega-force@4.0.7/node_modules/vega-force/build/vega-force.module.js"() {
    init_vega_dataflow_module();
    init_vega_util_module();
    init_src26();
    ForceMap = {
      center: center_default,
      collide: collide_default,
      nbody: manyBody_default,
      link: link_default,
      x: x_default2,
      y: y_default2
    };
    Forces = "forces";
    ForceParams = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"];
    ForceConfig = ["static", "iterations"];
    ForceOutput = ["x", "y", "vx", "vy"];
    Force.Definition = {
      "type": "Force",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "static",
        "type": "boolean",
        "default": false
      }, {
        "name": "restart",
        "type": "boolean",
        "default": false
      }, {
        "name": "iterations",
        "type": "number",
        "default": 300
      }, {
        "name": "alpha",
        "type": "number",
        "default": 1
      }, {
        "name": "alphaMin",
        "type": "number",
        "default": 1e-3
      }, {
        "name": "alphaTarget",
        "type": "number",
        "default": 0
      }, {
        "name": "velocityDecay",
        "type": "number",
        "default": 0.4
      }, {
        "name": "forces",
        "type": "param",
        "array": true,
        "params": [{
          "key": {
            "force": "center"
          },
          "params": [{
            "name": "x",
            "type": "number",
            "default": 0
          }, {
            "name": "y",
            "type": "number",
            "default": 0
          }]
        }, {
          "key": {
            "force": "collide"
          },
          "params": [{
            "name": "radius",
            "type": "number",
            "expr": true
          }, {
            "name": "strength",
            "type": "number",
            "default": 0.7
          }, {
            "name": "iterations",
            "type": "number",
            "default": 1
          }]
        }, {
          "key": {
            "force": "nbody"
          },
          "params": [{
            "name": "strength",
            "type": "number",
            "default": -30
          }, {
            "name": "theta",
            "type": "number",
            "default": 0.9
          }, {
            "name": "distanceMin",
            "type": "number",
            "default": 1
          }, {
            "name": "distanceMax",
            "type": "number"
          }]
        }, {
          "key": {
            "force": "link"
          },
          "params": [{
            "name": "links",
            "type": "data"
          }, {
            "name": "id",
            "type": "field"
          }, {
            "name": "distance",
            "type": "number",
            "default": 30,
            "expr": true
          }, {
            "name": "strength",
            "type": "number",
            "expr": true
          }, {
            "name": "iterations",
            "type": "number",
            "default": 1
          }]
        }, {
          "key": {
            "force": "x"
          },
          "params": [{
            "name": "strength",
            "type": "number",
            "default": 0.1
          }, {
            "name": "x",
            "type": "field"
          }]
        }, {
          "key": {
            "force": "y"
          },
          "params": [{
            "name": "strength",
            "type": "number",
            "default": 0.1
          }, {
            "name": "y",
            "type": "field"
          }]
        }]
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "modify": false,
        "default": ForceOutput
      }]
    };
    inherits(Force, Transform, {
      transform(_, pulse2) {
        var sim = this.value, change2 = pulse2.changed(pulse2.ADD_REM), params2 = _.modified(ForceParams), iters = _.iterations || 300;
        if (!sim) {
          this.value = sim = simulation(pulse2.source, _);
          sim.on("tick", rerun(pulse2.dataflow, this));
          if (!_.static) {
            change2 = true;
            sim.tick();
          }
          pulse2.modifies("index");
        } else {
          if (change2) {
            pulse2.modifies("index");
            sim.nodes(pulse2.source);
          }
          if (params2 || pulse2.changed(pulse2.MOD)) {
            setup(sim, _, 0, pulse2);
          }
        }
        if (params2 || change2 || _.modified(ForceConfig) || pulse2.changed() && _.restart) {
          sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));
          if (_.static) {
            for (sim.stop(); --iters >= 0; )
              sim.tick();
          } else {
            if (sim.stopped())
              sim.restart();
            if (!change2)
              return pulse2.StopPropagation;
          }
        }
        return this.finish(_, pulse2);
      },
      finish(_, pulse2) {
        const dataflow = pulse2.dataflow;
        for (let args = this._argops, j = 0, m2 = args.length, arg; j < m2; ++j) {
          arg = args[j];
          if (arg.name !== Forces || arg.op._argval.force !== "link") {
            continue;
          }
          for (var ops2 = arg.op._argops, i = 0, n = ops2.length, op; i < n; ++i) {
            if (ops2[i].name === "links" && (op = ops2[i].op.source)) {
              dataflow.pulse(op, dataflow.changeset().reflow());
              break;
            }
          }
        }
        return pulse2.reflow(_.modified()).modifies(ForceOutput);
      }
    });
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a4, b3) {
  return a4.parent === b3.parent ? 1 : 2;
}
function meanX(children5) {
  return children5.reduce(meanXReduce, 0) / children5.length;
}
function meanXReduce(x7, c2) {
  return x7 + c2.x;
}
function maxY(children5) {
  return 1 + children5.reduce(maxYReduce, 0);
}
function maxYReduce(y7, c2) {
  return Math.max(y7, c2.y);
}
function leafLeft(node) {
  var children5;
  while (children5 = node.children)
    node = children5[0];
  return node;
}
function leafRight(node) {
  var children5;
  while (children5 = node.children)
    node = children5[children5.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root2) {
    var previousNode, x7 = 0;
    root2.eachAfter(function(node) {
      var children5 = node.children;
      if (children5) {
        node.x = meanX(children5);
        node.y = maxY(children5);
      } else {
        node.x = previousNode ? x7 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left = leafLeft(root2), right = leafRight(root2), x07 = left.x - separation(left, right) / 2, x13 = right.x + separation(right, left) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x07) / (x13 - x07) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster.separation = function(x7) {
    return arguments.length ? (separation = x7, cluster) : separation;
  };
  cluster.size = function(x7) {
    return arguments.length ? (nodeSize = false, dx = +x7[0], dy = +x7[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x7) {
    return arguments.length ? (nodeSize = true, dx = +x7[0], dy = +x7[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}
var init_cluster = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/cluster.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/count.js
function count3(node) {
  var sum6 = 0, children5 = node.children, i = children5 && children5.length;
  if (!i)
    sum6 = 1;
  else
    while (--i >= 0)
      sum6 += children5[i].value;
  node.value = sum6;
}
function count_default() {
  return this.eachAfter(count3);
}
var init_count3 = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/count.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index8 = -1;
  for (const node of this) {
    callback.call(that, node, ++index8, this);
  }
  return this;
}
var init_each = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/each.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children5, i, index8 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index8, this);
    if (children5 = node.children) {
      for (i = children5.length - 1; i >= 0; --i) {
        nodes.push(children5[i]);
      }
    }
  }
  return this;
}
var init_eachBefore = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children5, i, n, index8 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children5 = node.children) {
      for (i = 0, n = children5.length; i < n; ++i) {
        nodes.push(children5[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index8, this);
  }
  return this;
}
var init_eachAfter = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index8 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index8, this)) {
      return node;
    }
  }
}
var init_find2 = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/find.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value4) {
  return this.eachAfter(function(node) {
    var sum6 = +value4(node.data) || 0, children5 = node.children, i = children5 && children5.length;
    while (--i >= 0)
      sum6 += children5[i].value;
    node.value = sum6;
  });
}
var init_sum3 = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/sum.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare6) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare6);
    }
  });
}
var init_sort3 = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/sort.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default2(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k4 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k4, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a4, b3) {
  if (a4 === b3)
    return a4;
  var aNodes = a4.ancestors(), bNodes = b3.ancestors(), c2 = null;
  a4 = aNodes.pop();
  b3 = bNodes.pop();
  while (a4 === b3) {
    c2 = a4;
    a4 = aNodes.pop();
    b3 = bNodes.pop();
  }
  return c2;
}
var init_path4 = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/path.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
var init_ancestors = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/ancestors.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}
var init_descendants = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/descendants.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
var init_leaves = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/leaves.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}
var init_links = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/links.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current2, next = [node], children5, i, n;
  do {
    current2 = next.reverse(), next = [];
    while (node = current2.pop()) {
      yield node;
      if (children5 = node.children) {
        for (i = 0, n = children5.length; i < n; ++i) {
          next.push(children5[i]);
        }
      }
    }
  } while (next.length);
}
var init_iterator = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/iterator.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data3, children5) {
  if (data3 instanceof Map) {
    data3 = [void 0, data3];
    if (children5 === void 0)
      children5 = mapChildren;
  } else if (children5 === void 0) {
    children5 = objectChildren;
  }
  var root2 = new Node(data3), node, nodes = [root2], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children5(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height2 = 0;
  do
    node.height = height2;
  while ((node = node.parent) && node.height < ++height2);
}
function Node(data3) {
  this.data = data3;
  this.depth = this.height = 0;
  this.parent = null;
}
var init_hierarchy = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/hierarchy/index.js"() {
    init_count3();
    init_each();
    init_eachBefore();
    init_eachAfter();
    init_find2();
    init_sum3();
    init_sort3();
    init_path4();
    init_ancestors();
    init_descendants();
    init_leaves();
    init_links();
    init_iterator();
    Node.prototype = hierarchy.prototype = {
      constructor: Node,
      count: count_default,
      each: each_default,
      eachAfter: eachAfter_default,
      eachBefore: eachBefore_default,
      find: find_default2,
      sum: sum_default,
      sort: sort_default,
      path: path_default2,
      ancestors: ancestors_default,
      descendants: descendants_default,
      leaves: leaves_default,
      links: links_default,
      copy: node_copy,
      [Symbol.iterator]: iterator_default
    };
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/array.js
function array_default4(x7) {
  return typeof x7 === "object" && "length" in x7 ? x7 : Array.from(x7);
}
function shuffle(array9) {
  var m2 = array9.length, t, i;
  while (m2) {
    i = Math.random() * m2-- | 0;
    t = array9[m2];
    array9[m2] = array9[i];
    array9[i] = t;
  }
  return array9;
}
var init_array6 = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/array.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/pack/enclose.js
function enclose_default(circles) {
  var i = 0, n = (circles = shuffle(Array.from(circles))).length, B4 = [], p, e3;
  while (i < n) {
    p = circles[i];
    if (e3 && enclosesWeak(e3, p))
      ++i;
    else
      e3 = encloseBasis(B4 = extendBasis(B4, p)), i = 0;
  }
  return e3;
}
function extendBasis(B4, p) {
  var i, j;
  if (enclosesWeakAll(p, B4))
    return [p];
  for (i = 0; i < B4.length; ++i) {
    if (enclosesNot(p, B4[i]) && enclosesWeakAll(encloseBasis2(B4[i], p), B4)) {
      return [B4[i], p];
    }
  }
  for (i = 0; i < B4.length - 1; ++i) {
    for (j = i + 1; j < B4.length; ++j) {
      if (enclosesNot(encloseBasis2(B4[i], B4[j]), p) && enclosesNot(encloseBasis2(B4[i], p), B4[j]) && enclosesNot(encloseBasis2(B4[j], p), B4[i]) && enclosesWeakAll(encloseBasis3(B4[i], B4[j], p), B4)) {
        return [B4[i], B4[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a4, b3) {
  var dr = a4.r - b3.r, dx = b3.x - a4.x, dy = b3.y - a4.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a4, b3) {
  var dr = a4.r - b3.r + Math.max(a4.r, b3.r, 1) * 1e-9, dx = b3.x - a4.x, dy = b3.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a4, B4) {
  for (var i = 0; i < B4.length; ++i) {
    if (!enclosesWeak(a4, B4[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B4) {
  switch (B4.length) {
    case 1:
      return encloseBasis1(B4[0]);
    case 2:
      return encloseBasis2(B4[0], B4[1]);
    case 3:
      return encloseBasis3(B4[0], B4[1], B4[2]);
  }
}
function encloseBasis1(a4) {
  return {
    x: a4.x,
    y: a4.y,
    r: a4.r
  };
}
function encloseBasis2(a4, b3) {
  var x13 = a4.x, y13 = a4.y, r1 = a4.r, x22 = b3.x, y22 = b3.y, r2 = b3.r, x21 = x22 - x13, y21 = y22 - y13, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x13 + x22 + x21 / l * r21) / 2,
    y: (y13 + y22 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a4, b3, c2) {
  var x13 = a4.x, y13 = a4.y, r1 = a4.r, x22 = b3.x, y22 = b3.y, r2 = b3.r, x32 = c2.x, y32 = c2.y, r3 = c2.r, a22 = x13 - x22, a32 = x13 - x32, b22 = y13 - y22, b32 = y13 - y32, c22 = r2 - r1, c3 = r3 - r1, d1 = x13 * x13 + y13 * y13 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab = a32 * b22 - a22 * b32, xa = (b22 * d3 - b32 * d2) / (ab * 2) - x13, xb = (b32 * c22 - b22 * c3) / ab, ya = (a32 * d2 - a22 * d3) / (ab * 2) - y13, yb = (a22 * c3 - a32 * c22) / ab, A6 = xb * xb + yb * yb - 1, B4 = 2 * (r1 + xa * xb + ya * yb), C5 = xa * xa + ya * ya - r1 * r1, r4 = -(A6 ? (B4 + Math.sqrt(B4 * B4 - 4 * A6 * C5)) / (2 * A6) : C5 / B4);
  return {
    x: x13 + xa + xb * r4,
    y: y13 + ya + yb * r4,
    r: r4
  };
}
var init_enclose = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/pack/enclose.js"() {
    init_array6();
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/pack/siblings.js
function place(b3, a4, c2) {
  var dx = b3.x - a4.x, x7, a22, dy = b3.y - a4.y, y7, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a4.r + c2.r, a22 *= a22;
    b22 = b3.r + c2.r, b22 *= b22;
    if (a22 > b22) {
      x7 = (d2 + b22 - a22) / (2 * d2);
      y7 = Math.sqrt(Math.max(0, b22 / d2 - x7 * x7));
      c2.x = b3.x - x7 * dx - y7 * dy;
      c2.y = b3.y - x7 * dy + y7 * dx;
    } else {
      x7 = (d2 + a22 - b22) / (2 * d2);
      y7 = Math.sqrt(Math.max(0, a22 / d2 - x7 * x7));
      c2.x = a4.x + x7 * dx - y7 * dy;
      c2.y = a4.y + x7 * dy + y7 * dx;
    }
  } else {
    c2.x = a4.x + c2.r;
    c2.y = a4.y;
  }
}
function intersects(a4, b3) {
  var dr = a4.r + b3.r - 1e-6, dx = b3.x - a4.x, dy = b3.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a4 = node._, b3 = node.next._, ab = a4.r + b3.r, dx = (a4.x * b3.r + b3.x * a4.r) / ab, dy = (a4.y * b3.r + b3.y * a4.r) / ab;
  return dx * dx + dy * dy;
}
function Node2(circle3) {
  this._ = circle3;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n = (circles = array_default4(circles)).length))
    return 0;
  var a4, b3, c2, n, aa, ca, i, j, k4, sj, sk;
  a4 = circles[0], a4.x = 0, a4.y = 0;
  if (!(n > 1))
    return a4.r;
  b3 = circles[1], a4.x = -b3.r, b3.x = a4.r, b3.y = 0;
  if (!(n > 2))
    return a4.r + b3.r;
  place(b3, a4, c2 = circles[2]);
  a4 = new Node2(a4), b3 = new Node2(b3), c2 = new Node2(c2);
  a4.next = c2.previous = b3;
  b3.next = a4.previous = c2;
  c2.next = b3.previous = a4;
  pack:
    for (i = 3; i < n; ++i) {
      place(a4._, b3._, c2 = circles[i]), c2 = new Node2(c2);
      j = b3.next, k4 = a4.previous, sj = b3._.r, sk = a4._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c2._)) {
            b3 = j, a4.next = b3, b3.previous = a4, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k4._, c2._)) {
            a4 = k4, a4.next = b3, b3.previous = a4, --i;
            continue pack;
          }
          sk += k4._.r, k4 = k4.previous;
        }
      } while (j !== k4.next);
      c2.previous = a4, c2.next = b3, a4.next = b3.previous = b3 = c2;
      aa = score(a4);
      while ((c2 = c2.next) !== b3) {
        if ((ca = score(c2)) < aa) {
          a4 = c2, aa = ca;
        }
      }
      b3 = a4.next;
    }
  a4 = [b3._], c2 = b3;
  while ((c2 = c2.next) !== b3)
    a4.push(c2._);
  c2 = enclose_default(a4);
  for (i = 0; i < n; ++i)
    a4 = circles[i], a4.x -= c2.x, a4.y -= c2.y;
  return c2.r;
}
var init_siblings = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/pack/siblings.js"() {
    init_array6();
    init_enclose();
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}
var init_accessors = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/accessors.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default7(x7) {
  return function() {
    return x7;
  };
}
var init_constant10 = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function pack_default() {
  var radius2 = null, dx = 1, dy = 1, padding3 = constantZero;
  function pack(root2) {
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius2) {
      root2.eachBefore(radiusLeaf(radius2)).eachAfter(packChildren(padding3, 0.5)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding3, root2.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack.radius = function(x7) {
    return arguments.length ? (radius2 = optional(x7), pack) : radius2;
  };
  pack.size = function(x7) {
    return arguments.length ? (dx = +x7[0], dy = +x7[1], pack) : [dx, dy];
  };
  pack.padding = function(x7) {
    return arguments.length ? (padding3 = typeof x7 === "function" ? x7 : constant_default7(+x7), pack) : padding3;
  };
  return pack;
}
function radiusLeaf(radius2) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius2(node) || 0);
    }
  };
}
function packChildren(padding3, k4) {
  return function(node) {
    if (children5 = node.children) {
      var children5, i, n = children5.length, r2 = padding3(node) * k4 || 0, e3;
      if (r2)
        for (i = 0; i < n; ++i)
          children5[i].r += r2;
      e3 = packEnclose(children5);
      if (r2)
        for (i = 0; i < n; ++i)
          children5[i].r -= r2;
      node.r = e3 + r2;
    }
  };
}
function translateChild(k4) {
  return function(node) {
    var parent = node.parent;
    node.r *= k4;
    if (parent) {
      node.x = parent.x + k4 * node.x;
      node.y = parent.y + k4 * node.y;
    }
  };
}
var init_pack = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/pack/index.js"() {
    init_siblings();
    init_accessors();
    init_constant10();
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/round.js
function round_default3(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}
var init_round3 = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/round.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x07, y07, x13, y13) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k4 = parent.value && (x13 - x07) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y07, node.y1 = y13;
    node.x0 = x07, node.x1 = x07 += node.value * k4;
  }
}
var init_dice = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/dice.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding3 = 0, round2 = false;
  function partition5(root2) {
    var n = root2.height + 1;
    root2.x0 = root2.y0 = padding3;
    root2.x1 = dx;
    root2.y1 = dy / n;
    root2.eachBefore(positionNode(dy, n));
    if (round2)
      root2.eachBefore(round_default3);
    return root2;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x07 = node.x0, y07 = node.y0, x13 = node.x1 - padding3, y13 = node.y1 - padding3;
      if (x13 < x07)
        x07 = x13 = (x07 + x13) / 2;
      if (y13 < y07)
        y07 = y13 = (y07 + y13) / 2;
      node.x0 = x07;
      node.y0 = y07;
      node.x1 = x13;
      node.y1 = y13;
    };
  }
  partition5.round = function(x7) {
    return arguments.length ? (round2 = !!x7, partition5) : round2;
  };
  partition5.size = function(x7) {
    return arguments.length ? (dx = +x7[0], dy = +x7[1], partition5) : [dx, dy];
  };
  partition5.padding = function(x7) {
    return arguments.length ? (padding3 = +x7, partition5) : padding3;
  };
  return partition5;
}
var init_partition = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/partition.js"() {
    init_round3();
    init_dice();
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/stratify.js
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id4 = defaultId, parentId = defaultParentId;
  function stratify(data3) {
    var nodes = Array.from(data3), n = nodes.length, d, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    for (i = 0; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node(d);
      if ((nodeId = id4(d, i, data3)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d, i, data3)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root2)
          throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2)
      throw new Error("no root");
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify.id = function(x7) {
    return arguments.length ? (id4 = required(x7), stratify) : id4;
  };
  stratify.parentId = function(x7) {
    return arguments.length ? (parentId = required(x7), stratify) : parentId;
  };
  return stratify;
}
var preroot, ambiguous;
var init_stratify = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/stratify.js"() {
    init_accessors();
    init_hierarchy();
    preroot = { depth: -1 };
    ambiguous = {};
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a4, b3) {
  return a4.parent === b3.parent ? 1 : 2;
}
function nextLeft(v) {
  var children5 = v.children;
  return children5 ? children5[0] : v.t;
}
function nextRight(v) {
  var children5 = v.children;
  return children5 ? children5[children5.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change2 = shift / (wp.i - wm.i);
  wp.c -= change2;
  wp.s += shift;
  wm.c += change2;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change2 = 0, children5 = v.children, i = children5.length, w5;
  while (--i >= 0) {
    w5 = children5[i];
    w5.z += shift;
    w5.m += shift;
    shift += w5.s + (change2 += w5.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
function treeRoot(root2) {
  var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children5, i, n;
  while (node = nodes.pop()) {
    if (children5 = node._.children) {
      node.children = new Array(n = children5.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children5[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left = root2, right = root2, bottom = root2;
      root2.eachBefore(function(node) {
        if (node.x < left.x)
          left = node;
        if (node.x > right.x)
          right = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s3 = left === right ? 1 : separation(left, right) / 2, tx = s3 - left.x, kx4 = dx / (right.x + s3 + tx), ky3 = dy / (bottom.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx4;
        node.y = node.depth * ky3;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children5 = v.children, siblings = v.parent.children, w5 = v.i ? siblings[v.i - 1] : null;
    if (children5) {
      executeShifts(v);
      var midpoint = (children5[0].z + children5[children5.length - 1].z) / 2;
      if (w5) {
        v.z = w5.z + separation(v._, w5._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w5) {
      v.z = w5.z + separation(v._, w5._);
    }
    v.parent.A = apportion(v, w5, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w5, ancestor) {
    if (w5) {
      var vip = v, vop = v, vim = w5, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x7) {
    return arguments.length ? (separation = x7, tree) : separation;
  };
  tree.size = function(x7) {
    return arguments.length ? (nodeSize = false, dx = +x7[0], dy = +x7[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x7) {
    return arguments.length ? (nodeSize = true, dx = +x7[0], dy = +x7[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}
var init_tree = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/tree.js"() {
    init_hierarchy();
    TreeNode.prototype = Object.create(Node.prototype);
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x07, y07, x13, y13) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k4 = parent.value && (y13 - y07) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x07, node.x1 = x13;
    node.y0 = y07, node.y1 = y07 += node.value * k4;
  }
}
var init_slice = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/slice.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/squarify.js
function squarifyRatio(ratio, parent, x07, y07, x13, y13) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value4 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x13 - x07, dy = y13 - y07;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value4 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x07, y07, x13, value4 ? y07 += dy * sumValue / value4 : y13);
    else
      slice_default(row, x07, y07, value4 ? x07 += dx * sumValue / value4 : x13, y13);
    value4 -= sumValue, i0 = i1;
  }
  return rows;
}
var phi, squarify_default;
var init_squarify = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/squarify.js"() {
    init_dice();
    init_slice();
    phi = (1 + Math.sqrt(5)) / 2;
    squarify_default = function custom9(ratio) {
      function squarify(parent, x07, y07, x13, y13) {
        squarifyRatio(ratio, parent, x07, y07, x13, y13);
      }
      squarify.ratio = function(x7) {
        return custom9((x7 = +x7) > 1 ? x7 : 1);
      };
      return squarify;
    }(phi);
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner2 = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round2)
      root2.eachBefore(round_default3);
    return root2;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x07 = node.x0 + p, y07 = node.y0 + p, x13 = node.x1 - p, y13 = node.y1 - p;
    if (x13 < x07)
      x07 = x13 = (x07 + x13) / 2;
    if (y13 < y07)
      y07 = y13 = (y07 + y13) / 2;
    node.x0 = x07;
    node.y0 = y07;
    node.x1 = x13;
    node.y1 = y13;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner2(node) / 2;
      x07 += paddingLeft(node) - p;
      y07 += paddingTop(node) - p;
      x13 -= paddingRight(node) - p;
      y13 -= paddingBottom(node) - p;
      if (x13 < x07)
        x07 = x13 = (x07 + x13) / 2;
      if (y13 < y07)
        y07 = y13 = (y07 + y13) / 2;
      tile(node, x07, y07, x13, y13);
    }
  }
  treemap.round = function(x7) {
    return arguments.length ? (round2 = !!x7, treemap) : round2;
  };
  treemap.size = function(x7) {
    return arguments.length ? (dx = +x7[0], dy = +x7[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x7) {
    return arguments.length ? (tile = required(x7), treemap) : tile;
  };
  treemap.padding = function(x7) {
    return arguments.length ? treemap.paddingInner(x7).paddingOuter(x7) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x7) {
    return arguments.length ? (paddingInner2 = typeof x7 === "function" ? x7 : constant_default7(+x7), treemap) : paddingInner2;
  };
  treemap.paddingOuter = function(x7) {
    return arguments.length ? treemap.paddingTop(x7).paddingRight(x7).paddingBottom(x7).paddingLeft(x7) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x7) {
    return arguments.length ? (paddingTop = typeof x7 === "function" ? x7 : constant_default7(+x7), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x7) {
    return arguments.length ? (paddingRight = typeof x7 === "function" ? x7 : constant_default7(+x7), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x7) {
    return arguments.length ? (paddingBottom = typeof x7 === "function" ? x7 : constant_default7(+x7), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x7) {
    return arguments.length ? (paddingLeft = typeof x7 === "function" ? x7 : constant_default7(+x7), treemap) : paddingLeft;
  };
  return treemap;
}
var init_treemap = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/index.js"() {
    init_round3();
    init_squarify();
    init_accessors();
    init_constant10();
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x07, y07, x13, y13) {
  var nodes = parent.children, i, n = nodes.length, sum6, sums = new Array(n + 1);
  for (sums[0] = sum6 = i = 0; i < n; ++i) {
    sums[i + 1] = sum6 += nodes[i].value;
  }
  partition5(0, n, parent.value, x07, y07, x13, y13);
  function partition5(i2, j, value4, x08, y08, x14, y14) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x08, node.y0 = y08;
      node.x1 = x14, node.y1 = y14;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value4 / 2 + valueOffset, k4 = i2 + 1, hi = j - 1;
    while (k4 < hi) {
      var mid = k4 + hi >>> 1;
      if (sums[mid] < valueTarget)
        k4 = mid + 1;
      else
        hi = mid;
    }
    if (valueTarget - sums[k4 - 1] < sums[k4] - valueTarget && i2 + 1 < k4)
      --k4;
    var valueLeft = sums[k4] - valueOffset, valueRight = value4 - valueLeft;
    if (x14 - x08 > y14 - y08) {
      var xk = value4 ? (x08 * valueRight + x14 * valueLeft) / value4 : x14;
      partition5(i2, k4, valueLeft, x08, y08, xk, y14);
      partition5(k4, j, valueRight, xk, y08, x14, y14);
    } else {
      var yk = value4 ? (y08 * valueRight + y14 * valueLeft) / value4 : y14;
      partition5(i2, k4, valueLeft, x08, y08, x14, yk);
      partition5(k4, j, valueRight, x08, yk, x14, y14);
    }
  }
}
var init_binary = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/binary.js"() {
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x07, y07, x13, y13) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x07, y07, x13, y13);
}
var init_sliceDice = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/sliceDice.js"() {
    init_dice();
    init_slice();
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default;
var init_resquarify = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/treemap/resquarify.js"() {
    init_dice();
    init_slice();
    init_squarify();
    resquarify_default = function custom10(ratio) {
      function resquarify(parent, x07, y07, x13, y13) {
        if ((rows = parent._squarify) && rows.ratio === ratio) {
          var rows, row, nodes, i, j = -1, n, m2 = rows.length, value4 = parent.value;
          while (++j < m2) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i)
              row.value += nodes[i].value;
            if (row.dice)
              dice_default(row, x07, y07, x13, value4 ? y07 += (y13 - y07) * row.value / value4 : y13);
            else
              slice_default(row, x07, y07, value4 ? x07 += (x13 - x07) * row.value / value4 : x13, y13);
            value4 -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x07, y07, x13, y13);
          rows.ratio = ratio;
        }
      }
      resquarify.ratio = function(x7) {
        return custom10((x7 = +x7) > 1 ? x7 : 1);
      };
      return resquarify;
    }(phi);
  }
});

// node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/index.js
var init_src27 = __esm({
  "node_modules/.pnpm/d3-hierarchy@2.0.0/node_modules/d3-hierarchy/src/index.js"() {
    init_cluster();
    init_hierarchy();
    init_pack();
    init_siblings();
    init_enclose();
    init_partition();
    init_stratify();
    init_tree();
    init_treemap();
    init_binary();
    init_dice();
    init_slice();
    init_sliceDice();
    init_squarify();
    init_resquarify();
  }
});

// node_modules/.pnpm/vega-hierarchy@4.0.9/node_modules/vega-hierarchy/build/vega-hierarchy.module.js
var vega_hierarchy_module_exports = {};
__export(vega_hierarchy_module_exports, {
  nest: () => Nest,
  pack: () => Pack,
  partition: () => Partition,
  stratify: () => Stratify,
  tree: () => Tree,
  treelinks: () => TreeLinks,
  treemap: () => Treemap
});
function lookup3(tree, key3, filter6) {
  const map11 = {};
  tree.each((node) => {
    const t = node.data;
    if (filter6(t))
      map11[key3(t)] = node;
  });
  tree.lookup = map11;
  return tree;
}
function Nest(params2) {
  Transform.call(this, null, params2);
}
function nest() {
  const keys5 = [], nest2 = {
    entries: (array9) => entries3(apply3(array9, 0), 0),
    key: (d) => (keys5.push(d), nest2)
  };
  function apply3(array9, depth) {
    if (depth >= keys5.length) {
      return array9;
    }
    const n = array9.length, key3 = keys5[depth++], valuesByKey = {}, result = {};
    let i = -1, keyValue, value4, values5;
    while (++i < n) {
      keyValue = key3(value4 = array9[i]) + "";
      if (values5 = valuesByKey[keyValue]) {
        values5.push(value4);
      } else {
        valuesByKey[keyValue] = [value4];
      }
    }
    for (keyValue in valuesByKey) {
      result[keyValue] = apply3(valuesByKey[keyValue], depth);
    }
    return result;
  }
  function entries3(map11, depth) {
    if (++depth > keys5.length)
      return map11;
    const array9 = [];
    for (const key3 in map11) {
      array9.push({
        key: key3,
        values: entries3(map11[key3], depth)
      });
    }
    return array9;
  }
  return nest2;
}
function HierarchyLayout(params2) {
  Transform.call(this, null, params2);
}
function setParams(layout, params2, _) {
  for (let p, i = 0, n = params2.length; i < n; ++i) {
    p = params2[i];
    if (p in _)
      layout[p](_[p]);
  }
}
function setFields(node, fields, as) {
  const t = node.data, n = fields.length - 1;
  for (let i = 0; i < n; ++i) {
    t[as[i]] = node[fields[i]];
  }
  t[as[n]] = node.children ? node.children.length : 0;
}
function Pack(params2) {
  HierarchyLayout.call(this, params2);
}
function Partition(params2) {
  HierarchyLayout.call(this, params2);
}
function Stratify(params2) {
  Transform.call(this, null, params2);
}
function Tree(params2) {
  HierarchyLayout.call(this, params2);
}
function TreeLinks(params2) {
  Transform.call(this, [], params2);
}
function Treemap(params2) {
  HierarchyLayout.call(this, params2);
}
var children, defaultSeparation3, Output2, Output$1, Layouts, Output$2, Tiles, Output$3;
var init_vega_hierarchy_module = __esm({
  "node_modules/.pnpm/vega-hierarchy@4.0.9/node_modules/vega-hierarchy/build/vega-hierarchy.module.js"() {
    init_vega_dataflow_module();
    init_vega_util_module();
    init_src27();
    Nest.Definition = {
      "type": "Nest",
      "metadata": {
        "treesource": true,
        "changes": true
      },
      "params": [{
        "name": "keys",
        "type": "field",
        "array": true
      }, {
        "name": "generate",
        "type": "boolean"
      }]
    };
    children = (n) => n.values;
    inherits(Nest, Transform, {
      transform(_, pulse2) {
        if (!pulse2.source) {
          error("Nest transform requires an upstream data source.");
        }
        var gen = _.generate, mod = _.modified(), out = pulse2.clone(), tree = this.value;
        if (!tree || mod || pulse2.changed()) {
          if (tree) {
            tree.each((node) => {
              if (node.children && isTuple(node.data)) {
                out.rem.push(node.data);
              }
            });
          }
          this.value = tree = hierarchy({
            values: array(_.keys).reduce((n, k4) => {
              n.key(k4);
              return n;
            }, nest()).entries(out.source)
          }, children);
          if (gen) {
            tree.each((node) => {
              if (node.children) {
                node = ingest$1(node.data);
                out.add.push(node);
                out.source.push(node);
              }
            });
          }
          lookup3(tree, tupleid, tupleid);
        }
        out.source.root = tree;
        return out;
      }
    });
    defaultSeparation3 = (a4, b3) => a4.parent === b3.parent ? 1 : 2;
    inherits(HierarchyLayout, Transform, {
      transform(_, pulse2) {
        if (!pulse2.source || !pulse2.source.root) {
          error(this.constructor.name + " transform requires a backing tree data source.");
        }
        const layout = this.layout(_.method), fields = this.fields, root2 = pulse2.source.root, as = _.as || fields;
        if (_.field)
          root2.sum(_.field);
        else
          root2.count();
        if (_.sort)
          root2.sort(stableCompare(_.sort, (d) => d.data));
        setParams(layout, this.params, _);
        if (layout.separation) {
          layout.separation(_.separation !== false ? defaultSeparation3 : one);
        }
        try {
          this.value = layout(root2);
        } catch (err) {
          error(err);
        }
        root2.each((node) => setFields(node, fields, as));
        return pulse2.reflow(_.modified()).modifies(as).modifies("leaf");
      }
    });
    Output2 = ["x", "y", "r", "depth", "children"];
    Pack.Definition = {
      "type": "Pack",
      "metadata": {
        "tree": true,
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "sort",
        "type": "compare"
      }, {
        "name": "padding",
        "type": "number",
        "default": 0
      }, {
        "name": "radius",
        "type": "field",
        "default": null
      }, {
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": Output2.length,
        "default": Output2
      }]
    };
    inherits(Pack, HierarchyLayout, {
      layout: pack_default,
      params: ["radius", "size", "padding"],
      fields: Output2
    });
    Output$1 = ["x0", "y0", "x1", "y1", "depth", "children"];
    Partition.Definition = {
      "type": "Partition",
      "metadata": {
        "tree": true,
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "sort",
        "type": "compare"
      }, {
        "name": "padding",
        "type": "number",
        "default": 0
      }, {
        "name": "round",
        "type": "boolean",
        "default": false
      }, {
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": Output$1.length,
        "default": Output$1
      }]
    };
    inherits(Partition, HierarchyLayout, {
      layout: partition_default,
      params: ["size", "round", "padding"],
      fields: Output$1
    });
    Stratify.Definition = {
      "type": "Stratify",
      "metadata": {
        "treesource": true
      },
      "params": [{
        "name": "key",
        "type": "field",
        "required": true
      }, {
        "name": "parentKey",
        "type": "field",
        "required": true
      }]
    };
    inherits(Stratify, Transform, {
      transform(_, pulse2) {
        if (!pulse2.source) {
          error("Stratify transform requires an upstream data source.");
        }
        let tree = this.value;
        const mod = _.modified(), out = pulse2.fork(pulse2.ALL).materialize(pulse2.SOURCE), run2 = !tree || mod || pulse2.changed(pulse2.ADD_REM) || pulse2.modified(_.key.fields) || pulse2.modified(_.parentKey.fields);
        out.source = out.source.slice();
        if (run2) {
          tree = out.source.length ? lookup3(stratify_default().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup3(stratify_default()([{}]), _.key, _.key);
        }
        out.source.root = this.value = tree;
        return out;
      }
    });
    Layouts = {
      tidy: tree_default,
      cluster: cluster_default
    };
    Output$2 = ["x", "y", "depth", "children"];
    Tree.Definition = {
      "type": "Tree",
      "metadata": {
        "tree": true,
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "sort",
        "type": "compare"
      }, {
        "name": "method",
        "type": "enum",
        "default": "tidy",
        "values": ["tidy", "cluster"]
      }, {
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "nodeSize",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "separation",
        "type": "boolean",
        "default": true
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": Output$2.length,
        "default": Output$2
      }]
    };
    inherits(Tree, HierarchyLayout, {
      layout(method3) {
        const m2 = method3 || "tidy";
        if (has(Layouts, m2))
          return Layouts[m2]();
        else
          error("Unrecognized Tree layout method: " + m2);
      },
      params: ["size", "nodeSize"],
      fields: Output$2
    });
    TreeLinks.Definition = {
      "type": "TreeLinks",
      "metadata": {
        "tree": true,
        "generates": true,
        "changes": true
      },
      "params": []
    };
    inherits(TreeLinks, Transform, {
      transform(_, pulse2) {
        const links = this.value, tree = pulse2.source && pulse2.source.root, out = pulse2.fork(pulse2.NO_SOURCE), lut = {};
        if (!tree)
          error("TreeLinks transform requires a tree data source.");
        if (pulse2.changed(pulse2.ADD_REM)) {
          out.rem = links;
          pulse2.visit(pulse2.SOURCE, (t) => lut[tupleid(t)] = 1);
          tree.each((node) => {
            const t = node.data, p = node.parent && node.parent.data;
            if (p && lut[tupleid(t)] && lut[tupleid(p)]) {
              out.add.push(ingest$1({
                source: p,
                target: t
              }));
            }
          });
          this.value = out.add;
        } else if (pulse2.changed(pulse2.MOD)) {
          pulse2.visit(pulse2.MOD, (t) => lut[tupleid(t)] = 1);
          links.forEach((link3) => {
            if (lut[tupleid(link3.source)] || lut[tupleid(link3.target)]) {
              out.mod.push(link3);
            }
          });
        }
        return out;
      }
    });
    Tiles = {
      binary: binary_default,
      dice: dice_default,
      slice: slice_default,
      slicedice: sliceDice_default,
      squarify: squarify_default,
      resquarify: resquarify_default
    };
    Output$3 = ["x0", "y0", "x1", "y1", "depth", "children"];
    Treemap.Definition = {
      "type": "Treemap",
      "metadata": {
        "tree": true,
        "modifies": true
      },
      "params": [{
        "name": "field",
        "type": "field"
      }, {
        "name": "sort",
        "type": "compare"
      }, {
        "name": "method",
        "type": "enum",
        "default": "squarify",
        "values": ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
      }, {
        "name": "padding",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingInner",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingOuter",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingTop",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingRight",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingBottom",
        "type": "number",
        "default": 0
      }, {
        "name": "paddingLeft",
        "type": "number",
        "default": 0
      }, {
        "name": "ratio",
        "type": "number",
        "default": 1.618033988749895
      }, {
        "name": "round",
        "type": "boolean",
        "default": false
      }, {
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": Output$3.length,
        "default": Output$3
      }]
    };
    inherits(Treemap, HierarchyLayout, {
      layout() {
        const x7 = treemap_default();
        x7.ratio = (_) => {
          const t = x7.tile();
          if (t.ratio)
            x7.tile(t.ratio(_));
        };
        x7.method = (_) => {
          if (has(Tiles, _))
            x7.tile(Tiles[_]);
          else
            error("Unrecognized Treemap layout method: " + _);
        };
        return x7;
      },
      params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
      fields: Output$3
    });
  }
});

// node_modules/.pnpm/d3-path@2.0.0/node_modules/d3-path/src/path.js
function Path2() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path3() {
  return new Path2();
}
var pi5, tau5, epsilon7, tauEpsilon2, path_default3;
var init_path5 = __esm({
  "node_modules/.pnpm/d3-path@2.0.0/node_modules/d3-path/src/path.js"() {
    pi5 = Math.PI;
    tau5 = 2 * pi5;
    epsilon7 = 1e-6;
    tauEpsilon2 = tau5 - epsilon7;
    Path2.prototype = path3.prototype = {
      constructor: Path2,
      moveTo: function(x7, y7) {
        this._ += "M" + (this._x0 = this._x1 = +x7) + "," + (this._y0 = this._y1 = +y7);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x7, y7) {
        this._ += "L" + (this._x1 = +x7) + "," + (this._y1 = +y7);
      },
      quadraticCurveTo: function(x13, y13, x7, y7) {
        this._ += "Q" + +x13 + "," + +y13 + "," + (this._x1 = +x7) + "," + (this._y1 = +y7);
      },
      bezierCurveTo: function(x13, y13, x22, y22, x7, y7) {
        this._ += "C" + +x13 + "," + +y13 + "," + +x22 + "," + +y22 + "," + (this._x1 = +x7) + "," + (this._y1 = +y7);
      },
      arcTo: function(x13, y13, x22, y22, r2) {
        x13 = +x13, y13 = +y13, x22 = +x22, y22 = +y22, r2 = +r2;
        var x07 = this._x1, y07 = this._y1, x21 = x22 - x13, y21 = y22 - y13, x01 = x07 - x13, y01 = y07 - y13, l01_2 = x01 * x01 + y01 * y01;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x13) + "," + (this._y1 = y13);
        } else if (!(l01_2 > epsilon7))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon7) || !r2) {
          this._ += "L" + (this._x1 = x13) + "," + (this._y1 = y13);
        } else {
          var x20 = x22 - x07, y20 = y22 - y07, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi5 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
          if (Math.abs(t01 - 1) > epsilon7) {
            this._ += "L" + (x13 + t01 * x01) + "," + (y13 + t01 * y01);
          }
          this._ += "A" + r2 + "," + r2 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x13 + t21 * x21) + "," + (this._y1 = y13 + t21 * y21);
        }
      },
      arc: function(x7, y7, r2, a0, a1, ccw) {
        x7 = +x7, y7 = +y7, r2 = +r2, ccw = !!ccw;
        var dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x07 = x7 + dx, y07 = y7 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + x07 + "," + y07;
        } else if (Math.abs(this._x1 - x07) > epsilon7 || Math.abs(this._y1 - y07) > epsilon7) {
          this._ += "L" + x07 + "," + y07;
        }
        if (!r2)
          return;
        if (da < 0)
          da = da % tau5 + tau5;
        if (da > tauEpsilon2) {
          this._ += "A" + r2 + "," + r2 + ",0,1," + cw2 + "," + (x7 - dx) + "," + (y7 - dy) + "A" + r2 + "," + r2 + ",0,1," + cw2 + "," + (this._x1 = x07) + "," + (this._y1 = y07);
        } else if (da > epsilon7) {
          this._ += "A" + r2 + "," + r2 + ",0," + +(da >= pi5) + "," + cw2 + "," + (this._x1 = x7 + r2 * Math.cos(a1)) + "," + (this._y1 = y7 + r2 * Math.sin(a1));
        }
      },
      rect: function(x7, y7, w5, h4) {
        this._ += "M" + (this._x0 = this._x1 = +x7) + "," + (this._y0 = this._y1 = +y7) + "h" + +w5 + "v" + +h4 + "h" + -w5 + "Z";
      },
      toString: function() {
        return this._;
      }
    };
    path_default3 = path3;
  }
});

// node_modules/.pnpm/d3-path@2.0.0/node_modules/d3-path/src/index.js
var init_src28 = __esm({
  "node_modules/.pnpm/d3-path@2.0.0/node_modules/d3-path/src/index.js"() {
    init_path5();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/constant.js
function constant_default8(x7) {
  return function constant5() {
    return x7;
  };
}
var init_constant11 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/math.js
function acos4(x7) {
  return x7 > 1 ? 0 : x7 < -1 ? pi6 : Math.acos(x7);
}
function asin4(x7) {
  return x7 >= 1 ? halfPi4 : x7 <= -1 ? -halfPi4 : Math.asin(x7);
}
var abs4, atan24, cos4, max6, min6, sin4, sqrt9, epsilon8, pi6, halfPi4, tau6;
var init_math6 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/math.js"() {
    abs4 = Math.abs;
    atan24 = Math.atan2;
    cos4 = Math.cos;
    max6 = Math.max;
    min6 = Math.min;
    sin4 = Math.sin;
    sqrt9 = Math.sqrt;
    epsilon8 = 1e-12;
    pi6 = Math.PI;
    halfPi4 = pi6 / 2;
    tau6 = 2 * pi6;
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/arc.js
function arcInnerRadius2(d) {
  return d.innerRadius;
}
function arcOuterRadius2(d) {
  return d.outerRadius;
}
function arcStartAngle2(d) {
  return d.startAngle;
}
function arcEndAngle2(d) {
  return d.endAngle;
}
function arcPadAngle2(d) {
  return d && d.padAngle;
}
function intersect3(x07, y07, x13, y13, x22, y22, x32, y32) {
  var x10 = x13 - x07, y10 = y13 - y07, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;
  if (t * t < epsilon8)
    return;
  t = (x322 * (y07 - y22) - y322 * (x07 - x22)) / t;
  return [x07 + t * x10, y07 + t * y10];
}
function cornerTangents2(x07, y07, x13, y13, r1, rc, cw2) {
  var x01 = x07 - x13, y01 = y07 - y13, lo = (cw2 ? rc : -rc) / sqrt9(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x07 + ox, y11 = y07 + oy, x10 = x13 + ox, y10 = y13 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r2 = r1 - rc, D3 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt9(max6(0, r2 * r2 * d2 - D3 * D3)), cx0 = (D3 * dy - dx * d) / d2, cy0 = (-D3 * dx - dy * d) / d2, cx1 = (D3 * dy + dx * d) / d2, cy1 = (-D3 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function arc_default2() {
  var innerRadius = arcInnerRadius2, outerRadius = arcOuterRadius2, cornerRadius = constant_default8(0), padRadius = null, startAngle = arcStartAngle2, endAngle = arcEndAngle2, padAngle = arcPadAngle2, context4 = null;
  function arc5() {
    var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi4, a1 = endAngle.apply(this, arguments) - halfPi4, da = abs4(a1 - a0), cw2 = a1 > a0;
    if (!context4)
      context4 = buffer = path_default3();
    if (r1 < r0)
      r2 = r1, r1 = r0, r0 = r2;
    if (!(r1 > epsilon8))
      context4.moveTo(0, 0);
    else if (da > tau6 - epsilon8) {
      context4.moveTo(r1 * cos4(a0), r1 * sin4(a0));
      context4.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon8) {
        context4.moveTo(r0 * cos4(a1), r0 * sin4(a1));
        context4.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon8 && (padRadius ? +padRadius.apply(this, arguments) : sqrt9(r0 * r0 + r1 * r1)), rc = min6(abs4(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t07, t15;
      if (rp > epsilon8) {
        var p02 = asin4(rp / r0 * sin4(ap)), p1 = asin4(rp / r1 * sin4(ap));
        if ((da0 -= p02 * 2) > epsilon8)
          p02 *= cw2 ? 1 : -1, a00 += p02, a10 -= p02;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon8)
          p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos4(a01), y01 = r1 * sin4(a01), x10 = r0 * cos4(a10), y10 = r0 * sin4(a10);
      if (rc > epsilon8) {
        var x11 = r1 * cos4(a11), y11 = r1 * sin4(a11), x004 = r0 * cos4(a00), y004 = r0 * sin4(a00), oc;
        if (da < pi6 && (oc = intersect3(x01, y01, x004, y004, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin4(acos4((ax * bx + ay * by) / (sqrt9(ax * ax + ay * ay) * sqrt9(bx * bx + by * by))) / 2), lc = sqrt9(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min6(rc, (r0 - lc) / (kc - 1));
          rc1 = min6(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon8))
        context4.moveTo(x01, y01);
      else if (rc1 > epsilon8) {
        t07 = cornerTangents2(x004, y004, x01, y01, r1, rc1, cw2);
        t15 = cornerTangents2(x11, y11, x10, y10, r1, rc1, cw2);
        context4.moveTo(t07.cx + t07.x01, t07.cy + t07.y01);
        if (rc1 < rc)
          context4.arc(t07.cx, t07.cy, rc1, atan24(t07.y01, t07.x01), atan24(t15.y01, t15.x01), !cw2);
        else {
          context4.arc(t07.cx, t07.cy, rc1, atan24(t07.y01, t07.x01), atan24(t07.y11, t07.x11), !cw2);
          context4.arc(0, 0, r1, atan24(t07.cy + t07.y11, t07.cx + t07.x11), atan24(t15.cy + t15.y11, t15.cx + t15.x11), !cw2);
          context4.arc(t15.cx, t15.cy, rc1, atan24(t15.y11, t15.x11), atan24(t15.y01, t15.x01), !cw2);
        }
      } else
        context4.moveTo(x01, y01), context4.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon8) || !(da0 > epsilon8))
        context4.lineTo(x10, y10);
      else if (rc0 > epsilon8) {
        t07 = cornerTangents2(x10, y10, x11, y11, r0, -rc0, cw2);
        t15 = cornerTangents2(x01, y01, x004, y004, r0, -rc0, cw2);
        context4.lineTo(t07.cx + t07.x01, t07.cy + t07.y01);
        if (rc0 < rc)
          context4.arc(t07.cx, t07.cy, rc0, atan24(t07.y01, t07.x01), atan24(t15.y01, t15.x01), !cw2);
        else {
          context4.arc(t07.cx, t07.cy, rc0, atan24(t07.y01, t07.x01), atan24(t07.y11, t07.x11), !cw2);
          context4.arc(0, 0, r0, atan24(t07.cy + t07.y11, t07.cx + t07.x11), atan24(t15.cy + t15.y11, t15.cx + t15.x11), cw2);
          context4.arc(t15.cx, t15.cy, rc0, atan24(t15.y11, t15.x11), atan24(t15.y01, t15.x01), !cw2);
        }
      } else
        context4.arc(0, 0, r0, a10, a00, cw2);
    }
    context4.closePath();
    if (buffer)
      return context4 = null, buffer + "" || null;
  }
  arc5.centroid = function() {
    var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi6 / 2;
    return [cos4(a4) * r2, sin4(a4) * r2];
  };
  arc5.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default8(+_), arc5) : innerRadius;
  };
  arc5.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default8(+_), arc5) : outerRadius;
  };
  arc5.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default8(+_), arc5) : cornerRadius;
  };
  arc5.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default8(+_), arc5) : padRadius;
  };
  arc5.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default8(+_), arc5) : startAngle;
  };
  arc5.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default8(+_), arc5) : endAngle;
  };
  arc5.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default8(+_), arc5) : padAngle;
  };
  arc5.context = function(_) {
    return arguments.length ? (context4 = _ == null ? null : _, arc5) : context4;
  };
  return arc5;
}
var init_arc2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/arc.js"() {
    init_src28();
    init_constant11();
    init_math6();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/array.js
function array_default5(x7) {
  return typeof x7 === "object" && "length" in x7 ? x7 : Array.from(x7);
}
var slice6;
var init_array7 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/array.js"() {
    slice6 = Array.prototype.slice;
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/linear.js
function Linear4(context4) {
  this._context = context4;
}
function linear_default2(context4) {
  return new Linear4(context4);
}
var init_linear4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/linear.js"() {
    Linear4.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
          default:
            this._context.lineTo(x7, y7);
            break;
        }
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/point.js
function x5(p) {
  return p[0];
}
function y5(p) {
  return p[1];
}
var init_point2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/point.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/line.js
function line_default3(x7, y7) {
  var defined2 = constant_default8(true), context4 = null, curve2 = linear_default2, output3 = null;
  x7 = typeof x7 === "function" ? x7 : x7 === void 0 ? x5 : constant_default8(x7);
  y7 = typeof y7 === "function" ? y7 : y7 === void 0 ? y5 : constant_default8(y7);
  function line5(data3) {
    var i, n = (data3 = array_default5(data3)).length, d, defined0 = false, buffer;
    if (context4 == null)
      output3 = curve2(buffer = path_default3());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          output3.lineStart();
        else
          output3.lineEnd();
      }
      if (defined0)
        output3.point(+x7(d, i, data3), +y7(d, i, data3));
    }
    if (buffer)
      return output3 = null, buffer + "" || null;
  }
  line5.x = function(_) {
    return arguments.length ? (x7 = typeof _ === "function" ? _ : constant_default8(+_), line5) : x7;
  };
  line5.y = function(_) {
    return arguments.length ? (y7 = typeof _ === "function" ? _ : constant_default8(+_), line5) : y7;
  };
  line5.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default8(!!_), line5) : defined2;
  };
  line5.curve = function(_) {
    return arguments.length ? (curve2 = _, context4 != null && (output3 = curve2(context4)), line5) : curve2;
  };
  line5.context = function(_) {
    return arguments.length ? (_ == null ? context4 = output3 = null : output3 = curve2(context4 = _), line5) : context4;
  };
  return line5;
}
var init_line3 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/line.js"() {
    init_src28();
    init_array7();
    init_constant11();
    init_linear4();
    init_point2();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/area.js
function area_default4(x07, y07, y13) {
  var x13 = null, defined2 = constant_default8(true), context4 = null, curve2 = linear_default2, output3 = null;
  x07 = typeof x07 === "function" ? x07 : x07 === void 0 ? x5 : constant_default8(+x07);
  y07 = typeof y07 === "function" ? y07 : y07 === void 0 ? constant_default8(0) : constant_default8(+y07);
  y13 = typeof y13 === "function" ? y13 : y13 === void 0 ? y5 : constant_default8(+y13);
  function area5(data3) {
    var i, j, k4, n = (data3 = array_default5(data3)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context4 == null)
      output3 = curve2(buffer = path_default3());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output3.areaStart();
          output3.lineStart();
        } else {
          output3.lineEnd();
          output3.lineStart();
          for (k4 = i - 1; k4 >= j; --k4) {
            output3.point(x0z[k4], y0z[k4]);
          }
          output3.lineEnd();
          output3.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x07(d, i, data3), y0z[i] = +y07(d, i, data3);
        output3.point(x13 ? +x13(d, i, data3) : x0z[i], y13 ? +y13(d, i, data3) : y0z[i]);
      }
    }
    if (buffer)
      return output3 = null, buffer + "" || null;
  }
  function arealine() {
    return line_default3().defined(defined2).curve(curve2).context(context4);
  }
  area5.x = function(_) {
    return arguments.length ? (x07 = typeof _ === "function" ? _ : constant_default8(+_), x13 = null, area5) : x07;
  };
  area5.x0 = function(_) {
    return arguments.length ? (x07 = typeof _ === "function" ? _ : constant_default8(+_), area5) : x07;
  };
  area5.x1 = function(_) {
    return arguments.length ? (x13 = _ == null ? null : typeof _ === "function" ? _ : constant_default8(+_), area5) : x13;
  };
  area5.y = function(_) {
    return arguments.length ? (y07 = typeof _ === "function" ? _ : constant_default8(+_), y13 = null, area5) : y07;
  };
  area5.y0 = function(_) {
    return arguments.length ? (y07 = typeof _ === "function" ? _ : constant_default8(+_), area5) : y07;
  };
  area5.y1 = function(_) {
    return arguments.length ? (y13 = _ == null ? null : typeof _ === "function" ? _ : constant_default8(+_), area5) : y13;
  };
  area5.lineX0 = area5.lineY0 = function() {
    return arealine().x(x07).y(y07);
  };
  area5.lineY1 = function() {
    return arealine().x(x07).y(y13);
  };
  area5.lineX1 = function() {
    return arealine().x(x13).y(y07);
  };
  area5.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default8(!!_), area5) : defined2;
  };
  area5.curve = function(_) {
    return arguments.length ? (curve2 = _, context4 != null && (output3 = curve2(context4)), area5) : curve2;
  };
  area5.context = function(_) {
    return arguments.length ? (_ == null ? context4 = output3 = null : output3 = curve2(context4 = _), area5) : context4;
  };
  return area5;
}
var init_area4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/area.js"() {
    init_src28();
    init_array7();
    init_constant11();
    init_linear4();
    init_line3();
    init_point2();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/descending.js
var init_descending5 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/descending.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/identity.js
var init_identity11 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/identity.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/pie.js
var init_pie2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/pie.js"() {
    init_array7();
    init_constant11();
    init_descending5();
    init_identity11();
    init_math6();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/radial.js
function Radial2(curve2) {
  this._curve = curve2;
}
function curveRadial2(curve2) {
  function radial3(context4) {
    return new Radial2(curve2(context4));
  }
  radial3._curve = curve2;
  return radial3;
}
var curveRadialLinear2;
var init_radial5 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/radial.js"() {
    init_linear4();
    curveRadialLinear2 = curveRadial2(linear_default2);
    Radial2.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a4, r2) {
        this._curve.point(r2 * Math.sin(a4), r2 * -Math.cos(a4));
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/lineRadial.js
var init_lineRadial2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/lineRadial.js"() {
    init_radial5();
    init_line3();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/areaRadial.js
var init_areaRadial2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/areaRadial.js"() {
    init_radial5();
    init_area4();
    init_lineRadial2();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/pointRadial.js
var init_pointRadial2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/pointRadial.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/link/index.js
var init_link3 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/link/index.js"() {
    init_src28();
    init_array7();
    init_constant11();
    init_point2();
    init_pointRadial2();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/circle.js
var circle_default4;
var init_circle4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/circle.js"() {
    init_math6();
    circle_default4 = {
      draw: function(context4, size) {
        var r2 = Math.sqrt(size / pi6);
        context4.moveTo(r2, 0);
        context4.arc(0, 0, r2, 0, tau6);
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/cross.js
var init_cross4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/cross.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/diamond.js
var tan302, tan30_22;
var init_diamond3 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/diamond.js"() {
    tan302 = Math.sqrt(1 / 3);
    tan30_22 = tan302 * 2;
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/star.js
var kr2, kx3, ky2;
var init_star2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/star.js"() {
    init_math6();
    kr2 = Math.sin(pi6 / 10) / Math.sin(7 * pi6 / 10);
    kx3 = Math.sin(tau6 / 10) * kr2;
    ky2 = -Math.cos(tau6 / 10) * kr2;
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/square.js
var init_square4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/square.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/triangle.js
var sqrt35;
var init_triangle3 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/triangle.js"() {
    sqrt35 = Math.sqrt(3);
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/wye.js
var s2, k3, a3;
var init_wye2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol/wye.js"() {
    s2 = Math.sqrt(3) / 2;
    k3 = 1 / Math.sqrt(12);
    a3 = (k3 / 2 + 1) * 3;
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol.js
function symbol_default(type4, size) {
  var context4 = null;
  type4 = typeof type4 === "function" ? type4 : constant_default8(type4 || circle_default4);
  size = typeof size === "function" ? size : constant_default8(size === void 0 ? 64 : +size);
  function symbol3() {
    var buffer;
    if (!context4)
      context4 = buffer = path_default3();
    type4.apply(this, arguments).draw(context4, +size.apply(this, arguments));
    if (buffer)
      return context4 = null, buffer + "" || null;
  }
  symbol3.type = function(_) {
    return arguments.length ? (type4 = typeof _ === "function" ? _ : constant_default8(_), symbol3) : type4;
  };
  symbol3.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default8(+_), symbol3) : size;
  };
  symbol3.context = function(_) {
    return arguments.length ? (context4 = _ == null ? null : _, symbol3) : context4;
  };
  return symbol3;
}
var init_symbol2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/symbol.js"() {
    init_src28();
    init_circle4();
    init_cross4();
    init_diamond3();
    init_star2();
    init_square4();
    init_triangle3();
    init_wye2();
    init_constant11();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/noop.js
function noop_default3() {
}
var init_noop4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/noop.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/basis.js
function point10(that, x7, y7) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x7) / 6,
    (that._y0 + 4 * that._y1 + y7) / 6
  );
}
function Basis2(context4) {
  this._context = context4;
}
function basis_default4(context4) {
  return new Basis2(context4);
}
var init_basis4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/basis.js"() {
    Basis2.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3:
            point10(this, this._x1, this._y1);
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
          default:
            point10(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = x7;
        this._y0 = this._y1, this._y1 = y7;
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed2(context4) {
  this._context = context4;
}
function basisClosed_default4(context4) {
  return new BasisClosed2(context4);
}
var init_basisClosed4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/basisClosed.js"() {
    init_noop4();
    init_basis4();
    BasisClosed2.prototype = {
      areaStart: noop_default3,
      areaEnd: noop_default3,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x2 = x7, this._y2 = y7;
            break;
          case 1:
            this._point = 2;
            this._x3 = x7, this._y3 = y7;
            break;
          case 2:
            this._point = 3;
            this._x4 = x7, this._y4 = y7;
            this._context.moveTo((this._x0 + 4 * this._x1 + x7) / 6, (this._y0 + 4 * this._y1 + y7) / 6);
            break;
          default:
            point10(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = x7;
        this._y0 = this._y1, this._y1 = y7;
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen2(context4) {
  this._context = context4;
}
function basisOpen_default2(context4) {
  return new BasisOpen2(context4);
}
var init_basisOpen2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/basisOpen.js"() {
    init_basis4();
    BasisOpen2.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            var x07 = (this._x0 + 4 * this._x1 + x7) / 6, y07 = (this._y0 + 4 * this._y1 + y7) / 6;
            this._line ? this._context.lineTo(x07, y07) : this._context.moveTo(x07, y07);
            break;
          case 3:
            this._point = 4;
          default:
            point10(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = x7;
        this._y0 = this._y1, this._y1 = y7;
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/bump.js
var init_bump2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/bump.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/bundle.js
function Bundle2(context4, beta) {
  this._basis = new Basis2(context4);
  this._beta = beta;
}
var bundle_default2;
var init_bundle2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/bundle.js"() {
    init_basis4();
    Bundle2.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x7 = this._x, y7 = this._y, j = x7.length - 1;
        if (j > 0) {
          var x07 = x7[0], y07 = y7[0], dx = x7[j] - x07, dy = y7[j] - y07, i = -1, t;
          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x7[i] + (1 - this._beta) * (x07 + t * dx),
              this._beta * y7[i] + (1 - this._beta) * (y07 + t * dy)
            );
          }
        }
        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x7, y7) {
        this._x.push(+x7);
        this._y.push(+y7);
      }
    };
    bundle_default2 = function custom11(beta) {
      function bundle3(context4) {
        return beta === 1 ? new Basis2(context4) : new Bundle2(context4, beta);
      }
      bundle3.beta = function(beta2) {
        return custom11(+beta2);
      };
      return bundle3;
    }(0.85);
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/cardinal.js
function point11(that, x7, y7) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x7),
    that._y2 + that._k * (that._y1 - y7),
    that._x2,
    that._y2
  );
}
function Cardinal2(context4, tension) {
  this._context = context4;
  this._k = (1 - tension) / 6;
}
var cardinal_default2;
var init_cardinal2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/cardinal.js"() {
    Cardinal2.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            point11(this, this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
            this._x1 = x7, this._y1 = y7;
            break;
          case 2:
            this._point = 3;
          default:
            point11(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    cardinal_default2 = function custom12(tension) {
      function cardinal(context4) {
        return new Cardinal2(context4, tension);
      }
      cardinal.tension = function(tension2) {
        return custom12(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed2(context4, tension) {
  this._context = context4;
  this._k = (1 - tension) / 6;
}
var cardinalClosed_default2;
var init_cardinalClosed2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/cardinalClosed.js"() {
    init_noop4();
    init_cardinal2();
    CardinalClosed2.prototype = {
      areaStart: noop_default3,
      areaEnd: noop_default3,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x7, this._y3 = y7;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x7, this._y4 = y7);
            break;
          case 2:
            this._point = 3;
            this._x5 = x7, this._y5 = y7;
            break;
          default:
            point11(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    cardinalClosed_default2 = function custom13(tension) {
      function cardinal(context4) {
        return new CardinalClosed2(context4, tension);
      }
      cardinal.tension = function(tension2) {
        return custom13(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen2(context4, tension) {
  this._context = context4;
  this._k = (1 - tension) / 6;
}
var cardinalOpen_default2;
var init_cardinalOpen2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/cardinalOpen.js"() {
    init_cardinal2();
    CardinalOpen2.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point11(this, x7, y7);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    cardinalOpen_default2 = function custom14(tension) {
      function cardinal(context4) {
        return new CardinalOpen2(context4, tension);
      }
      cardinal.tension = function(tension2) {
        return custom14(+tension2);
      };
      return cardinal;
    }(0);
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/catmullRom.js
function point12(that, x7, y7) {
  var x13 = that._x1, y13 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon8) {
    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x13 = (x13 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y13 = (y13 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon8) {
    var b3 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b3 + that._x1 * that._l23_2a - x7 * that._l12_2a) / m2;
    y22 = (y22 * b3 + that._y1 * that._l23_2a - y7 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x13, y13, x22, y22, that._x2, that._y2);
}
function CatmullRom2(context4, alpha) {
  this._context = context4;
  this._alpha = alpha;
}
var catmullRom_default2;
var init_catmullRom2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/catmullRom.js"() {
    init_math6();
    init_cardinal2();
    CatmullRom2.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            this.point(this._x2, this._y2);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        if (this._point) {
          var x23 = this._x2 - x7, y23 = this._y2 - y7;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
          default:
            point12(this, x7, y7);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    catmullRom_default2 = function custom15(alpha) {
      function catmullRom(context4) {
        return alpha ? new CatmullRom2(context4, alpha) : new Cardinal2(context4, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom15(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed2(context4, alpha) {
  this._context = context4;
  this._alpha = alpha;
}
var catmullRomClosed_default2;
var init_catmullRomClosed2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/catmullRomClosed.js"() {
    init_cardinalClosed2();
    init_noop4();
    init_catmullRom2();
    CatmullRomClosed2.prototype = {
      areaStart: noop_default3,
      areaEnd: noop_default3,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        if (this._point) {
          var x23 = this._x2 - x7, y23 = this._y2 - y7;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x7, this._y3 = y7;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x7, this._y4 = y7);
            break;
          case 2:
            this._point = 3;
            this._x5 = x7, this._y5 = y7;
            break;
          default:
            point12(this, x7, y7);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    catmullRomClosed_default2 = function custom16(alpha) {
      function catmullRom(context4) {
        return alpha ? new CatmullRomClosed2(context4, alpha) : new CardinalClosed2(context4, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom16(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen2(context4, alpha) {
  this._context = context4;
  this._alpha = alpha;
}
var catmullRomOpen_default2;
var init_catmullRomOpen2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/catmullRomOpen.js"() {
    init_cardinalOpen2();
    init_catmullRom2();
    CatmullRomOpen2.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        if (this._point) {
          var x23 = this._x2 - x7, y23 = this._y2 - y7;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point12(this, x7, y7);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x7;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y7;
      }
    };
    catmullRomOpen_default2 = function custom17(alpha) {
      function catmullRom(context4) {
        return alpha ? new CatmullRomOpen2(context4, alpha) : new CardinalOpen2(context4, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom17(+alpha2);
      };
      return catmullRom;
    }(0.5);
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed2(context4) {
  this._context = context4;
}
function linearClosed_default2(context4) {
  return new LinearClosed2(context4);
}
var init_linearClosed2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/linearClosed.js"() {
    init_noop4();
    LinearClosed2.prototype = {
      areaStart: noop_default3,
      areaEnd: noop_default3,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point)
          this._context.closePath();
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        if (this._point)
          this._context.lineTo(x7, y7);
        else
          this._point = 1, this._context.moveTo(x7, y7);
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/monotone.js
function sign4(x7) {
  return x7 < 0 ? -1 : 1;
}
function slope32(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign4(s0) + sign4(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope22(that, t) {
  var h4 = that._x1 - that._x0;
  return h4 ? (3 * (that._y1 - that._y0) / h4 - t) / 2 : t;
}
function point13(that, t07, t15) {
  var x07 = that._x0, y07 = that._y0, x13 = that._x1, y13 = that._y1, dx = (x13 - x07) / 3;
  that._context.bezierCurveTo(x07 + dx, y07 + dx * t07, x13 - dx, y13 - dx * t15, x13, y13);
}
function MonotoneX2(context4) {
  this._context = context4;
}
function MonotoneY2(context4) {
  this._context = new ReflectContext2(context4);
}
function ReflectContext2(context4) {
  this._context = context4;
}
function monotoneX2(context4) {
  return new MonotoneX2(context4);
}
function monotoneY2(context4) {
  return new MonotoneY2(context4);
}
var init_monotone2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/monotone.js"() {
    MonotoneX2.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
          case 3:
            point13(this, this._t0, slope22(this, this._t0));
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        var t15 = NaN;
        x7 = +x7, y7 = +y7;
        if (x7 === this._x1 && y7 === this._y1)
          return;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            point13(this, slope22(this, t15 = slope32(this, x7, y7)), t15);
            break;
          default:
            point13(this, this._t0, t15 = slope32(this, x7, y7));
            break;
        }
        this._x0 = this._x1, this._x1 = x7;
        this._y0 = this._y1, this._y1 = y7;
        this._t0 = t15;
      }
    };
    (MonotoneY2.prototype = Object.create(MonotoneX2.prototype)).point = function(x7, y7) {
      MonotoneX2.prototype.point.call(this, y7, x7);
    };
    ReflectContext2.prototype = {
      moveTo: function(x7, y7) {
        this._context.moveTo(y7, x7);
      },
      closePath: function() {
        this._context.closePath();
      },
      lineTo: function(x7, y7) {
        this._context.lineTo(y7, x7);
      },
      bezierCurveTo: function(x13, y13, x22, y22, x7, y7) {
        this._context.bezierCurveTo(y13, x13, y22, x22, y7, x7);
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/natural.js
function Natural2(context4) {
  this._context = context4;
}
function controlPoints2(x7) {
  var i, n = x7.length - 1, m2, a4 = new Array(n), b3 = new Array(n), r2 = new Array(n);
  a4[0] = 0, b3[0] = 2, r2[0] = x7[0] + 2 * x7[1];
  for (i = 1; i < n - 1; ++i)
    a4[i] = 1, b3[i] = 4, r2[i] = 4 * x7[i] + 2 * x7[i + 1];
  a4[n - 1] = 2, b3[n - 1] = 7, r2[n - 1] = 8 * x7[n - 1] + x7[n];
  for (i = 1; i < n; ++i)
    m2 = a4[i] / b3[i - 1], b3[i] -= m2, r2[i] -= m2 * r2[i - 1];
  a4[n - 1] = r2[n - 1] / b3[n - 1];
  for (i = n - 2; i >= 0; --i)
    a4[i] = (r2[i] - a4[i + 1]) / b3[i];
  b3[n - 1] = (x7[n] + a4[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b3[i] = 2 * x7[i + 1] - a4[i + 1];
  return [a4, b3];
}
function natural_default2(context4) {
  return new Natural2(context4);
}
var init_natural2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/natural.js"() {
    Natural2.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x7 = this._x, y7 = this._y, n = x7.length;
        if (n) {
          this._line ? this._context.lineTo(x7[0], y7[0]) : this._context.moveTo(x7[0], y7[0]);
          if (n === 2) {
            this._context.lineTo(x7[1], y7[1]);
          } else {
            var px3 = controlPoints2(x7), py3 = controlPoints2(y7);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px3[0][i0], py3[0][i0], px3[1][i0], py3[1][i0], x7[i1], y7[i1]);
            }
          }
        }
        if (this._line || this._line !== 0 && n === 1)
          this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x7, y7) {
        this._x.push(+x7);
        this._y.push(+y7);
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/step.js
function Step2(context4, t) {
  this._context = context4;
  this._t = t;
}
function step_default2(context4) {
  return new Step2(context4, 0.5);
}
function stepBefore2(context4) {
  return new Step2(context4, 0);
}
function stepAfter2(context4) {
  return new Step2(context4, 1);
}
var init_step2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/curve/step.js"() {
    Step2.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2)
          this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        if (this._line >= 0)
          this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x7, y7) {
        x7 = +x7, y7 = +y7;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x7, y7) : this._context.moveTo(x7, y7);
            break;
          case 1:
            this._point = 2;
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y7);
              this._context.lineTo(x7, y7);
            } else {
              var x13 = this._x * (1 - this._t) + x7 * this._t;
              this._context.lineTo(x13, this._y);
              this._context.lineTo(x13, y7);
            }
            break;
          }
        }
        this._x = x7, this._y = y7;
      }
    };
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/offset/none.js
var init_none3 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/offset/none.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/none.js
var init_none4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/none.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/stack.js
var init_stack2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/stack.js"() {
    init_array7();
    init_constant11();
    init_none3();
    init_none4();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/offset/expand.js
var init_expand2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/offset/expand.js"() {
    init_none3();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/offset/diverging.js
var init_diverging4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/offset/diverging.js"() {
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/offset/silhouette.js
var init_silhouette2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/offset/silhouette.js"() {
    init_none3();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/offset/wiggle.js
var init_wiggle2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/offset/wiggle.js"() {
    init_none3();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/appearance.js
var init_appearance2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/appearance.js"() {
    init_none4();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/ascending.js
var init_ascending4 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/ascending.js"() {
    init_none4();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/descending.js
var init_descending6 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/descending.js"() {
    init_ascending4();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/insideOut.js
var init_insideOut2 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/insideOut.js"() {
    init_appearance2();
    init_ascending4();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/reverse.js
var init_reverse5 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/order/reverse.js"() {
    init_none4();
  }
});

// node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/index.js
var init_src29 = __esm({
  "node_modules/.pnpm/d3-shape@2.1.0/node_modules/d3-shape/src/index.js"() {
    init_arc2();
    init_area4();
    init_line3();
    init_pie2();
    init_areaRadial2();
    init_lineRadial2();
    init_pointRadial2();
    init_link3();
    init_symbol2();
    init_circle4();
    init_cross4();
    init_diamond3();
    init_square4();
    init_star2();
    init_triangle3();
    init_wye2();
    init_basisClosed4();
    init_basisOpen2();
    init_basis4();
    init_bump2();
    init_bundle2();
    init_cardinalClosed2();
    init_cardinalOpen2();
    init_cardinal2();
    init_catmullRomClosed2();
    init_catmullRomOpen2();
    init_catmullRom2();
    init_linearClosed2();
    init_linear4();
    init_monotone2();
    init_natural2();
    init_step2();
    init_stack2();
    init_expand2();
    init_diverging4();
    init_none3();
    init_silhouette2();
    init_wiggle2();
    init_appearance2();
    init_ascending4();
    init_descending6();
    init_insideOut2();
    init_none4();
    init_reverse5();
  }
});

// node_modules/.pnpm/d3-dsv@2.0.0/node_modules/d3-dsv/src/dsv.js
function objectConverter2(columns) {
  return new Function("d", "return {" + columns.map(function(name4, i) {
    return JSON.stringify(name4) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter2(columns, f) {
  var object2 = objectConverter2(columns);
  return function(row, i) {
    return f(object2(row), i, columns);
  };
}
function inferColumns2(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad5(value4, width2) {
  var s3 = value4 + "", length4 = s3.length;
  return length4 < width2 ? new Array(width2 - length4 + 1).join(0) + s3 : s3;
}
function formatYear4(year2) {
  return year2 < 0 ? "-" + pad5(-year2, 6) : year2 > 9999 ? "+" + pad5(year2, 6) : pad5(year2, 4);
}
function formatDate2(date3) {
  var hours2 = date3.getUTCHours(), minutes2 = date3.getUTCMinutes(), seconds3 = date3.getUTCSeconds(), milliseconds3 = date3.getUTCMilliseconds();
  return isNaN(date3) ? "Invalid Date" : formatYear4(date3.getUTCFullYear(), 4) + "-" + pad5(date3.getUTCMonth() + 1, 2) + "-" + pad5(date3.getUTCDate(), 2) + (milliseconds3 ? "T" + pad5(hours2, 2) + ":" + pad5(minutes2, 2) + ":" + pad5(seconds3, 2) + "." + pad5(milliseconds3, 3) + "Z" : seconds3 ? "T" + pad5(hours2, 2) + ":" + pad5(minutes2, 2) + ":" + pad5(seconds3, 2) + "Z" : minutes2 || hours2 ? "T" + pad5(hours2, 2) + ":" + pad5(minutes2, 2) + "Z" : "");
}
function dsv_default2(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse8(text5, f) {
    var convert, columns, rows = parseRows(text5, function(row, i) {
      if (convert)
        return convert(row, i - 1);
      columns = row, convert = f ? customConverter2(row, f) : objectConverter2(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text5, f) {
    var rows = [], N = text5.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text5.charCodeAt(N - 1) === NEWLINE2)
      --N;
    if (text5.charCodeAt(N - 1) === RETURN2)
      --N;
    function token() {
      if (eof)
        return EOF2;
      if (eol)
        return eol = false, EOL2;
      var i, j = I, c2;
      if (text5.charCodeAt(j) === QUOTE2) {
        while (I++ < N && text5.charCodeAt(I) !== QUOTE2 || text5.charCodeAt(++I) === QUOTE2)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c2 = text5.charCodeAt(I++)) === NEWLINE2)
          eol = true;
        else if (c2 === RETURN2) {
          eol = true;
          if (text5.charCodeAt(I) === NEWLINE2)
            ++I;
        }
        return text5.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c2 = text5.charCodeAt(i = I++)) === NEWLINE2)
          eol = true;
        else if (c2 === RETURN2) {
          eol = true;
          if (text5.charCodeAt(I) === NEWLINE2)
            ++I;
        } else if (c2 !== DELIMITER)
          continue;
        return text5.slice(j, i);
      }
      return eof = true, text5.slice(j, N);
    }
    while ((t = token()) !== EOF2) {
      var row = [];
      while (t !== EOL2 && t !== EOF2)
        row.push(t), t = token();
      if (f && (row = f(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue5(row[column]);
      }).join(delimiter);
    });
  }
  function format9(rows, columns) {
    if (columns == null)
      columns = inferColumns2(rows);
    return [columns.map(formatValue5).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns2(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue5).join(delimiter);
  }
  function formatValue5(value4) {
    return value4 == null ? "" : value4 instanceof Date ? formatDate2(value4) : reFormat.test(value4 += "") ? '"' + value4.replace(/"/g, '""') + '"' : value4;
  }
  return {
    parse: parse8,
    parseRows,
    format: format9,
    formatBody,
    formatRows,
    formatRow,
    formatValue: formatValue5
  };
}
var EOL2, EOF2, QUOTE2, NEWLINE2, RETURN2;
var init_dsv2 = __esm({
  "node_modules/.pnpm/d3-dsv@2.0.0/node_modules/d3-dsv/src/dsv.js"() {
    EOL2 = {};
    EOF2 = {};
    QUOTE2 = 34;
    NEWLINE2 = 10;
    RETURN2 = 13;
  }
});

// node_modules/.pnpm/d3-dsv@2.0.0/node_modules/d3-dsv/src/csv.js
var csv2, csvParse2, csvParseRows2, csvFormat2, csvFormatBody2, csvFormatRows2, csvFormatRow2, csvFormatValue2;
var init_csv2 = __esm({
  "node_modules/.pnpm/d3-dsv@2.0.0/node_modules/d3-dsv/src/csv.js"() {
    init_dsv2();
    csv2 = dsv_default2(",");
    csvParse2 = csv2.parse;
    csvParseRows2 = csv2.parseRows;
    csvFormat2 = csv2.format;
    csvFormatBody2 = csv2.formatBody;
    csvFormatRows2 = csv2.formatRows;
    csvFormatRow2 = csv2.formatRow;
    csvFormatValue2 = csv2.formatValue;
  }
});

// node_modules/.pnpm/d3-dsv@2.0.0/node_modules/d3-dsv/src/tsv.js
var tsv2, tsvParse2, tsvParseRows2, tsvFormat2, tsvFormatBody2, tsvFormatRows2, tsvFormatRow2, tsvFormatValue2;
var init_tsv2 = __esm({
  "node_modules/.pnpm/d3-dsv@2.0.0/node_modules/d3-dsv/src/tsv.js"() {
    init_dsv2();
    tsv2 = dsv_default2("	");
    tsvParse2 = tsv2.parse;
    tsvParseRows2 = tsv2.parseRows;
    tsvFormat2 = tsv2.format;
    tsvFormatBody2 = tsv2.formatBody;
    tsvFormatRows2 = tsv2.formatRows;
    tsvFormatRow2 = tsv2.formatRow;
    tsvFormatValue2 = tsv2.formatValue;
  }
});

// node_modules/.pnpm/d3-dsv@2.0.0/node_modules/d3-dsv/src/autoType.js
var fixtz2;
var init_autoType2 = __esm({
  "node_modules/.pnpm/d3-dsv@2.0.0/node_modules/d3-dsv/src/autoType.js"() {
    fixtz2 = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
  }
});

// node_modules/.pnpm/d3-dsv@2.0.0/node_modules/d3-dsv/src/index.js
var init_src30 = __esm({
  "node_modules/.pnpm/d3-dsv@2.0.0/node_modules/d3-dsv/src/index.js"() {
    init_dsv2();
    init_csv2();
    init_tsv2();
    init_autoType2();
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default3(x7) {
  return Math.abs(x7 = Math.round(x7)) >= 1e21 ? x7.toLocaleString("en").replace(/,/g, "") : x7.toString(10);
}
function formatDecimalParts2(x7, p) {
  if ((i = (x7 = p ? x7.toExponential(p - 1) : x7.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x7.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x7.slice(i + 1)
  ];
}
var init_formatDecimal3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatDecimal.js"() {
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/exponent.js
function exponent_default3(x7) {
  return x7 = formatDecimalParts2(Math.abs(x7)), x7 ? x7[1] : NaN;
}
var init_exponent3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/exponent.js"() {
    init_formatDecimal3();
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatGroup.js
function formatGroup_default3(grouping, thousands) {
  return function(value4, width2) {
    var i = value4.length, t = [], j = 0, g = grouping[0], length4 = 0;
    while (i > 0 && g > 0) {
      if (length4 + g + 1 > width2)
        g = Math.max(1, width2 - length4);
      t.push(value4.substring(i -= g, i + g));
      if ((length4 += g + 1) > width2)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
var init_formatGroup3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatGroup.js"() {
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default3(numerals) {
  return function(value4) {
    return value4.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var init_formatNumerals3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatNumerals.js"() {
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatSpecifier.js
function formatSpecifier3(specifier) {
  if (!(match4 = re3.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match4;
  return new FormatSpecifier3({
    fill: match4[1],
    align: match4[2],
    sign: match4[3],
    symbol: match4[4],
    zero: match4[5],
    width: match4[6],
    comma: match4[7],
    precision: match4[8] && match4[8].slice(1),
    trim: match4[9],
    type: match4[10]
  });
}
function FormatSpecifier3(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
var re3;
var init_formatSpecifier3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatSpecifier.js"() {
    re3 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    formatSpecifier3.prototype = FormatSpecifier3.prototype;
    FormatSpecifier3.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatTrim.js
function formatTrim_default3(s3) {
  out:
    for (var n = s3.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s3[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s3[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
}
var init_formatTrim3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatTrim.js"() {
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatPrefixAuto.js
function formatPrefixAuto_default3(x7, p) {
  var d = formatDecimalParts2(x7, p);
  if (!d)
    return x7 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent3 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts2(x7, Math.max(0, p + i - 1))[0];
}
var prefixExponent3;
var init_formatPrefixAuto3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatPrefixAuto.js"() {
    init_formatDecimal3();
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatRounded.js
function formatRounded_default3(x7, p) {
  var d = formatDecimalParts2(x7, p);
  if (!d)
    return x7 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
var init_formatRounded3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatRounded.js"() {
    init_formatDecimal3();
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatTypes.js
var formatTypes_default3;
var init_formatTypes3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/formatTypes.js"() {
    init_formatDecimal3();
    init_formatPrefixAuto3();
    init_formatRounded3();
    formatTypes_default3 = {
      "%": (x7, p) => (x7 * 100).toFixed(p),
      "b": (x7) => Math.round(x7).toString(2),
      "c": (x7) => x7 + "",
      "d": formatDecimal_default3,
      "e": (x7, p) => x7.toExponential(p),
      "f": (x7, p) => x7.toFixed(p),
      "g": (x7, p) => x7.toPrecision(p),
      "o": (x7) => Math.round(x7).toString(8),
      "p": (x7, p) => formatRounded_default3(x7 * 100, p),
      "r": formatRounded_default3,
      "s": formatPrefixAuto_default3,
      "X": (x7) => Math.round(x7).toString(16).toUpperCase(),
      "x": (x7) => Math.round(x7).toString(16)
    };
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/identity.js
function identity_default9(x7) {
  return x7;
}
var init_identity12 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/identity.js"() {
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/locale.js
function locale_default3(locale7) {
  var group6 = locale7.grouping === void 0 || locale7.thousands === void 0 ? identity_default9 : formatGroup_default3(map8.call(locale7.grouping, Number), locale7.thousands + ""), currencyPrefix = locale7.currency === void 0 ? "" : locale7.currency[0] + "", currencySuffix = locale7.currency === void 0 ? "" : locale7.currency[1] + "", decimal = locale7.decimal === void 0 ? "." : locale7.decimal + "", numerals = locale7.numerals === void 0 ? identity_default9 : formatNumerals_default3(map8.call(locale7.numerals, String)), percent = locale7.percent === void 0 ? "%" : locale7.percent + "", minus = locale7.minus === void 0 ? "" : locale7.minus + "", nan = locale7.nan === void 0 ? "NaN" : locale7.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier3(specifier);
    var fill3 = specifier.fill, align2 = specifier.align, sign5 = specifier.sign, symbol3 = specifier.symbol, zero10 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type4 = specifier.type;
    if (type4 === "n")
      comma = true, type4 = "g";
    else if (!formatTypes_default3[type4])
      precision === void 0 && (precision = 12), trim = true, type4 = "g";
    if (zero10 || fill3 === "0" && align2 === "=")
      zero10 = true, fill3 = "0", align2 = "=";
    var prefix = symbol3 === "$" ? currencyPrefix : symbol3 === "#" && /[boxX]/.test(type4) ? "0" + type4.toLowerCase() : "", suffix = symbol3 === "$" ? currencySuffix : /[%p]/.test(type4) ? percent : "";
    var formatType = formatTypes_default3[type4], maybeSuffix = /[defgprs%]/.test(type4);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type4) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format9(value4) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
      if (type4 === "c") {
        valueSuffix = formatType(value4) + valueSuffix;
        value4 = "";
      } else {
        value4 = +value4;
        var valueNegative = value4 < 0 || 1 / value4 < 0;
        value4 = isNaN(value4) ? nan : formatType(Math.abs(value4), precision);
        if (trim)
          value4 = formatTrim_default3(value4);
        if (valueNegative && +value4 === 0 && sign5 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign5 === "(" ? sign5 : minus : sign5 === "-" || sign5 === "(" ? "" : sign5) + valuePrefix;
        valueSuffix = (type4 === "s" ? prefixes3[8 + prefixExponent3 / 3] : "") + valueSuffix + (valueNegative && sign5 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value4.length;
          while (++i < n) {
            if (c2 = value4.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value4.slice(i + 1) : value4.slice(i)) + valueSuffix;
              value4 = value4.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero10)
        value4 = group6(value4, Infinity);
      var length4 = valuePrefix.length + value4.length + valueSuffix.length, padding3 = length4 < width2 ? new Array(width2 - length4 + 1).join(fill3) : "";
      if (comma && zero10)
        value4 = group6(padding3 + value4, padding3.length ? width2 - valueSuffix.length : Infinity), padding3 = "";
      switch (align2) {
        case "<":
          value4 = valuePrefix + value4 + valueSuffix + padding3;
          break;
        case "=":
          value4 = valuePrefix + padding3 + value4 + valueSuffix;
          break;
        case "^":
          value4 = padding3.slice(0, length4 = padding3.length >> 1) + valuePrefix + value4 + valueSuffix + padding3.slice(length4);
          break;
        default:
          value4 = padding3 + valuePrefix + value4 + valueSuffix;
          break;
      }
      return numerals(value4);
    }
    format9.toString = function() {
      return specifier + "";
    };
    return format9;
  }
  function formatPrefix4(specifier, value4) {
    var f = newFormat((specifier = formatSpecifier3(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default3(value4) / 3))) * 3, k4 = Math.pow(10, -e3), prefix = prefixes3[8 + e3 / 3];
    return function(value5) {
      return f(k4 * value5) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix4
  };
}
var map8, prefixes3;
var init_locale5 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/locale.js"() {
    init_exponent3();
    init_formatGroup3();
    init_formatNumerals3();
    init_formatSpecifier3();
    init_formatTrim3();
    init_formatTypes3();
    init_formatPrefixAuto3();
    init_identity12();
    map8 = Array.prototype.map;
    prefixes3 = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/defaultLocale.js
function defaultLocale6(definition3) {
  locale5 = locale_default3(definition3);
  format6 = locale5.format;
  formatPrefix3 = locale5.formatPrefix;
  return locale5;
}
var locale5, format6, formatPrefix3;
var init_defaultLocale5 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/defaultLocale.js"() {
    init_locale5();
    defaultLocale6({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default3(step) {
  return Math.max(0, -exponent_default3(Math.abs(step)));
}
var init_precisionFixed3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/precisionFixed.js"() {
    init_exponent3();
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default3(step, value4) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default3(value4) / 3))) * 3 - exponent_default3(Math.abs(step)));
}
var init_precisionPrefix3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/precisionPrefix.js"() {
    init_exponent3();
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/precisionRound.js
function precisionRound_default3(step, max8) {
  step = Math.abs(step), max8 = Math.abs(max8) - step;
  return Math.max(0, exponent_default3(max8) - exponent_default3(step)) + 1;
}
var init_precisionRound3 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/precisionRound.js"() {
    init_exponent3();
  }
});

// node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/index.js
var init_src31 = __esm({
  "node_modules/.pnpm/d3-format@2.0.0/node_modules/d3-format/src/index.js"() {
    init_defaultLocale5();
    init_locale5();
    init_formatSpecifier3();
    init_precisionFixed3();
    init_precisionPrefix3();
    init_precisionRound3();
  }
});

// node_modules/.pnpm/vega-format@1.0.4/node_modules/vega-format/build/vega-format.module.js
function memoize2(method3) {
  const cache3 = {};
  return (spec) => cache3[spec] || (cache3[spec] = method3(spec));
}
function trimZeroes2(numberFormat2, decimalChar) {
  return (x7) => {
    const str = numberFormat2(x7), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit2(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit2(str, dec) {
  let i = str.lastIndexOf("e"), c2;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c2 = str.charCodeAt(i);
    if (c2 >= 48 && c2 <= 57)
      return i + 1;
  }
}
function numberLocale2(locale7) {
  const format9 = memoize2(locale7.format), formatPrefix4 = locale7.formatPrefix;
  return {
    format: format9,
    formatPrefix: formatPrefix4,
    formatFloat(spec) {
      const s3 = formatSpecifier3(spec || ",");
      if (s3.precision == null) {
        s3.precision = 12;
        switch (s3.type) {
          case "%":
            s3.precision -= 2;
            break;
          case "e":
            s3.precision -= 1;
            break;
        }
        return trimZeroes2(
          format9(s3),
          format9(".1f")(1)[1]
        );
      } else {
        return format9(s3);
      }
    },
    formatSpan(start, stop2, count5, specifier) {
      specifier = formatSpecifier3(specifier == null ? ",f" : specifier);
      const step = tickStep2(start, stop2, count5), value4 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default3(step, value4))) {
              specifier.precision = precision;
            }
            return formatPrefix4(specifier, value4);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default3(step, value4))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default3(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format9(specifier);
    }
  };
}
function resetNumberFormatDefaultLocale2() {
  return defaultNumberLocale2 = numberLocale2({
    format: format6,
    formatPrefix: formatPrefix3
  });
}
function numberFormatLocale2(definition3) {
  return numberLocale2(locale_default3(definition3));
}
function numberFormatDefaultLocale2(definition3) {
  return arguments.length ? defaultNumberLocale2 = numberFormatLocale2(definition3) : defaultNumberLocale2;
}
function timeMultiFormat2(format9, interval3, spec) {
  spec = spec || {};
  if (!isObject(spec)) {
    error("Invalid time multi-format specifier: ".concat(spec));
  }
  const second3 = interval3(SECONDS2), minute2 = interval3(MINUTES2), hour2 = interval3(HOURS2), day2 = interval3(DATE2), week2 = interval3(WEEK2), month2 = interval3(MONTH2), quarter3 = interval3(QUARTER2), year2 = interval3(YEAR2), L = format9(spec[MILLISECONDS2] || ".%L"), S = format9(spec[SECONDS2] || ":%S"), M2 = format9(spec[MINUTES2] || "%I:%M"), H = format9(spec[HOURS2] || "%I %p"), d = format9(spec[DATE2] || spec[DAY2] || "%a %d"), w5 = format9(spec[WEEK2] || "%b %d"), m2 = format9(spec[MONTH2] || "%B"), q = format9(spec[QUARTER2] || "%B"), y7 = format9(spec[YEAR2] || "%Y");
  return (date3) => (second3(date3) < date3 ? L : minute2(date3) < date3 ? S : hour2(date3) < date3 ? M2 : day2(date3) < date3 ? H : month2(date3) < date3 ? week2(date3) < date3 ? d : w5 : year2(date3) < date3 ? quarter3(date3) < date3 ? m2 : q : y7)(date3);
}
function timeLocale2(locale7) {
  const timeFormat5 = memoize2(locale7.format), utcFormat4 = memoize2(locale7.utcFormat);
  return {
    timeFormat: (spec) => isString(spec) ? timeFormat5(spec) : timeMultiFormat2(timeFormat5, timeInterval3, spec),
    utcFormat: (spec) => isString(spec) ? utcFormat4(spec) : timeMultiFormat2(utcFormat4, utcInterval2, spec),
    timeParse: memoize2(locale7.parse),
    utcParse: memoize2(locale7.utcParse)
  };
}
function resetTimeFormatDefaultLocale2() {
  return defaultTimeLocale2 = timeLocale2({
    format: timeFormat2,
    parse: timeParse2,
    utcFormat: utcFormat2,
    utcParse: utcParse2
  });
}
function timeFormatLocale2(definition3) {
  return timeLocale2(formatLocale2(definition3));
}
function timeFormatDefaultLocale2(definition3) {
  return arguments.length ? defaultTimeLocale2 = timeFormatLocale2(definition3) : defaultTimeLocale2;
}
function locale6(numberSpec, timeSpec) {
  const number12 = numberSpec ? numberFormatLocale2(numberSpec) : numberFormatDefaultLocale2();
  const time4 = timeSpec ? timeFormatLocale2(timeSpec) : timeFormatDefaultLocale2();
  return createLocale2(number12, time4);
}
function defaultLocale7(numberSpec, timeSpec) {
  const args = arguments.length;
  if (args && args !== 2) {
    error("defaultLocale expects either zero or two arguments.");
  }
  return args ? createLocale2(numberFormatDefaultLocale2(numberSpec), timeFormatDefaultLocale2(timeSpec)) : createLocale2(numberFormatDefaultLocale2(), timeFormatDefaultLocale2());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale2();
  resetTimeFormatDefaultLocale2();
  return defaultLocale7();
}
var defaultNumberLocale2, defaultTimeLocale2, createLocale2;
var init_vega_format_module2 = __esm({
  "node_modules/.pnpm/vega-format@1.0.4/node_modules/vega-format/build/vega-format.module.js"() {
    init_src9();
    init_src31();
    init_vega_time_module2();
    init_vega_util_module();
    init_src19();
    resetNumberFormatDefaultLocale2();
    resetTimeFormatDefaultLocale2();
    createLocale2 = (number12, time4) => extend({}, number12, time4);
  }
});

// node_modules/.pnpm/vega-loader@4.4.1/node_modules/vega-loader/build/vega-loader.browser.module.js
function loaderFactory2(fetch2, fs) {
  return (options2) => ({
    options: options2 || {},
    sanitize: sanitize2,
    load: load2,
    fileAccess: !!fs,
    file: fileLoader2(fs),
    http: httpLoader2(fetch2)
  });
}
async function load2(uri, options2) {
  const opt = await this.sanitize(uri, options2), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options2);
}
async function sanitize2(uri, options2) {
  options2 = extend({}, this.options, options2);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base3;
  const isAllowed = allowed_re2.test(uri.replace(whitespace_re2, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error("Sanitize failure, invalid URI: " + $(uri));
  }
  const hasProtocol = protocol_re2.test(uri);
  if ((base3 = options2.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base3.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base3 + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol2)) || options2.mode === "file" || options2.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol2.length);
  } else if (uri.startsWith("//")) {
    if (options2.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options2.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options2.target) {
    result.target = options2.target + "";
  }
  if (options2.rel) {
    result.rel = options2.rel + "";
  }
  if (options2.context === "image" && options2.crossOrigin) {
    result.crossOrigin = options2.crossOrigin + "";
  }
  return result;
}
function fileLoader2(fs) {
  return fs ? (filename) => new Promise((accept, reject) => {
    fs.readFile(filename, (error3, data3) => {
      if (error3)
        reject(error3);
      else
        accept(data3);
    });
  }) : fileReject2;
}
async function fileReject2() {
  error("No file system access.");
}
function httpLoader2(fetch2) {
  return fetch2 ? async function(url, options2) {
    const opt = extend({}, this.options.http, options2), type4 = options2 && options2.response, response = await fetch2(url, opt);
    return !response.ok ? error(response.status + "" + response.statusText) : isFunction(response[type4]) ? response[type4]() : response.text();
  } : httpReject2;
}
async function httpReject2() {
  error("No HTTP fetch method available.");
}
function inferType2(values5, field4) {
  if (!values5 || !values5.length)
    return "unknown";
  const n = values5.length, m2 = typeTests2.length, a4 = typeTests2.map((_, i) => i + 1);
  for (let i = 0, t = 0, j, value4; i < n; ++i) {
    value4 = field4 ? values5[i][field4] : values5[i];
    for (j = 0; j < m2; ++j) {
      if (a4[j] && isValid2(value4) && !typeTests2[j](value4)) {
        a4[j] = 0;
        ++t;
        if (t === typeTests2.length)
          return "string";
      }
    }
  }
  return typeList2[a4.reduce((u, v) => u === 0 ? v : u, 0) - 1];
}
function inferTypes2(data3, fields) {
  return fields.reduce((types4, field4) => {
    types4[field4] = inferType2(data3, field4);
    return types4;
  }, {});
}
function delimitedFormat2(delimiter) {
  const parse8 = function(data3, format9) {
    const delim = {
      delimiter
    };
    return dsv2(data3, format9 ? extend(format9, delim) : delim);
  };
  parse8.responseType = "text";
  return parse8;
}
function dsv2(data3, format9) {
  if (format9.header) {
    data3 = format9.header.map($).join(format9.delimiter) + "\n" + data3;
  }
  return dsv_default2(format9.delimiter).parse(data3 + "");
}
function isBuffer2(_) {
  return typeof Buffer === "function" && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json2(data3, format9) {
  const prop = format9 && format9.property ? field(format9.property) : identity;
  return isObject(data3) && !isBuffer2(data3) ? parseJSON2(prop(data3), format9) : prop(JSON.parse(data3));
}
function parseJSON2(data3, format9) {
  if (!isArray(data3) && isIterable(data3)) {
    data3 = [...data3];
  }
  return format9 && format9.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}
function topojson2(data3, format9) {
  let method3, object2, property2, filter6;
  data3 = json2(data3, format9);
  if (format9 && format9.feature) {
    method3 = feature_default;
    property2 = format9.feature;
  } else if (format9 && format9.mesh) {
    method3 = mesh_default;
    property2 = format9.mesh;
    filter6 = filters2[format9.filter];
  } else {
    error("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method3(data3, object2, filter6) : error("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
function formats4(name4, reader) {
  if (arguments.length > 1) {
    format7[name4] = reader;
    return this;
  } else {
    return has(format7, name4) ? format7[name4] : null;
  }
}
function responseType2(type4) {
  const f = formats4(type4);
  return f && f.responseType || "text";
}
function read2(data3, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats4(schema.type || "json");
  if (!reader)
    error("Unknown data format type: " + schema.type);
  data3 = reader(data3, schema);
  if (schema.parse)
    parse5(data3, schema.parse, timeParser, utcParser);
  if (has(data3, "columns"))
    delete data3.columns;
  return data3;
}
function parse5(data3, types4, timeParser, utcParser) {
  if (!data3.length)
    return;
  const locale7 = timeFormatDefaultLocale2();
  timeParser = timeParser || locale7.timeParse;
  utcParser = utcParser || locale7.utcParse;
  let fields = data3.columns || Object.keys(data3[0]), datum2, field4, i, j, n, m2;
  if (types4 === "auto")
    types4 = inferTypes2(data3, fields);
  fields = Object.keys(types4);
  const parsers = fields.map((field5) => {
    const type4 = types4[field5];
    let parts, pattern;
    if (type4 && (type4.startsWith("date:") || type4.startsWith("utc:"))) {
      parts = type4.split(/:(.+)?/, 2);
      pattern = parts[1];
      if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }
      const parse8 = parts[0] === "utc" ? utcParser : timeParser;
      return parse8(pattern);
    }
    if (!typeParsers2[type4]) {
      throw Error("Illegal format pattern: " + field5 + ":" + type4);
    }
    return typeParsers2[type4];
  });
  for (i = 0, n = data3.length, m2 = fields.length; i < n; ++i) {
    datum2 = data3[i];
    for (j = 0; j < m2; ++j) {
      field4 = fields[j];
      datum2[field4] = parsers[j](datum2[field4]);
    }
  }
}
var protocol_re2, allowed_re2, whitespace_re2, fileProtocol2, isValid2, isBoolean3, isDate4, isNumber4, isInteger3, typeParsers2, typeTests2, typeList2, filters2, format7, loader2;
var init_vega_loader_browser_module2 = __esm({
  "node_modules/.pnpm/vega-loader@4.4.1/node_modules/vega-loader/build/vega-loader.browser.module.js"() {
    init_vega_util_module();
    init_src30();
    init_src2();
    init_vega_format_module2();
    protocol_re2 = /^(data:|([A-Za-z]+:)?\/\/)/;
    allowed_re2 = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
    whitespace_re2 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
    fileProtocol2 = "file://";
    isValid2 = (_) => _ != null && _ === _;
    isBoolean3 = (_) => _ === "true" || _ === "false" || _ === true || _ === false;
    isDate4 = (_) => !Number.isNaN(Date.parse(_));
    isNumber4 = (_) => !Number.isNaN(+_) && !(_ instanceof Date);
    isInteger3 = (_) => isNumber4(_) && Number.isInteger(+_);
    typeParsers2 = {
      boolean: toBoolean,
      integer: toNumber,
      number: toNumber,
      date: toDate,
      string: toString,
      unknown: identity
    };
    typeTests2 = [isBoolean3, isInteger3, isNumber4, isDate4];
    typeList2 = ["boolean", "integer", "number", "date"];
    dsv2.responseType = "text";
    json2.responseType = "json";
    filters2 = {
      interior: (a4, b3) => a4 !== b3,
      exterior: (a4, b3) => a4 === b3
    };
    topojson2.responseType = "json";
    format7 = {
      dsv: dsv2,
      csv: delimitedFormat2(","),
      tsv: delimitedFormat2("	"),
      json: json2,
      topojson: topojson2
    };
    loader2 = loaderFactory2(
      typeof fetch !== "undefined" && fetch,
      null
    );
  }
});

// node_modules/.pnpm/vega-scenegraph@4.9.4/node_modules/vega-scenegraph/build/vega-scenegraph.module.js
function resetSVGGradientId() {
  gradient_id2 = 0;
}
function isGradient2(value4) {
  return value4 && value4.gradient;
}
function gradientRef2(g, defs, base3) {
  const type4 = g.gradient;
  let id4 = g.id, prefix = type4 === "radial" ? patternPrefix2 : "";
  if (!id4) {
    id4 = g.id = "gradient_" + gradient_id2++;
    if (type4 === "radial") {
      g.x1 = get7(g.x1, 0.5);
      g.y1 = get7(g.y1, 0.5);
      g.r1 = get7(g.r1, 0);
      g.x2 = get7(g.x2, 0.5);
      g.y2 = get7(g.y2, 0.5);
      g.r2 = get7(g.r2, 0.5);
      prefix = patternPrefix2;
    } else {
      g.x1 = get7(g.x1, 0);
      g.y1 = get7(g.y1, 0);
      g.x2 = get7(g.x2, 1);
      g.y2 = get7(g.y2, 0);
    }
  }
  defs[id4] = g;
  return "url(" + (base3 || "") + "#" + prefix + id4 + ")";
}
function get7(val, def3) {
  return val != null ? val : def3;
}
function Gradient(p02, p1) {
  var stops = [], gradient5;
  return gradient5 = {
    gradient: "linear",
    x1: p02 ? p02[0] : 0,
    y1: p02 ? p02[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops,
    stop: function(offset5, color7) {
      stops.push({
        offset: offset5,
        color: color7
      });
      return gradient5;
    }
  };
}
function curves2(type4, orientation, tension) {
  var entry2 = has(lookup4, type4) && lookup4[type4], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
function pathParse(pathstr) {
  const result = [];
  let curr, chunks, parsed, param2, cmd, len, i, j, n, m2;
  const path5 = pathstr.slice().replace(regexp[0], "###$1").split(regexp[1]).slice(1);
  for (i = 0, n = path5.length; i < n; ++i) {
    curr = path5[i];
    chunks = curr.slice(1).trim().replace(regexp[2], "$1###$2").replace(regexp[3], "$1###$2").split(regexp[4]);
    cmd = curr.charAt(0);
    parsed = [cmd];
    for (j = 0, m2 = chunks.length; j < m2; ++j) {
      if ((param2 = +chunks[j]) === param2) {
        parsed.push(param2);
      }
    }
    len = cmdlen[cmd.toLowerCase()];
    if (parsed.length - 1 > len) {
      const m3 = parsed.length;
      j = 1;
      result.push([cmd].concat(parsed.slice(j, j += len)));
      cmd = cmd === "M" ? "L" : cmd === "m" ? "l" : cmd;
      for (; j < m3; j += len) {
        result.push([cmd].concat(parsed.slice(j, j + len)));
      }
    } else {
      result.push(parsed);
    }
  }
  return result;
}
function segments2(x7, y7, rx, ry, large, sweep, rotateX, ox, oy) {
  const key3 = join2.call(arguments);
  if (segmentCache2[key3]) {
    return segmentCache2[key3];
  }
  const th = rotateX * DegToRad2;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px3 = cos_th * (ox - x7) * 0.5 + sin_th * (oy - y7) * 0.5;
  const py3 = cos_th * (oy - y7) * 0.5 - sin_th * (ox - x7) * 0.5;
  let pl = px3 * px3 / (rx * rx) + py3 * py3 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x07 = a00 * ox + a01 * oy;
  const y07 = a10 * ox + a11 * oy;
  const x13 = a00 * x7 + a01 * y7;
  const y13 = a10 * x7 + a11 * y7;
  const d = (x13 - x07) * (x13 - x07) + (y13 - y07) * (y13 - y07);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0)
    sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large)
    sfactor = -sfactor;
  const xc = 0.5 * (x07 + x13) - sfactor * (y13 - y07);
  const yc = 0.5 * (y07 + y13) + sfactor * (x13 - x07);
  const th0 = Math.atan2(y07 - yc, x07 - xc);
  const th1 = Math.atan2(y13 - yc, x13 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau2;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau2;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi2 + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache2[key3] = result;
}
function bezier2(params2) {
  const key3 = join2.call(params2);
  if (bezierCache2[key3]) {
    return bezierCache2[key3];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x13 = cx + cos_th0 - t * sin_th0;
  const y13 = cy + sin_th0 + t * cos_th0;
  const x32 = cx + cos_th1;
  const y32 = cy + sin_th1;
  const x22 = x32 + t * sin_th1;
  const y22 = y32 - t * cos_th1;
  return bezierCache2[key3] = [a00 * x13 + a01 * y13, a10 * x13 + a11 * y13, a00 * x22 + a01 * y22, a10 * x22 + a11 * y22, a00 * x32 + a01 * y32, a10 * x32 + a11 * y32];
}
function scale$12(current2, sX, sY) {
  const c2 = temp2[0] = current2[0];
  if (c2 === "a" || c2 === "A") {
    temp2[1] = sX * current2[1];
    temp2[2] = sY * current2[2];
    temp2[3] = current2[3];
    temp2[4] = current2[4];
    temp2[5] = current2[5];
    temp2[6] = sX * current2[6];
    temp2[7] = sY * current2[7];
  } else if (c2 === "h" || c2 === "H") {
    temp2[1] = sX * current2[1];
  } else if (c2 === "v" || c2 === "V") {
    temp2[1] = sY * current2[1];
  } else {
    for (var i = 1, n = current2.length; i < n; ++i) {
      temp2[i] = (i % 2 == 1 ? sX : sY) * current2[i];
    }
  }
  return temp2;
}
function pathRender2(context4, path5, l, t, sX, sY) {
  var current2, previous = null, x7 = 0, y7 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY;
  if (l == null)
    l = 0;
  if (t == null)
    t = 0;
  if (sX == null)
    sX = 1;
  if (sY == null)
    sY = sX;
  if (context4.beginPath)
    context4.beginPath();
  for (var i = 0, len = path5.length; i < len; ++i) {
    current2 = path5[i];
    if (sX !== 1 || sY !== 1) {
      current2 = scale$12(current2, sX, sY);
    }
    switch (current2[0]) {
      case "l":
        x7 += current2[1];
        y7 += current2[2];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "L":
        x7 = current2[1];
        y7 = current2[2];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "h":
        x7 += current2[1];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "H":
        x7 = current2[1];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "v":
        y7 += current2[1];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "V":
        y7 = current2[1];
        context4.lineTo(x7 + l, y7 + t);
        break;
      case "m":
        x7 += current2[1];
        y7 += current2[2];
        context4.moveTo(x7 + l, y7 + t);
        break;
      case "M":
        x7 = current2[1];
        y7 = current2[2];
        context4.moveTo(x7 + l, y7 + t);
        break;
      case "c":
        tempX = x7 + current2[5];
        tempY = y7 + current2[6];
        controlX = x7 + current2[3];
        controlY = y7 + current2[4];
        context4.bezierCurveTo(
          x7 + current2[1] + l,
          y7 + current2[2] + t,
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x7 = tempX;
        y7 = tempY;
        break;
      case "C":
        x7 = current2[5];
        y7 = current2[6];
        controlX = current2[3];
        controlY = current2[4];
        context4.bezierCurveTo(current2[1] + l, current2[2] + t, controlX + l, controlY + t, x7 + l, y7 + t);
        break;
      case "s":
        tempX = x7 + current2[3];
        tempY = y7 + current2[4];
        controlX = 2 * x7 - controlX;
        controlY = 2 * y7 - controlY;
        context4.bezierCurveTo(controlX + l, controlY + t, x7 + current2[1] + l, y7 + current2[2] + t, tempX + l, tempY + t);
        controlX = x7 + current2[1];
        controlY = y7 + current2[2];
        x7 = tempX;
        y7 = tempY;
        break;
      case "S":
        tempX = current2[3];
        tempY = current2[4];
        controlX = 2 * x7 - controlX;
        controlY = 2 * y7 - controlY;
        context4.bezierCurveTo(controlX + l, controlY + t, current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x7 = tempX;
        y7 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "q":
        tempX = x7 + current2[3];
        tempY = y7 + current2[4];
        controlX = x7 + current2[1];
        controlY = y7 + current2[2];
        context4.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x7 = tempX;
        y7 = tempY;
        break;
      case "Q":
        tempX = current2[3];
        tempY = current2[4];
        context4.quadraticCurveTo(current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x7 = tempX;
        y7 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "t":
        tempX = x7 + current2[1];
        tempY = y7 + current2[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x7;
          controlY = y7;
        } else if (previous[0] === "t") {
          controlX = 2 * x7 - tempControlX;
          controlY = 2 * y7 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x7 - controlX;
          controlY = 2 * y7 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context4.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x7 = tempX;
        y7 = tempY;
        controlX = x7 + current2[1];
        controlY = y7 + current2[2];
        break;
      case "T":
        tempX = current2[1];
        tempY = current2[2];
        controlX = 2 * x7 - controlX;
        controlY = 2 * y7 - controlY;
        context4.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x7 = tempX;
        y7 = tempY;
        break;
      case "a":
        drawArc2(context4, x7 + l, y7 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x7 + l, current2[7] + y7 + t]);
        x7 += current2[6];
        y7 += current2[7];
        break;
      case "A":
        drawArc2(context4, x7 + l, y7 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t]);
        x7 = current2[6];
        y7 = current2[7];
        break;
      case "z":
      case "Z":
        context4.closePath();
        break;
    }
    previous = current2;
  }
}
function drawArc2(context4, x7, y7, coords) {
  const seg = segments2(
    coords[5],
    coords[6],
    coords[0],
    coords[1],
    coords[3],
    coords[4],
    coords[2],
    x7,
    y7
  );
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier2(seg[i]);
    context4.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
function symbols5(_) {
  return has(builtins2, _) ? builtins2[_] : customSymbol2(_);
}
function customSymbol2(path5) {
  if (!has(custom18, path5)) {
    const parsed = pathParse(path5);
    custom18[path5] = {
      draw: function(context4, size) {
        pathRender2(context4, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom18[path5];
}
function rectangleX2(d) {
  return d.x;
}
function rectangleY2(d) {
  return d.y;
}
function rectangleWidth2(d) {
  return d.width;
}
function rectangleHeight2(d) {
  return d.height;
}
function number8(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp2(value4, min8, max8) {
  return Math.max(min8, Math.min(value4, max8));
}
function vg_rect2() {
  var x7 = rectangleX2, y7 = rectangleY2, width2 = rectangleWidth2, height2 = rectangleHeight2, crTL = number8(0), crTR = crTL, crBL = crTL, crBR = crTL, context4 = null;
  function rectangle3(_, x07, y07) {
    var buffer, x13 = x07 != null ? x07 : +x7.call(this, _), y13 = y07 != null ? y07 : +y7.call(this, _), w5 = +width2.call(this, _), h4 = +height2.call(this, _), s3 = Math.min(w5, h4) / 2, tl3 = clamp2(+crTL.call(this, _), 0, s3), tr3 = clamp2(+crTR.call(this, _), 0, s3), bl3 = clamp2(+crBL.call(this, _), 0, s3), br3 = clamp2(+crBR.call(this, _), 0, s3);
    if (!context4)
      context4 = buffer = path_default3();
    if (tl3 <= 0 && tr3 <= 0 && bl3 <= 0 && br3 <= 0) {
      context4.rect(x13, y13, w5, h4);
    } else {
      var x22 = x13 + w5, y22 = y13 + h4;
      context4.moveTo(x13 + tl3, y13);
      context4.lineTo(x22 - tr3, y13);
      context4.bezierCurveTo(x22 - C4 * tr3, y13, x22, y13 + C4 * tr3, x22, y13 + tr3);
      context4.lineTo(x22, y22 - br3);
      context4.bezierCurveTo(x22, y22 - C4 * br3, x22 - C4 * br3, y22, x22 - br3, y22);
      context4.lineTo(x13 + bl3, y22);
      context4.bezierCurveTo(x13 + C4 * bl3, y22, x13, y22 - C4 * bl3, x13, y22 - bl3);
      context4.lineTo(x13, y13 + tl3);
      context4.bezierCurveTo(x13, y13 + C4 * tl3, x13 + C4 * tl3, y13, x13 + tl3, y13);
      context4.closePath();
    }
    if (buffer) {
      context4 = null;
      return buffer + "" || null;
    }
  }
  rectangle3.x = function(_) {
    if (arguments.length) {
      x7 = number8(_);
      return rectangle3;
    } else {
      return x7;
    }
  };
  rectangle3.y = function(_) {
    if (arguments.length) {
      y7 = number8(_);
      return rectangle3;
    } else {
      return y7;
    }
  };
  rectangle3.width = function(_) {
    if (arguments.length) {
      width2 = number8(_);
      return rectangle3;
    } else {
      return width2;
    }
  };
  rectangle3.height = function(_) {
    if (arguments.length) {
      height2 = number8(_);
      return rectangle3;
    } else {
      return height2;
    }
  };
  rectangle3.cornerRadius = function(tl3, tr3, br3, bl3) {
    if (arguments.length) {
      crTL = number8(tl3);
      crTR = tr3 != null ? number8(tr3) : crTL;
      crBR = br3 != null ? number8(br3) : crTL;
      crBL = bl3 != null ? number8(bl3) : crTR;
      return rectangle3;
    } else {
      return crTL;
    }
  };
  rectangle3.context = function(_) {
    if (arguments.length) {
      context4 = _ == null ? null : _;
      return rectangle3;
    } else {
      return context4;
    }
  };
  return rectangle3;
}
function vg_trail2() {
  var x7, y7, size, defined2, context4 = null, ready, x13, y13, r1;
  function point16(x22, y22, w22) {
    const r2 = w22 / 2;
    if (ready) {
      var ux = y13 - y22, uy = x22 - x13;
      if (ux || uy) {
        var ud = Math.sqrt(ux * ux + uy * uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t = Math.atan2(uy, ux);
        context4.moveTo(x13 - rx, y13 - ry);
        context4.lineTo(x22 - ux * r2, y22 - uy * r2);
        context4.arc(x22, y22, r2, t - Math.PI, t);
        context4.lineTo(x13 + rx, y13 + ry);
        context4.arc(x13, y13, r1, t, t + Math.PI);
      } else {
        context4.arc(x22, y22, r2, 0, Tau2);
      }
      context4.closePath();
    } else {
      ready = 1;
    }
    x13 = x22;
    y13 = y22;
    r1 = r2;
  }
  function trail4(data3) {
    var i, n = data3.length, d, defined0 = false, buffer;
    if (context4 == null)
      context4 = buffer = path_default3();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          ready = 0;
      }
      if (defined0)
        point16(+x7(d, i, data3), +y7(d, i, data3), +size(d, i, data3));
    }
    if (buffer) {
      context4 = null;
      return buffer + "" || null;
    }
  }
  trail4.x = function(_) {
    if (arguments.length) {
      x7 = _;
      return trail4;
    } else {
      return x7;
    }
  };
  trail4.y = function(_) {
    if (arguments.length) {
      y7 = _;
      return trail4;
    } else {
      return y7;
    }
  };
  trail4.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail4;
    } else {
      return size;
    }
  };
  trail4.defined = function(_) {
    if (arguments.length) {
      defined2 = _;
      return trail4;
    } else {
      return defined2;
    }
  };
  trail4.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context4 = null;
      } else {
        context4 = _;
      }
      return trail4;
    } else {
      return context4;
    }
  };
  return trail4;
}
function value$12(a4, b3) {
  return a4 != null ? a4 : b3;
}
function hasCornerRadius2(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$12(context4, item) {
  return arcShape2.context(context4)(item);
}
function area$12(context4, items2) {
  const item = items2[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape2 : areavShape2).curve(curves2(interp, item.orient, item.tension)).context(context4)(items2);
}
function line$12(context4, items2) {
  const item = items2[0], interp = item.interpolate || "linear";
  return lineShape2.curve(curves2(interp, item.orient, item.tension)).context(context4)(items2);
}
function rectangle2(context4, item, x7, y7) {
  return rectShape2.context(context4)(item, x7, y7);
}
function shape$12(context4, item) {
  return (item.mark.shape || item.shape).context(context4)(item);
}
function symbol$12(context4, item) {
  return symbolShape2.context(context4)(item);
}
function trail$12(context4, items2) {
  return trailShape2.context(context4)(items2);
}
function resetSVGClipId() {
  clip_id2 = 1;
}
function clip$12(renderer, item, size) {
  var clip4 = item.clip, defs = renderer._defs, id4 = item.clip_id || (item.clip_id = "clip" + clip_id2++), c2 = defs.clipping[id4] || (defs.clipping[id4] = {
    id: id4
  });
  if (isFunction(clip4)) {
    c2.path = clip4(null);
  } else if (hasCornerRadius2(size)) {
    c2.path = rectangle2(null, size, 0, 0);
  } else {
    c2.width = size.width || 0;
    c2.height = size.height || 0;
  }
  return "url(#" + id4 + ")";
}
function Bounds2(b3) {
  this.clear();
  if (b3)
    this.union(b3);
}
function Item2(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds2();
}
function GroupItem2(mark) {
  Item2.call(this, mark);
  this.items = this.items || [];
}
function ResourceLoader2(customLoader) {
  this._pending = 0;
  this._loader = customLoader || loader2();
}
function increment2(loader3) {
  loader3._pending += 1;
}
function decrement2(loader3) {
  loader3._pending -= 1;
}
function boundStroke2(bounds3, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds3.expand(sw + (miter ? miterAdjustment2(item, sw) : 0));
  }
  return bounds3;
}
function miterAdjustment2(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
function boundContext2(_, deg) {
  bounds2 = _;
  if (deg) {
    rot2 = deg * DegToRad2;
    ma2 = md2 = Math.cos(rot2);
    mb2 = Math.sin(rot2);
    mc2 = -mb2;
  } else {
    ma2 = md2 = 1;
    rot2 = mb2 = mc2 = 0;
  }
  return context$12;
}
function quadExtrema2(x07, x13, x22, cb) {
  const t = (x07 - x13) / (x07 + x22 - 2 * x13);
  if (0 < t && t < 1)
    cb(x07 + (x13 - x07) * t);
}
function cubicExtrema2(x07, x13, x22, x32, cb) {
  const a4 = x32 - x07 + 3 * x13 - 3 * x22, b3 = x07 + x22 - 2 * x13, c2 = x07 - x13;
  let t07 = 0, t15 = 0, r2;
  if (Math.abs(a4) > Epsilon2) {
    r2 = b3 * b3 + c2 * a4;
    if (r2 >= 0) {
      r2 = Math.sqrt(r2);
      t07 = (-b3 + r2) / a4;
      t15 = (-b3 - r2) / a4;
    }
  } else {
    t07 = 0.5 * c2 / b3;
  }
  if (0 < t07 && t07 < 1)
    cb(cubic2(t07, x07, x13, x22, x32));
  if (0 < t15 && t15 < 1)
    cb(cubic2(t15, x07, x13, x22, x32));
}
function cubic2(t, x07, x13, x22, x32) {
  const s3 = 1 - t, s22 = s3 * s3, t23 = t * t;
  return s22 * s3 * x07 + 3 * s22 * t * x13 + 3 * s3 * t23 * x22 + t23 * t * x32;
}
function intersectPath2(draw4) {
  return function(item, brush) {
    if (!context2)
      return true;
    draw4(context2, item);
    b2.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = b2;
    for (let y7 = y13; y7 <= y22; ++y7) {
      for (let x7 = x13; x7 <= x22; ++x7) {
        if (context2.isPointInPath(x7, y7)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint2(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect2(item, box) {
  const x7 = item.x || 0, y7 = item.y || 0, w5 = item.width || 0, h4 = item.height || 0;
  return box.intersects(b2.set(x7, y7, x7 + w5, y7 + h4));
}
function intersectRule2(item, box) {
  const x7 = item.x || 0, y7 = item.y || 0, x22 = item.x2 != null ? item.x2 : x7, y22 = item.y2 != null ? item.y2 : y7;
  return intersectBoxLine2(box, x7, y7, x22, y22);
}
function intersectBoxLine2(box, x7, y7, u, v) {
  const {
    x1: x13,
    y1: y13,
    x2: x22,
    y2: y22
  } = box, dx = u - x7, dy = v - y7;
  let t07 = 0, t15 = 1, p, q, r2, e3;
  for (e3 = 0; e3 < 4; ++e3) {
    if (e3 === 0) {
      p = -dx;
      q = -(x13 - x7);
    }
    if (e3 === 1) {
      p = dx;
      q = x22 - x7;
    }
    if (e3 === 2) {
      p = -dy;
      q = -(y13 - y7);
    }
    if (e3 === 3) {
      p = dy;
      q = y22 - y7;
    }
    if (Math.abs(p) < 1e-10 && q < 0)
      return false;
    r2 = q / p;
    if (p < 0) {
      if (r2 > t15)
        return false;
      else if (r2 > t07)
        t07 = r2;
    } else if (p > 0) {
      if (r2 < t07)
        return false;
      else if (r2 < t15)
        t15 = r2;
    }
  }
  return true;
}
function blend2(context4, item) {
  context4.globalCompositeOperation = item.blend || "source-over";
}
function value2(value4, dflt) {
  return value4 == null ? dflt : value4;
}
function addStops2(gradient5, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient5.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient5;
}
function gradient2(context4, spec, bounds3) {
  const w5 = bounds3.width(), h4 = bounds3.height();
  let gradient5;
  if (spec.gradient === "radial") {
    gradient5 = context4.createRadialGradient(bounds3.x1 + value2(spec.x1, 0.5) * w5, bounds3.y1 + value2(spec.y1, 0.5) * h4, Math.max(w5, h4) * value2(spec.r1, 0), bounds3.x1 + value2(spec.x2, 0.5) * w5, bounds3.y1 + value2(spec.y2, 0.5) * h4, Math.max(w5, h4) * value2(spec.r2, 0.5));
  } else {
    const x13 = value2(spec.x1, 0), y13 = value2(spec.y1, 0), x22 = value2(spec.x2, 1), y22 = value2(spec.y2, 0);
    if (x13 === x22 || y13 === y22 || w5 === h4) {
      gradient5 = context4.createLinearGradient(bounds3.x1 + x13 * w5, bounds3.y1 + y13 * h4, bounds3.x1 + x22 * w5, bounds3.y1 + y22 * h4);
    } else {
      const image4 = domCanvas(Math.ceil(w5), Math.ceil(h4)), ictx = image4.getContext("2d");
      ictx.scale(w5, h4);
      ictx.fillStyle = addStops2(ictx.createLinearGradient(x13, y13, x22, y22), spec.stops);
      ictx.fillRect(0, 0, w5, h4);
      return context4.createPattern(image4, "no-repeat");
    }
  }
  return addStops2(gradient5, spec.stops);
}
function color4(context4, item, value4) {
  return isGradient2(value4) ? gradient2(context4, value4, item.bounds) : value4;
}
function fill2(context4, item, opacity2) {
  opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity2 > 0) {
    context4.globalAlpha = opacity2;
    context4.fillStyle = color4(context4, item, item.fill);
    return true;
  } else {
    return false;
  }
}
function stroke2(context4, item, opacity2) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0)
    return false;
  opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity2 > 0) {
    context4.globalAlpha = opacity2;
    context4.strokeStyle = color4(context4, item, item.stroke);
    context4.lineWidth = lw;
    context4.lineCap = item.strokeCap || "butt";
    context4.lineJoin = item.strokeJoin || "miter";
    context4.miterLimit = item.strokeMiterLimit || 10;
    if (context4.setLineDash) {
      context4.setLineDash(item.strokeDash || Empty3);
      context4.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare5(a4, b3) {
  return a4.zindex - b3.zindex || a4.index - b3.index;
}
function zorder2(scene) {
  if (!scene.zdirty)
    return scene.zitems;
  var items2 = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items2.length; i < n; ++i) {
    item = items2[i];
    item.index = i;
    if (item.zindex)
      output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare5);
}
function visit2(scene, visitor) {
  var items2 = scene.items, i, n;
  if (!items2 || !items2.length)
    return;
  const zitems = zorder2(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items2.length; i < n; ++i) {
      if (!items2[i].zindex)
        visitor(items2[i]);
    }
    items2 = zitems;
  }
  for (i = 0, n = items2.length; i < n; ++i) {
    visitor(items2[i]);
  }
}
function pickVisit2(scene, visitor) {
  var items2 = scene.items, hit3, i;
  if (!items2 || !items2.length)
    return null;
  const zitems = zorder2(scene);
  if (zitems && zitems.length)
    items2 = zitems;
  for (i = items2.length; --i >= 0; ) {
    if (hit3 = visitor(items2[i]))
      return hit3;
  }
  if (items2 === zitems) {
    for (items2 = scene.items, i = items2.length; --i >= 0; ) {
      if (!items2[i].zindex) {
        if (hit3 = visitor(items2[i]))
          return hit3;
      }
    }
  }
  return null;
}
function drawAll2(path5) {
  return function(context4, scene, bounds3) {
    visit2(scene, (item) => {
      if (!bounds3 || bounds3.intersects(item.bounds)) {
        drawPath2(path5, context4, item, item);
      }
    });
  };
}
function drawOne2(path5) {
  return function(context4, scene, bounds3) {
    if (scene.items.length && (!bounds3 || bounds3.intersects(scene.bounds))) {
      drawPath2(path5, context4, scene.items[0], scene.items);
    }
  };
}
function drawPath2(path5, context4, item, items2) {
  var opacity2 = item.opacity == null ? 1 : item.opacity;
  if (opacity2 === 0)
    return;
  if (path5(context4, items2))
    return;
  blend2(context4, item);
  if (item.fill && fill2(context4, item, opacity2)) {
    context4.fill();
  }
  if (item.stroke && stroke2(context4, item, opacity2)) {
    context4.stroke();
  }
}
function pick$12(test2) {
  test2 = test2 || truthy;
  return function(context4, scene, x7, y7, gx, gy) {
    x7 *= context4.pixelRatio;
    y7 *= context4.pixelRatio;
    return pickVisit2(scene, (item) => {
      const b3 = item.bounds;
      if (b3 && !b3.contains(gx, gy) || !b3)
        return;
      if (test2(context4, item, x7, y7, gx, gy))
        return item;
    });
  };
}
function hitPath2(path5, filled2) {
  return function(context4, o, x7, y7) {
    var item = Array.isArray(o) ? o[0] : o, fill3 = filled2 == null ? item.fill : filled2, stroke3 = item.stroke && context4.isPointInStroke, lw, lc;
    if (stroke3) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context4.lineWidth = lw != null ? lw : 1;
      context4.lineCap = lc != null ? lc : "butt";
    }
    return path5(context4, o) ? false : fill3 && context4.isPointInPath(x7, y7) || stroke3 && context4.isPointInStroke(x7, y7);
  };
}
function pickPath2(path5) {
  return pick$12(hitPath2(path5));
}
function translate3(x7, y7) {
  return "translate(" + x7 + "," + y7 + ")";
}
function rotate2(a4) {
  return "rotate(" + a4 + ")";
}
function scale4(scaleX, scaleY2) {
  return "scale(" + scaleX + "," + scaleY2 + ")";
}
function translateItem2(item) {
  return translate3(item.x || 0, item.y || 0);
}
function rotateItem2(item) {
  return translate3(item.x || 0, item.y || 0) + (item.angle ? " " + rotate2(item.angle) : "");
}
function transformItem2(item) {
  return translate3(item.x || 0, item.y || 0) + (item.angle ? " " + rotate2(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale4(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath2(type4, shape3, isect) {
  function attr3(emit3, item) {
    emit3("transform", rotateItem2(item));
    emit3("d", shape3(null, item));
  }
  function bound3(bounds3, item) {
    shape3(boundContext2(bounds3, item.angle), item);
    return boundStroke2(bounds3, item).translate(item.x || 0, item.y || 0);
  }
  function draw4(context4, item) {
    var x7 = item.x || 0, y7 = item.y || 0, a4 = item.angle || 0;
    context4.translate(x7, y7);
    if (a4)
      context4.rotate(a4 *= DegToRad2);
    context4.beginPath();
    shape3(context4, item);
    if (a4)
      context4.rotate(-a4);
    context4.translate(-x7, -y7);
  }
  return {
    type: type4,
    tag: "path",
    nested: false,
    attr: attr3,
    bound: bound3,
    draw: drawAll2(draw4),
    pick: pickPath2(draw4),
    isect: isect || intersectPath2(draw4)
  };
}
function pickArea2(a4, p) {
  var v = a4[0].orient === "horizontal" ? p[1] : p[0], z = a4[0].orient === "horizontal" ? "y" : "x", i = a4.length, min8 = Infinity, hit3, d;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    d = Math.abs(a4[i][z] - v);
    if (d < min8) {
      min8 = d;
      hit3 = a4[i];
    }
  }
  return hit3;
}
function pickLine2(a4, p) {
  var t = Math.pow(a4[0].strokeWidth || 1, 2), i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t)
      return a4[i];
  }
  return null;
}
function pickTrail2(a4, p) {
  var i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a4[i].size || 1;
    if (dd < dx * dx)
      return a4[i];
  }
  return null;
}
function markMultiItemPath2(type4, shape3, tip) {
  function attr3(emit3, item) {
    var items2 = item.mark.items;
    if (items2.length)
      emit3("d", shape3(null, items2));
  }
  function bound3(bounds3, mark) {
    var items2 = mark.items;
    if (items2.length === 0) {
      return bounds3;
    } else {
      shape3(boundContext2(bounds3), items2);
      return boundStroke2(bounds3, items2[0]);
    }
  }
  function draw4(context4, items2) {
    context4.beginPath();
    shape3(context4, items2);
  }
  const hit3 = hitPath2(draw4);
  function pick4(context4, scene, x7, y7, gx, gy) {
    var items2 = scene.items, b3 = scene.bounds;
    if (!items2 || !items2.length || b3 && !b3.contains(gx, gy)) {
      return null;
    }
    x7 *= context4.pixelRatio;
    y7 *= context4.pixelRatio;
    return hit3(context4, items2, x7, y7) ? items2[0] : null;
  }
  return {
    type: type4,
    tag: "path",
    nested: true,
    attr: attr3,
    bound: bound3,
    draw: drawOne2(draw4),
    pick: pick4,
    isect: intersectPoint2,
    tip
  };
}
function clip2(context4, scene) {
  var clip4 = scene.clip;
  context4.save();
  if (isFunction(clip4)) {
    context4.beginPath();
    clip4(context4);
    context4.clip();
  } else {
    clipGroup2(context4, scene.group);
  }
}
function clipGroup2(context4, group6) {
  context4.beginPath();
  hasCornerRadius2(group6) ? rectangle2(context4, group6, 0, 0) : context4.rect(0, 0, group6.width || 0, group6.height || 0);
  context4.clip();
}
function offset$12(item) {
  const sw = value2(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$52(emit3, item) {
  emit3("transform", translateItem2(item));
}
function emitRectangle2(emit3, item) {
  const off = offset$12(item);
  emit3("d", rectangle2(null, item, off, off));
}
function background2(emit3, item) {
  emit3("class", "background");
  emit3("aria-hidden", true);
  emitRectangle2(emit3, item);
}
function foreground2(emit3, item) {
  emit3("class", "foreground");
  emit3("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle2(emit3, item);
  } else {
    emit3("d", "");
  }
}
function content2(emit3, item, renderer) {
  const url = item.clip ? clip$12(renderer, item, item) : null;
  emit3("clip-path", url);
}
function bound$52(bounds3, group6) {
  if (!group6.clip && group6.items) {
    const items2 = group6.items, m2 = items2.length;
    for (let j = 0; j < m2; ++j) {
      bounds3.union(items2[j].bounds);
    }
  }
  if ((group6.clip || group6.width || group6.height) && !group6.noBound) {
    bounds3.add(0, 0).add(group6.width || 0, group6.height || 0);
  }
  boundStroke2(bounds3, group6);
  return bounds3.translate(group6.x || 0, group6.y || 0);
}
function rectanglePath2(context4, group6, x7, y7) {
  const off = offset$12(group6);
  context4.beginPath();
  rectangle2(context4, group6, (x7 || 0) + off, (y7 || 0) + off);
}
function draw$42(context4, scene, bounds3) {
  visit2(scene, (group6) => {
    const gx = group6.x || 0, gy = group6.y || 0, fore = group6.strokeForeground, opacity2 = group6.opacity == null ? 1 : group6.opacity;
    if ((group6.stroke || group6.fill) && opacity2) {
      rectanglePath2(context4, group6, gx, gy);
      blend2(context4, group6);
      if (group6.fill && fill2(context4, group6, opacity2)) {
        context4.fill();
      }
      if (group6.stroke && !fore && stroke2(context4, group6, opacity2)) {
        context4.stroke();
      }
    }
    context4.save();
    context4.translate(gx, gy);
    if (group6.clip)
      clipGroup2(context4, group6);
    if (bounds3)
      bounds3.translate(-gx, -gy);
    visit2(group6, (item) => {
      this.draw(context4, item, bounds3);
    });
    if (bounds3)
      bounds3.translate(gx, gy);
    context4.restore();
    if (fore && group6.stroke && opacity2) {
      rectanglePath2(context4, group6, gx, gy);
      blend2(context4, group6);
      if (stroke2(context4, group6, opacity2)) {
        context4.stroke();
      }
    }
  });
}
function pick2(context4, scene, x7, y7, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x7 * context4.pixelRatio, cy = y7 * context4.pixelRatio;
  return pickVisit2(scene, (group6) => {
    let hit3, dx, dy;
    const b3 = group6.bounds;
    if (b3 && !b3.contains(gx, gy))
      return;
    dx = group6.x || 0;
    dy = group6.y || 0;
    const dw = dx + (group6.width || 0), dh = dy + (group6.height || 0), c2 = group6.clip;
    if (c2 && (gx < dx || gx > dw || gy < dy || gy > dh))
      return;
    context4.save();
    context4.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c2 && hasCornerRadius2(group6) && !hitCorner2(context4, group6, cx, cy)) {
      context4.restore();
      return null;
    }
    const fore = group6.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group6.stroke && hitForeground2(context4, group6, cx, cy)) {
      context4.restore();
      return group6;
    }
    hit3 = pickVisit2(group6, (mark) => pickMark2(mark, dx, dy) ? this.pick(mark, x7, y7, dx, dy) : null);
    if (!hit3 && ix && (group6.fill || !fore && group6.stroke) && hitBackground2(context4, group6, cx, cy)) {
      hit3 = group6;
    }
    context4.restore();
    return hit3 || null;
  });
}
function pickMark2(mark, x7, y7) {
  return (mark.interactive !== false || mark.marktype === "group") && mark.bounds && mark.bounds.contains(x7, y7);
}
function getImage2(item, renderer) {
  var image4 = item.image;
  if (!image4 || item.url && item.url !== image4.url) {
    image4 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image5) => {
      item.image = image5;
      item.image.url = item.url;
    });
  }
  return image4;
}
function imageWidth2(item, image4) {
  return item.width != null ? item.width : !image4 || !image4.width ? 0 : item.aspect !== false && item.height ? item.height * image4.width / image4.height : image4.width;
}
function imageHeight2(item, image4) {
  return item.height != null ? item.height : !image4 || !image4.height ? 0 : item.aspect !== false && item.width ? item.width * image4.height / image4.width : image4.height;
}
function imageXOffset2(align2, w5) {
  return align2 === "center" ? w5 / 2 : align2 === "right" ? w5 : 0;
}
function imageYOffset2(baseline3, h4) {
  return baseline3 === "middle" ? h4 / 2 : baseline3 === "bottom" ? h4 : 0;
}
function attr$42(emit3, item, renderer) {
  const img = getImage2(item, renderer), w5 = imageWidth2(item, img), h4 = imageHeight2(item, img), x7 = (item.x || 0) - imageXOffset2(item.align, w5), y7 = (item.y || 0) - imageYOffset2(item.baseline, h4), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit3("href", i, metadata2["xmlns:xlink"], "xlink:href");
  emit3("transform", translate3(x7, y7));
  emit3("width", w5);
  emit3("height", h4);
  emit3("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$42(bounds3, item) {
  const img = item.image, w5 = imageWidth2(item, img), h4 = imageHeight2(item, img), x7 = (item.x || 0) - imageXOffset2(item.align, w5), y7 = (item.y || 0) - imageYOffset2(item.baseline, h4);
  return bounds3.set(x7, y7, x7 + w5, y7 + h4);
}
function draw$32(context4, scene, bounds3) {
  visit2(scene, (item) => {
    if (bounds3 && !bounds3.intersects(item.bounds))
      return;
    const img = getImage2(item, this);
    let w5 = imageWidth2(item, img);
    let h4 = imageHeight2(item, img);
    if (w5 === 0 || h4 === 0)
      return;
    let x7 = (item.x || 0) - imageXOffset2(item.align, w5), y7 = (item.y || 0) - imageYOffset2(item.baseline, h4), opacity2, ar0, ar1, t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w5 / ar0;
          y7 += (h4 - t) / 2;
          h4 = t;
        } else {
          t = h4 * ar0;
          x7 += (w5 - t) / 2;
          w5 = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend2(context4, item);
      context4.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
      context4.imageSmoothingEnabled = item.smooth !== false;
      context4.drawImage(img, x7, y7, w5, h4);
    }
  });
}
function attr$32(emit3, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit3("vector-effect", "non-scaling-stroke");
  }
  emit3("transform", transformItem2(item));
  emit3("d", item.path);
}
function path$12(context4, item) {
  var path5 = item.path;
  if (path5 == null)
    return true;
  var x7 = item.x || 0, y7 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a4 = (item.angle || 0) * DegToRad2, cache3 = item.pathCache;
  if (!cache3 || cache3.path !== path5) {
    (item.pathCache = cache3 = pathParse(path5)).path = path5;
  }
  if (a4 && context4.rotate && context4.translate) {
    context4.translate(x7, y7);
    context4.rotate(a4);
    pathRender2(context4, cache3, 0, 0, sx, sy);
    context4.rotate(-a4);
    context4.translate(-x7, -y7);
  } else {
    pathRender2(context4, cache3, x7, y7, sx, sy);
  }
}
function bound$32(bounds3, item) {
  return path$12(boundContext2(bounds3, item.angle), item) ? bounds3.set(0, 0, 0, 0) : boundStroke2(bounds3, item, true);
}
function attr$22(emit3, item) {
  emit3("d", rectangle2(null, item));
}
function bound$22(bounds3, item) {
  var x7, y7;
  return boundStroke2(bounds3.set(x7 = item.x || 0, y7 = item.y || 0, x7 + item.width || 0, y7 + item.height || 0), item);
}
function draw$22(context4, item) {
  context4.beginPath();
  rectangle2(context4, item);
}
function attr$12(emit3, item) {
  emit3("transform", translateItem2(item));
  emit3("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit3("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$12(bounds3, item) {
  var x13, y13;
  return boundStroke2(bounds3.set(x13 = item.x || 0, y13 = item.y || 0, item.x2 != null ? item.x2 : x13, item.y2 != null ? item.y2 : y13), item);
}
function path4(context4, item, opacity2) {
  var x13, y13, x22, y22;
  if (item.stroke && stroke2(context4, item, opacity2)) {
    x13 = item.x || 0;
    y13 = item.y || 0;
    x22 = item.x2 != null ? item.x2 : x13;
    y22 = item.y2 != null ? item.y2 : y13;
    context4.beginPath();
    context4.moveTo(x13, y13);
    context4.lineTo(x22, y22);
    return true;
  }
  return false;
}
function draw$12(context4, scene, bounds3) {
  visit2(scene, (item) => {
    if (bounds3 && !bounds3.intersects(item.bounds))
      return;
    var opacity2 = item.opacity == null ? 1 : item.opacity;
    if (opacity2 && path4(context4, item, opacity2)) {
      blend2(context4, item);
      context4.stroke();
    }
  });
}
function hit$12(context4, item, x7, y7) {
  if (!context4.isPointInStroke)
    return false;
  return path4(context4, item, 1) && context4.isPointInStroke(x7, y7);
}
function useCanvas2(use) {
  textMetrics2.width = use && context2 ? measureWidth2 : estimateWidth2;
}
function estimateWidth2(item, text5) {
  return _estimateWidth2(textValue2(item, text5), fontSize2(item));
}
function _estimateWidth2(text5, currentFontHeight) {
  return ~~(0.8 * text5.length * currentFontHeight);
}
function measureWidth2(item, text5) {
  return fontSize2(item) <= 0 || !(text5 = textValue2(item, text5)) ? 0 : _measureWidth2(text5, font2(item));
}
function _measureWidth2(text5, currentFont) {
  const key3 = `(${currentFont}) ${text5}`;
  let width2 = widthCache2.get(key3);
  if (width2 === void 0) {
    context2.font = currentFont;
    width2 = context2.measureText(text5).width;
    widthCache2.set(key3, width2);
  }
  return width2;
}
function fontSize2(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight2(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize2(item) + 2;
}
function lineArray2(_) {
  return isArray(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines2(item) {
  return lineArray2(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset2(item) {
  const tl3 = textLines2(item);
  return (isArray(tl3) ? tl3.length - 1 : 0) * lineHeight2(item);
}
function textValue2(item, line5) {
  const text5 = line5 == null ? "" : (line5 + "").trim();
  return item.limit > 0 && text5.length ? truncate3(item, text5) : text5;
}
function widthGetter2(item) {
  if (textMetrics2.width === measureWidth2) {
    const currentFont = font2(item);
    return (text5) => _measureWidth2(text5, currentFont);
  } else {
    const currentFontHeight = fontSize2(item);
    return (text5) => _estimateWidth2(text5, currentFontHeight);
  }
}
function truncate3(item, text5) {
  var limit = +item.limit, width2 = widthGetter2(item);
  if (width2(text5) < limit)
    return text5;
  var ellipsis = item.ellipsis || "", rtl = item.dir === "rtl", lo = 0, hi = text5.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text5.slice(mid)) > limit)
        lo = mid + 1;
      else
        hi = mid;
    }
    return ellipsis + text5.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text5.slice(0, mid)) < limit)
        lo = mid;
      else
        hi = mid - 1;
    }
    return text5.slice(0, lo) + ellipsis;
  }
}
function fontFamily2(item, quote) {
  var font4 = item.font;
  return (quote && font4 ? String(font4).replace(/"/g, "'") : font4) || "sans-serif";
}
function font2(item, quote) {
  return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize2(item) + "px " + fontFamily2(item, quote);
}
function offset3(item) {
  var baseline3 = item.baseline, h4 = fontSize2(item);
  return Math.round(baseline3 === "top" ? 0.79 * h4 : baseline3 === "middle" ? 0.3 * h4 : baseline3 === "bottom" ? -0.21 * h4 : baseline3 === "line-top" ? 0.29 * h4 + 0.5 * lineHeight2(item) : baseline3 === "line-bottom" ? 0.29 * h4 - 0.5 * lineHeight2(item) : 0);
}
function anchorPoint2(item) {
  var x7 = item.x || 0, y7 = item.y || 0, r2 = item.radius || 0, t;
  if (r2) {
    t = (item.theta || 0) - HalfPi2;
    x7 += r2 * Math.cos(t);
    y7 += r2 * Math.sin(t);
  }
  tempBounds3.x1 = x7;
  tempBounds3.y1 = y7;
  return tempBounds3;
}
function attr2(emit3, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset3(item), p = anchorPoint2(item), x7 = p.x1, y7 = p.y1, a4 = item.angle || 0, t;
  emit3("text-anchor", textAlign2[item.align] || "start");
  if (a4) {
    t = translate3(x7, y7) + " " + rotate2(a4);
    if (dx || dy)
      t += " " + translate3(dx, dy);
  } else {
    t = translate3(x7 + dx, y7 + dy);
  }
  emit3("transform", t);
}
function bound2(bounds3, item, mode3) {
  var h4 = textMetrics2.height(item), a4 = item.align, p = anchorPoint2(item), x7 = p.x1, y7 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset3(item) - Math.round(0.8 * h4), tl3 = textLines2(item), w5;
  if (isArray(tl3)) {
    h4 += lineHeight2(item) * (tl3.length - 1);
    w5 = tl3.reduce((w6, t) => Math.max(w6, textMetrics2.width(item, t)), 0);
  } else {
    w5 = textMetrics2.width(item, tl3);
  }
  if (a4 === "center") {
    dx -= w5 / 2;
  } else if (a4 === "right") {
    dx -= w5;
  } else
    ;
  bounds3.set(dx += x7, dy += y7, dx + w5, dy + h4);
  if (item.angle && !mode3) {
    bounds3.rotate(item.angle * DegToRad2, x7, y7);
  } else if (mode3 === 2) {
    return bounds3.rotatedPoints(item.angle * DegToRad2, x7, y7);
  }
  return bounds3;
}
function draw2(context4, scene, bounds3) {
  visit2(scene, (item) => {
    var opacity2 = item.opacity == null ? 1 : item.opacity, p, x7, y7, i, lh, tl3, str;
    if (bounds3 && !bounds3.intersects(item.bounds) || opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
      return;
    context4.font = font2(item);
    context4.textAlign = item.align || "left";
    p = anchorPoint2(item);
    x7 = p.x1, y7 = p.y1;
    if (item.angle) {
      context4.save();
      context4.translate(x7, y7);
      context4.rotate(item.angle * DegToRad2);
      x7 = y7 = 0;
    }
    x7 += item.dx || 0;
    y7 += (item.dy || 0) + offset3(item);
    tl3 = textLines2(item);
    blend2(context4, item);
    if (isArray(tl3)) {
      lh = lineHeight2(item);
      for (i = 0; i < tl3.length; ++i) {
        str = textValue2(item, tl3[i]);
        if (item.fill && fill2(context4, item, opacity2)) {
          context4.fillText(str, x7, y7);
        }
        if (item.stroke && stroke2(context4, item, opacity2)) {
          context4.strokeText(str, x7, y7);
        }
        y7 += lh;
      }
    } else {
      str = textValue2(item, tl3);
      if (item.fill && fill2(context4, item, opacity2)) {
        context4.fillText(str, x7, y7);
      }
      if (item.stroke && stroke2(context4, item, opacity2)) {
        context4.strokeText(str, x7, y7);
      }
    }
    if (item.angle)
      context4.restore();
  });
}
function hit2(context4, item, x7, y7, gx, gy) {
  if (item.fontSize <= 0)
    return false;
  if (!item.angle)
    return true;
  var p = anchorPoint2(item), ax = p.x1, ay = p.y1, b3 = bound2(tempBounds3, item, 1), a4 = -item.angle * DegToRad2, cos5 = Math.cos(a4), sin5 = Math.sin(a4), px3 = cos5 * gx - sin5 * gy + (ax - cos5 * ax + sin5 * ay), py3 = sin5 * gx + cos5 * gy + (ay - sin5 * ax - cos5 * ay);
  return b3.contains(px3, py3);
}
function intersectText2(item, box) {
  const p = bound2(tempBounds3, item, 2);
  return intersectBoxLine2(box, p[0], p[1], p[2], p[3]) || intersectBoxLine2(box, p[0], p[1], p[4], p[5]) || intersectBoxLine2(box, p[4], p[5], p[6], p[7]) || intersectBoxLine2(box, p[2], p[3], p[6], p[7]);
}
function boundItem3(item, func, opt) {
  var type4 = Marks2[item.mark.marktype], bound3 = func || type4.bound;
  if (type4.nested)
    item = item.mark;
  return bound3(item.bounds || (item.bounds = new Bounds2()), item, opt);
}
function boundMark2(mark, bounds3, opt) {
  var type4 = Marks2[mark.marktype], bound3 = type4.bound, items2 = mark.items, hasItems = items2 && items2.length, i, n, item, b3;
  if (type4.nested) {
    if (hasItems) {
      item = items2[0];
    } else {
      DUMMY2.mark = mark;
      item = DUMMY2;
    }
    b3 = boundItem3(item, bound3, opt);
    bounds3 = bounds3 && bounds3.union(b3) || b3;
    return bounds3;
  }
  bounds3 = bounds3 || mark.bounds && mark.bounds.clear() || new Bounds2();
  if (hasItems) {
    for (i = 0, n = items2.length; i < n; ++i) {
      bounds3.union(boundItem3(items2[i], bound3, opt));
    }
  }
  return mark.bounds = bounds3;
}
function sceneToJSON2(scene, indent) {
  return JSON.stringify(scene, keys2, indent);
}
function sceneFromJSON2(json3) {
  const scene = typeof json3 === "string" ? JSON.parse(json3) : json3;
  return initialize2(scene);
}
function initialize2(scene) {
  var type4 = scene.marktype, items2 = scene.items, parent, i, n;
  if (items2) {
    for (i = 0, n = items2.length; i < n; ++i) {
      parent = type4 ? "mark" : "group";
      items2[i][parent] = scene;
      if (items2[i].zindex)
        items2[i][parent].zdirty = true;
      if ("group" === (type4 || parent))
        initialize2(items2[i]);
    }
  }
  if (type4)
    boundMark2(scene);
  return scene;
}
function Scenegraph2(scene) {
  if (arguments.length) {
    this.root = sceneFromJSON2(scene);
  } else {
    this.root = createMark2({
      marktype: "group",
      name: "root",
      role: "frame"
    });
    this.root.items = [new GroupItem2(this.root)];
  }
}
function createMark2(def3, group6) {
  const mark = {
    bounds: new Bounds2(),
    clip: !!def3.clip,
    group: group6,
    interactive: def3.interactive === false ? false : true,
    items: [],
    marktype: def3.marktype,
    name: def3.name || void 0,
    role: def3.role || void 0,
    zindex: def3.zindex || 0
  };
  if (def3.aria != null) {
    mark.aria = def3.aria;
  }
  if (def3.description) {
    mark.description = def3.description;
  }
  return mark;
}
function domCreate2(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind2(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i)
    if (nodes[i].tagName.toLowerCase() === tag) {
      return nodes[i];
    }
}
function domChild2(el, index8, tag, ns) {
  var a4 = el.childNodes[index8], b3;
  if (!a4 || a4.tagName.toLowerCase() !== tag.toLowerCase()) {
    b3 = a4 || null;
    a4 = domCreate2(el.ownerDocument, tag, ns);
    el.insertBefore(a4, b3);
  }
  return a4;
}
function domClear2(el, index8) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index8)
    el.removeChild(nodes[--curr]);
  return el;
}
function cssClass2(mark) {
  return "mark-" + mark.marktype + (mark.role ? " role-" + mark.role : "") + (mark.name ? " " + mark.name : "");
}
function point14(event3, el) {
  const rect4 = el.getBoundingClientRect();
  return [event3.clientX - rect4.left - (el.clientLeft || 0), event3.clientY - rect4.top - (el.clientTop || 0)];
}
function resolveItem2(item, event3, el, origin) {
  var mark = item && item.mark, mdef, p;
  if (mark && (mdef = Marks2[mark.marktype]).tip) {
    p = point14(event3, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark.items, p);
  }
  return item;
}
function Handler2(customLoader, customTooltip) {
  this._active = null;
  this._handlers = {};
  this._loader = customLoader || loader2();
  this._tooltip = customTooltip || defaultTooltip2;
}
function defaultTooltip2(handler, event3, item, value4) {
  handler.element().setAttribute("title", value4 || "");
}
function Renderer2(loader3) {
  this._el = null;
  this._bgcolor = null;
  this._loader = new ResourceLoader2(loader3);
}
function CanvasHandler2(loader3, tooltip2) {
  Handler2.call(this, loader3, tooltip2);
  this._down = null;
  this._touch = null;
  this._first = true;
  this._events = {};
}
function eventListenerCheck2(handler, type4) {
  eventBundle2(type4).forEach((_) => addEventListener2(handler, _));
}
function addEventListener2(handler, type4) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type4]) {
    handler._events[type4] = 1;
    canvas.addEventListener(type4, handler[type4] ? (evt) => handler[type4](evt) : (evt) => handler.fire(type4, evt));
  }
}
function move2(moveEvent, overEvent, outEvent) {
  return function(evt) {
    const a4 = this._active, p = this.pickEvent(evt);
    if (p === a4) {
      this.fire(moveEvent, evt);
    } else {
      if (!a4 || !a4.exit) {
        this.fire(outEvent, evt);
      }
      this._active = p;
      this.fire(overEvent, evt);
      this.fire(moveEvent, evt);
    }
  };
}
function inactive2(type4) {
  return function(evt) {
    this.fire(type4, evt);
    this._active = null;
  };
}
function devicePixelRatio2() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
function resize2(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context4 = canvas.getContext("2d"), ratio = inDOM ? pixelRatio2 : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key3 in opt) {
    context4[key3] = opt[key3];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context4.pixelRatio = ratio;
  context4.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
function CanvasRenderer2(loader3) {
  Renderer2.call(this, loader3);
  this._options = {};
  this._redraw = false;
  this._dirty = new Bounds2();
  this._tempb = new Bounds2();
}
function clipToBounds2(g, b3, origin) {
  b3.expand(1).round();
  if (g.pixelRatio % 1) {
    b3.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b3.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b3.x1, b3.y1, b3.width(), b3.height());
  g.clip();
  return b3;
}
function SVGHandler2(loader3, tooltip2) {
  Handler2.call(this, loader3, tooltip2);
  const h4 = this;
  h4._hrefHandler = listener2(h4, (evt, item) => {
    if (item && item.href)
      h4.handleHref(evt, item, item.href);
  });
  h4._tooltipHandler = listener2(h4, (evt, item) => {
    h4.handleTooltip(evt, item, evt.type !== TooltipHideEvent2);
  });
}
function ariaItemAttributes2(emit3, item) {
  const hide = item.aria === false;
  emit3(ARIA_HIDDEN2, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode2) {
      emit3(AriaEncode2[prop], void 0);
    }
  } else {
    const type4 = item.mark.marktype;
    emit3(ARIA_LABEL2, item.description);
    emit3(ARIA_ROLE2, item.ariaRole || (type4 === "group" ? GRAPHICS_OBJECT2 : GRAPHICS_SYMBOL2));
    emit3(ARIA_ROLEDESCRIPTION2, item.ariaRoleDescription || `${type4} mark`);
  }
}
function ariaMarkAttributes2(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN2]: true
  } : AriaIgnore2[mark.role] ? null : AriaGuides2[mark.role] ? ariaGuide2(mark, AriaGuides2[mark.role]) : ariaMark2(mark);
}
function ariaMark2(mark) {
  const type4 = mark.marktype;
  const recurse3 = type4 === "group" || type4 === "text" || mark.items.some((_) => _.description != null && _.aria !== false);
  return bundle2(recurse3 ? GRAPHICS_OBJECT2 : GRAPHICS_SYMBOL2, `${type4} mark container`, mark.description);
}
function ariaGuide2(mark, opt) {
  try {
    const item = mark.items[0], caption = opt.caption || (() => "");
    return bundle2(opt.role || GRAPHICS_SYMBOL2, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption2(item) {
  return array(item.text).join(" ");
}
function axisCaption2(item) {
  const datum2 = item.datum, orient3 = item.orient, title2 = datum2.title ? extractTitle2(item) : null, ctx = item.context, scale8 = ctx.scales[datum2.scale].value, locale7 = ctx.dataflow.locale(), type4 = scale8.type, xy = orient3 === "left" || orient3 === "right" ? "Y" : "X";
  return `${xy}-axis` + (title2 ? ` titled '${title2}'` : "") + ` for a ${isDiscrete2(type4) ? "discrete" : type4} scale with ${domainCaption2(locale7, scale8, item)}`;
}
function legendCaption2(item) {
  const datum2 = item.datum, title2 = datum2.title ? extractTitle2(item) : null, type4 = `${datum2.type || ""} legend`.trim(), scales3 = datum2.scales, props = Object.keys(scales3), ctx = item.context, scale8 = ctx.scales[scales3[props[0]]].value, locale7 = ctx.dataflow.locale();
  return capitalize2(type4) + (title2 ? ` titled '${title2}'` : "") + ` for ${channelCaption2(props)} with ${domainCaption2(locale7, scale8, item)}`;
}
function extractTitle2(item) {
  try {
    return array(peek(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption2(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek(props);
}
function capitalize2(s3) {
  return s3.length ? s3[0].toUpperCase() + s3.slice(1) : s3;
}
function markup2() {
  let buf = "", outer = "", inner = "";
  const stack3 = [], clear2 = () => outer = inner = "", push = (tag) => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear2();
    }
    stack3.push(tag);
  }, attr3 = (name4, value4) => {
    if (value4 != null)
      outer += ` ${name4}="${attrText2(value4)}"`;
    return m2;
  }, m2 = {
    open(tag, ...attrs) {
      push(tag);
      outer = "<" + tag;
      for (const set8 of attrs) {
        for (const key3 in set8)
          attr3(key3, set8[key3]);
      }
      return m2;
    },
    close() {
      const tag = stack3.pop();
      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : "/>");
      } else {
        buf += `</${tag}>`;
      }
      clear2();
      return m2;
    },
    attr: attr3,
    text: (t) => (inner += innerText2(t), m2),
    toString: () => buf
  };
  return m2;
}
function _serialize2(m2, node) {
  m2.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m2.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children5 = node.childNodes, n = children5.length;
    for (let i = 0; i < n; i++) {
      const child = children5[i];
      child.nodeType === 3 ? m2.text(child.nodeValue) : _serialize2(m2, child);
    }
  }
  return m2.close();
}
function SVGRenderer2(loader3) {
  Renderer2.call(this, loader3);
  this._dirtyID = 0;
  this._dirty = [];
  this._svg = null;
  this._root = null;
  this._defs = null;
}
function dirtyParents2(item, id4) {
  for (; item && item.dirty !== id4; item = item.mark.group) {
    item.dirty = id4;
    if (item.mark && item.mark.dirty !== id4) {
      item.mark.dirty = id4;
    } else
      return;
  }
}
function updateGradient2(el, grad, index8) {
  let i, n, stop2;
  if (grad.gradient === "radial") {
    let pt = domChild2(el, index8++, "pattern", svgns2);
    setAttributes2(pt, {
      id: patternPrefix2 + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild2(pt, 0, "rect", svgns2);
    setAttributes2(pt, {
      width: 1,
      height: 1,
      fill: `url(${href2()}#${grad.id})`
    });
    el = domChild2(el, index8++, "radialGradient", svgns2);
    setAttributes2(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild2(el, index8++, "linearGradient", svgns2);
    setAttributes2(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop2 = domChild2(el, i, "stop", svgns2);
    stop2.setAttribute("offset", grad.stops[i].offset);
    stop2.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear2(el, i);
  return index8;
}
function updateClipping2(el, clip4, index8) {
  let mask;
  el = domChild2(el, index8, "clipPath", svgns2);
  el.setAttribute("id", clip4.id);
  if (clip4.path) {
    mask = domChild2(el, 0, "path", svgns2);
    mask.setAttribute("d", clip4.path);
  } else {
    mask = domChild2(el, 0, "rect", svgns2);
    setAttributes2(mask, {
      x: 0,
      y: 0,
      width: clip4.width,
      height: clip4.height
    });
  }
  domClear2(el, 1);
  return index8 + 1;
}
function recurse2(renderer, el, group6) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit2(group6, (item) => {
    prev = renderer.mark(el, item, prev);
    ++idx;
  });
  domClear2(el, 1 + idx);
}
function bind2(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate2(doc, tag, svgns2);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate2(doc, "path", svgns2);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate2(doc, "g", svgns2);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate2(doc, "path", svgns2);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck2(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck2(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
function emit2(name4, value4, ns) {
  if (value4 === values2[name4])
    return;
  if (ns) {
    setAttributeNS2(element2, name4, value4, ns);
  } else {
    setAttribute2(element2, name4, value4);
  }
  values2[name4] = value4;
}
function setStyle2(el, name4, value4) {
  if (value4 !== values2[name4]) {
    if (value4 == null) {
      el.style.removeProperty(name4);
    } else {
      el.style.setProperty(name4, value4 + "");
    }
    values2[name4] = value4;
  }
}
function setAttributes2(el, attrs) {
  for (const key3 in attrs) {
    setAttribute2(el, key3, attrs[key3]);
  }
}
function setAttribute2(el, name4, value4) {
  if (value4 != null) {
    el.setAttribute(name4, value4);
  } else {
    el.removeAttribute(name4);
  }
}
function setAttributeNS2(el, name4, value4, ns) {
  if (value4 != null) {
    el.setAttributeNS(ns, name4, value4);
  } else {
    el.removeAttributeNS(ns, name4);
  }
}
function href2() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
function SVGStringRenderer2(loader3) {
  Renderer2.call(this, loader3);
  this._text = null;
  this._defs = {
    gradient: {},
    clipping: {}
  };
}
function style2(s3, item, scene, tag, defs) {
  if (item == null)
    return s3;
  if (tag === "bgrect" && scene.interactive === false) {
    s3["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s3["pointer-events"] = "none";
    }
    s3.display = "none";
    if (item.fill !== null)
      return s3;
  }
  if (tag === "image" && item.smooth === false) {
    s3.style = "image-rendering: optimizeSpeed; image-rendering: pixelated;";
  }
  if (tag === "text") {
    s3["font-family"] = fontFamily2(item);
    s3["font-size"] = fontSize2(item) + "px";
    s3["font-style"] = item.fontStyle;
    s3["font-variant"] = item.fontVariant;
    s3["font-weight"] = item.fontWeight;
  }
  for (const prop in styles) {
    let value4 = item[prop];
    const name4 = styles[prop];
    if (value4 === "transparent" && (name4 === "fill" || name4 === "stroke"))
      ;
    else if (value4 != null) {
      if (isGradient2(value4)) {
        value4 = gradientRef2(value4, defs.gradient, "");
      }
      s3[name4] = value4;
    }
  }
  return s3;
}
function renderModule(name4, _) {
  name4 = String(name4 || "").toLowerCase();
  if (arguments.length > 1) {
    modules2[name4] = _;
    return this;
  } else {
    return modules2[name4];
  }
}
function intersect4(scene, bounds3, filter6) {
  const hits = [], box = new Bounds2().union(bounds3), type4 = scene.marktype;
  return type4 ? intersectMark(scene, box, filter6, hits) : type4 === "group" ? intersectGroup(scene, box, filter6, hits) : error("Intersect scene must be mark node or group item.");
}
function intersectMark(mark, box, filter6, hits) {
  if (visitMark(mark, box, filter6)) {
    const items2 = mark.items, type4 = mark.marktype, n = items2.length;
    let i = 0;
    if (type4 === "group") {
      for (; i < n; ++i) {
        intersectGroup(items2[i], box, filter6, hits);
      }
    } else {
      for (const test2 = Marks2[type4].isect; i < n; ++i) {
        const item = items2[i];
        if (intersectItem(item, box, test2))
          hits.push(item);
      }
    }
  }
  return hits;
}
function visitMark(mark, box, filter6) {
  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === "group" || mark.interactive !== false && (!filter6 || filter6(mark)));
}
function intersectGroup(group6, box, filter6, hits) {
  if (filter6 && filter6(group6.mark) && intersectItem(group6, box, Marks2.group.isect)) {
    hits.push(group6);
  }
  const marks = group6.items, n = marks && marks.length;
  if (n) {
    const x7 = group6.x || 0, y7 = group6.y || 0;
    box.translate(-x7, -y7);
    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter6, hits);
    }
    box.translate(x7, y7);
  }
  return hits;
}
function intersectItem(item, box, test2) {
  const bounds3 = item.bounds;
  return box.encloses(bounds3) || box.intersects(bounds3) && test2(item, box);
}
function boundClip2(mark) {
  const clip4 = mark.clip;
  if (isFunction(clip4)) {
    clip4(boundContext2(clipBounds2.clear()));
  } else if (clip4) {
    clipBounds2.set(0, 0, mark.group.width, mark.group.height);
  } else
    return;
  mark.bounds.intersect(clipBounds2);
}
function sceneEqual(a4, b3, key3) {
  return a4 === b3 ? true : key3 === "path" ? pathEqual(a4, b3) : a4 instanceof Date && b3 instanceof Date ? +a4 === +b3 : isNumber(a4) && isNumber(b3) ? Math.abs(a4 - b3) <= TOLERANCE : !a4 || !b3 || !isObject(a4) && !isObject(b3) ? a4 == b3 : objectEqual(a4, b3);
}
function pathEqual(a4, b3) {
  return sceneEqual(pathParse(a4), pathParse(b3));
}
function objectEqual(a4, b3) {
  var ka = Object.keys(a4), kb = Object.keys(b3), key3, i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key3 = ka[i];
    if (!sceneEqual(a4[key3], b3[key3], key3))
      return false;
  }
  return typeof a4 === typeof b3;
}
function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}
var gradient_id2, patternPrefix2, lookup4, cmdlen, regexp, DegToRad2, Epsilon2, HalfPi2, Tau2, HalfSqrt32, segmentCache2, bezierCache2, join2, temp2, Tan302, builtins2, custom18, C4, x6, y6, w3, h2, xw2, yh2, sa2, ea2, pa2, ir2, or2, cr2, tl2, tr2, br2, bl2, sz2, ts2, def2, type2, arcShape2, areavShape2, areahShape2, lineShape2, rectShape2, symbolShape2, trailShape2, clip_id2, circleThreshold2, bounds2, lx2, ly2, rot2, ma2, mb2, mc2, md2, add5, addL2, addX2, addY2, px2, py2, addp2, addpL2, context$12, context2, b2, Empty3, arc3, area3, hitBackground2, hitForeground2, hitCorner2, group4, metadata2, image2, line3, path$22, rect2, rule2, shape2, symbol2, widthCache2, textMetrics2, textAlign2, tempBounds3, text2, trail2, Marks2, DUMMY2, keys2, KeyDownEvent2, KeyPressEvent2, KeyUpEvent2, DragEnterEvent2, DragLeaveEvent2, DragOverEvent2, MouseDownEvent2, MouseUpEvent2, MouseMoveEvent2, MouseOutEvent2, MouseOverEvent2, ClickEvent2, DoubleClickEvent2, WheelEvent2, MouseWheelEvent2, TouchStartEvent2, TouchMoveEvent2, TouchEndEvent2, Events2, TooltipShowEvent2, TooltipHideEvent2, HrefEvent2, eventBundle2, pixelRatio2, base$12, viewBounds2, listener2, ARIA_HIDDEN2, ARIA_LABEL2, ARIA_ROLE2, ARIA_ROLEDESCRIPTION2, GRAPHICS_OBJECT2, GRAPHICS_SYMBOL2, bundle2, AriaIgnore2, AriaGuides2, AriaEncode2, innerText2, attrText2, serializeXML2, styles, rootAttributes2, RootIndex2, xmlns2, svgns2, base2, element2, values2, mark_extras2, Canvas2, PNG2, SVG2, None5, RenderType, modules2, clipBounds2, TOLERANCE;
var init_vega_scenegraph_module2 = __esm({
  "node_modules/.pnpm/vega-scenegraph@4.9.4/node_modules/vega-scenegraph/build/vega-scenegraph.module.js"() {
    init_vega_util_module();
    init_src29();
    init_src28();
    init_vega_canvas_browser_module();
    init_vega_loader_browser_module2();
    init_vega_scale_module2();
    gradient_id2 = 0;
    patternPrefix2 = "p_";
    lookup4 = {
      "basis": {
        curve: basis_default4
      },
      "basis-closed": {
        curve: basisClosed_default4
      },
      "basis-open": {
        curve: basisOpen_default2
      },
      "bundle": {
        curve: bundle_default2,
        tension: "beta",
        value: 0.85
      },
      "cardinal": {
        curve: cardinal_default2,
        tension: "tension",
        value: 0
      },
      "cardinal-open": {
        curve: cardinalOpen_default2,
        tension: "tension",
        value: 0
      },
      "cardinal-closed": {
        curve: cardinalClosed_default2,
        tension: "tension",
        value: 0
      },
      "catmull-rom": {
        curve: catmullRom_default2,
        tension: "alpha",
        value: 0.5
      },
      "catmull-rom-closed": {
        curve: catmullRomClosed_default2,
        tension: "alpha",
        value: 0.5
      },
      "catmull-rom-open": {
        curve: catmullRomOpen_default2,
        tension: "alpha",
        value: 0.5
      },
      "linear": {
        curve: linear_default2
      },
      "linear-closed": {
        curve: linearClosed_default2
      },
      "monotone": {
        horizontal: monotoneY2,
        vertical: monotoneX2
      },
      "natural": {
        curve: natural_default2
      },
      "step": {
        curve: step_default2
      },
      "step-after": {
        curve: stepAfter2
      },
      "step-before": {
        curve: stepBefore2
      }
    };
    cmdlen = {
      m: 2,
      l: 2,
      h: 1,
      v: 1,
      c: 6,
      s: 4,
      q: 4,
      t: 2,
      a: 7
    };
    regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\.\d+)(\.\d)/g, /(\d)([-+])/g, /\s|,|###/];
    DegToRad2 = Math.PI / 180;
    Epsilon2 = 1e-14;
    HalfPi2 = Math.PI / 2;
    Tau2 = Math.PI * 2;
    HalfSqrt32 = Math.sqrt(3) / 2;
    segmentCache2 = {};
    bezierCache2 = {};
    join2 = [].join;
    temp2 = ["l", 0, 0, 0, 0, 0, 0, 0];
    Tan302 = 0.5773502691896257;
    builtins2 = {
      "circle": {
        draw: function(context4, size) {
          const r2 = Math.sqrt(size) / 2;
          context4.moveTo(r2, 0);
          context4.arc(0, 0, r2, 0, Tau2);
        }
      },
      "cross": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, s3 = r2 / 2.5;
          context4.moveTo(-r2, -s3);
          context4.lineTo(-r2, s3);
          context4.lineTo(-s3, s3);
          context4.lineTo(-s3, r2);
          context4.lineTo(s3, r2);
          context4.lineTo(s3, s3);
          context4.lineTo(r2, s3);
          context4.lineTo(r2, -s3);
          context4.lineTo(s3, -s3);
          context4.lineTo(s3, -r2);
          context4.lineTo(-s3, -r2);
          context4.lineTo(-s3, -s3);
          context4.closePath();
        }
      },
      "diamond": {
        draw: function(context4, size) {
          const r2 = Math.sqrt(size) / 2;
          context4.moveTo(-r2, 0);
          context4.lineTo(0, -r2);
          context4.lineTo(r2, 0);
          context4.lineTo(0, r2);
          context4.closePath();
        }
      },
      "square": {
        draw: function(context4, size) {
          var w5 = Math.sqrt(size), x7 = -w5 / 2;
          context4.rect(x7, x7, w5, w5);
        }
      },
      "arrow": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, s3 = r2 / 7, t = r2 / 2.5, v = r2 / 8;
          context4.moveTo(-s3, r2);
          context4.lineTo(s3, r2);
          context4.lineTo(s3, -v);
          context4.lineTo(t, -v);
          context4.lineTo(0, -r2);
          context4.lineTo(-t, -v);
          context4.lineTo(-s3, -v);
          context4.closePath();
        }
      },
      "wedge": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt32 * r2, o = h4 - r2 * Tan302, b3 = r2 / 4;
          context4.moveTo(0, -h4 - o);
          context4.lineTo(-b3, h4 - o);
          context4.lineTo(b3, h4 - o);
          context4.closePath();
        }
      },
      "triangle": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt32 * r2, o = h4 - r2 * Tan302;
          context4.moveTo(0, -h4 - o);
          context4.lineTo(-r2, h4 - o);
          context4.lineTo(r2, h4 - o);
          context4.closePath();
        }
      },
      "triangle-up": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt32 * r2;
          context4.moveTo(0, -h4);
          context4.lineTo(-r2, h4);
          context4.lineTo(r2, h4);
          context4.closePath();
        }
      },
      "triangle-down": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt32 * r2;
          context4.moveTo(0, h4);
          context4.lineTo(-r2, -h4);
          context4.lineTo(r2, -h4);
          context4.closePath();
        }
      },
      "triangle-right": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt32 * r2;
          context4.moveTo(h4, 0);
          context4.lineTo(-h4, -r2);
          context4.lineTo(-h4, r2);
          context4.closePath();
        }
      },
      "triangle-left": {
        draw: function(context4, size) {
          var r2 = Math.sqrt(size) / 2, h4 = HalfSqrt32 * r2;
          context4.moveTo(-h4, 0);
          context4.lineTo(h4, -r2);
          context4.lineTo(h4, r2);
          context4.closePath();
        }
      },
      "stroke": {
        draw: function(context4, size) {
          const r2 = Math.sqrt(size) / 2;
          context4.moveTo(-r2, 0);
          context4.lineTo(r2, 0);
        }
      }
    };
    custom18 = {};
    C4 = 0.448084975506;
    x6 = (item) => item.x || 0;
    y6 = (item) => item.y || 0;
    w3 = (item) => item.width || 0;
    h2 = (item) => item.height || 0;
    xw2 = (item) => (item.x || 0) + (item.width || 0);
    yh2 = (item) => (item.y || 0) + (item.height || 0);
    sa2 = (item) => item.startAngle || 0;
    ea2 = (item) => item.endAngle || 0;
    pa2 = (item) => item.padAngle || 0;
    ir2 = (item) => item.innerRadius || 0;
    or2 = (item) => item.outerRadius || 0;
    cr2 = (item) => item.cornerRadius || 0;
    tl2 = (item) => value$12(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
    tr2 = (item) => value$12(item.cornerRadiusTopRight, item.cornerRadius) || 0;
    br2 = (item) => value$12(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
    bl2 = (item) => value$12(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
    sz2 = (item) => value$12(item.size, 64);
    ts2 = (item) => item.size || 1;
    def2 = (item) => !(item.defined === false);
    type2 = (item) => symbols5(item.shape || "circle");
    arcShape2 = arc_default2().startAngle(sa2).endAngle(ea2).padAngle(pa2).innerRadius(ir2).outerRadius(or2).cornerRadius(cr2);
    areavShape2 = area_default4().x(x6).y1(y6).y0(yh2).defined(def2);
    areahShape2 = area_default4().y(y6).x1(x6).x0(xw2).defined(def2);
    lineShape2 = line_default3().x(x6).y(y6).defined(def2);
    rectShape2 = vg_rect2().x(x6).y(y6).width(w3).height(h2).cornerRadius(tl2, tr2, br2, bl2);
    symbolShape2 = symbol_default().type(type2).size(sz2);
    trailShape2 = vg_trail2().x(x6).y(y6).defined(def2).size(ts2);
    clip_id2 = 1;
    Bounds2.prototype = {
      clone() {
        return new Bounds2(this);
      },
      clear() {
        this.x1 = +Number.MAX_VALUE;
        this.y1 = +Number.MAX_VALUE;
        this.x2 = -Number.MAX_VALUE;
        this.y2 = -Number.MAX_VALUE;
        return this;
      },
      empty() {
        return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
      },
      equals(b3) {
        return this.x1 === b3.x1 && this.y1 === b3.y1 && this.x2 === b3.x2 && this.y2 === b3.y2;
      },
      set(x13, y13, x22, y22) {
        if (x22 < x13) {
          this.x2 = x13;
          this.x1 = x22;
        } else {
          this.x1 = x13;
          this.x2 = x22;
        }
        if (y22 < y13) {
          this.y2 = y13;
          this.y1 = y22;
        } else {
          this.y1 = y13;
          this.y2 = y22;
        }
        return this;
      },
      add(x7, y7) {
        if (x7 < this.x1)
          this.x1 = x7;
        if (y7 < this.y1)
          this.y1 = y7;
        if (x7 > this.x2)
          this.x2 = x7;
        if (y7 > this.y2)
          this.y2 = y7;
        return this;
      },
      expand(d) {
        this.x1 -= d;
        this.y1 -= d;
        this.x2 += d;
        this.y2 += d;
        return this;
      },
      round() {
        this.x1 = Math.floor(this.x1);
        this.y1 = Math.floor(this.y1);
        this.x2 = Math.ceil(this.x2);
        this.y2 = Math.ceil(this.y2);
        return this;
      },
      scale(s3) {
        this.x1 *= s3;
        this.y1 *= s3;
        this.x2 *= s3;
        this.y2 *= s3;
        return this;
      },
      translate(dx, dy) {
        this.x1 += dx;
        this.x2 += dx;
        this.y1 += dy;
        this.y2 += dy;
        return this;
      },
      rotate(angle2, x7, y7) {
        const p = this.rotatedPoints(angle2, x7, y7);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
      },
      rotatedPoints(angle2, x7, y7) {
        var {
          x1: x13,
          y1: y13,
          x2: x22,
          y2: y22
        } = this, cos5 = Math.cos(angle2), sin5 = Math.sin(angle2), cx = x7 - x7 * cos5 + y7 * sin5, cy = y7 - x7 * sin5 - y7 * cos5;
        return [cos5 * x13 - sin5 * y13 + cx, sin5 * x13 + cos5 * y13 + cy, cos5 * x13 - sin5 * y22 + cx, sin5 * x13 + cos5 * y22 + cy, cos5 * x22 - sin5 * y13 + cx, sin5 * x22 + cos5 * y13 + cy, cos5 * x22 - sin5 * y22 + cx, sin5 * x22 + cos5 * y22 + cy];
      },
      union(b3) {
        if (b3.x1 < this.x1)
          this.x1 = b3.x1;
        if (b3.y1 < this.y1)
          this.y1 = b3.y1;
        if (b3.x2 > this.x2)
          this.x2 = b3.x2;
        if (b3.y2 > this.y2)
          this.y2 = b3.y2;
        return this;
      },
      intersect(b3) {
        if (b3.x1 > this.x1)
          this.x1 = b3.x1;
        if (b3.y1 > this.y1)
          this.y1 = b3.y1;
        if (b3.x2 < this.x2)
          this.x2 = b3.x2;
        if (b3.y2 < this.y2)
          this.y2 = b3.y2;
        return this;
      },
      encloses(b3) {
        return b3 && this.x1 <= b3.x1 && this.x2 >= b3.x2 && this.y1 <= b3.y1 && this.y2 >= b3.y2;
      },
      alignsWith(b3) {
        return b3 && (this.x1 == b3.x1 || this.x2 == b3.x2 || this.y1 == b3.y1 || this.y2 == b3.y2);
      },
      intersects(b3) {
        return b3 && !(this.x2 < b3.x1 || this.x1 > b3.x2 || this.y2 < b3.y1 || this.y1 > b3.y2);
      },
      contains(x7, y7) {
        return !(x7 < this.x1 || x7 > this.x2 || y7 < this.y1 || y7 > this.y2);
      },
      width() {
        return this.x2 - this.x1;
      },
      height() {
        return this.y2 - this.y1;
      }
    };
    inherits(GroupItem2, Item2);
    ResourceLoader2.prototype = {
      pending() {
        return this._pending;
      },
      sanitizeURL(uri) {
        const loader3 = this;
        increment2(loader3);
        return loader3._loader.sanitize(uri, {
          context: "href"
        }).then((opt) => {
          decrement2(loader3);
          return opt;
        }).catch(() => {
          decrement2(loader3);
          return null;
        });
      },
      loadImage(uri) {
        const loader3 = this, Image2 = domImage();
        increment2(loader3);
        return loader3._loader.sanitize(uri, {
          context: "image"
        }).then((opt) => {
          const url = opt.href;
          if (!url || !Image2)
            throw {
              url
            };
          const img = new Image2();
          const cors = has(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
          if (cors != null)
            img.crossOrigin = cors;
          img.onload = () => decrement2(loader3);
          img.onerror = () => decrement2(loader3);
          img.src = url;
          return img;
        }).catch((e3) => {
          decrement2(loader3);
          return {
            complete: false,
            width: 0,
            height: 0,
            src: e3 && e3.url || ""
          };
        });
      },
      ready() {
        const loader3 = this;
        return new Promise((accept) => {
          function poll(value4) {
            if (!loader3.pending())
              accept(value4);
            else
              setTimeout(() => {
                poll(true);
              }, 10);
          }
          poll(false);
        });
      }
    };
    circleThreshold2 = Tau2 - 1e-8;
    add5 = (x7, y7) => bounds2.add(x7, y7);
    addL2 = (x7, y7) => add5(lx2 = x7, ly2 = y7);
    addX2 = (x7) => add5(x7, bounds2.y1);
    addY2 = (y7) => add5(bounds2.x1, y7);
    px2 = (x7, y7) => ma2 * x7 + mc2 * y7;
    py2 = (x7, y7) => mb2 * x7 + md2 * y7;
    addp2 = (x7, y7) => add5(px2(x7, y7), py2(x7, y7));
    addpL2 = (x7, y7) => addL2(px2(x7, y7), py2(x7, y7));
    context$12 = {
      beginPath() {
      },
      closePath() {
      },
      moveTo: addpL2,
      lineTo: addpL2,
      rect(x7, y7, w5, h4) {
        if (rot2) {
          addp2(x7 + w5, y7);
          addp2(x7 + w5, y7 + h4);
          addp2(x7, y7 + h4);
          addpL2(x7, y7);
        } else {
          add5(x7 + w5, y7 + h4);
          addL2(x7, y7);
        }
      },
      quadraticCurveTo(x13, y13, x22, y22) {
        const px1 = px2(x13, y13), py1 = py2(x13, y13), px22 = px2(x22, y22), py22 = py2(x22, y22);
        quadExtrema2(lx2, px1, px22, addX2);
        quadExtrema2(ly2, py1, py22, addY2);
        addL2(px22, py22);
      },
      bezierCurveTo(x13, y13, x22, y22, x32, y32) {
        const px1 = px2(x13, y13), py1 = py2(x13, y13), px22 = px2(x22, y22), py22 = py2(x22, y22), px3 = px2(x32, y32), py3 = py2(x32, y32);
        cubicExtrema2(lx2, px1, px22, px3, addX2);
        cubicExtrema2(ly2, py1, py22, py3, addY2);
        addL2(px3, py3);
      },
      arc(cx, cy, r2, sa3, ea3, ccw) {
        sa3 += rot2;
        ea3 += rot2;
        lx2 = r2 * Math.cos(ea3) + cx;
        ly2 = r2 * Math.sin(ea3) + cy;
        if (Math.abs(ea3 - sa3) > circleThreshold2) {
          add5(cx - r2, cy - r2);
          add5(cx + r2, cy + r2);
        } else {
          const update3 = (a4) => add5(r2 * Math.cos(a4) + cx, r2 * Math.sin(a4) + cy);
          let s3, i;
          update3(sa3);
          update3(ea3);
          if (ea3 !== sa3) {
            sa3 = sa3 % Tau2;
            if (sa3 < 0)
              sa3 += Tau2;
            ea3 = ea3 % Tau2;
            if (ea3 < 0)
              ea3 += Tau2;
            if (ea3 < sa3) {
              ccw = !ccw;
              s3 = sa3;
              sa3 = ea3;
              ea3 = s3;
            }
            if (ccw) {
              ea3 -= Tau2;
              s3 = sa3 - sa3 % HalfPi2;
              for (i = 0; i < 4 && s3 > ea3; ++i, s3 -= HalfPi2)
                update3(s3);
            } else {
              s3 = sa3 - sa3 % HalfPi2 + HalfPi2;
              for (i = 0; i < 4 && s3 < ea3; ++i, s3 = s3 + HalfPi2)
                update3(s3);
            }
          }
        }
      }
    };
    context2 = (context2 = domCanvas(1, 1)) ? context2.getContext("2d") : null;
    b2 = new Bounds2();
    Empty3 = [];
    arc3 = markItemPath2("arc", arc$12);
    area3 = markMultiItemPath2("area", area$12, pickArea2);
    hitBackground2 = hitPath2(rectanglePath2);
    hitForeground2 = hitPath2(rectanglePath2, false);
    hitCorner2 = hitPath2(rectanglePath2, true);
    group4 = {
      type: "group",
      tag: "g",
      nested: false,
      attr: attr$52,
      bound: bound$52,
      draw: draw$42,
      pick: pick2,
      isect: intersectRect2,
      content: content2,
      background: background2,
      foreground: foreground2
    };
    metadata2 = {
      "xmlns": "http://www.w3.org/2000/svg",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "version": "1.1"
    };
    image2 = {
      type: "image",
      tag: "image",
      nested: false,
      attr: attr$42,
      bound: bound$42,
      draw: draw$32,
      pick: pick$12(),
      isect: truthy,
      get: getImage2,
      xOffset: imageXOffset2,
      yOffset: imageYOffset2
    };
    line3 = markMultiItemPath2("line", line$12, pickLine2);
    path$22 = {
      type: "path",
      tag: "path",
      nested: false,
      attr: attr$32,
      bound: bound$32,
      draw: drawAll2(path$12),
      pick: pickPath2(path$12),
      isect: intersectPath2(path$12)
    };
    rect2 = {
      type: "rect",
      tag: "path",
      nested: false,
      attr: attr$22,
      bound: bound$22,
      draw: drawAll2(draw$22),
      pick: pickPath2(draw$22),
      isect: intersectRect2
    };
    rule2 = {
      type: "rule",
      tag: "line",
      nested: false,
      attr: attr$12,
      bound: bound$12,
      draw: draw$12,
      pick: pick$12(hit$12),
      isect: intersectRule2
    };
    shape2 = markItemPath2("shape", shape$12);
    symbol2 = markItemPath2("symbol", symbol$12, intersectPoint2);
    widthCache2 = lruCache();
    textMetrics2 = {
      height: fontSize2,
      measureWidth: measureWidth2,
      estimateWidth: estimateWidth2,
      width: estimateWidth2,
      canvas: useCanvas2
    };
    useCanvas2(true);
    textAlign2 = {
      "left": "start",
      "center": "middle",
      "right": "end"
    };
    tempBounds3 = new Bounds2();
    text2 = {
      type: "text",
      tag: "text",
      nested: false,
      attr: attr2,
      bound: bound2,
      draw: draw2,
      pick: pick$12(hit2),
      isect: intersectText2
    };
    trail2 = markMultiItemPath2("trail", trail$12, pickTrail2);
    Marks2 = {
      arc: arc3,
      area: area3,
      group: group4,
      image: image2,
      line: line3,
      path: path$22,
      rect: rect2,
      rule: rule2,
      shape: shape2,
      symbol: symbol2,
      text: text2,
      trail: trail2
    };
    DUMMY2 = {
      mark: null
    };
    keys2 = [
      "marktype",
      "name",
      "role",
      "interactive",
      "clip",
      "items",
      "zindex",
      "x",
      "y",
      "width",
      "height",
      "align",
      "baseline",
      "fill",
      "fillOpacity",
      "opacity",
      "blend",
      "stroke",
      "strokeOpacity",
      "strokeWidth",
      "strokeCap",
      "strokeDash",
      "strokeDashOffset",
      "strokeForeground",
      "strokeOffset",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "cornerRadius",
      "padAngle",
      "cornerRadiusTopLeft",
      "cornerRadiusTopRight",
      "cornerRadiusBottomLeft",
      "cornerRadiusBottomRight",
      "interpolate",
      "tension",
      "orient",
      "defined",
      "url",
      "aspect",
      "smooth",
      "path",
      "scaleX",
      "scaleY",
      "x2",
      "y2",
      "size",
      "shape",
      "text",
      "angle",
      "theta",
      "radius",
      "dir",
      "dx",
      "dy",
      "ellipsis",
      "limit",
      "lineBreak",
      "lineHeight",
      "font",
      "fontSize",
      "fontWeight",
      "fontStyle",
      "fontVariant",
      "description",
      "aria",
      "ariaRole",
      "ariaRoleDescription"
    ];
    Scenegraph2.prototype = {
      toJSON(indent) {
        return sceneToJSON2(this.root, indent || 0);
      },
      mark(markdef, group6, index8) {
        group6 = group6 || this.root.items[0];
        const mark = createMark2(markdef, group6);
        group6.items[index8] = mark;
        if (mark.zindex)
          mark.group.zdirty = true;
        return mark;
      }
    };
    Handler2.prototype = {
      initialize(el, origin, obj) {
        this._el = el;
        this._obj = obj || null;
        return this.origin(origin);
      },
      element() {
        return this._el;
      },
      canvas() {
        return this._el && this._el.firstChild;
      },
      origin(origin) {
        if (arguments.length) {
          this._origin = origin || [0, 0];
          return this;
        } else {
          return this._origin.slice();
        }
      },
      scene(scene) {
        if (!arguments.length)
          return this._scene;
        this._scene = scene;
        return this;
      },
      on() {
      },
      off() {
      },
      _handlerIndex(h4, type4, handler) {
        for (let i = h4 ? h4.length : 0; --i >= 0; ) {
          if (h4[i].type === type4 && (!handler || h4[i].handler === handler)) {
            return i;
          }
        }
        return -1;
      },
      handlers(type4) {
        const h4 = this._handlers, a4 = [];
        if (type4) {
          a4.push(...h4[this.eventName(type4)]);
        } else {
          for (const k4 in h4) {
            a4.push(...h4[k4]);
          }
        }
        return a4;
      },
      eventName(name4) {
        const i = name4.indexOf(".");
        return i < 0 ? name4 : name4.slice(0, i);
      },
      handleHref(event3, item, href3) {
        this._loader.sanitize(href3, {
          context: "href"
        }).then((opt) => {
          const e3 = new MouseEvent(event3.type, event3), a4 = domCreate2(null, "a");
          for (const name4 in opt)
            a4.setAttribute(name4, opt[name4]);
          a4.dispatchEvent(e3);
        }).catch(() => {
        });
      },
      handleTooltip(event3, item, show) {
        if (item && item.tooltip != null) {
          item = resolveItem2(item, event3, this.canvas(), this._origin);
          const value4 = show && item && item.tooltip || null;
          this._tooltip.call(this._obj, this, event3, item, value4);
        }
      },
      getItemBoundingClientRect(item) {
        const el = this.canvas();
        if (!el)
          return;
        const rect4 = el.getBoundingClientRect(), origin = this._origin, bounds3 = item.bounds, width2 = bounds3.width(), height2 = bounds3.height();
        let x7 = bounds3.x1 + origin[0] + rect4.left, y7 = bounds3.y1 + origin[1] + rect4.top;
        while (item.mark && (item = item.mark.group)) {
          x7 += item.x || 0;
          y7 += item.y || 0;
        }
        return {
          x: x7,
          y: y7,
          width: width2,
          height: height2,
          left: x7,
          top: y7,
          right: x7 + width2,
          bottom: y7 + height2
        };
      }
    };
    Renderer2.prototype = {
      initialize(el, width2, height2, origin, scaleFactor) {
        this._el = el;
        return this.resize(width2, height2, origin, scaleFactor);
      },
      element() {
        return this._el;
      },
      canvas() {
        return this._el && this._el.firstChild;
      },
      background(bgcolor) {
        if (arguments.length === 0)
          return this._bgcolor;
        this._bgcolor = bgcolor;
        return this;
      },
      resize(width2, height2, origin, scaleFactor) {
        this._width = width2;
        this._height = height2;
        this._origin = origin || [0, 0];
        this._scale = scaleFactor || 1;
        return this;
      },
      dirty() {
      },
      render(scene) {
        const r2 = this;
        r2._call = function() {
          r2._render(scene);
        };
        r2._call();
        r2._call = null;
        return r2;
      },
      _render() {
      },
      renderAsync(scene) {
        const r2 = this.render(scene);
        return this._ready ? this._ready.then(() => r2) : Promise.resolve(r2);
      },
      _load(method3, uri) {
        var r2 = this, p = r2._loader[method3](uri);
        if (!r2._ready) {
          const call = r2._call;
          r2._ready = r2._loader.ready().then((redraw) => {
            if (redraw)
              call();
            r2._ready = null;
          });
        }
        return p;
      },
      sanitizeURL(uri) {
        return this._load("sanitizeURL", uri);
      },
      loadImage(uri) {
        return this._load("loadImage", uri);
      }
    };
    KeyDownEvent2 = "keydown";
    KeyPressEvent2 = "keypress";
    KeyUpEvent2 = "keyup";
    DragEnterEvent2 = "dragenter";
    DragLeaveEvent2 = "dragleave";
    DragOverEvent2 = "dragover";
    MouseDownEvent2 = "mousedown";
    MouseUpEvent2 = "mouseup";
    MouseMoveEvent2 = "mousemove";
    MouseOutEvent2 = "mouseout";
    MouseOverEvent2 = "mouseover";
    ClickEvent2 = "click";
    DoubleClickEvent2 = "dblclick";
    WheelEvent2 = "wheel";
    MouseWheelEvent2 = "mousewheel";
    TouchStartEvent2 = "touchstart";
    TouchMoveEvent2 = "touchmove";
    TouchEndEvent2 = "touchend";
    Events2 = [KeyDownEvent2, KeyPressEvent2, KeyUpEvent2, DragEnterEvent2, DragLeaveEvent2, DragOverEvent2, MouseDownEvent2, MouseUpEvent2, MouseMoveEvent2, MouseOutEvent2, MouseOverEvent2, ClickEvent2, DoubleClickEvent2, WheelEvent2, MouseWheelEvent2, TouchStartEvent2, TouchMoveEvent2, TouchEndEvent2];
    TooltipShowEvent2 = MouseMoveEvent2;
    TooltipHideEvent2 = MouseOutEvent2;
    HrefEvent2 = ClickEvent2;
    eventBundle2 = (type4) => type4 === TouchStartEvent2 || type4 === TouchMoveEvent2 || type4 === TouchEndEvent2 ? [TouchStartEvent2, TouchMoveEvent2, TouchEndEvent2] : [type4];
    inherits(CanvasHandler2, Handler2, {
      initialize(el, origin, obj) {
        this._canvas = el && domFind2(el, "canvas");
        [ClickEvent2, MouseDownEvent2, MouseMoveEvent2, MouseOutEvent2, DragLeaveEvent2].forEach((type4) => eventListenerCheck2(this, type4));
        return Handler2.prototype.initialize.call(this, el, origin, obj);
      },
      canvas() {
        return this._canvas;
      },
      context() {
        return this._canvas.getContext("2d");
      },
      events: Events2,
      DOMMouseScroll(evt) {
        this.fire(MouseWheelEvent2, evt);
      },
      mousemove: move2(MouseMoveEvent2, MouseOverEvent2, MouseOutEvent2),
      dragover: move2(DragOverEvent2, DragEnterEvent2, DragLeaveEvent2),
      mouseout: inactive2(MouseOutEvent2),
      dragleave: inactive2(DragLeaveEvent2),
      mousedown(evt) {
        this._down = this._active;
        this.fire(MouseDownEvent2, evt);
      },
      click(evt) {
        if (this._down === this._active) {
          this.fire(ClickEvent2, evt);
          this._down = null;
        }
      },
      touchstart(evt) {
        this._touch = this.pickEvent(evt.changedTouches[0]);
        if (this._first) {
          this._active = this._touch;
          this._first = false;
        }
        this.fire(TouchStartEvent2, evt, true);
      },
      touchmove(evt) {
        this.fire(TouchMoveEvent2, evt, true);
      },
      touchend(evt) {
        this.fire(TouchEndEvent2, evt, true);
        this._touch = null;
      },
      fire(type4, evt, touch2) {
        const a4 = touch2 ? this._touch : this._active, h4 = this._handlers[type4];
        evt.vegaType = type4;
        if (type4 === HrefEvent2 && a4 && a4.href) {
          this.handleHref(evt, a4, a4.href);
        } else if (type4 === TooltipShowEvent2 || type4 === TooltipHideEvent2) {
          this.handleTooltip(evt, a4, type4 !== TooltipHideEvent2);
        }
        if (h4) {
          for (let i = 0, len = h4.length; i < len; ++i) {
            h4[i].handler.call(this._obj, evt, a4);
          }
        }
      },
      on(type4, handler) {
        const name4 = this.eventName(type4), h4 = this._handlers, i = this._handlerIndex(h4[name4], type4, handler);
        if (i < 0) {
          eventListenerCheck2(this, type4);
          (h4[name4] || (h4[name4] = [])).push({
            type: type4,
            handler
          });
        }
        return this;
      },
      off(type4, handler) {
        const name4 = this.eventName(type4), h4 = this._handlers[name4], i = this._handlerIndex(h4, type4, handler);
        if (i >= 0) {
          h4.splice(i, 1);
        }
        return this;
      },
      pickEvent(evt) {
        const p = point14(evt, this._canvas), o = this._origin;
        return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
      },
      pick(scene, x7, y7, gx, gy) {
        const g = this.context(), mark = Marks2[scene.marktype];
        return mark.pick.call(this, g, scene, x7, y7, gx, gy);
      }
    });
    pixelRatio2 = devicePixelRatio2();
    base$12 = Renderer2.prototype;
    viewBounds2 = (origin, width2, height2) => new Bounds2().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
    inherits(CanvasRenderer2, Renderer2, {
      initialize(el, width2, height2, origin, scaleFactor, options2) {
        this._options = options2 || {};
        this._canvas = this._options.externalContext ? null : domCanvas(1, 1, this._options.type);
        if (el && this._canvas) {
          domClear2(el, 0).appendChild(this._canvas);
          this._canvas.setAttribute("class", "marks");
        }
        return base$12.initialize.call(this, el, width2, height2, origin, scaleFactor);
      },
      resize(width2, height2, origin, scaleFactor) {
        base$12.resize.call(this, width2, height2, origin, scaleFactor);
        if (this._canvas) {
          resize2(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
        } else {
          const ctx = this._options.externalContext;
          if (!ctx)
            error("CanvasRenderer is missing a valid canvas or context");
          ctx.scale(this._scale, this._scale);
          ctx.translate(this._origin[0], this._origin[1]);
        }
        this._redraw = true;
        return this;
      },
      canvas() {
        return this._canvas;
      },
      context() {
        return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
      },
      dirty(item) {
        const b3 = this._tempb.clear().union(item.bounds);
        let g = item.mark.group;
        while (g) {
          b3.translate(g.x || 0, g.y || 0);
          g = g.mark.group;
        }
        this._dirty.union(b3);
      },
      _render(scene) {
        const g = this.context(), o = this._origin, w5 = this._width, h4 = this._height, db = this._dirty, vb = viewBounds2(o, w5, h4);
        g.save();
        const b3 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds2(g, vb.intersect(db), o);
        this.clear(-o[0], -o[1], w5, h4);
        this.draw(g, scene, b3);
        g.restore();
        db.clear();
        return this;
      },
      draw(ctx, scene, bounds3) {
        const mark = Marks2[scene.marktype];
        if (scene.clip)
          clip2(ctx, scene);
        mark.draw.call(this, ctx, scene, bounds3);
        if (scene.clip)
          ctx.restore();
      },
      clear(x7, y7, w5, h4) {
        const opt = this._options, g = this.context();
        if (opt.type !== "pdf" && !opt.externalContext) {
          g.clearRect(x7, y7, w5, h4);
        }
        if (this._bgcolor != null) {
          g.fillStyle = this._bgcolor;
          g.fillRect(x7, y7, w5, h4);
        }
      }
    });
    listener2 = (context4, handler) => (evt) => {
      let item = evt.target.__data__;
      item = Array.isArray(item) ? item[0] : item;
      evt.vegaType = evt.type;
      handler.call(context4._obj, evt, item);
    };
    inherits(SVGHandler2, Handler2, {
      initialize(el, origin, obj) {
        let svg = this._svg;
        if (svg) {
          svg.removeEventListener(HrefEvent2, this._hrefHandler);
          svg.removeEventListener(TooltipShowEvent2, this._tooltipHandler);
          svg.removeEventListener(TooltipHideEvent2, this._tooltipHandler);
        }
        this._svg = svg = el && domFind2(el, "svg");
        if (svg) {
          svg.addEventListener(HrefEvent2, this._hrefHandler);
          svg.addEventListener(TooltipShowEvent2, this._tooltipHandler);
          svg.addEventListener(TooltipHideEvent2, this._tooltipHandler);
        }
        return Handler2.prototype.initialize.call(this, el, origin, obj);
      },
      canvas() {
        return this._svg;
      },
      on(type4, handler) {
        const name4 = this.eventName(type4), h4 = this._handlers, i = this._handlerIndex(h4[name4], type4, handler);
        if (i < 0) {
          const x7 = {
            type: type4,
            handler,
            listener: listener2(this, handler)
          };
          (h4[name4] || (h4[name4] = [])).push(x7);
          if (this._svg) {
            this._svg.addEventListener(name4, x7.listener);
          }
        }
        return this;
      },
      off(type4, handler) {
        const name4 = this.eventName(type4), h4 = this._handlers[name4], i = this._handlerIndex(h4, type4, handler);
        if (i >= 0) {
          if (this._svg) {
            this._svg.removeEventListener(name4, h4[i].listener);
          }
          h4.splice(i, 1);
        }
        return this;
      }
    });
    ARIA_HIDDEN2 = "aria-hidden";
    ARIA_LABEL2 = "aria-label";
    ARIA_ROLE2 = "role";
    ARIA_ROLEDESCRIPTION2 = "aria-roledescription";
    GRAPHICS_OBJECT2 = "graphics-object";
    GRAPHICS_SYMBOL2 = "graphics-symbol";
    bundle2 = (role, roledesc, label) => ({
      [ARIA_ROLE2]: role,
      [ARIA_ROLEDESCRIPTION2]: roledesc,
      [ARIA_LABEL2]: label || void 0
    });
    AriaIgnore2 = toSet(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
    AriaGuides2 = {
      "axis": {
        desc: "axis",
        caption: axisCaption2
      },
      "legend": {
        desc: "legend",
        caption: legendCaption2
      },
      "title-text": {
        desc: "title",
        caption: (item) => `Title text '${titleCaption2(item)}'`
      },
      "title-subtitle": {
        desc: "subtitle",
        caption: (item) => `Subtitle text '${titleCaption2(item)}'`
      }
    };
    AriaEncode2 = {
      ariaRole: ARIA_ROLE2,
      ariaRoleDescription: ARIA_ROLEDESCRIPTION2,
      description: ARIA_LABEL2
    };
    innerText2 = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    attrText2 = (val) => innerText2(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
    serializeXML2 = (node) => _serialize2(markup2(), node) + "";
    styles = {
      fill: "fill",
      fillOpacity: "fill-opacity",
      stroke: "stroke",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      strokeCap: "stroke-linecap",
      strokeJoin: "stroke-linejoin",
      strokeDash: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeMiterLimit: "stroke-miterlimit",
      opacity: "opacity",
      blend: "mix-blend-mode"
    };
    rootAttributes2 = {
      "fill": "none",
      "stroke-miterlimit": 10
    };
    RootIndex2 = 0;
    xmlns2 = "http://www.w3.org/2000/xmlns/";
    svgns2 = metadata2.xmlns;
    base2 = Renderer2.prototype;
    inherits(SVGRenderer2, Renderer2, {
      initialize(el, width2, height2, origin, scaleFactor) {
        this._defs = {};
        this._clearDefs();
        if (el) {
          this._svg = domChild2(el, 0, "svg", svgns2);
          this._svg.setAttributeNS(xmlns2, "xmlns", svgns2);
          this._svg.setAttributeNS(xmlns2, "xmlns:xlink", metadata2["xmlns:xlink"]);
          this._svg.setAttribute("version", metadata2["version"]);
          this._svg.setAttribute("class", "marks");
          domClear2(el, 1);
          this._root = domChild2(this._svg, RootIndex2, "g", svgns2);
          setAttributes2(this._root, rootAttributes2);
          domClear2(this._svg, RootIndex2 + 1);
        }
        this.background(this._bgcolor);
        return base2.initialize.call(this, el, width2, height2, origin, scaleFactor);
      },
      background(bgcolor) {
        if (arguments.length && this._svg) {
          this._svg.style.setProperty("background-color", bgcolor);
        }
        return base2.background.apply(this, arguments);
      },
      resize(width2, height2, origin, scaleFactor) {
        base2.resize.call(this, width2, height2, origin, scaleFactor);
        if (this._svg) {
          setAttributes2(this._svg, {
            width: this._width * this._scale,
            height: this._height * this._scale,
            viewBox: `0 0 ${this._width} ${this._height}`
          });
          this._root.setAttribute("transform", `translate(${this._origin})`);
        }
        this._dirty = [];
        return this;
      },
      canvas() {
        return this._svg;
      },
      svg() {
        const svg = this._svg, bg = this._bgcolor;
        if (!svg)
          return null;
        let node;
        if (bg) {
          svg.removeAttribute("style");
          node = domChild2(svg, RootIndex2, "rect", svgns2);
          setAttributes2(node, {
            width: this._width,
            height: this._height,
            fill: bg
          });
        }
        const text5 = serializeXML2(svg);
        if (bg) {
          svg.removeChild(node);
          this._svg.style.setProperty("background-color", bg);
        }
        return text5;
      },
      _render(scene) {
        if (this._dirtyCheck()) {
          if (this._dirtyAll)
            this._clearDefs();
          this.mark(this._root, scene);
          domClear2(this._root, 1);
        }
        this.defs();
        this._dirty = [];
        ++this._dirtyID;
        return this;
      },
      dirty(item) {
        if (item.dirty !== this._dirtyID) {
          item.dirty = this._dirtyID;
          this._dirty.push(item);
        }
      },
      isDirty(item) {
        return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;
      },
      _dirtyCheck() {
        this._dirtyAll = true;
        const items2 = this._dirty;
        if (!items2.length || !this._dirtyID)
          return true;
        const id4 = ++this._dirtyID;
        let item, mark, type4, mdef, i, n, o;
        for (i = 0, n = items2.length; i < n; ++i) {
          item = items2[i];
          mark = item.mark;
          if (mark.marktype !== type4) {
            type4 = mark.marktype;
            mdef = Marks2[type4];
          }
          if (mark.zdirty && mark.dirty !== id4) {
            this._dirtyAll = false;
            dirtyParents2(item, id4);
            mark.items.forEach((i2) => {
              i2.dirty = id4;
            });
          }
          if (mark.zdirty)
            continue;
          if (item.exit) {
            if (mdef.nested && mark.items.length) {
              o = mark.items[0];
              if (o._svg)
                this._update(mdef, o._svg, o);
            } else if (item._svg) {
              o = item._svg.parentNode;
              if (o)
                o.removeChild(item._svg);
            }
            item._svg = null;
            continue;
          }
          item = mdef.nested ? mark.items[0] : item;
          if (item._update === id4)
            continue;
          if (!item._svg || !item._svg.ownerSVGElement) {
            this._dirtyAll = false;
            dirtyParents2(item, id4);
          } else {
            this._update(mdef, item._svg, item);
          }
          item._update = id4;
        }
        return !this._dirtyAll;
      },
      mark(el, scene, prev) {
        if (!this.isDirty(scene))
          return scene._svg;
        const svg = this._svg, mdef = Marks2[scene.marktype], events4 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
        let sibling = null, i = 0;
        const parent = bind2(scene, el, prev, "g", svg);
        parent.setAttribute("class", cssClass2(scene));
        const aria2 = ariaMarkAttributes2(scene);
        for (const key3 in aria2)
          setAttribute2(parent, key3, aria2[key3]);
        if (!isGroup) {
          setAttribute2(parent, "pointer-events", events4);
        }
        setAttribute2(parent, "clip-path", scene.clip ? clip$12(this, scene, scene.group) : null);
        const process2 = (item) => {
          const dirty = this.isDirty(item), node = bind2(item, parent, sibling, mdef.tag, svg);
          if (dirty) {
            this._update(mdef, node, item);
            if (isGroup)
              recurse2(this, node, item);
          }
          sibling = node;
          ++i;
        };
        if (mdef.nested) {
          if (scene.items.length)
            process2(scene.items[0]);
        } else {
          visit2(scene, process2);
        }
        domClear2(parent, i);
        return parent;
      },
      _update(mdef, el, item) {
        element2 = el;
        values2 = el.__values__;
        ariaItemAttributes2(emit2, item);
        mdef.attr(emit2, item, this);
        const extra = mark_extras2[mdef.type];
        if (extra)
          extra.call(this, mdef, el, item);
        if (element2)
          this.style(element2, item);
      },
      style(el, item) {
        if (item == null)
          return;
        for (const prop in styles) {
          let value4 = prop === "font" ? fontFamily2(item) : item[prop];
          if (value4 === values2[prop])
            continue;
          const name4 = styles[prop];
          if (value4 == null) {
            el.removeAttribute(name4);
          } else {
            if (isGradient2(value4)) {
              value4 = gradientRef2(value4, this._defs.gradient, href2());
            }
            el.setAttribute(name4, value4 + "");
          }
          values2[prop] = value4;
        }
      },
      defs() {
        const svg = this._svg, defs = this._defs;
        let el = defs.el, index8 = 0;
        for (const id4 in defs.gradient) {
          if (!el)
            defs.el = el = domChild2(svg, RootIndex2 + 1, "defs", svgns2);
          index8 = updateGradient2(el, defs.gradient[id4], index8);
        }
        for (const id4 in defs.clipping) {
          if (!el)
            defs.el = el = domChild2(svg, RootIndex2 + 1, "defs", svgns2);
          index8 = updateClipping2(el, defs.clipping[id4], index8);
        }
        if (el) {
          index8 === 0 ? (svg.removeChild(el), defs.el = null) : domClear2(el, index8);
        }
      },
      _clearDefs() {
        const def3 = this._defs;
        def3.gradient = {};
        def3.clipping = {};
      }
    });
    element2 = null;
    values2 = null;
    mark_extras2 = {
      group(mdef, el, item) {
        const fg = element2 = el.childNodes[2];
        values2 = fg.__values__;
        mdef.foreground(emit2, item, this);
        values2 = el.__values__;
        element2 = el.childNodes[1];
        mdef.content(emit2, item, this);
        const bg = element2 = el.childNodes[0];
        mdef.background(emit2, item, this);
        const value4 = item.mark.interactive === false ? "none" : null;
        if (value4 !== values2.events) {
          setAttribute2(fg, "pointer-events", value4);
          setAttribute2(bg, "pointer-events", value4);
          values2.events = value4;
        }
        if (item.strokeForeground && item.stroke) {
          const fill3 = item.fill;
          setAttribute2(fg, "display", null);
          this.style(bg, item);
          setAttribute2(bg, "stroke", null);
          if (fill3)
            item.fill = null;
          values2 = fg.__values__;
          this.style(fg, item);
          if (fill3)
            item.fill = fill3;
          element2 = null;
        } else {
          setAttribute2(fg, "display", "none");
        }
      },
      image(mdef, el, item) {
        if (item.smooth === false) {
          setStyle2(el, "image-rendering", "optimizeSpeed");
          setStyle2(el, "image-rendering", "pixelated");
        } else {
          setStyle2(el, "image-rendering", null);
        }
      },
      text(mdef, el, item) {
        const tl3 = textLines2(item);
        let key3, value4, doc, lh;
        if (isArray(tl3)) {
          value4 = tl3.map((_) => textValue2(item, _));
          key3 = value4.join("\n");
          if (key3 !== values2.text) {
            domClear2(el, 0);
            doc = el.ownerDocument;
            lh = lineHeight2(item);
            value4.forEach((t, i) => {
              const ts3 = domCreate2(doc, "tspan", svgns2);
              ts3.__data__ = item;
              ts3.textContent = t;
              if (i) {
                ts3.setAttribute("x", 0);
                ts3.setAttribute("dy", lh);
              }
              el.appendChild(ts3);
            });
            values2.text = key3;
          }
        } else {
          value4 = textValue2(item, tl3);
          if (value4 !== values2.text) {
            el.textContent = value4;
            values2.text = value4;
          }
        }
        setAttribute2(el, "font-family", fontFamily2(item));
        setAttribute2(el, "font-size", fontSize2(item) + "px");
        setAttribute2(el, "font-style", item.fontStyle);
        setAttribute2(el, "font-variant", item.fontVariant);
        setAttribute2(el, "font-weight", item.fontWeight);
      }
    };
    inherits(SVGStringRenderer2, Renderer2, {
      svg() {
        return this._text;
      },
      _render(scene) {
        const m2 = markup2();
        m2.open("svg", extend({}, metadata2, {
          class: "marks",
          width: this._width * this._scale,
          height: this._height * this._scale,
          viewBox: `0 0 ${this._width} ${this._height}`
        }));
        const bg = this._bgcolor;
        if (bg && bg !== "transparent" && bg !== "none") {
          m2.open("rect", {
            width: this._width,
            height: this._height,
            fill: bg
          }).close();
        }
        m2.open("g", rootAttributes2, {
          transform: "translate(" + this._origin + ")"
        });
        this.mark(m2, scene);
        m2.close();
        this.defs(m2);
        this._text = m2.close() + "";
        return this;
      },
      mark(m2, scene) {
        const mdef = Marks2[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes2, mdef.attr];
        m2.open("g", {
          "class": cssClass2(scene),
          "clip-path": scene.clip ? clip$12(this, scene, scene.group) : null
        }, ariaMarkAttributes2(scene), {
          "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
        });
        const process2 = (item) => {
          const href3 = this.href(item);
          if (href3)
            m2.open("a", href3);
          m2.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
          if (tag === "text") {
            const tl3 = textLines2(item);
            if (isArray(tl3)) {
              const attrs = {
                x: 0,
                dy: lineHeight2(item)
              };
              for (let i = 0; i < tl3.length; ++i) {
                m2.open("tspan", i ? attrs : null).text(textValue2(item, tl3[i])).close();
              }
            } else {
              m2.text(textValue2(item, tl3));
            }
          } else if (tag === "g") {
            const fore = item.strokeForeground, fill3 = item.fill, stroke3 = item.stroke;
            if (fore && stroke3) {
              item.stroke = null;
            }
            m2.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
            m2.open("g", this.attr(scene, item, mdef.content));
            visit2(item, (scene2) => this.mark(m2, scene2));
            m2.close();
            if (fore && stroke3) {
              if (fill3)
                item.fill = null;
              item.stroke = stroke3;
              m2.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
              if (fill3)
                item.fill = fill3;
            } else {
              m2.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
            }
          }
          m2.close();
          if (href3)
            m2.close();
        };
        if (mdef.nested) {
          if (scene.items && scene.items.length)
            process2(scene.items[0]);
        } else {
          visit2(scene, process2);
        }
        return m2.close();
      },
      href(item) {
        const href3 = item.href;
        let attr3;
        if (href3) {
          if (attr3 = this._hrefs && this._hrefs[href3]) {
            return attr3;
          } else {
            this.sanitizeURL(href3).then((attr4) => {
              attr4["xlink:href"] = attr4.href;
              attr4.href = null;
              (this._hrefs || (this._hrefs = {}))[href3] = attr4;
            });
          }
        }
        return null;
      },
      attr(scene, item, attrs, tag) {
        const object2 = {}, emit3 = (name4, value4, ns, prefixed) => {
          object2[prefixed || name4] = value4;
        };
        if (Array.isArray(attrs)) {
          attrs.forEach((fn) => fn(emit3, item, this));
        } else {
          attrs(emit3, item, this);
        }
        if (tag) {
          style2(object2, item, scene, tag, this._defs);
        }
        return object2;
      },
      defs(m2) {
        const gradient5 = this._defs.gradient, clipping = this._defs.clipping, count5 = Object.keys(gradient5).length + Object.keys(clipping).length;
        if (count5 === 0)
          return;
        m2.open("defs");
        for (const id4 in gradient5) {
          const def3 = gradient5[id4], stops = def3.stops;
          if (def3.gradient === "radial") {
            m2.open("pattern", {
              id: patternPrefix2 + id4,
              viewBox: "0,0,1,1",
              width: "100%",
              height: "100%",
              preserveAspectRatio: "xMidYMid slice"
            });
            m2.open("rect", {
              width: "1",
              height: "1",
              fill: "url(#" + id4 + ")"
            }).close();
            m2.close();
            m2.open("radialGradient", {
              id: id4,
              fx: def3.x1,
              fy: def3.y1,
              fr: def3.r1,
              cx: def3.x2,
              cy: def3.y2,
              r: def3.r2
            });
          } else {
            m2.open("linearGradient", {
              id: id4,
              x1: def3.x1,
              x2: def3.x2,
              y1: def3.y1,
              y2: def3.y2
            });
          }
          for (let i = 0; i < stops.length; ++i) {
            m2.open("stop", {
              offset: stops[i].offset,
              "stop-color": stops[i].color
            }).close();
          }
          m2.close();
        }
        for (const id4 in clipping) {
          const def3 = clipping[id4];
          m2.open("clipPath", {
            id: id4
          });
          if (def3.path) {
            m2.open("path", {
              d: def3.path
            }).close();
          } else {
            m2.open("rect", {
              x: 0,
              y: 0,
              width: def3.width,
              height: def3.height
            }).close();
          }
          m2.close();
        }
        m2.close();
      }
    });
    Canvas2 = "canvas";
    PNG2 = "png";
    SVG2 = "svg";
    None5 = "none";
    RenderType = {
      Canvas: Canvas2,
      PNG: PNG2,
      SVG: SVG2,
      None: None5
    };
    modules2 = {};
    modules2[Canvas2] = modules2[PNG2] = {
      renderer: CanvasRenderer2,
      headless: CanvasRenderer2,
      handler: CanvasHandler2
    };
    modules2[SVG2] = {
      renderer: SVGRenderer2,
      headless: SVGStringRenderer2,
      handler: SVGHandler2
    };
    modules2[None5] = {};
    clipBounds2 = new Bounds2();
    TOLERANCE = 1e-9;
  }
});

// node_modules/.pnpm/vega-label@1.0.0/node_modules/vega-label/build/vega-label.module.js
var vega_label_module_exports = {};
__export(vega_label_module_exports, {
  label: () => Label
});
function baseBitmaps($4, data3) {
  const bitmap = $4.bitmap();
  (data3 || []).forEach((d) => bitmap.set($4(d.boundary[0]), $4(d.boundary[3])));
  return [bitmap, void 0];
}
function markBitmaps($4, avoidMarks, labelInside, isGroupArea) {
  const width2 = $4.width, height2 = $4.height, border = labelInside || isGroupArea, context4 = domCanvas(width2, height2).getContext("2d");
  avoidMarks.forEach((items2) => draw3(context4, items2, border));
  const buffer = new Uint32Array(context4.getImageData(0, 0, width2, height2).data.buffer), layer1 = $4.bitmap(), layer2 = border && $4.bitmap();
  let x7, y7, u, v, alpha;
  for (y7 = 0; y7 < height2; ++y7) {
    for (x7 = 0; x7 < width2; ++x7) {
      alpha = buffer[y7 * width2 + x7] & ALPHA_MASK;
      if (alpha) {
        u = $4(x7);
        v = $4(y7);
        if (!isGroupArea)
          layer1.set(u, v);
        if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA)
          layer2.set(u, v);
      }
    }
  }
  return [layer1, layer2];
}
function draw3(context4, items2, interior) {
  if (!items2.length)
    return;
  const type4 = items2[0].mark.marktype;
  if (type4 === "group") {
    items2.forEach((group6) => {
      group6.items.forEach((mark) => draw3(context4, mark.items, interior));
    });
  } else {
    Marks2[type4].draw(context4, {
      items: interior ? items2.map(prepare) : items2
    });
  }
}
function prepare(source5) {
  const item = rederive(source5, {});
  if (item.stroke) {
    item.strokeOpacity = 1;
  }
  if (item.fill) {
    item.fillOpacity = INSIDE_OPACITY;
    item.stroke = "#000";
    item.strokeOpacity = 1;
    item.strokeWidth = 2;
  }
  return item;
}
function Bitmap(w5, h4) {
  const array9 = new Uint32Array(~~((w5 * h4 + SIZE) / SIZE));
  function _set(index8, mask) {
    array9[index8] |= mask;
  }
  function _clear(index8, mask) {
    array9[index8] &= mask;
  }
  return {
    array: array9,
    get: (x7, y7) => {
      const index8 = y7 * w5 + x7;
      return array9[index8 >>> DIV] & 1 << (index8 & MOD2);
    },
    set: (x7, y7) => {
      const index8 = y7 * w5 + x7;
      _set(index8 >>> DIV, 1 << (index8 & MOD2));
    },
    clear: (x7, y7) => {
      const index8 = y7 * w5 + x7;
      _clear(index8 >>> DIV, ~(1 << (index8 & MOD2)));
    },
    getRange: (x7, y7, x22, y22) => {
      let r2 = y22, start, end, indexStart, indexEnd;
      for (; r2 >= y7; --r2) {
        start = r2 * w5 + x7;
        end = r2 * w5 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          if (array9[indexStart] & RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]) {
            return true;
          }
        } else {
          if (array9[indexStart] & RIGHT0[start & MOD2])
            return true;
          if (array9[indexEnd] & RIGHT1[(end & MOD2) + 1])
            return true;
          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array9[i])
              return true;
          }
        }
      }
      return false;
    },
    setRange: (x7, y7, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y7 <= y22; ++y7) {
        start = y7 * w5 + x7;
        end = y7 * w5 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD2]);
          _set(indexEnd, RIGHT1[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i)
            _set(i, 4294967295);
        }
      }
    },
    clearRange: (x7, y7, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y7 <= y22; ++y7) {
        start = y7 * w5 + x7;
        end = y7 * w5 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD2] | RIGHT0[(end & MOD2) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD2]);
          _clear(indexEnd, RIGHT0[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i)
            _clear(i, 0);
        }
      }
    },
    outOfBounds: (x7, y7, x22, y22) => x7 < 0 || y7 < 0 || y22 >= h4 || x22 >= w5
  };
}
function scaler(width2, height2, padding3) {
  const ratio = Math.max(1, Math.sqrt(width2 * height2 / 1e6)), w5 = ~~((width2 + 2 * padding3 + ratio) / ratio), h4 = ~~((height2 + 2 * padding3 + ratio) / ratio), scale8 = (_) => ~~((_ + padding3) / ratio);
  scale8.invert = (_) => _ * ratio - padding3;
  scale8.bitmap = () => Bitmap(w5, h4);
  scale8.ratio = ratio;
  scale8.padding = padding3;
  scale8.width = width2;
  scale8.height = height2;
  return scale8;
}
function placeAreaLabelNaive($4, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $4.width, height2 = $4.height;
  return function(d) {
    const items2 = d.datum.datum.items[markIndex].items, n = items2.length, textHeight = d.datum.fontSize, textWidth = textMetrics2.width(d.datum, d.datum.text);
    let maxAreaWidth = 0, x13, x22, y13, y22, x7, y7, areaWidth;
    for (let i = 0; i < n; ++i) {
      x13 = items2[i].x;
      y13 = items2[i].y;
      x22 = items2[i].x2 === void 0 ? x13 : items2[i].x2;
      y22 = items2[i].y2 === void 0 ? y13 : items2[i].y2;
      x7 = (x13 + x22) / 2;
      y7 = (y13 + y22) / 2;
      areaWidth = Math.abs(x22 - x13 + y22 - y13);
      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x7;
        d.y = y7;
      }
    }
    x7 = textWidth / 2;
    y7 = textHeight / 2;
    x13 = d.x - x7;
    x22 = d.x + x7;
    y13 = d.y - y7;
    y22 = d.y + y7;
    d.align = "center";
    if (x13 < 0 && x22 <= width2) {
      d.align = "left";
    } else if (0 <= x13 && width2 < x22) {
      d.align = "right";
    }
    d.baseline = "middle";
    if (y13 < 0 && y22 <= height2) {
      d.baseline = "top";
    } else if (0 <= y13 && height2 < y22) {
      d.baseline = "bottom";
    }
    return true;
  };
}
function outOfBounds(x7, y7, textWidth, textHeight, width2, height2) {
  let r2 = textWidth / 2;
  return x7 - r2 < 0 || x7 + r2 > width2 || y7 - (r2 = textHeight / 2) < 0 || y7 + r2 > height2;
}
function collision($4, x7, y7, textHeight, textWidth, h4, bm0, bm1) {
  const w5 = textWidth * h4 / (textHeight * 2), x13 = $4(x7 - w5), x22 = $4(x7 + w5), y13 = $4(y7 - (h4 = h4 / 2)), y22 = $4(y7 + h4);
  return bm0.outOfBounds(x13, y13, x22, y22) || bm0.getRange(x13, y13, x22, y22) || bm1 && bm1.getRange(x13, y13, x22, y22);
}
function placeAreaLabelReducedSearch($4, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $4.width, height2 = $4.height, bm0 = bitmaps[0], bm1 = bitmaps[1];
  function tryLabel(_x3, _y3, maxSize, textWidth, textHeight) {
    const x7 = $4.invert(_x3), y7 = $4.invert(_y3);
    let lo = maxSize, hi = height2, mid;
    if (!outOfBounds(x7, y7, textWidth, textHeight, width2, height2) && !collision($4, x7, y7, textHeight, textWidth, lo, bm0, bm1) && !collision($4, x7, y7, textHeight, textWidth, textHeight, bm0, null)) {
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;
        if (collision($4, x7, y7, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      }
      if (lo > maxSize) {
        return [x7, y7, lo, true];
      }
    }
  }
  return function(d) {
    const items2 = d.datum.datum.items[markIndex].items, n = items2.length, textHeight = d.datum.fontSize, textWidth = textMetrics2.width(d.datum, d.datum.text);
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x13, x22, y13, y22, x7, y7, _x3, _y3, _x1, _xMid, _x22, _y1, _yMid, _y22, areaWidth, result, swapTmp;
    for (let i = 0; i < n; ++i) {
      x13 = items2[i].x;
      y13 = items2[i].y;
      x22 = items2[i].x2 === void 0 ? x13 : items2[i].x2;
      y22 = items2[i].y2 === void 0 ? y13 : items2[i].y2;
      if (x13 > x22) {
        swapTmp = x13;
        x13 = x22;
        x22 = swapTmp;
      }
      if (y13 > y22) {
        swapTmp = y13;
        y13 = y22;
        y22 = swapTmp;
      }
      _x1 = $4(x13);
      _x22 = $4(x22);
      _xMid = ~~((_x1 + _x22) / 2);
      _y1 = $4(y13);
      _y22 = $4(y22);
      _yMid = ~~((_y1 + _y22) / 2);
      for (_x3 = _xMid; _x3 >= _x1; --_x3) {
        for (_y3 = _yMid; _y3 >= _y1; --_y3) {
          result = tryLabel(_x3, _y3, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      for (_x3 = _xMid; _x3 <= _x22; ++_x3) {
        for (_y3 = _yMid; _y3 <= _y22; ++_y3) {
          result = tryLabel(_x3, _y3, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x22 - x13 + y22 - y13);
        x7 = (x13 + x22) / 2;
        y7 = (y13 + y22) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x7, y7, textWidth, textHeight, width2, height2) && !collision($4, x7, y7, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x7;
          d.y = y7;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x7 = textWidth / 2;
      y7 = textHeight / 2;
      bm0.setRange($4(d.x - x7), $4(d.y - y7), $4(d.x + x7), $4(d.y + y7));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
function placeAreaLabelFloodFill($4, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $4.width, height2 = $4.height, bm0 = bitmaps[0], bm1 = bitmaps[1], bm2 = $4.bitmap();
  return function(d) {
    const items2 = d.datum.datum.items[markIndex].items, n = items2.length, textHeight = d.datum.fontSize, textWidth = textMetrics2.width(d.datum, d.datum.text), stack3 = [];
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x13, x22, y13, y22, x7, y7, _x3, _y3, lo, hi, mid, areaWidth;
    for (let i = 0; i < n; ++i) {
      x13 = items2[i].x;
      y13 = items2[i].y;
      x22 = items2[i].x2 === void 0 ? x13 : items2[i].x2;
      y22 = items2[i].y2 === void 0 ? y13 : items2[i].y2;
      stack3.push([$4((x13 + x22) / 2), $4((y13 + y22) / 2)]);
      while (stack3.length) {
        [_x3, _y3] = stack3.pop();
        if (bm0.get(_x3, _y3) || bm1.get(_x3, _y3) || bm2.get(_x3, _y3))
          continue;
        bm2.set(_x3, _y3);
        for (let j = 0; j < 4; ++j) {
          x7 = _x3 + X_DIR[j];
          y7 = _y3 + Y_DIR[j];
          if (!bm2.outOfBounds(x7, y7, x7, y7))
            stack3.push([x7, y7]);
        }
        x7 = $4.invert(_x3);
        y7 = $4.invert(_y3);
        lo = maxSize;
        hi = height2;
        if (!outOfBounds(x7, y7, textWidth, textHeight, width2, height2) && !collision($4, x7, y7, textHeight, textWidth, lo, bm0, bm1) && !collision($4, x7, y7, textHeight, textWidth, textHeight, bm0, null)) {
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;
            if (collision($4, x7, y7, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          }
          if (lo > maxSize) {
            d.x = x7;
            d.y = y7;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x22 - x13 + y22 - y13);
        x7 = (x13 + x22) / 2;
        y7 = (y13 + y22) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x7, y7, textWidth, textHeight, width2, height2) && !collision($4, x7, y7, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x7;
          d.y = y7;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x7 = textWidth / 2;
      y7 = textHeight / 2;
      bm0.setRange($4(d.x - x7), $4(d.y - y7), $4(d.x + x7), $4(d.y + y7));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
function placeMarkLabel($4, bitmaps, anchors, offsets2) {
  const width2 = $4.width, height2 = $4.height, bm0 = bitmaps[0], bm1 = bitmaps[1], n = offsets2.length;
  return function(d) {
    const boundary = d.boundary, textHeight = d.datum.fontSize;
    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width2 || boundary[3] > height2) {
      return false;
    }
    let textWidth = 0, dx, dy, isInside, sizeFactor, insideFactor, x13, x22, y13, y22, xc, yc, _x1, _x22, _y1, _y22;
    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 3) - 1;
      dy = (anchors[i] >>> 2 & 3) - 1;
      isInside = dx === 0 && dy === 0 || offsets2[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets2[i] < 0 ? -1 : 1;
      x13 = boundary[1 + dx] + offsets2[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets2[i] * dy * sizeFactor;
      y13 = yc - textHeight / 2;
      y22 = yc + textHeight / 2;
      _x1 = $4(x13);
      _y1 = $4(y13);
      _y22 = $4(y22);
      if (!textWidth) {
        if (!test(_x1, _x1, _y1, _y22, bm0, bm1, x13, x13, y13, y22, boundary, isInside)) {
          continue;
        } else {
          textWidth = textMetrics2.width(d.datum, d.datum.text);
        }
      }
      xc = x13 + insideFactor * textWidth * dx / 2;
      x13 = xc - textWidth / 2;
      x22 = xc + textWidth / 2;
      _x1 = $4(x13);
      _x22 = $4(x22);
      if (test(_x1, _x22, _y1, _y22, bm0, bm1, x13, x22, y13, y22, boundary, isInside)) {
        d.x = !dx ? xc : dx * insideFactor < 0 ? x22 : x13;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y22 : y13;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x22, _y22);
        return true;
      }
    }
    return false;
  };
}
function test(_x1, _x22, _y1, _y22, bm0, bm1, x13, x22, y13, y22, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x22, _y22) || (isInside && bm1 ? bm1.getRange(_x1, _y1, _x22, _y22) || !isInMarkBound(x13, y13, x22, y22, boundary) : bm0.getRange(_x1, _y1, _x22, _y22)));
}
function isInMarkBound(x13, y13, x22, y22, boundary) {
  return boundary[0] <= x13 && x22 <= boundary[2] && boundary[3] <= y13 && y22 <= boundary[5];
}
function labelLayout(texts, size, compare6, offset5, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding3, method3) {
  if (!texts.length)
    return texts;
  const positions = Math.max(offset5.length, anchor.length), offsets2 = getOffsets(offset5, positions), anchors = getAnchors(anchor, positions), marktype = markType(texts[0].datum), grouptype = marktype === "group" && texts[0].datum.items[markIndex].marktype, isGroupArea = grouptype === "area", boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex), $4 = scaler(size[0], size[1], padding3), isNaiveGroupArea = isGroupArea && method3 === "naive";
  const data3 = texts.map((d) => ({
    datum: d,
    opacity: 0,
    x: void 0,
    y: void 0,
    align: void 0,
    baseline: void 0,
    boundary: boundary(d)
  }));
  let bitmaps;
  if (!isNaiveGroupArea) {
    if (compare6) {
      data3.sort((a4, b3) => compare6(a4.datum, b3.datum));
    }
    let labelInside = false;
    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      labelInside = anchors[i] === 5 || offsets2[i] < 0;
    }
    if (marktype && (avoidBaseMark || isGroupArea)) {
      avoidMarks = [texts.map((d) => d.datum)].concat(avoidMarks);
    }
    bitmaps = avoidMarks.length ? markBitmaps($4, avoidMarks, labelInside, isGroupArea) : baseBitmaps($4, avoidBaseMark && data3);
  }
  const place2 = isGroupArea ? placeAreaLabel[method3]($4, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($4, bitmaps, anchors, offsets2);
  data3.forEach((d) => d.opacity = +place2(d));
  return data3;
}
function getOffsets(_, count5) {
  const offsets2 = new Float64Array(count5), n = _.length;
  for (let i = 0; i < n; ++i)
    offsets2[i] = _[i] || 0;
  for (let i = n; i < count5; ++i)
    offsets2[i] = offsets2[n - 1];
  return offsets2;
}
function getAnchors(_, count5) {
  const anchors = new Int8Array(count5), n = _.length;
  for (let i = 0; i < n; ++i)
    anchors[i] |= anchorCode[_[i]];
  for (let i = n; i < count5; ++i)
    anchors[i] = anchors[n - 1];
  return anchors;
}
function markType(item) {
  return item && item.mark && item.mark.marktype;
}
function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = (d) => [d.x, d.x, d.x, d.y, d.y, d.y];
  if (!marktype) {
    return xy;
  } else if (marktype === "line" || marktype === "area") {
    return (d) => xy(d.datum);
  } else if (grouptype === "line") {
    return (d) => {
      const items2 = d.datum.items[markIndex].items;
      return xy(items2.length ? items2[lineAnchor === "start" ? 0 : items2.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return (d) => {
      const b3 = d.datum.bounds;
      return [b3.x1, (b3.x1 + b3.x2) / 2, b3.x2, b3.y1, (b3.y1 + b3.y2) / 2, b3.y2];
    };
  }
}
function Label(params2) {
  Transform.call(this, null, params2);
}
var ALPHA_MASK, INSIDE_OPACITY_IN_ALPHA, INSIDE_OPACITY, DIV, MOD2, SIZE, RIGHT0, RIGHT1, X_DIR, Y_DIR, Aligns, Baselines, TOP, MIDDLE, BOTTOM, LEFT, CENTER, RIGHT, anchorCode, placeAreaLabel, Output3, Anchors;
var init_vega_label_module = __esm({
  "node_modules/.pnpm/vega-label@1.0.0/node_modules/vega-label/build/vega-label.module.js"() {
    init_vega_canvas_browser_module();
    init_vega_dataflow_module();
    init_vega_scenegraph_module2();
    init_vega_util_module();
    ALPHA_MASK = 4278190080;
    INSIDE_OPACITY_IN_ALPHA = 268435456;
    INSIDE_OPACITY = 0.0625;
    DIV = 5;
    MOD2 = 31;
    SIZE = 32;
    RIGHT0 = new Uint32Array(SIZE + 1);
    RIGHT1 = new Uint32Array(SIZE + 1);
    RIGHT1[0] = 0;
    RIGHT0[0] = ~RIGHT1[0];
    for (let i = 1; i <= SIZE; ++i) {
      RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
      RIGHT0[i] = ~RIGHT1[i];
    }
    X_DIR = [-1, -1, 1, 1];
    Y_DIR = [-1, 1, -1, 1];
    Aligns = ["right", "center", "left"];
    Baselines = ["bottom", "middle", "top"];
    TOP = 0;
    MIDDLE = 4;
    BOTTOM = 8;
    LEFT = 0;
    CENTER = 1;
    RIGHT = 2;
    anchorCode = {
      "top-left": TOP + LEFT,
      "top": TOP + CENTER,
      "top-right": TOP + RIGHT,
      "left": MIDDLE + LEFT,
      "middle": MIDDLE + CENTER,
      "right": MIDDLE + RIGHT,
      "bottom-left": BOTTOM + LEFT,
      "bottom": BOTTOM + CENTER,
      "bottom-right": BOTTOM + RIGHT
    };
    placeAreaLabel = {
      "naive": placeAreaLabelNaive,
      "reduced-search": placeAreaLabelReducedSearch,
      "floodfill": placeAreaLabelFloodFill
    };
    Output3 = ["x", "y", "opacity", "align", "baseline"];
    Anchors = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
    Label.Definition = {
      type: "Label",
      metadata: {
        modifies: true
      },
      params: [{
        name: "size",
        type: "number",
        array: true,
        length: 2,
        required: true
      }, {
        name: "sort",
        type: "compare"
      }, {
        name: "anchor",
        type: "string",
        array: true,
        default: Anchors
      }, {
        name: "offset",
        type: "number",
        array: true,
        default: [1]
      }, {
        name: "padding",
        type: "number",
        default: 0
      }, {
        name: "lineAnchor",
        type: "string",
        values: ["start", "end"],
        default: "end"
      }, {
        name: "markIndex",
        type: "number",
        default: 0
      }, {
        name: "avoidBaseMark",
        type: "boolean",
        default: true
      }, {
        name: "avoidMarks",
        type: "data",
        array: true
      }, {
        name: "method",
        type: "string",
        default: "naive"
      }, {
        name: "as",
        type: "string",
        array: true,
        length: Output3.length,
        default: Output3
      }]
    };
    inherits(Label, Transform, {
      transform(_, pulse2) {
        function modp(param2) {
          const p = _[param2];
          return isFunction(p) && pulse2.modified(p.fields);
        }
        const mod = _.modified();
        if (!(mod || pulse2.changed(pulse2.ADD_REM) || modp("sort")))
          return;
        if (!_.size || _.size.length !== 2) {
          error("Size parameter should be specified as a [width, height] array.");
        }
        const as = _.as || Output3;
        labelLayout(pulse2.materialize(pulse2.SOURCE).source, _.size, _.sort, array(_.offset || 1), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark === false ? false : true, _.lineAnchor || "end", _.markIndex || 0, _.padding || 0, _.method || "naive").forEach((l) => {
          const t = l.datum;
          t[as[0]] = l.x;
          t[as[1]] = l.y;
          t[as[2]] = l.opacity;
          t[as[3]] = l.align;
          t[as[4]] = l.baseline;
        });
        return pulse2.reflow(mod).modifies(as);
      }
    });
  }
});

// node_modules/.pnpm/vega-regression@1.0.9/node_modules/vega-regression/build/vega-regression.module.js
var vega_regression_module_exports = {};
__export(vega_regression_module_exports, {
  loess: () => Loess,
  regression: () => Regression
});
function partition4(data3, groupby) {
  var groups4 = [], get8 = function(f) {
    return f(t);
  }, map11, i, n, t, k4, g;
  if (groupby == null) {
    groups4.push(data3);
  } else {
    for (map11 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k4 = groupby.map(get8);
      g = map11[k4];
      if (!g) {
        map11[k4] = g = [];
        g.dims = k4;
        groups4.push(g);
      }
      g.push(t);
    }
  }
  return groups4;
}
function Loess(params2) {
  Transform.call(this, null, params2);
}
function Regression(params2) {
  Transform.call(this, null, params2);
}
var Methods2, degreesOfFreedom;
var init_vega_regression_module = __esm({
  "node_modules/.pnpm/vega-regression@1.0.9/node_modules/vega-regression/build/vega-regression.module.js"() {
    init_vega_statistics_module();
    init_vega_dataflow_module();
    init_vega_util_module();
    Loess.Definition = {
      "type": "Loess",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "x",
        "type": "field",
        "required": true
      }, {
        "name": "y",
        "type": "field",
        "required": true
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "bandwidth",
        "type": "number",
        "default": 0.3
      }, {
        "name": "as",
        "type": "string",
        "array": true
      }]
    };
    inherits(Loess, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
        if (!this.value || pulse2.changed() || _.modified()) {
          const source5 = pulse2.materialize(pulse2.SOURCE).source, groups4 = partition4(source5, _.groupby), names = (_.groupby || []).map(accessorName), m2 = names.length, as = _.as || [accessorName(_.x), accessorName(_.y)], values5 = [];
          groups4.forEach((g) => {
            loess(g, _.x, _.y, _.bandwidth || 0.3).forEach((p) => {
              const t = {};
              for (let i = 0; i < m2; ++i) {
                t[names[i]] = g.dims[i];
              }
              t[as[0]] = p[0];
              t[as[1]] = p[1];
              values5.push(ingest$1(t));
            });
          });
          if (this.value)
            out.rem = this.value;
          this.value = out.add = out.source = values5;
        }
        return out;
      }
    });
    Methods2 = {
      linear,
      log: log2,
      exp: exp2,
      pow: pow2,
      quad,
      poly
    };
    degreesOfFreedom = (method3, order) => method3 === "poly" ? order : method3 === "quad" ? 2 : 1;
    Regression.Definition = {
      "type": "Regression",
      "metadata": {
        "generates": true
      },
      "params": [{
        "name": "x",
        "type": "field",
        "required": true
      }, {
        "name": "y",
        "type": "field",
        "required": true
      }, {
        "name": "groupby",
        "type": "field",
        "array": true
      }, {
        "name": "method",
        "type": "string",
        "default": "linear",
        "values": Object.keys(Methods2)
      }, {
        "name": "order",
        "type": "number",
        "default": 3
      }, {
        "name": "extent",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "params",
        "type": "boolean",
        "default": false
      }, {
        "name": "as",
        "type": "string",
        "array": true
      }]
    };
    inherits(Regression, Transform, {
      transform(_, pulse2) {
        const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
        if (!this.value || pulse2.changed() || _.modified()) {
          const source5 = pulse2.materialize(pulse2.SOURCE).source, groups4 = partition4(source5, _.groupby), names = (_.groupby || []).map(accessorName), method3 = _.method || "linear", order = _.order || 3, dof = degreesOfFreedom(method3, order), as = _.as || [accessorName(_.x), accessorName(_.y)], fit3 = Methods2[method3], values5 = [];
          let domain4 = _.extent;
          if (!has(Methods2, method3)) {
            error("Invalid regression method: " + method3);
          }
          if (domain4 != null) {
            if (method3 === "log" && domain4[0] <= 0) {
              pulse2.dataflow.warn("Ignoring extent with values <= 0 for log regression.");
              domain4 = null;
            }
          }
          groups4.forEach((g) => {
            const n = g.length;
            if (n <= dof) {
              pulse2.dataflow.warn("Skipping regression with more parameters than data points.");
              return;
            }
            const model = fit3(g, _.x, _.y, order);
            if (_.params) {
              values5.push(ingest$1({
                keys: g.dims,
                coef: model.coef,
                rSquared: model.rSquared
              }));
              return;
            }
            const dom = domain4 || extent(g, _.x), add7 = (p) => {
              const t = {};
              for (let i = 0; i < names.length; ++i) {
                t[names[i]] = g.dims[i];
              }
              t[as[0]] = p[0];
              t[as[1]] = p[1];
              values5.push(ingest$1(t));
            };
            if (method3 === "linear") {
              dom.forEach((x7) => add7([x7, model.predict(x7)]));
            } else {
              sampleCurve(model.predict, dom, 25, 200).forEach(add7);
            }
          });
          if (this.value)
            out.rem = this.value;
          this.value = out.add = out.source = values5;
        }
        return out;
      }
    });
  }
});

// node_modules/.pnpm/delaunator@4.0.1/node_modules/delaunator/index.js
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function orientIfSure(px3, py3, rx, ry, qx, qy) {
  const l = (ry - py3) * (qx - px3);
  const r2 = (rx - px3) * (qy - py3);
  return Math.abs(l - r2) >= 33306690738754716e-32 * Math.abs(l + r2) ? l - r2 : 0;
}
function orient(rx, ry, qx, qy, px3, py3) {
  const sign5 = orientIfSure(px3, py3, rx, ry, qx, qy) || orientIfSure(rx, ry, qx, qy, px3, py3) || orientIfSure(qx, qy, px3, py3, rx, ry);
  return sign5 < 0;
}
function inCircle(ax, ay, bx, by, cx, cy, px3, py3) {
  const dx = ax - px3;
  const dy = ay - py3;
  const ex = bx - px3;
  const ey = by - py3;
  const fx = cx - px3;
  const fy = cy - py3;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl3 = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x7 = (ey * bl3 - dy * cl) * d;
  const y7 = (dx * cl - ex * bl3) * d;
  return x7 * x7 + y7 * y7;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl3 = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x7 = ax + (ey * bl3 - dy * cl) * d;
  const y7 = ay + (dx * cl - ex * bl3) * d;
  return { x: x7, y: y7 };
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i = left + 1; i <= right; i++) {
      const temp3 = ids[i];
      const tempDist = dists[temp3];
      let j = i - 1;
      while (j >= left && dists[ids[j]] > tempDist)
        ids[j + 1] = ids[j--];
      ids[j + 1] = temp3;
    }
  } else {
    const median3 = left + right >> 1;
    let i = left + 1;
    let j = right;
    swap2(ids, median3, i);
    if (dists[ids[left]] > dists[ids[right]])
      swap2(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]])
      swap2(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]])
      swap2(ids, left, i);
    const temp3 = ids[i];
    const tempDist = dists[temp3];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i)
        break;
      swap2(ids, i, j);
    }
    ids[left + 1] = ids[j];
    ids[j] = temp3;
    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
}
function swap2(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}
var EPSILON2, EDGE_STACK, Delaunator;
var init_delaunator = __esm({
  "node_modules/.pnpm/delaunator@4.0.1/node_modules/delaunator/index.js"() {
    EPSILON2 = Math.pow(2, -52);
    EDGE_STACK = new Uint32Array(512);
    Delaunator = class {
      static from(points2, getX = defaultGetX, getY = defaultGetY) {
        const n = points2.length;
        const coords = new Float64Array(n * 2);
        for (let i = 0; i < n; i++) {
          const p = points2[i];
          coords[2 * i] = getX(p);
          coords[2 * i + 1] = getY(p);
        }
        return new Delaunator(coords);
      }
      constructor(coords) {
        const n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== "number")
          throw new Error("Expected coords to contain numbers.");
        this.coords = coords;
        const maxTriangles = Math.max(2 * n - 5, 0);
        this._triangles = new Uint32Array(maxTriangles * 3);
        this._halfedges = new Int32Array(maxTriangles * 3);
        this._hashSize = Math.ceil(Math.sqrt(n));
        this._hullPrev = new Uint32Array(n);
        this._hullNext = new Uint32Array(n);
        this._hullTri = new Uint32Array(n);
        this._hullHash = new Int32Array(this._hashSize).fill(-1);
        this._ids = new Uint32Array(n);
        this._dists = new Float64Array(n);
        this.update();
      }
      update() {
        const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
        const n = coords.length >> 1;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY2 = -Infinity;
        for (let i = 0; i < n; i++) {
          const x7 = coords[2 * i];
          const y7 = coords[2 * i + 1];
          if (x7 < minX)
            minX = x7;
          if (y7 < minY)
            minY = y7;
          if (x7 > maxX)
            maxX = x7;
          if (y7 > maxY2)
            maxY2 = y7;
          this._ids[i] = i;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY2) / 2;
        let minDist = Infinity;
        let i0, i1, i2;
        for (let i = 0; i < n; i++) {
          const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
          if (d < minDist) {
            i0 = i;
            minDist = d;
          }
        }
        const i0x = coords[2 * i0];
        const i0y = coords[2 * i0 + 1];
        minDist = Infinity;
        for (let i = 0; i < n; i++) {
          if (i === i0)
            continue;
          const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
          if (d < minDist && d > 0) {
            i1 = i;
            minDist = d;
          }
        }
        let i1x = coords[2 * i1];
        let i1y = coords[2 * i1 + 1];
        let minRadius = Infinity;
        for (let i = 0; i < n; i++) {
          if (i === i0 || i === i1)
            continue;
          const r2 = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
          if (r2 < minRadius) {
            i2 = i;
            minRadius = r2;
          }
        }
        let i2x = coords[2 * i2];
        let i2y = coords[2 * i2 + 1];
        if (minRadius === Infinity) {
          for (let i = 0; i < n; i++) {
            this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
          }
          quicksort(this._ids, this._dists, 0, n - 1);
          const hull = new Uint32Array(n);
          let j = 0;
          for (let i = 0, d0 = -Infinity; i < n; i++) {
            const id4 = this._ids[i];
            if (this._dists[id4] > d0) {
              hull[j++] = id4;
              d0 = this._dists[id4];
            }
          }
          this.hull = hull.subarray(0, j);
          this.triangles = new Uint32Array(0);
          this.halfedges = new Uint32Array(0);
          return;
        }
        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
          const i = i1;
          const x7 = i1x;
          const y7 = i1y;
          i1 = i2;
          i1x = i2x;
          i1y = i2y;
          i2 = i;
          i2x = x7;
          i2y = y7;
        }
        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center.x;
        this._cy = center.y;
        for (let i = 0; i < n; i++) {
          this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
        }
        quicksort(this._ids, this._dists, 0, n - 1);
        this._hullStart = i0;
        let hullSize = 3;
        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;
        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;
        hullHash.fill(-1);
        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;
        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);
        for (let k4 = 0, xp, yp; k4 < this._ids.length; k4++) {
          const i = this._ids[k4];
          const x7 = coords[2 * i];
          const y7 = coords[2 * i + 1];
          if (k4 > 0 && Math.abs(x7 - xp) <= EPSILON2 && Math.abs(y7 - yp) <= EPSILON2)
            continue;
          xp = x7;
          yp = y7;
          if (i === i0 || i === i1 || i === i2)
            continue;
          let start = 0;
          for (let j = 0, key3 = this._hashKey(x7, y7); j < this._hashSize; j++) {
            start = hullHash[(key3 + j) % this._hashSize];
            if (start !== -1 && start !== hullNext[start])
              break;
          }
          start = hullPrev[start];
          let e3 = start, q;
          while (q = hullNext[e3], !orient(x7, y7, coords[2 * e3], coords[2 * e3 + 1], coords[2 * q], coords[2 * q + 1])) {
            e3 = q;
            if (e3 === start) {
              e3 = -1;
              break;
            }
          }
          if (e3 === -1)
            continue;
          let t = this._addTriangle(e3, i, hullNext[e3], -1, -1, hullTri[e3]);
          hullTri[i] = this._legalize(t + 2);
          hullTri[e3] = t;
          hullSize++;
          let n2 = hullNext[e3];
          while (q = hullNext[n2], orient(x7, y7, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1])) {
            t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
            hullTri[i] = this._legalize(t + 2);
            hullNext[n2] = n2;
            hullSize--;
            n2 = q;
          }
          if (e3 === start) {
            while (q = hullPrev[e3], orient(x7, y7, coords[2 * q], coords[2 * q + 1], coords[2 * e3], coords[2 * e3 + 1])) {
              t = this._addTriangle(q, i, e3, -1, hullTri[e3], hullTri[q]);
              this._legalize(t + 2);
              hullTri[q] = t;
              hullNext[e3] = e3;
              hullSize--;
              e3 = q;
            }
          }
          this._hullStart = hullPrev[i] = e3;
          hullNext[e3] = hullPrev[n2] = i;
          hullNext[i] = n2;
          hullHash[this._hashKey(x7, y7)] = i;
          hullHash[this._hashKey(coords[2 * e3], coords[2 * e3 + 1])] = e3;
        }
        this.hull = new Uint32Array(hullSize);
        for (let i = 0, e3 = this._hullStart; i < hullSize; i++) {
          this.hull[i] = e3;
          e3 = hullNext[e3];
        }
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
      }
      _hashKey(x7, y7) {
        return Math.floor(pseudoAngle(x7 - this._cx, y7 - this._cy) * this._hashSize) % this._hashSize;
      }
      _legalize(a4) {
        const { _triangles: triangles, _halfedges: halfedges, coords } = this;
        let i = 0;
        let ar = 0;
        while (true) {
          const b3 = halfedges[a4];
          const a0 = a4 - a4 % 3;
          ar = a0 + (a4 + 2) % 3;
          if (b3 === -1) {
            if (i === 0)
              break;
            a4 = EDGE_STACK[--i];
            continue;
          }
          const b0 = b3 - b3 % 3;
          const al = a0 + (a4 + 1) % 3;
          const bl3 = b0 + (b3 + 2) % 3;
          const p02 = triangles[ar];
          const pr = triangles[a4];
          const pl = triangles[al];
          const p1 = triangles[bl3];
          const illegal = inCircle(
            coords[2 * p02],
            coords[2 * p02 + 1],
            coords[2 * pr],
            coords[2 * pr + 1],
            coords[2 * pl],
            coords[2 * pl + 1],
            coords[2 * p1],
            coords[2 * p1 + 1]
          );
          if (illegal) {
            triangles[a4] = p1;
            triangles[b3] = p02;
            const hbl = halfedges[bl3];
            if (hbl === -1) {
              let e3 = this._hullStart;
              do {
                if (this._hullTri[e3] === bl3) {
                  this._hullTri[e3] = a4;
                  break;
                }
                e3 = this._hullPrev[e3];
              } while (e3 !== this._hullStart);
            }
            this._link(a4, hbl);
            this._link(b3, halfedges[ar]);
            this._link(ar, bl3);
            const br3 = b0 + (b3 + 1) % 3;
            if (i < EDGE_STACK.length) {
              EDGE_STACK[i++] = br3;
            }
          } else {
            if (i === 0)
              break;
            a4 = EDGE_STACK[--i];
          }
        }
        return ar;
      }
      _link(a4, b3) {
        this._halfedges[a4] = b3;
        if (b3 !== -1)
          this._halfedges[b3] = a4;
      }
      _addTriangle(i0, i1, i2, a4, b3, c2) {
        const t = this.trianglesLen;
        this._triangles[t] = i0;
        this._triangles[t + 1] = i1;
        this._triangles[t + 2] = i2;
        this._link(t, a4);
        this._link(t + 1, b3);
        this._link(t + 2, c2);
        this.trianglesLen += 3;
        return t;
      }
    };
  }
});

// node_modules/.pnpm/d3-delaunay@5.3.0/node_modules/d3-delaunay/src/path.js
var epsilon9, Path3;
var init_path6 = __esm({
  "node_modules/.pnpm/d3-delaunay@5.3.0/node_modules/d3-delaunay/src/path.js"() {
    epsilon9 = 1e-6;
    Path3 = class {
      constructor() {
        this._x0 = this._y0 = this._x1 = this._y1 = null;
        this._ = "";
      }
      moveTo(x7, y7) {
        this._ += `M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x7, y7) {
        this._ += `L${this._x1 = +x7},${this._y1 = +y7}`;
      }
      arc(x7, y7, r2) {
        x7 = +x7, y7 = +y7, r2 = +r2;
        const x07 = x7 + r2;
        const y07 = y7;
        if (r2 < 0)
          throw new Error("negative radius");
        if (this._x1 === null)
          this._ += `M${x07},${y07}`;
        else if (Math.abs(this._x1 - x07) > epsilon9 || Math.abs(this._y1 - y07) > epsilon9)
          this._ += "L" + x07 + "," + y07;
        if (!r2)
          return;
        this._ += `A${r2},${r2},0,1,1,${x7 - r2},${y7}A${r2},${r2},0,1,1,${this._x1 = x07},${this._y1 = y07}`;
      }
      rect(x7, y7, w5, h4) {
        this._ += `M${this._x0 = this._x1 = +x7},${this._y0 = this._y1 = +y7}h${+w5}v${+h4}h${-w5}Z`;
      }
      value() {
        return this._ || null;
      }
    };
  }
});

// node_modules/.pnpm/d3-delaunay@5.3.0/node_modules/d3-delaunay/src/polygon.js
var Polygon;
var init_polygon = __esm({
  "node_modules/.pnpm/d3-delaunay@5.3.0/node_modules/d3-delaunay/src/polygon.js"() {
    Polygon = class {
      constructor() {
        this._ = [];
      }
      moveTo(x7, y7) {
        this._.push([x7, y7]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x7, y7) {
        this._.push([x7, y7]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    };
  }
});

// node_modules/.pnpm/d3-delaunay@5.3.0/node_modules/d3-delaunay/src/voronoi.js
var Voronoi;
var init_voronoi = __esm({
  "node_modules/.pnpm/d3-delaunay@5.3.0/node_modules/d3-delaunay/src/voronoi.js"() {
    init_path6();
    init_polygon();
    Voronoi = class {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
          throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const { delaunay: { points: points2, hull, triangles }, vectors } = this;
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x7, y7; i < n; i += 3, j += 2) {
          const t15 = triangles[i] * 2;
          const t23 = triangles[i + 1] * 2;
          const t33 = triangles[i + 2] * 2;
          const x14 = points2[t15];
          const y14 = points2[t15 + 1];
          const x22 = points2[t23];
          const y22 = points2[t23 + 1];
          const x32 = points2[t33];
          const y32 = points2[t33 + 1];
          const dx = x22 - x14;
          const dy = y22 - y14;
          const ex = x32 - x14;
          const ey = y32 - y14;
          const bl3 = dx * dx + dy * dy;
          const cl = ex * ex + ey * ey;
          const ab = (dx * ey - dy * ex) * 2;
          if (!ab) {
            x7 = (x14 + x32) / 2 - 1e8 * ey;
            y7 = (y14 + y32) / 2 + 1e8 * ex;
          } else if (Math.abs(ab) < 1e-8) {
            x7 = (x14 + x32) / 2;
            y7 = (y14 + y32) / 2;
          } else {
            const d = 1 / ab;
            x7 = x14 + (ey * bl3 - dy * cl) * d;
            y7 = y14 + (dx * cl - ex * bl3) * d;
          }
          circumcenters[j] = x7;
          circumcenters[j + 1] = y7;
        }
        let h4 = hull[hull.length - 1];
        let p02, p1 = h4 * 4;
        let x07, x13 = points2[2 * h4];
        let y07, y13 = points2[2 * h4 + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h4 = hull[i];
          p02 = p1, x07 = x13, y07 = y13;
          p1 = h4 * 4, x13 = points2[2 * h4], y13 = points2[2 * h4 + 1];
          vectors[p02 + 2] = vectors[p1] = y07 - y13;
          vectors[p02 + 3] = vectors[p1 + 1] = x13 - x07;
        }
      }
      render(context4) {
        const buffer = context4 == null ? context4 = new Path3() : void 0;
        const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
        if (hull.length <= 1)
          return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i)
            continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context4);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t = Math.floor(inedges[h1] / 3) * 2;
          const x7 = circumcenters[t];
          const y7 = circumcenters[t + 1];
          const v = h0 * 4;
          const p = this._project(x7, y7, vectors[v + 2], vectors[v + 3]);
          if (p)
            this._renderSegment(x7, y7, p[0], p[1], context4);
        }
        return buffer && buffer.value();
      }
      renderBounds(context4) {
        const buffer = context4 == null ? context4 = new Path3() : void 0;
        context4.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context4) {
        const buffer = context4 == null ? context4 = new Path3() : void 0;
        const points2 = this._clip(i);
        if (points2 === null || !points2.length)
          return;
        context4.moveTo(points2[0], points2[1]);
        let n = points2.length;
        while (points2[0] === points2[n - 2] && points2[1] === points2[n - 1] && n > 1)
          n -= 2;
        for (let i2 = 2; i2 < n; i2 += 2) {
          if (points2[i2] !== points2[i2 - 2] || points2[i2 + 1] !== points2[i2 - 1])
            context4.lineTo(points2[i2], points2[i2 + 1]);
        }
        context4.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const { delaunay: { points: points2 } } = this;
        for (let i = 0, n = points2.length / 2; i < n; ++i) {
          const cell2 = this.cellPolygon(i);
          if (cell2)
            cell2.index = i, yield cell2;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon();
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x07, y07, x13, y13, context4) {
        let S;
        const c0 = this._regioncode(x07, y07);
        const c1 = this._regioncode(x13, y13);
        if (c0 === 0 && c1 === 0) {
          context4.moveTo(x07, y07);
          context4.lineTo(x13, y13);
        } else if (S = this._clipSegment(x07, y07, x13, y13, c0, c1)) {
          context4.moveTo(S[0], S[1]);
          context4.lineTo(S[2], S[3]);
        }
      }
      contains(i, x7, y7) {
        if ((x7 = +x7, x7 !== x7) || (y7 = +y7, y7 !== y7))
          return false;
        return this.delaunay._step(i, x7, y7) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci)
          for (const j of this.delaunay.neighbors(i)) {
            const cj = this._clip(j);
            if (cj)
              loop:
                for (let ai = 0, li = ci.length; ai < li; ai += 2) {
                  for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
                    if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
                      yield j;
                      break loop;
                    }
                  }
                }
          }
      }
      _cell(i) {
        const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
        const e0 = inedges[i];
        if (e0 === -1)
          return null;
        const points2 = [];
        let e3 = e0;
        do {
          const t = Math.floor(e3 / 3);
          points2.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
          e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
          if (triangles[e3] !== i)
            break;
          e3 = halfedges[e3];
        } while (e3 !== e0 && e3 !== -1);
        return points2;
      }
      _clip(i) {
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points2 = this._cell(i);
        if (points2 === null)
          return null;
        const { vectors: V } = this;
        const v = i * 4;
        return V[v] || V[v + 1] ? this._clipInfinite(i, points2, V[v], V[v + 1], V[v + 2], V[v + 3]) : this._clipFinite(i, points2);
      }
      _clipFinite(i, points2) {
        const n = points2.length;
        let P = null;
        let x07, y07, x13 = points2[n - 2], y13 = points2[n - 1];
        let c0, c1 = this._regioncode(x13, y13);
        let e0, e1;
        for (let j = 0; j < n; j += 2) {
          x07 = x13, y07 = y13, x13 = points2[j], y13 = points2[j + 1];
          c0 = c1, c1 = this._regioncode(x13, y13);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P)
              P.push(x13, y13);
            else
              P = [x13, y13];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x07, y07, x13, y13, c0, c1)) === null)
                continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x13, y13, x07, y07, c1, c0)) === null)
                continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1)
                this._edge(i, e0, e1, P, P.length);
              if (P)
                P.push(sx0, sy0);
              else
                P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1)
              this._edge(i, e0, e1, P, P.length);
            if (P)
              P.push(sx1, sy1);
            else
              P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1)
            this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x07, y07, x13, y13, c0, c1) {
        while (true) {
          if (c0 === 0 && c1 === 0)
            return [x07, y07, x13, y13];
          if (c0 & c1)
            return null;
          let x7, y7, c2 = c0 || c1;
          if (c2 & 8)
            x7 = x07 + (x13 - x07) * (this.ymax - y07) / (y13 - y07), y7 = this.ymax;
          else if (c2 & 4)
            x7 = x07 + (x13 - x07) * (this.ymin - y07) / (y13 - y07), y7 = this.ymin;
          else if (c2 & 2)
            y7 = y07 + (y13 - y07) * (this.xmax - x07) / (x13 - x07), x7 = this.xmax;
          else
            y7 = y07 + (y13 - y07) * (this.xmin - x07) / (x13 - x07), x7 = this.xmin;
          if (c0)
            x07 = x7, y07 = y7, c0 = this._regioncode(x07, y07);
          else
            x13 = x7, y13 = y7, c1 = this._regioncode(x13, y13);
        }
      }
      _clipInfinite(i, points2, vx0, vy0, vxn, vyn) {
        let P = Array.from(points2), p;
        if (p = this._project(P[0], P[1], vx0, vy0))
          P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))
          P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1)
              j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x7, y7;
          switch (e0) {
            case 5:
              e0 = 4;
              continue;
            case 4:
              e0 = 6, x7 = this.xmax, y7 = this.ymin;
              break;
            case 6:
              e0 = 2;
              continue;
            case 2:
              e0 = 10, x7 = this.xmax, y7 = this.ymax;
              break;
            case 10:
              e0 = 8;
              continue;
            case 8:
              e0 = 9, x7 = this.xmin, y7 = this.ymax;
              break;
            case 9:
              e0 = 1;
              continue;
            case 1:
              e0 = 5, x7 = this.xmin, y7 = this.ymin;
              break;
          }
          if ((P[j] !== x7 || P[j + 1] !== y7) && this.contains(i, x7, y7)) {
            P.splice(j, 0, x7, y7), j += 2;
          }
        }
        if (P.length > 4) {
          for (let i2 = 0; i2 < P.length; i2 += 2) {
            const j2 = (i2 + 2) % P.length, k4 = (i2 + 4) % P.length;
            if (P[i2] === P[j2] && P[j2] === P[k4] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k4 + 1])
              P.splice(j2, 2), i2 -= 2;
          }
        }
        return j;
      }
      _project(x07, y07, vx, vy) {
        let t = Infinity, c2, x7, y7;
        if (vy < 0) {
          if (y07 <= this.ymin)
            return null;
          if ((c2 = (this.ymin - y07) / vy) < t)
            y7 = this.ymin, x7 = x07 + (t = c2) * vx;
        } else if (vy > 0) {
          if (y07 >= this.ymax)
            return null;
          if ((c2 = (this.ymax - y07) / vy) < t)
            y7 = this.ymax, x7 = x07 + (t = c2) * vx;
        }
        if (vx > 0) {
          if (x07 >= this.xmax)
            return null;
          if ((c2 = (this.xmax - x07) / vx) < t)
            x7 = this.xmax, y7 = y07 + (t = c2) * vy;
        } else if (vx < 0) {
          if (x07 <= this.xmin)
            return null;
          if ((c2 = (this.xmin - x07) / vx) < t)
            x7 = this.xmin, y7 = y07 + (t = c2) * vy;
        }
        return [x7, y7];
      }
      _edgecode(x7, y7) {
        return (x7 === this.xmin ? 1 : x7 === this.xmax ? 2 : 0) | (y7 === this.ymin ? 4 : y7 === this.ymax ? 8 : 0);
      }
      _regioncode(x7, y7) {
        return (x7 < this.xmin ? 1 : x7 > this.xmax ? 2 : 0) | (y7 < this.ymin ? 4 : y7 > this.ymax ? 8 : 0);
      }
    };
  }
});

// node_modules/.pnpm/d3-delaunay@5.3.0/node_modules/d3-delaunay/src/delaunay.js
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear2(d) {
  const { triangles, coords } = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a4 = 2 * triangles[i], b3 = 2 * triangles[i + 1], c2 = 2 * triangles[i + 2], cross5 = (coords[c2] - coords[a4]) * (coords[b3 + 1] - coords[a4 + 1]) - (coords[b3] - coords[a4]) * (coords[c2 + 1] - coords[a4 + 1]);
    if (cross5 > 1e-10)
      return false;
  }
  return true;
}
function jitter(x7, y7, r2) {
  return [x7 + Math.sin(x7 + y7) * r2, y7 + Math.cos(x7 - y7) * r2];
}
function flatArray(points2, fx, fy, that) {
  const n = points2.length;
  const array9 = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points2[i];
    array9[i * 2] = fx.call(that, p, i, points2);
    array9[i * 2 + 1] = fy.call(that, p, i, points2);
  }
  return array9;
}
function* flatIterable(points2, fx, fy, that) {
  let i = 0;
  for (const p of points2) {
    yield fx.call(that, p, i, points2);
    yield fy.call(that, p, i, points2);
    ++i;
  }
}
var tau7, pow7, Delaunay;
var init_delaunay = __esm({
  "node_modules/.pnpm/d3-delaunay@5.3.0/node_modules/d3-delaunay/src/delaunay.js"() {
    init_delaunator();
    init_path6();
    init_polygon();
    init_voronoi();
    tau7 = 2 * Math.PI;
    pow7 = Math.pow;
    Delaunay = class {
      static from(points2, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points2 ? flatArray(points2, fx, fy, that) : Float64Array.from(flatIterable(points2, fx, fy, that)));
      }
      constructor(points2) {
        this._delaunator = new Delaunator(points2);
        this.inedges = new Int32Array(points2.length / 2);
        this._hullIndex = new Int32Array(points2.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points2 = this.points;
        if (d.hull && d.hull.length > 2 && collinear2(d)) {
          this.collinear = Int32Array.from({ length: points2.length / 2 }, (_, i) => i).sort((i, j) => points2[2 * i] - points2[2 * j] || points2[2 * i + 1] - points2[2 * j + 1]);
          const e3 = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds3 = [points2[2 * e3], points2[2 * e3 + 1], points2[2 * f], points2[2 * f + 1]], r2 = 1e-8 * Math.hypot(bounds3[3] - bounds3[1], bounds3[2] - bounds3[0]);
          for (let i = 0, n = points2.length / 2; i < n; ++i) {
            const p = jitter(points2[2 * i], points2[2 * i + 1], r2);
            points2[2 * i] = p[0];
            points2[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points2);
        } else {
          delete this.collinear;
        }
        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);
        for (let e3 = 0, n = halfedges.length; e3 < n; ++e3) {
          const p = triangles[e3 % 3 === 2 ? e3 - 2 : e3 + 1];
          if (halfedges[e3] === -1 || inedges[p] === -1)
            inedges[p] = e3;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          this.triangles[1] = hull[1];
          this.triangles[2] = hull[1];
          inedges[hull[0]] = 1;
          if (hull.length === 2)
            inedges[hull[1]] = 0;
        }
      }
      voronoi(bounds3) {
        return new Voronoi(this, bounds3);
      }
      *neighbors(i) {
        const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;
        if (collinear3) {
          const l = collinear3.indexOf(i);
          if (l > 0)
            yield collinear3[l - 1];
          if (l < collinear3.length - 1)
            yield collinear3[l + 1];
          return;
        }
        const e0 = inedges[i];
        if (e0 === -1)
          return;
        let e3 = e0, p02 = -1;
        do {
          yield p02 = triangles[e3];
          e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
          if (triangles[e3] !== i)
            return;
          e3 = halfedges[e3];
          if (e3 === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p02)
              yield p;
            return;
          }
        } while (e3 !== e0);
      }
      find(x7, y7, i = 0) {
        if ((x7 = +x7, x7 !== x7) || (y7 = +y7, y7 !== y7))
          return -1;
        const i0 = i;
        let c2;
        while ((c2 = this._step(i, x7, y7)) >= 0 && c2 !== i && c2 !== i0)
          i = c2;
        return c2;
      }
      _step(i, x7, y7) {
        const { inedges, hull, _hullIndex, halfedges, triangles, points: points2 } = this;
        if (inedges[i] === -1 || !points2.length)
          return (i + 1) % (points2.length >> 1);
        let c2 = i;
        let dc = pow7(x7 - points2[i * 2], 2) + pow7(y7 - points2[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e3 = e0;
        do {
          let t = triangles[e3];
          const dt = pow7(x7 - points2[t * 2], 2) + pow7(y7 - points2[t * 2 + 1], 2);
          if (dt < dc)
            dc = dt, c2 = t;
          e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
          if (triangles[e3] !== i)
            break;
          e3 = halfedges[e3];
          if (e3 === -1) {
            e3 = hull[(_hullIndex[i] + 1) % hull.length];
            if (e3 !== t) {
              if (pow7(x7 - points2[e3 * 2], 2) + pow7(y7 - points2[e3 * 2 + 1], 2) < dc)
                return e3;
            }
            break;
          }
        } while (e3 !== e0);
        return c2;
      }
      render(context4) {
        const buffer = context4 == null ? context4 = new Path3() : void 0;
        const { points: points2, halfedges, triangles } = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i)
            continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context4.moveTo(points2[ti], points2[ti + 1]);
          context4.lineTo(points2[tj], points2[tj + 1]);
        }
        this.renderHull(context4);
        return buffer && buffer.value();
      }
      renderPoints(context4, r2 = 2) {
        const buffer = context4 == null ? context4 = new Path3() : void 0;
        const { points: points2 } = this;
        for (let i = 0, n = points2.length; i < n; i += 2) {
          const x7 = points2[i], y7 = points2[i + 1];
          context4.moveTo(x7 + r2, y7);
          context4.arc(x7, y7, r2, 0, tau7);
        }
        return buffer && buffer.value();
      }
      renderHull(context4) {
        const buffer = context4 == null ? context4 = new Path3() : void 0;
        const { hull, points: points2 } = this;
        const h4 = hull[0] * 2, n = hull.length;
        context4.moveTo(points2[h4], points2[h4 + 1]);
        for (let i = 1; i < n; ++i) {
          const h5 = 2 * hull[i];
          context4.lineTo(points2[h5], points2[h5 + 1]);
        }
        context4.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon();
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context4) {
        const buffer = context4 == null ? context4 = new Path3() : void 0;
        const { points: points2, triangles } = this;
        const t07 = triangles[i *= 3] * 2;
        const t15 = triangles[i + 1] * 2;
        const t23 = triangles[i + 2] * 2;
        context4.moveTo(points2[t07], points2[t07 + 1]);
        context4.lineTo(points2[t15], points2[t15 + 1]);
        context4.lineTo(points2[t23], points2[t23 + 1]);
        context4.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const { triangles } = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon();
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    };
  }
});

// node_modules/.pnpm/d3-delaunay@5.3.0/node_modules/d3-delaunay/src/index.js
var init_src32 = __esm({
  "node_modules/.pnpm/d3-delaunay@5.3.0/node_modules/d3-delaunay/src/index.js"() {
    init_delaunay();
    init_voronoi();
  }
});

// node_modules/.pnpm/vega-voronoi@4.1.5/node_modules/vega-voronoi/build/vega-voronoi.module.js
var vega_voronoi_module_exports = {};
__export(vega_voronoi_module_exports, {
  voronoi: () => Voronoi2
});
function Voronoi2(params2) {
  Transform.call(this, null, params2);
}
function toPathString(p) {
  const x7 = p[0][0], y7 = p[0][1];
  let n = p.length - 1;
  for (; p[n][0] === x7 && p[n][1] === y7; --n)
    ;
  return "M" + p.slice(0, n + 1).join("L") + "Z";
}
var defaultExtent;
var init_vega_voronoi_module = __esm({
  "node_modules/.pnpm/vega-voronoi@4.1.5/node_modules/vega-voronoi/build/vega-voronoi.module.js"() {
    init_vega_dataflow_module();
    init_vega_util_module();
    init_src32();
    Voronoi2.Definition = {
      "type": "Voronoi",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "x",
        "type": "field",
        "required": true
      }, {
        "name": "y",
        "type": "field",
        "required": true
      }, {
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "extent",
        "type": "array",
        "array": true,
        "length": 2,
        "default": [[-1e5, -1e5], [1e5, 1e5]],
        "content": {
          "type": "number",
          "array": true,
          "length": 2
        }
      }, {
        "name": "as",
        "type": "string",
        "default": "path"
      }]
    };
    defaultExtent = [-1e5, -1e5, 1e5, 1e5];
    inherits(Voronoi2, Transform, {
      transform(_, pulse2) {
        const as = _.as || "path", data3 = pulse2.source;
        if (!data3 || !data3.length)
          return pulse2;
        let s3 = _.size;
        s3 = s3 ? [0, 0, s3[0], s3[1]] : (s3 = _.extent) ? [s3[0][0], s3[0][1], s3[1][0], s3[1][1]] : defaultExtent;
        const voronoi = this.value = Delaunay.from(data3, _.x, _.y).voronoi(s3);
        for (let i = 0, n = data3.length; i < n; ++i) {
          const polygon = voronoi.cellPolygon(i);
          data3[i][as] = polygon ? toPathString(polygon) : null;
        }
        return pulse2.reflow(_.modified()).modifies(as);
      }
    });
  }
});

// node_modules/.pnpm/vega-statistics@1.9.0/node_modules/vega-statistics/build/vega-statistics.module.js
var random2, SQRT2PI2, MIN_RADIANS2;
var init_vega_statistics_module2 = __esm({
  "node_modules/.pnpm/vega-statistics@1.9.0/node_modules/vega-statistics/build/vega-statistics.module.js"() {
    init_src4();
    random2 = Math.random;
    SQRT2PI2 = Math.sqrt(2 * Math.PI);
    MIN_RADIANS2 = 0.5 * Math.PI / 180;
  }
});

// node_modules/.pnpm/vega-wordcloud@4.1.4/node_modules/vega-wordcloud/build/vega-wordcloud.module.js
var vega_wordcloud_module_exports = {};
__export(vega_wordcloud_module_exports, {
  wordcloud: () => Wordcloud
});
function cloud() {
  var size = [256, 256], text5, font4, fontSize3, fontStyle, fontWeight2, rotate3, padding3, spiral = archimedeanSpiral, words = [], random3 = Math.random, cloud2 = {};
  cloud2.layout = function() {
    var contextAndRatio = getContext2(domCanvas()), board = zeroArray((size[0] >> 5) * size[1]), bounds3 = null, n = words.length, i = -1, tags = [], data3 = words.map((d2) => ({
      text: text5(d2),
      font: font4(d2),
      style: fontStyle(d2),
      weight: fontWeight2(d2),
      rotate: rotate3(d2),
      size: ~~(fontSize3(d2) + 1e-14),
      padding: padding3(d2),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d2
    })).sort((a4, b3) => b3.size - a4.size);
    while (++i < n) {
      var d = data3[i];
      d.x = size[0] * (random3() + 0.5) >> 1;
      d.y = size[1] * (random3() + 0.5) >> 1;
      cloudSprite(contextAndRatio, d, data3, i);
      if (d.hasText && place2(board, d, bounds3)) {
        tags.push(d);
        if (bounds3)
          cloudBounds(bounds3, d);
        else
          bounds3 = [{
            x: d.x + d.x0,
            y: d.y + d.y0
          }, {
            x: d.x + d.x1,
            y: d.y + d.y1
          }];
        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }
    return tags;
  };
  function getContext2(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context4 = canvas.getContext("2d");
    context4.fillStyle = context4.strokeStyle = "red";
    context4.textAlign = "center";
    return {
      context: context4,
      ratio
    };
  }
  function place2(board, tag, bounds3) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s3 = spiral(size), dt = random3() < 0.5 ? 1 : -1, t = -dt, dxdy, dx, dy;
    while (dxdy = s3(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])
        continue;
      if (!bounds3 || !cloudCollide(tag, board, size[0])) {
        if (!bounds3 || collideRects(tag, bounds3)) {
          var sprite = tag.sprite, w5 = tag.width >> 5, sw = size[0] >> 5, lx3 = tag.x - (w5 << 4), sx = lx3 & 127, msx = 32 - sx, h4 = tag.y1 - tag.y0, x7 = (tag.y + tag.y0) * sw + (lx3 >> 5), last;
          for (var j = 0; j < h4; j++) {
            last = 0;
            for (var i = 0; i <= w5; i++) {
              board[x7 + i] |= last << msx | (i < w5 ? (last = sprite[j * w5 + i]) >>> sx : 0);
            }
            x7 += sw;
          }
          tag.sprite = null;
          return true;
        }
      }
    }
    return false;
  }
  cloud2.words = function(_) {
    if (arguments.length) {
      words = _;
      return cloud2;
    } else {
      return words;
    }
  };
  cloud2.size = function(_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud2;
    } else {
      return size;
    }
  };
  cloud2.font = function(_) {
    if (arguments.length) {
      font4 = functor(_);
      return cloud2;
    } else {
      return font4;
    }
  };
  cloud2.fontStyle = function(_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud2;
    } else {
      return fontStyle;
    }
  };
  cloud2.fontWeight = function(_) {
    if (arguments.length) {
      fontWeight2 = functor(_);
      return cloud2;
    } else {
      return fontWeight2;
    }
  };
  cloud2.rotate = function(_) {
    if (arguments.length) {
      rotate3 = functor(_);
      return cloud2;
    } else {
      return rotate3;
    }
  };
  cloud2.text = function(_) {
    if (arguments.length) {
      text5 = functor(_);
      return cloud2;
    } else {
      return text5;
    }
  };
  cloud2.spiral = function(_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud2;
    } else {
      return spiral;
    }
  };
  cloud2.fontSize = function(_) {
    if (arguments.length) {
      fontSize3 = functor(_);
      return cloud2;
    } else {
      return fontSize3;
    }
  };
  cloud2.padding = function(_) {
    if (arguments.length) {
      padding3 = functor(_);
      return cloud2;
    } else {
      return padding3;
    }
  };
  cloud2.random = function(_) {
    if (arguments.length) {
      random3 = _;
      return cloud2;
    } else {
      return random3;
    }
  };
  return cloud2;
}
function cloudSprite(contextAndRatio, d, data3, di) {
  if (d.sprite)
    return;
  var c2 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c2.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x7 = 0, y7 = 0, maxh = 0, n = data3.length, w5, w32, h4, i, j;
  --di;
  while (++di < n) {
    d = data3[di];
    c2.save();
    c2.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    w5 = c2.measureText(d.text + "m").width * ratio;
    h4 = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr3 = Math.cos(d.rotate * cloudRadians), wcr = w5 * cr3, wsr = w5 * sr, hcr = h4 * cr3, hsr = h4 * sr;
      w5 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h4 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w5 = w5 + 31 >> 5 << 5;
    }
    if (h4 > maxh)
      maxh = h4;
    if (x7 + w5 >= cw << 5) {
      x7 = 0;
      y7 += maxh;
      maxh = 0;
    }
    if (y7 + h4 >= ch)
      break;
    c2.translate((x7 + (w5 >> 1)) / ratio, (y7 + (h4 >> 1)) / ratio);
    if (d.rotate)
      c2.rotate(d.rotate * cloudRadians);
    c2.fillText(d.text, 0, 0);
    if (d.padding) {
      c2.lineWidth = 2 * d.padding;
      c2.strokeText(d.text, 0, 0);
    }
    c2.restore();
    d.width = w5;
    d.height = h4;
    d.xoff = x7;
    d.yoff = y7;
    d.x1 = w5 >> 1;
    d.y1 = h4 >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x7 += w5;
  }
  var pixels = c2.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data3[di];
    if (!d.hasText)
      continue;
    w5 = d.width;
    w32 = w5 >> 5;
    h4 = d.y1 - d.y0;
    for (i = 0; i < h4 * w32; i++)
      sprite[i] = 0;
    x7 = d.xoff;
    if (x7 == null)
      return;
    y7 = d.yoff;
    var seen = 0, seenRow = -1;
    for (j = 0; j < h4; j++) {
      for (i = 0; i < w5; i++) {
        var k4 = w32 * j + (i >> 5), m2 = pixels[(y7 + j) * (cw << 5) + (x7 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k4] |= m2;
        seen |= m2;
      }
      if (seen)
        seenRow = j;
      else {
        d.y0++;
        h4--;
        j--;
        y7++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w5 = tag.width >> 5, lx3 = tag.x - (w5 << 4), sx = lx3 & 127, msx = 32 - sx, h4 = tag.y1 - tag.y0, x7 = (tag.y + tag.y0) * sw + (lx3 >> 5), last;
  for (var j = 0; j < h4; j++) {
    last = 0;
    for (var i = 0; i <= w5; i++) {
      if ((last << msx | (i < w5 ? (last = sprite[j * w5 + i]) >>> sx : 0)) & board[x7 + i])
        return true;
    }
    x7 += sw;
  }
  return false;
}
function cloudBounds(bounds3, d) {
  var b0 = bounds3[0], b1 = bounds3[1];
  if (d.x + d.x0 < b0.x)
    b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y)
    b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x)
    b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y)
    b1.y = d.y + d.y1;
}
function collideRects(a4, b3) {
  return a4.x + a4.x1 > b3[0].x && a4.x + a4.x0 < b3[1].x && a4.y + a4.y1 > b3[0].y && a4.y + a4.y0 < b3[1].y;
}
function archimedeanSpiral(size) {
  var e3 = size[0] / size[1];
  return function(t) {
    return [e3 * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size) {
  var dy = 4, dx = dy * size[0] / size[1], x7 = 0, y7 = 0;
  return function(t) {
    var sign5 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign5 * t) - sign5 & 3) {
      case 0:
        x7 += dx;
        break;
      case 1:
        y7 += dy;
        break;
      case 2:
        x7 -= dx;
        break;
      default:
        y7 -= dy;
        break;
    }
    return [x7, y7];
  };
}
function zeroArray(n) {
  var a4 = [], i = -1;
  while (++i < n)
    a4[i] = 0;
  return a4;
}
function functor(d) {
  return typeof d === "function" ? d : function() {
    return d;
  };
}
function Wordcloud(params2) {
  Transform.call(this, cloud(), params2);
}
var cloudRadians, cw, ch, spirals, Output4, Params2;
var init_vega_wordcloud_module = __esm({
  "node_modules/.pnpm/vega-wordcloud@4.1.4/node_modules/vega-wordcloud/build/vega-wordcloud.module.js"() {
    init_vega_canvas_browser_module();
    init_vega_dataflow_module();
    init_vega_util_module2();
    init_vega_scale_module();
    init_vega_statistics_module2();
    cloudRadians = Math.PI / 180;
    cw = 1 << 11 >> 5;
    ch = 1 << 11;
    spirals = {
      archimedean: archimedeanSpiral,
      rectangular: rectangularSpiral
    };
    Output4 = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"];
    Params2 = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
    Wordcloud.Definition = {
      "type": "Wordcloud",
      "metadata": {
        "modifies": true
      },
      "params": [{
        "name": "size",
        "type": "number",
        "array": true,
        "length": 2
      }, {
        "name": "font",
        "type": "string",
        "expr": true,
        "default": "sans-serif"
      }, {
        "name": "fontStyle",
        "type": "string",
        "expr": true,
        "default": "normal"
      }, {
        "name": "fontWeight",
        "type": "string",
        "expr": true,
        "default": "normal"
      }, {
        "name": "fontSize",
        "type": "number",
        "expr": true,
        "default": 14
      }, {
        "name": "fontSizeRange",
        "type": "number",
        "array": "nullable",
        "default": [10, 50]
      }, {
        "name": "rotate",
        "type": "number",
        "expr": true,
        "default": 0
      }, {
        "name": "text",
        "type": "field"
      }, {
        "name": "spiral",
        "type": "string",
        "values": ["archimedean", "rectangular"]
      }, {
        "name": "padding",
        "type": "number",
        "expr": true
      }, {
        "name": "as",
        "type": "string",
        "array": true,
        "length": 7,
        "default": Output4
      }]
    };
    inherits2(Wordcloud, Transform, {
      transform(_, pulse2) {
        if (_.size && !(_.size[0] && _.size[1])) {
          error2("Wordcloud size dimensions must be non-zero.");
        }
        function modp(param2) {
          const p = _[param2];
          return isFunction2(p) && pulse2.modified(p.fields);
        }
        const mod = _.modified();
        if (!(mod || pulse2.changed(pulse2.ADD_REM) || Params2.some(modp)))
          return;
        const data3 = pulse2.materialize(pulse2.SOURCE).source, layout = this.value, as = _.as || Output4;
        let fontSize3 = _.fontSize || 14, range7;
        isFunction2(fontSize3) ? range7 = _.fontSizeRange : fontSize3 = constant2(fontSize3);
        if (range7) {
          const fsize = fontSize3, sizeScale = scale("sqrt")().domain(extent2(data3, fsize)).range(range7);
          fontSize3 = (x7) => sizeScale(fsize(x7));
        }
        data3.forEach((t) => {
          t[as[0]] = NaN;
          t[as[1]] = NaN;
          t[as[3]] = 0;
        });
        const words = layout.words(data3).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || "archimedean").rotate(_.rotate || 0).font(_.font || "sans-serif").fontStyle(_.fontStyle || "normal").fontWeight(_.fontWeight || "normal").fontSize(fontSize3).random(random2).layout();
        const size = layout.size(), dx = size[0] >> 1, dy = size[1] >> 1, n = words.length;
        for (let i = 0, w5, t; i < n; ++i) {
          w5 = words[i];
          t = w5.datum;
          t[as[0]] = w5.x + dx;
          t[as[1]] = w5.y + dy;
          t[as[2]] = w5.font;
          t[as[3]] = w5.size;
          t[as[4]] = w5.style;
          t[as[5]] = w5.weight;
          t[as[6]] = w5.rotate;
        }
        return pulse2.reflow(mod).modifies(as);
      }
    });
  }
});

// node_modules/.pnpm/vega-crossfilter@4.0.5/node_modules/vega-crossfilter/build/vega-crossfilter.module.js
var vega_crossfilter_module_exports = {};
__export(vega_crossfilter_module_exports, {
  crossfilter: () => CrossFilter,
  resolvefilter: () => ResolveFilter
});
function Bitmaps() {
  let width2 = 8, data3 = [], seen = array32(0), curr = array5(0, width2), prev = array5(0, width2);
  return {
    data: () => data3,
    seen: () => seen = lengthen(seen, data3.length),
    add(array9) {
      for (let i = 0, j = data3.length, n = array9.length, t; i < n; ++i) {
        t = array9[i];
        t._index = j++;
        data3.push(t);
      }
    },
    remove(num, map11) {
      const n = data3.length, copy6 = Array(n - num), reindex = data3;
      let t, i, j;
      for (i = 0; !map11[i] && i < n; ++i) {
        copy6[i] = data3[i];
        reindex[i] = i;
      }
      for (j = i; i < n; ++i) {
        t = data3[i];
        if (!map11[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev[j] = prev[i];
          copy6[j] = t;
          t._index = j++;
        } else {
          reindex[i] = -1;
        }
        curr[i] = 0;
      }
      data3 = copy6;
      return reindex;
    },
    size: () => data3.length,
    curr: () => curr,
    prev: () => prev,
    reset: (k4) => prev[k4] = curr[k4],
    all: () => width2 < 257 ? 255 : width2 < 65537 ? 65535 : 4294967295,
    set(k4, one7) {
      curr[k4] |= one7;
    },
    clear(k4, one7) {
      curr[k4] &= ~one7;
    },
    resize(n, m2) {
      const k4 = curr.length;
      if (n > k4 || m2 > width2) {
        width2 = Math.max(m2, width2);
        curr = array5(n, width2, curr);
        prev = array5(n, width2);
      }
    }
  };
}
function lengthen(array9, length4, copy6) {
  if (array9.length >= length4)
    return array9;
  copy6 = copy6 || new array9.constructor(length4);
  copy6.set(array9);
  return copy6;
}
function array5(n, m2, array9) {
  const copy6 = (m2 < 257 ? array8 : m2 < 65537 ? array16 : array32)(n);
  if (array9)
    copy6.set(array9);
  return copy6;
}
function Dimension(index8, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index8.bisect,
    index: index8.index,
    size: index8.size,
    onAdd(added, curr) {
      const dim = this, range7 = dim.bisect(dim.range, added.value), idx = added.index, lo = range7[0], hi = range7[1], n1 = idx.length;
      let i2;
      for (i2 = 0; i2 < lo; ++i2)
        curr[idx[i2]] |= bit;
      for (i2 = hi; i2 < n1; ++i2)
        curr[idx[i2]] |= bit;
      return dim;
    }
  };
}
function SortedIndex() {
  let index8 = array32(0), value4 = [], size = 0;
  function insert2(key3, data3, base3) {
    if (!data3.length)
      return [];
    const n0 = size, n1 = data3.length, addi = array32(n1);
    let addv = Array(n1), oldv, oldi, i;
    for (i = 0; i < n1; ++i) {
      addv[i] = key3(data3[i]);
      addi[i] = i;
    }
    addv = sort3(addv, addi);
    if (n0) {
      oldv = value4;
      oldi = index8;
      value4 = Array(n0 + n1);
      index8 = array32(n0 + n1);
      merge4(base3, oldv, oldi, n0, addv, addi, n1, value4, index8);
    } else {
      if (base3 > 0)
        for (i = 0; i < n1; ++i) {
          addi[i] += base3;
        }
      value4 = addv;
      index8 = addi;
    }
    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }
  function remove3(num, map11) {
    const n = size;
    let idx, i, j;
    for (i = 0; !map11[index8[i]] && i < n; ++i)
      ;
    for (j = i; i < n; ++i) {
      if (!map11[idx = index8[i]]) {
        index8[j] = idx;
        value4[j] = value4[i];
        ++j;
      }
    }
    size = n - num;
  }
  function reindex(map11) {
    for (let i = 0, n = size; i < n; ++i) {
      index8[i] = map11[index8[i]];
    }
  }
  function bisect2(range7, array9) {
    let n;
    if (array9) {
      n = array9.length;
    } else {
      array9 = value4;
      n = size;
    }
    return [bisectLeft2(array9, range7[0], 0, n), bisectRight2(array9, range7[1], 0, n)];
  }
  return {
    insert: insert2,
    remove: remove3,
    bisect: bisect2,
    reindex,
    index: () => index8,
    size: () => size
  };
}
function sort3(values5, index8) {
  values5.sort.call(index8, (a4, b3) => {
    const x7 = values5[a4], y7 = values5[b3];
    return x7 < y7 ? -1 : x7 > y7 ? 1 : 0;
  });
  return permute_default(values5, index8);
}
function merge4(base3, value0, index0, n0, value1, index1, n1, value4, index8) {
  let i0 = 0, i1 = 0, i;
  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value4[i] = value0[i0];
      index8[i] = index0[i0++];
    } else {
      value4[i] = value1[i1];
      index8[i] = index1[i1++] + base3;
    }
  }
  for (; i0 < n0; ++i0, ++i) {
    value4[i] = value0[i0];
    index8[i] = index0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    value4[i] = value1[i1];
    index8[i] = index1[i1] + base3;
  }
}
function CrossFilter(params2) {
  Transform.call(this, Bitmaps(), params2);
  this._indices = null;
  this._dims = null;
}
function ResolveFilter(params2) {
  Transform.call(this, null, params2);
}
var array8, array16, array32;
var init_vega_crossfilter_module = __esm({
  "node_modules/.pnpm/vega-crossfilter@4.0.5/node_modules/vega-crossfilter/build/vega-crossfilter.module.js"() {
    init_src9();
    init_vega_dataflow_module();
    init_vega_util_module();
    array8 = (n) => new Uint8Array(n);
    array16 = (n) => new Uint16Array(n);
    array32 = (n) => new Uint32Array(n);
    CrossFilter.Definition = {
      "type": "CrossFilter",
      "metadata": {},
      "params": [{
        "name": "fields",
        "type": "field",
        "array": true,
        "required": true
      }, {
        "name": "query",
        "type": "array",
        "array": true,
        "required": true,
        "content": {
          "type": "number",
          "array": true,
          "length": 2
        }
      }]
    };
    inherits(CrossFilter, Transform, {
      transform(_, pulse2) {
        if (!this._dims) {
          return this.init(_, pulse2);
        } else {
          var init2 = _.modified("fields") || _.fields.some((f) => pulse2.modified(f.fields));
          return init2 ? this.reinit(_, pulse2) : this.eval(_, pulse2);
        }
      },
      init(_, pulse2) {
        const fields = _.fields, query = _.query, indices = this._indices = {}, dims = this._dims = [], m2 = query.length;
        let i = 0, key3, index8;
        for (; i < m2; ++i) {
          key3 = fields[i].fname;
          index8 = indices[key3] || (indices[key3] = SortedIndex());
          dims.push(Dimension(index8, i, query[i]));
        }
        return this.eval(_, pulse2);
      },
      reinit(_, pulse2) {
        const output3 = pulse2.materialize().fork(), fields = _.fields, query = _.query, indices = this._indices, dims = this._dims, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), out = output3.rem = output3.add, mod = output3.mod, m2 = query.length, adds = {};
        let add7, index8, key3, mods, remMap, modMap, i, n, f;
        prev.set(curr);
        if (pulse2.rem.length) {
          remMap = this.remove(_, pulse2, output3);
        }
        if (pulse2.add.length) {
          bits.add(pulse2.add);
        }
        if (pulse2.mod.length) {
          modMap = {};
          for (mods = pulse2.mod, i = 0, n = mods.length; i < n; ++i) {
            modMap[mods[i]._index] = 1;
          }
        }
        for (i = 0; i < m2; ++i) {
          f = fields[i];
          if (!dims[i] || _.modified("fields", i) || pulse2.modified(f.fields)) {
            key3 = f.fname;
            if (!(add7 = adds[key3])) {
              indices[key3] = index8 = SortedIndex();
              adds[key3] = add7 = index8.insert(f, pulse2.source, 0);
            }
            dims[i] = Dimension(index8, i, query[i]).onAdd(add7, curr);
          }
        }
        for (i = 0, n = bits.data().length; i < n; ++i) {
          if (remMap[i]) {
            continue;
          } else if (prev[i] !== curr[i]) {
            out.push(i);
          } else if (modMap[i] && curr[i] !== all) {
            mod.push(i);
          }
        }
        bits.mask = (1 << m2) - 1;
        return output3;
      },
      eval(_, pulse2) {
        const output3 = pulse2.materialize().fork(), m2 = this._dims.length;
        let mask = 0;
        if (pulse2.rem.length) {
          this.remove(_, pulse2, output3);
          mask |= (1 << m2) - 1;
        }
        if (_.modified("query") && !_.modified("fields")) {
          mask |= this.update(_, pulse2, output3);
        }
        if (pulse2.add.length) {
          this.insert(_, pulse2, output3);
          mask |= (1 << m2) - 1;
        }
        if (pulse2.mod.length) {
          this.modify(pulse2, output3);
          mask |= (1 << m2) - 1;
        }
        this.value.mask = mask;
        return output3;
      },
      insert(_, pulse2, output3) {
        const tuples = pulse2.add, bits = this.value, dims = this._dims, indices = this._indices, fields = _.fields, adds = {}, out = output3.add, n = bits.size() + tuples.length, m2 = dims.length;
        let k4 = bits.size(), j, key3, add7;
        bits.resize(n, m2);
        bits.add(tuples);
        const curr = bits.curr(), prev = bits.prev(), all = bits.all();
        for (j = 0; j < m2; ++j) {
          key3 = fields[j].fname;
          add7 = adds[key3] || (adds[key3] = indices[key3].insert(fields[j], tuples, k4));
          dims[j].onAdd(add7, curr);
        }
        for (; k4 < n; ++k4) {
          prev[k4] = all;
          if (curr[k4] !== all)
            out.push(k4);
        }
      },
      modify(pulse2, output3) {
        const out = output3.mod, bits = this.value, curr = bits.curr(), all = bits.all(), tuples = pulse2.mod;
        let i, n, k4;
        for (i = 0, n = tuples.length; i < n; ++i) {
          k4 = tuples[i]._index;
          if (curr[k4] !== all)
            out.push(k4);
        }
      },
      remove(_, pulse2, output3) {
        const indices = this._indices, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), map11 = {}, out = output3.rem, tuples = pulse2.rem;
        let i, n, k4, f;
        for (i = 0, n = tuples.length; i < n; ++i) {
          k4 = tuples[i]._index;
          map11[k4] = 1;
          prev[k4] = f = curr[k4];
          curr[k4] = all;
          if (f !== all)
            out.push(k4);
        }
        for (k4 in indices) {
          indices[k4].remove(n, map11);
        }
        this.reindex(pulse2, n, map11);
        return map11;
      },
      reindex(pulse2, num, map11) {
        const indices = this._indices, bits = this.value;
        pulse2.runAfter(() => {
          const indexMap = bits.remove(num, map11);
          for (const key3 in indices)
            indices[key3].reindex(indexMap);
        });
      },
      update(_, pulse2, output3) {
        const dims = this._dims, query = _.query, stamp = pulse2.stamp, m2 = dims.length;
        let mask = 0, i, q;
        output3.filters = 0;
        for (q = 0; q < m2; ++q) {
          if (_.modified("query", q)) {
            i = q;
            ++mask;
          }
        }
        if (mask === 1) {
          mask = dims[i].one;
          this.incrementOne(dims[i], query[i], output3.add, output3.rem);
        } else {
          for (q = 0, mask = 0; q < m2; ++q) {
            if (!_.modified("query", q))
              continue;
            mask |= dims[q].one;
            this.incrementAll(dims[q], query[q], stamp, output3.add);
            output3.rem = output3.add;
          }
        }
        return mask;
      },
      incrementAll(dim, query, stamp, out) {
        const bits = this.value, seen = bits.seen(), curr = bits.curr(), prev = bits.prev(), index8 = dim.index(), old = dim.bisect(dim.range), range7 = dim.bisect(query), lo1 = range7[0], hi1 = range7[1], lo0 = old[0], hi0 = old[1], one7 = dim.one;
        let i, j, k4;
        if (lo1 < lo0) {
          for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
            k4 = index8[i];
            if (seen[k4] !== stamp) {
              prev[k4] = curr[k4];
              seen[k4] = stamp;
              out.push(k4);
            }
            curr[k4] ^= one7;
          }
        } else if (lo1 > lo0) {
          for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
            k4 = index8[i];
            if (seen[k4] !== stamp) {
              prev[k4] = curr[k4];
              seen[k4] = stamp;
              out.push(k4);
            }
            curr[k4] ^= one7;
          }
        }
        if (hi1 > hi0) {
          for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
            k4 = index8[i];
            if (seen[k4] !== stamp) {
              prev[k4] = curr[k4];
              seen[k4] = stamp;
              out.push(k4);
            }
            curr[k4] ^= one7;
          }
        } else if (hi1 < hi0) {
          for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
            k4 = index8[i];
            if (seen[k4] !== stamp) {
              prev[k4] = curr[k4];
              seen[k4] = stamp;
              out.push(k4);
            }
            curr[k4] ^= one7;
          }
        }
        dim.range = query.slice();
      },
      incrementOne(dim, query, add7, rem2) {
        const bits = this.value, curr = bits.curr(), index8 = dim.index(), old = dim.bisect(dim.range), range7 = dim.bisect(query), lo1 = range7[0], hi1 = range7[1], lo0 = old[0], hi0 = old[1], one7 = dim.one;
        let i, j, k4;
        if (lo1 < lo0) {
          for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
            k4 = index8[i];
            curr[k4] ^= one7;
            add7.push(k4);
          }
        } else if (lo1 > lo0) {
          for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
            k4 = index8[i];
            curr[k4] ^= one7;
            rem2.push(k4);
          }
        }
        if (hi1 > hi0) {
          for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
            k4 = index8[i];
            curr[k4] ^= one7;
            add7.push(k4);
          }
        } else if (hi1 < hi0) {
          for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
            k4 = index8[i];
            curr[k4] ^= one7;
            rem2.push(k4);
          }
        }
        dim.range = query.slice();
      }
    });
    ResolveFilter.Definition = {
      "type": "ResolveFilter",
      "metadata": {},
      "params": [{
        "name": "ignore",
        "type": "number",
        "required": true,
        "description": "A bit mask indicating which filters to ignore."
      }, {
        "name": "filter",
        "type": "object",
        "required": true,
        "description": "Per-tuple filter bitmaps from a CrossFilter transform."
      }]
    };
    inherits(ResolveFilter, Transform, {
      transform(_, pulse2) {
        const ignore = ~(_.ignore || 0), bitmap = _.filter, mask = bitmap.mask;
        if ((mask & ignore) === 0)
          return pulse2.StopPropagation;
        const output3 = pulse2.fork(pulse2.ALL), data3 = bitmap.data(), curr = bitmap.curr(), prev = bitmap.prev(), pass = (k4) => !(curr[k4] & ignore) ? data3[k4] : null;
        output3.filter(output3.MOD, pass);
        if (!(mask & mask - 1)) {
          output3.filter(output3.ADD, pass);
          output3.filter(output3.REM, (k4) => (curr[k4] & ignore) === mask ? data3[k4] : null);
        } else {
          output3.filter(output3.ADD, (k4) => {
            const c2 = curr[k4] & ignore, f = !c2 && c2 ^ prev[k4] & ignore;
            return f ? data3[k4] : null;
          });
          output3.filter(output3.REM, (k4) => {
            const c2 = curr[k4] & ignore, f = c2 && !(c2 ^ (c2 ^ prev[k4] & ignore));
            return f ? data3[k4] : null;
          });
        }
        return output3.filter(output3.SOURCE, (t) => pass(t._index));
      }
    });
  }
});

// node_modules/.pnpm/vega-expression@5.1.0/node_modules/vega-expression/build/vega-expression.module.js
function ASTNode(type4) {
  this.type = type4;
}
function children2(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;
    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];
    case CallExpression:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression:
      return [node.object, node.property];
    case ObjectExpression:
      return node.properties;
    case Property:
      return [node.key, node.value];
    case UnaryExpression:
      return [node.argument];
    case Identifier2:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}
function assert(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit(ch2) {
  return "0123456789abcdefABCDEF".indexOf(ch2) >= 0;
}
function isOctalDigit(ch2) {
  return "01234567".indexOf(ch2) >= 0;
}
function isWhiteSpace(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch2) >= 0;
}
function isLineTerminator(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch2));
}
function isIdentifierPart(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 >= 48 && ch2 <= 57 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch2));
}
function skipComment() {
  while (index4 < length) {
    const ch2 = source2.charCodeAt(index4);
    if (isWhiteSpace(ch2) || isLineTerminator(ch2)) {
      ++index4;
    } else {
      break;
    }
  }
}
function scanHexEscape(prefix) {
  var i, len, ch2, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index4 < length && isHexDigit(source2[index4])) {
      ch2 = source2[index4++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape() {
  var ch2, code, cu1, cu2;
  ch2 = source2[index4];
  code = 0;
  if (ch2 === "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  while (index4 < length) {
    ch2 = source2[index4++];
    if (!isHexDigit(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier() {
  var ch2, id4;
  ch2 = source2.charCodeAt(index4++);
  id4 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source2.charCodeAt(index4) !== 117) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    ++index4;
    ch2 = scanHexEscape("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart(ch2.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    id4 = ch2;
  }
  while (index4 < length) {
    ch2 = source2.charCodeAt(index4);
    if (!isIdentifierPart(ch2)) {
      break;
    }
    ++index4;
    id4 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id4 = id4.substr(0, id4.length - 1);
      if (source2.charCodeAt(index4) !== 117) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      ++index4;
      ch2 = scanHexEscape("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      id4 += ch2;
    }
  }
  return id4;
}
function getIdentifier() {
  var start, ch2;
  start = index4++;
  while (index4 < length) {
    ch2 = source2.charCodeAt(index4);
    if (ch2 === 92) {
      index4 = start;
      return getEscapedIdentifier();
    }
    if (isIdentifierPart(ch2)) {
      ++index4;
    } else {
      break;
    }
  }
  return source2.slice(start, index4);
}
function scanIdentifier() {
  var start, id4, type4;
  start = index4;
  id4 = source2.charCodeAt(index4) === 92 ? getEscapedIdentifier() : getIdentifier();
  if (id4.length === 1) {
    type4 = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id4)) {
    type4 = TokenKeyword;
  } else if (id4 === "null") {
    type4 = TokenNullLiteral;
  } else if (id4 === "true" || id4 === "false") {
    type4 = TokenBooleanLiteral;
  } else {
    type4 = TokenIdentifier;
  }
  return {
    type: type4,
    value: id4,
    start,
    end: index4
  };
}
function scanPunctuator() {
  var start = index4, code = source2.charCodeAt(index4), code2, ch1 = source2[index4], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index4;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start,
        end: index4
      };
    default:
      code2 = source2.charCodeAt(index4 + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index4 += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index4
            };
          case 33:
          case 61:
            index4 += 2;
            if (source2.charCodeAt(index4) === 61) {
              ++index4;
            }
            return {
              type: TokenPunctuator,
              value: source2.slice(start, index4),
              start,
              end: index4
            };
        }
      }
  }
  ch4 = source2.substr(index4, 4);
  if (ch4 === ">>>=") {
    index4 += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start,
      end: index4
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index4 += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start,
      end: index4
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index4 += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start,
      end: index4
    };
  }
  if (ch2 === "//") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index4;
    return {
      type: TokenPunctuator,
      value: ch1,
      start,
      end: index4
    };
  }
  throwError({}, MessageUnexpectedToken, ILLEGAL);
}
function scanHexLiteral(start) {
  let number12 = "";
  while (index4 < length) {
    if (!isHexDigit(source2[index4])) {
      break;
    }
    number12 += source2[index4++];
  }
  if (number12.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (isIdentifierStart(source2.charCodeAt(index4))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt("0x" + number12, 16),
    start,
    end: index4
  };
}
function scanOctalLiteral(start) {
  let number12 = "0" + source2[index4++];
  while (index4 < length) {
    if (!isOctalDigit(source2[index4])) {
      break;
    }
    number12 += source2[index4++];
  }
  if (isIdentifierStart(source2.charCodeAt(index4)) || isDecimalDigit(source2.charCodeAt(index4))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt(number12, 8),
    octal: true,
    start,
    end: index4
  };
}
function scanNumericLiteral() {
  var number12, start, ch2;
  ch2 = source2[index4];
  assert(isDecimalDigit(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index4;
  number12 = "";
  if (ch2 !== ".") {
    number12 = source2[index4++];
    ch2 = source2[index4];
    if (number12 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index4;
        return scanHexLiteral(start);
      }
      if (isOctalDigit(ch2)) {
        return scanOctalLiteral(start);
      }
      if (ch2 && isDecimalDigit(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }
    while (isDecimalDigit(source2.charCodeAt(index4))) {
      number12 += source2[index4++];
    }
    ch2 = source2[index4];
  }
  if (ch2 === ".") {
    number12 += source2[index4++];
    while (isDecimalDigit(source2.charCodeAt(index4))) {
      number12 += source2[index4++];
    }
    ch2 = source2[index4];
  }
  if (ch2 === "e" || ch2 === "E") {
    number12 += source2[index4++];
    ch2 = source2[index4];
    if (ch2 === "+" || ch2 === "-") {
      number12 += source2[index4++];
    }
    if (isDecimalDigit(source2.charCodeAt(index4))) {
      while (isDecimalDigit(source2.charCodeAt(index4))) {
        number12 += source2[index4++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  if (isIdentifierStart(source2.charCodeAt(index4))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseFloat(number12),
    start,
    end: index4
  };
}
function scanStringLiteral() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source2[index4];
  assert(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index4;
  ++index4;
  while (index4 < length) {
    ch2 = source2[index4++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source2[index4++];
      if (!ch2 || !isLineTerminator(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source2[index4] === "{") {
              ++index4;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index4 < length && isOctalDigit(source2[index4])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source2[index4++]);
                if ("0123".indexOf(ch2) >= 0 && index4 < length && isOctalDigit(source2[index4])) {
                  code = code * 8 + "01234567".indexOf(source2[index4++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source2[index4] === "\n") {
          ++index4;
        }
      }
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenStringLiteral,
    value: str,
    octal,
    start,
    end: index4
  };
}
function testRegExp(pattern, flags) {
  let tmp = pattern;
  if (flags.indexOf("u") >= 0) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e3) {
    throwError({}, MessageInvalidRegExp);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source2[index4];
  assert(ch2 === "/", "Regular expression literal must start with a slash");
  str = source2[index4++];
  classMarker = false;
  terminated = false;
  while (index4 < length) {
    ch2 = source2[index4++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source2[index4++];
      if (isLineTerminator(ch2.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }
      str += ch2;
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index4 < length) {
    ch2 = source2[index4];
    if (!isIdentifierPart(ch2.charCodeAt(0))) {
      break;
    }
    ++index4;
    if (ch2 === "\\" && index4 < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp() {
  var start, body, flags, value4;
  lookahead = null;
  skipComment();
  start = index4;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value4 = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value4,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index4
  };
}
function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}
function advance() {
  skipComment();
  if (index4 >= length) {
    return {
      type: TokenEOF,
      start: index4,
      end: index4
    };
  }
  const ch2 = source2.charCodeAt(index4);
  if (isIdentifierStart(ch2)) {
    return scanIdentifier();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral();
  }
  if (ch2 === 46) {
    if (isDecimalDigit(source2.charCodeAt(index4 + 1))) {
      return scanNumericLiteral();
    }
    return scanPunctuator();
  }
  if (isDecimalDigit(ch2)) {
    return scanNumericLiteral();
  }
  return scanPunctuator();
}
function lex() {
  const token = lookahead;
  index4 = token.end;
  lookahead = advance();
  index4 = token.end;
  return token;
}
function peek3() {
  const pos = index4;
  lookahead = advance();
  index4 = pos;
}
function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}
function finishBinaryExpression(operator2, left, right) {
  const node = new ASTNode(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator2;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression(test2, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test2;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier(name4) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name4;
  return node;
}
function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source2.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression(accessor3, object2, property2) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor3 === "[";
  node.object = object2;
  node.property = property2;
  if (!node.computed)
    property2.member = true;
  return node;
}
function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}
function finishProperty(kind, key3, value4) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key3;
  node.value = value4;
  node.kind = kind;
  return node;
}
function finishUnaryExpression(operator2, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator2;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError(token, messageFormat) {
  var error3, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index8) => {
    assert(index8 < args.length, "Message reference must be in range");
    return args[index8];
  });
  error3 = new Error(msg);
  error3.index = index4;
  error3.description = msg;
  throw error3;
}
function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }
  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }
  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }
  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }
  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  }
  throwError(token, MessageUnexpectedToken, token.value);
}
function expect(value4) {
  const token = lex();
  if (token.type !== TokenPunctuator || token.value !== value4) {
    throwUnexpected(token);
  }
}
function match(value4) {
  return lookahead.type === TokenPunctuator && lookahead.value === value4;
}
function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
}
function parseArrayInitialiser() {
  const elements = [];
  index4 = lookahead.start;
  expect("[");
  while (!match("]")) {
    if (match(",")) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());
      if (!match("]")) {
        expect(",");
      }
    }
  }
  lex();
  return finishArrayExpression(elements);
}
function parseObjectPropertyKey() {
  index4 = lookahead.start;
  const token = lex();
  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }
    return finishLiteral(token);
  }
  return finishIdentifier(token.value);
}
function parseObjectProperty() {
  var token, key3, id4, value4;
  index4 = lookahead.start;
  token = lookahead;
  if (token.type === TokenIdentifier) {
    id4 = parseObjectPropertyKey();
    expect(":");
    value4 = parseConditionalExpression();
    return finishProperty("init", id4, value4);
  }
  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key3 = parseObjectPropertyKey();
    expect(":");
    value4 = parseConditionalExpression();
    return finishProperty("init", key3, value4);
  }
}
function parseObjectInitialiser() {
  var properties = [], property2, name4, key3, map11 = {}, toString3 = String;
  index4 = lookahead.start;
  expect("{");
  while (!match("}")) {
    property2 = parseObjectProperty();
    if (property2.key.type === SyntaxIdentifier) {
      name4 = property2.key.name;
    } else {
      name4 = toString3(property2.key.value);
    }
    key3 = "$" + name4;
    if (Object.prototype.hasOwnProperty.call(map11, key3)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map11[key3] = true;
    }
    properties.push(property2);
    if (!match("}")) {
      expect(",");
    }
  }
  expect("}");
  return finishObjectExpression(properties);
}
function parseGroupExpression() {
  expect("(");
  const expr2 = parseExpression();
  expect(")");
  return expr2;
}
function parsePrimaryExpression() {
  var type4, token, expr2;
  if (match("(")) {
    return parseGroupExpression();
  }
  if (match("[")) {
    return parseArrayInitialiser();
  }
  if (match("{")) {
    return parseObjectInitialiser();
  }
  type4 = lookahead.type;
  index4 = lookahead.start;
  if (type4 === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr2 = finishIdentifier(lex().value);
  } else if (type4 === TokenStringLiteral || type4 === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }
    expr2 = finishLiteral(lex());
  } else if (type4 === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type4 === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === "true";
    expr2 = finishLiteral(token);
  } else if (type4 === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr2 = finishLiteral(token);
  } else if (match("/") || match("/=")) {
    expr2 = finishLiteral(scanRegExp());
    peek3();
  } else {
    throwUnexpected(lex());
  }
  return expr2;
}
function parseArguments() {
  const args = [];
  expect("(");
  if (!match(")")) {
    while (index4 < length) {
      args.push(parseConditionalExpression());
      if (match(")")) {
        break;
      }
      expect(",");
    }
  }
  expect(")");
  return args;
}
function parseNonComputedProperty() {
  index4 = lookahead.start;
  const token = lex();
  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }
  return finishIdentifier(token.value);
}
function parseNonComputedMember() {
  expect(".");
  return parseNonComputedProperty();
}
function parseComputedMember() {
  expect("[");
  const expr2 = parseExpression();
  expect("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression();
  for (; ; ) {
    if (match(".")) {
      property2 = parseNonComputedMember();
      expr2 = finishMemberExpression(".", expr2, property2);
    } else if (match("(")) {
      args = parseArguments();
      expr2 = finishCallExpression(expr2, args);
    } else if (match("[")) {
      property2 = parseComputedMember();
      expr2 = finishMemberExpression("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression() {
  const expr2 = parseLeftHandSideExpressionAllowCall();
  if (lookahead.type === TokenPunctuator) {
    if (match("++") || match("--")) {
      throw new Error(DISABLED);
    }
  }
  return expr2;
}
function parseUnaryExpression() {
  var token, expr2;
  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr2 = parsePostfixExpression();
  } else if (match("++") || match("--")) {
    throw new Error(DISABLED);
  } else if (match("+") || match("-") || match("~") || match("!")) {
    token = lex();
    expr2 = parseUnaryExpression();
    expr2 = finishUnaryExpression(token.value, expr2);
  } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
    throw new Error(DISABLED);
  } else {
    expr2 = parsePostfixExpression();
  }
  return expr2;
}
function binaryPrecedence(token) {
  let prec = 0;
  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
  }
  return prec;
}
function parseBinaryExpression() {
  var marker, markers, expr2, token, prec, stack3, right, operator2, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack3 = [left, token, right];
  while ((prec = binaryPrecedence(lookahead)) > 0) {
    while (stack3.length > 2 && prec <= stack3[stack3.length - 2].prec) {
      right = stack3.pop();
      operator2 = stack3.pop().value;
      left = stack3.pop();
      markers.pop();
      expr2 = finishBinaryExpression(operator2, left, right);
      stack3.push(expr2);
    }
    token = lex();
    token.prec = prec;
    stack3.push(token);
    markers.push(lookahead);
    expr2 = parseUnaryExpression();
    stack3.push(expr2);
  }
  i = stack3.length - 1;
  expr2 = stack3[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression(stack3[i - 1].value, stack3[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression();
  if (match("?")) {
    lex();
    consequent = parseConditionalExpression();
    expect(":");
    alternate = parseConditionalExpression();
    expr2 = finishConditionalExpression(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression() {
  const expr2 = parseConditionalExpression();
  if (match(",")) {
    throw new Error(DISABLED);
  }
  return expr2;
}
function parser(code) {
  source2 = code;
  index4 = 0;
  length = source2.length;
  lookahead = null;
  peek3();
  const expr2 = parseExpression();
  if (lookahead.type !== TokenEOF) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}
function Functions(codegen3) {
  function fncall(name4, args, cast, type4) {
    let obj = codegen3(args[0]);
    if (cast) {
      obj = cast + "(" + obj + ")";
      if (cast.lastIndexOf("new ", 0) === 0)
        obj = "(" + obj + ")";
    }
    return obj + "." + name4 + (type4 < 0 ? "" : type4 === 0 ? "()" : "(" + args.slice(1).map(codegen3).join(",") + ")");
  }
  function fn(name4, cast, type4) {
    return (args) => fncall(name4, args, cast, type4);
  }
  const DATE3 = "new Date", STRING = "String", REGEXP = "RegExp";
  return {
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    hypot: "Math.hypot",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(args) {
      if (args.length < 3)
        error2("Missing arguments to clamp function.");
      if (args.length > 3)
        error2("Too many arguments to clamp function.");
      const a4 = args.map(codegen3);
      return "Math.max(" + a4[1] + ", Math.min(" + a4[2] + "," + a4[0] + "))";
    },
    now: "Date.now",
    utc: "Date.UTC",
    datetime: DATE3,
    date: fn("getDate", DATE3, 0),
    day: fn("getDay", DATE3, 0),
    year: fn("getFullYear", DATE3, 0),
    month: fn("getMonth", DATE3, 0),
    hours: fn("getHours", DATE3, 0),
    minutes: fn("getMinutes", DATE3, 0),
    seconds: fn("getSeconds", DATE3, 0),
    milliseconds: fn("getMilliseconds", DATE3, 0),
    time: fn("getTime", DATE3, 0),
    timezoneoffset: fn("getTimezoneOffset", DATE3, 0),
    utcdate: fn("getUTCDate", DATE3, 0),
    utcday: fn("getUTCDay", DATE3, 0),
    utcyear: fn("getUTCFullYear", DATE3, 0),
    utcmonth: fn("getUTCMonth", DATE3, 0),
    utchours: fn("getUTCHours", DATE3, 0),
    utcminutes: fn("getUTCMinutes", DATE3, 0),
    utcseconds: fn("getUTCSeconds", DATE3, 0),
    utcmilliseconds: fn("getUTCMilliseconds", DATE3, 0),
    length: fn("length", null, -1),
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: fn("toUpperCase", STRING, 0),
    lower: fn("toLowerCase", STRING, 0),
    substring: fn("substring", STRING),
    split: fn("split", STRING),
    trim: fn("trim", STRING, 0),
    regexp: REGEXP,
    test: fn("test", REGEXP),
    if: function(args) {
      if (args.length < 3)
        error2("Missing arguments to if function.");
      if (args.length > 3)
        error2("Too many arguments to if function.");
      const a4 = args.map(codegen3);
      return "(" + a4[0] + "?" + a4[1] + ":" + a4[2] + ")";
    }
  };
}
function stripQuotes(s3) {
  const n = s3 && s3.length - 1;
  return n && (s3[0] === '"' && s3[n] === '"' || s3[0] === "'" && s3[n] === "'") ? s3.slice(1, -1) : s3;
}
function codegen(opt) {
  opt = opt || {};
  const allowed = opt.allowed ? toSet2(opt.allowed) : {}, forbidden = opt.forbidden ? toSet2(opt.forbidden) : {}, constants3 = opt.constants || Constants, functions = (opt.functions || Functions)(visit3), globalvar = opt.globalvar, fieldvar = opt.fieldvar, outputGlobal = isFunction2(globalvar) ? globalvar : (id4) => `${globalvar}["${id4}"]`;
  let globals = {}, fields = {}, memberDepth = 0;
  function visit3(ast) {
    if (isString2(ast))
      return ast;
    const generator = Generators[ast.type];
    if (generator == null)
      error2("Unsupported type: " + ast.type);
    return generator(ast);
  }
  const Generators = {
    Literal: (n) => n.raw,
    Identifier: (n) => {
      const id4 = n.name;
      if (memberDepth > 0) {
        return id4;
      } else if (has2(forbidden, id4)) {
        return error2("Illegal identifier: " + id4);
      } else if (has2(constants3, id4)) {
        return constants3[id4];
      } else if (has2(allowed, id4)) {
        return id4;
      } else {
        globals[id4] = 1;
        return outputGlobal(id4);
      }
    },
    MemberExpression: (n) => {
      const d = !n.computed, o = visit3(n.object);
      if (d)
        memberDepth += 1;
      const p = visit3(n.property);
      if (o === fieldvar) {
        fields[stripQuotes(p)] = 1;
      }
      if (d)
        memberDepth -= 1;
      return o + (d ? "." + p : "[" + p + "]");
    },
    CallExpression: (n) => {
      if (n.callee.type !== "Identifier") {
        error2("Illegal callee type: " + n.callee.type);
      }
      const callee = n.callee.name, args = n.arguments, fn = has2(functions, callee) && functions[callee];
      if (!fn)
        error2("Unrecognized function: " + callee);
      return isFunction2(fn) ? fn(args) : fn + "(" + args.map(visit3).join(",") + ")";
    },
    ArrayExpression: (n) => "[" + n.elements.map(visit3).join(",") + "]",
    BinaryExpression: (n) => "(" + visit3(n.left) + " " + n.operator + " " + visit3(n.right) + ")",
    UnaryExpression: (n) => "(" + n.operator + visit3(n.argument) + ")",
    ConditionalExpression: (n) => "(" + visit3(n.test) + "?" + visit3(n.consequent) + ":" + visit3(n.alternate) + ")",
    LogicalExpression: (n) => "(" + visit3(n.left) + n.operator + visit3(n.right) + ")",
    ObjectExpression: (n) => "{" + n.properties.map(visit3).join(",") + "}",
    Property: (n) => {
      memberDepth += 1;
      const k4 = visit3(n.key);
      memberDepth -= 1;
      return k4 + ":" + visit3(n.value);
    }
  };
  function codegen3(ast) {
    const result = {
      code: visit3(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }
  codegen3.functions = functions;
  codegen3.constants = constants3;
  return codegen3;
}
var RawCode, Literal, Property, Identifier2, ArrayExpression, BinaryExpression, CallExpression, ConditionalExpression, LogicalExpression, MemberExpression, ObjectExpression, UnaryExpression, TokenName, source2, index4, length, lookahead, TokenBooleanLiteral, TokenEOF, TokenIdentifier, TokenKeyword, TokenNullLiteral, TokenNumericLiteral, TokenPunctuator, TokenStringLiteral, TokenRegularExpression, SyntaxArrayExpression, SyntaxBinaryExpression, SyntaxCallExpression, SyntaxConditionalExpression, SyntaxIdentifier, SyntaxLiteral, SyntaxLogicalExpression, SyntaxMemberExpression, SyntaxObjectExpression, SyntaxProperty, SyntaxUnaryExpression, MessageUnexpectedToken, MessageUnexpectedNumber, MessageUnexpectedString, MessageUnexpectedIdentifier, MessageUnexpectedReserved, MessageUnexpectedEOS, MessageInvalidRegExp, MessageUnterminatedRegExp, MessageStrictOctalLiteral, MessageStrictDuplicateProperty, ILLEGAL, DISABLED, RegexNonAsciiIdentifierStart, RegexNonAsciiIdentifierPart, keywords, legalKeywords, Constants;
var init_vega_expression_module = __esm({
  "node_modules/.pnpm/vega-expression@5.1.0/node_modules/vega-expression/build/vega-expression.module.js"() {
    init_vega_util_module2();
    RawCode = "RawCode";
    Literal = "Literal";
    Property = "Property";
    Identifier2 = "Identifier";
    ArrayExpression = "ArrayExpression";
    BinaryExpression = "BinaryExpression";
    CallExpression = "CallExpression";
    ConditionalExpression = "ConditionalExpression";
    LogicalExpression = "LogicalExpression";
    MemberExpression = "MemberExpression";
    ObjectExpression = "ObjectExpression";
    UnaryExpression = "UnaryExpression";
    ASTNode.prototype.visit = function(visitor) {
      let c2, i, n;
      if (visitor(this))
        return 1;
      for (c2 = children2(this), i = 0, n = c2.length; i < n; ++i) {
        if (c2[i].visit(visitor))
          return 1;
      }
    };
    TokenBooleanLiteral = 1;
    TokenEOF = 2;
    TokenIdentifier = 3;
    TokenKeyword = 4;
    TokenNullLiteral = 5;
    TokenNumericLiteral = 6;
    TokenPunctuator = 7;
    TokenStringLiteral = 8;
    TokenRegularExpression = 9;
    TokenName = {};
    TokenName[TokenBooleanLiteral] = "Boolean";
    TokenName[TokenEOF] = "<end>";
    TokenName[TokenIdentifier] = "Identifier";
    TokenName[TokenKeyword] = "Keyword";
    TokenName[TokenNullLiteral] = "Null";
    TokenName[TokenNumericLiteral] = "Numeric";
    TokenName[TokenPunctuator] = "Punctuator";
    TokenName[TokenStringLiteral] = "String";
    TokenName[TokenRegularExpression] = "RegularExpression";
    SyntaxArrayExpression = "ArrayExpression";
    SyntaxBinaryExpression = "BinaryExpression";
    SyntaxCallExpression = "CallExpression";
    SyntaxConditionalExpression = "ConditionalExpression";
    SyntaxIdentifier = "Identifier";
    SyntaxLiteral = "Literal";
    SyntaxLogicalExpression = "LogicalExpression";
    SyntaxMemberExpression = "MemberExpression";
    SyntaxObjectExpression = "ObjectExpression";
    SyntaxProperty = "Property";
    SyntaxUnaryExpression = "UnaryExpression";
    MessageUnexpectedToken = "Unexpected token %0";
    MessageUnexpectedNumber = "Unexpected number";
    MessageUnexpectedString = "Unexpected string";
    MessageUnexpectedIdentifier = "Unexpected identifier";
    MessageUnexpectedReserved = "Unexpected reserved word";
    MessageUnexpectedEOS = "Unexpected end of input";
    MessageInvalidRegExp = "Invalid regular expression";
    MessageUnterminatedRegExp = "Invalid regular expression: missing /";
    MessageStrictOctalLiteral = "Octal literals are not allowed in strict mode.";
    MessageStrictDuplicateProperty = "Duplicate data property in object literal not allowed in strict mode";
    ILLEGAL = "ILLEGAL";
    DISABLED = "Disabled.";
    RegexNonAsciiIdentifierStart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
    RegexNonAsciiIdentifierPart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
    keywords = {
      "if": 1,
      "in": 1,
      "do": 1,
      "var": 1,
      "for": 1,
      "new": 1,
      "try": 1,
      "let": 1,
      "this": 1,
      "else": 1,
      "case": 1,
      "void": 1,
      "with": 1,
      "enum": 1,
      "while": 1,
      "break": 1,
      "catch": 1,
      "throw": 1,
      "const": 1,
      "yield": 1,
      "class": 1,
      "super": 1,
      "return": 1,
      "typeof": 1,
      "delete": 1,
      "switch": 1,
      "export": 1,
      "import": 1,
      "public": 1,
      "static": 1,
      "default": 1,
      "finally": 1,
      "extends": 1,
      "package": 1,
      "private": 1,
      "function": 1,
      "continue": 1,
      "debugger": 1,
      "interface": 1,
      "protected": 1,
      "instanceof": 1,
      "implements": 1
    };
    legalKeywords = {
      "if": 1
    };
    Constants = {
      NaN: "NaN",
      E: "Math.E",
      LN2: "Math.LN2",
      LN10: "Math.LN10",
      LOG2E: "Math.LOG2E",
      LOG10E: "Math.LOG10E",
      PI: "Math.PI",
      SQRT1_2: "Math.SQRT1_2",
      SQRT2: "Math.SQRT2",
      MIN_VALUE: "Number.MIN_VALUE",
      MAX_VALUE: "Number.MAX_VALUE"
    };
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/ascending.js
function ascending6(a4, b3) {
  return a4 == null || b3 == null ? NaN : a4 < b3 ? -1 : a4 > b3 ? 1 : a4 >= b3 ? 0 : NaN;
}
var init_ascending5 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/ascending.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/descending.js
function descending4(a4, b3) {
  return a4 == null || b3 == null ? NaN : b3 < a4 ? -1 : b3 > a4 ? 1 : b3 >= a4 ? 0 : NaN;
}
var init_descending7 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/descending.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/bisector.js
function bisector2(f) {
  let compare13, compare22, delta;
  if (f.length !== 2) {
    compare13 = ascending6;
    compare22 = (d, x7) => ascending6(f(d), x7);
    delta = (d, x7) => f(d) - x7;
  } else {
    compare13 = f === ascending6 || f === descending4 ? f : zero6;
    compare22 = f;
    delta = f;
  }
  function left(a4, x7, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare13(x7, x7) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare22(a4[mid], x7) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a4, x7, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare13(x7, x7) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare22(a4[mid], x7) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a4, x7, lo = 0, hi = a4.length) {
    const i = left(a4, x7, lo, hi - 1);
    return i > lo && delta(a4[i - 1], x7) > -delta(a4[i], x7) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero6() {
  return 0;
}
var init_bisector3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/bisector.js"() {
    init_ascending5();
    init_descending7();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/number.js
function number9(x7) {
  return x7 === null ? NaN : +x7;
}
var init_number7 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/number.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/bisect.js
var ascendingBisect3, bisectRight3, bisectLeft3, bisectCenter3;
var init_bisect4 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/bisect.js"() {
    init_ascending5();
    init_bisector3();
    init_number7();
    ascendingBisect3 = bisector2(ascending6);
    bisectRight3 = ascendingBisect3.right;
    bisectLeft3 = ascendingBisect3.left;
    bisectCenter3 = bisector2(number9).center;
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/blur.js
function Blur22(blur4) {
  return function(data3, rx, ry = rx) {
    if (!((rx = +rx) >= 0))
      throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0))
      throw new RangeError("invalid ry");
    let { data: values5, width: width2, height: height2 } = data3;
    if (!((width2 = Math.floor(width2)) >= 0))
      throw new RangeError("invalid width");
    if (!((height2 = Math.floor(height2 !== void 0 ? height2 : values5.length / width2)) >= 0))
      throw new RangeError("invalid height");
    if (!width2 || !height2 || !rx && !ry)
      return data3;
    const blurx = rx && blur4(rx);
    const blury = ry && blur4(ry);
    const temp3 = values5.slice();
    if (blurx && blury) {
      blurh2(blurx, temp3, values5, width2, height2);
      blurh2(blurx, values5, temp3, width2, height2);
      blurh2(blurx, temp3, values5, width2, height2);
      blurv2(blury, values5, temp3, width2, height2);
      blurv2(blury, temp3, values5, width2, height2);
      blurv2(blury, values5, temp3, width2, height2);
    } else if (blurx) {
      blurh2(blurx, values5, temp3, width2, height2);
      blurh2(blurx, temp3, values5, width2, height2);
      blurh2(blurx, values5, temp3, width2, height2);
    } else if (blury) {
      blurv2(blury, values5, temp3, width2, height2);
      blurv2(blury, temp3, values5, width2, height2);
      blurv2(blury, values5, temp3, width2, height2);
    }
    return data3;
  };
}
function blurh2(blur4, T, S, w5, h4) {
  for (let y7 = 0, n = w5 * h4; y7 < n; ) {
    blur4(T, S, y7, y7 += w5, 1);
  }
}
function blurv2(blur4, T, S, w5, h4) {
  for (let x7 = 0, n = w5 * h4; x7 < w5; ++x7) {
    blur4(T, S, x7, x7 + n, w5);
  }
}
function blurfImage2(radius2) {
  const blur4 = blurf2(radius2);
  return (T, S, start, stop2, step) => {
    start <<= 2, stop2 <<= 2, step <<= 2;
    blur4(T, S, start + 0, stop2 + 0, step);
    blur4(T, S, start + 1, stop2 + 1, step);
    blur4(T, S, start + 2, stop2 + 2, step);
    blur4(T, S, start + 3, stop2 + 3, step);
  };
}
function blurf2(radius2) {
  const radius0 = Math.floor(radius2);
  if (radius0 === radius2)
    return bluri2(radius2);
  const t = radius2 - radius0;
  const w5 = 2 * radius2 + 1;
  return (T, S, start, stop2, step) => {
    if (!((stop2 -= step) >= start))
      return;
    let sum6 = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum6 += S[Math.min(stop2, i)];
    }
    for (let i = start, j = stop2; i <= j; i += step) {
      sum6 += S[Math.min(stop2, i + s0)];
      T[i] = (sum6 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop2, i + s1)])) / w5;
      sum6 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri2(radius2) {
  const w5 = 2 * radius2 + 1;
  return (T, S, start, stop2, step) => {
    if (!((stop2 -= step) >= start))
      return;
    let sum6 = radius2 * S[start];
    const s3 = step * radius2;
    for (let i = start, j = start + s3; i < j; i += step) {
      sum6 += S[Math.min(stop2, i)];
    }
    for (let i = start, j = stop2; i <= j; i += step) {
      sum6 += S[Math.min(stop2, i + s3)];
      T[i] = sum6 / w5;
      sum6 -= S[Math.max(start, i - s3)];
    }
  };
}
var blur22, blurImage2;
var init_blur2 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/blur.js"() {
    blur22 = Blur22(blurf2);
    blurImage2 = Blur22(blurfImage2);
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/count.js
var init_count4 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/count.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/cross.js
var init_cross5 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/cross.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/cumsum.js
var init_cumsum3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/cumsum.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/variance.js
var init_variance3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/variance.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/deviation.js
var init_deviation3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/deviation.js"() {
    init_variance3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/extent.js
var init_extent5 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/extent.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/fsum.js
var init_fsum3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/fsum.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/identity.js
var init_identity13 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/identity.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/group.js
var init_group3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/group.js"() {
    init_src3();
    init_identity13();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/permute.js
var init_permute3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/permute.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/sort.js
var init_sort4 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/sort.js"() {
    init_ascending5();
    init_permute3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/groupSort.js
var init_groupSort3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/groupSort.js"() {
    init_ascending5();
    init_group3();
    init_sort4();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/array.js
var array6, slice7, map9;
var init_array8 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/array.js"() {
    array6 = Array.prototype;
    slice7 = array6.slice;
    map9 = array6.map;
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/constant.js
var init_constant12 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/ticks.js
var e103, e53, e23;
var init_ticks5 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/ticks.js"() {
    e103 = Math.sqrt(50);
    e53 = Math.sqrt(10);
    e23 = Math.sqrt(2);
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/nice.js
var init_nice5 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/nice.js"() {
    init_ticks5();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/threshold/sturges.js
var init_sturges3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/threshold/sturges.js"() {
    init_count4();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/bin.js
var init_bin3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/bin.js"() {
    init_array8();
    init_bisect4();
    init_constant12();
    init_extent5();
    init_identity13();
    init_nice5();
    init_ticks5();
    init_sturges3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/max.js
var init_max3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/max.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/maxIndex.js
var init_maxIndex3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/maxIndex.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/min.js
var init_min3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/min.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/minIndex.js
var init_minIndex3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/minIndex.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/quickselect.js
var init_quickselect3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/quickselect.js"() {
    init_sort4();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/greatest.js
var init_greatest3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/greatest.js"() {
    init_ascending5();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/quantile.js
var init_quantile5 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/quantile.js"() {
    init_max3();
    init_maxIndex3();
    init_min3();
    init_minIndex3();
    init_quickselect3();
    init_number7();
    init_sort4();
    init_greatest3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/threshold/freedmanDiaconis.js
var init_freedmanDiaconis3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/threshold/freedmanDiaconis.js"() {
    init_count4();
    init_quantile5();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/threshold/scott.js
var init_scott3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/threshold/scott.js"() {
    init_count4();
    init_deviation3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/mean.js
var init_mean3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/mean.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/median.js
var init_median3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/median.js"() {
    init_quantile5();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/merge.js
var init_merge4 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/merge.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/mode.js
var init_mode2 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/mode.js"() {
    init_src3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/pairs.js
var init_pairs3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/pairs.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/range.js
var init_range3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/range.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/rank.js
var init_rank2 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/rank.js"() {
    init_ascending5();
    init_sort4();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/least.js
var init_least3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/least.js"() {
    init_ascending5();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/leastIndex.js
var init_leastIndex3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/leastIndex.js"() {
    init_ascending5();
    init_minIndex3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/greatestIndex.js
var init_greatestIndex3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/greatestIndex.js"() {
    init_ascending5();
    init_maxIndex3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/scan.js
var init_scan3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/scan.js"() {
    init_leastIndex3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/shuffle.js
function shuffler3(random3) {
  return function shuffle2(array9, i0 = 0, i1 = array9.length) {
    let m2 = i1 - (i0 = +i0);
    while (m2) {
      const i = random3() * m2-- | 0, t = array9[m2 + i0];
      array9[m2 + i0] = array9[i + i0];
      array9[i + i0] = t;
    }
    return array9;
  };
}
var shuffle_default3;
var init_shuffle3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/shuffle.js"() {
    shuffle_default3 = shuffler3(Math.random);
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/sum.js
var init_sum4 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/sum.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/transpose.js
var init_transpose3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/transpose.js"() {
    init_min3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/zip.js
var init_zip3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/zip.js"() {
    init_transpose3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/every.js
var init_every3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/every.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/some.js
var init_some3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/some.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/filter.js
var init_filter3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/filter.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/map.js
var init_map3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/map.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/reduce.js
var init_reduce3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/reduce.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/reverse.js
var init_reverse6 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/reverse.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/difference.js
var init_difference3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/difference.js"() {
    init_src3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/disjoint.js
var init_disjoint3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/disjoint.js"() {
    init_src3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/intersection.js
function intersection3(values5, ...others) {
  values5 = new InternSet(values5);
  others = others.map(set6);
  out:
    for (const value4 of values5) {
      for (const other of others) {
        if (!other.has(value4)) {
          values5.delete(value4);
          continue out;
        }
      }
    }
  return values5;
}
function set6(values5) {
  return values5 instanceof InternSet ? values5 : new InternSet(values5);
}
var init_intersection3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/intersection.js"() {
    init_src3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/superset.js
var init_superset3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/superset.js"() {
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/subset.js
var init_subset3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/subset.js"() {
    init_superset3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/union.js
function union3(...others) {
  const set8 = new InternSet();
  for (const other of others) {
    for (const o of other) {
      set8.add(o);
    }
  }
  return set8;
}
var init_union3 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/union.js"() {
    init_src3();
  }
});

// node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/index.js
var init_src33 = __esm({
  "node_modules/.pnpm/d3-array@3.2.2/node_modules/d3-array/src/index.js"() {
    init_bisect4();
    init_ascending5();
    init_bisector3();
    init_blur2();
    init_count4();
    init_cross5();
    init_cumsum3();
    init_descending7();
    init_deviation3();
    init_extent5();
    init_fsum3();
    init_group3();
    init_groupSort3();
    init_bin3();
    init_freedmanDiaconis3();
    init_scott3();
    init_sturges3();
    init_max3();
    init_maxIndex3();
    init_mean3();
    init_median3();
    init_merge4();
    init_min3();
    init_minIndex3();
    init_mode2();
    init_nice5();
    init_pairs3();
    init_permute3();
    init_quantile5();
    init_quickselect3();
    init_range3();
    init_rank2();
    init_least3();
    init_leastIndex3();
    init_greatest3();
    init_greatestIndex3();
    init_scan3();
    init_shuffle3();
    init_sum4();
    init_ticks5();
    init_transpose3();
    init_variance3();
    init_zip3();
    init_every3();
    init_some3();
    init_filter3();
    init_map3();
    init_reduce3();
    init_reverse6();
    init_sort4();
    init_difference3();
    init_disjoint3();
    init_intersection3();
    init_subset3();
    init_superset3();
    init_union3();
    init_src3();
  }
});

// node_modules/.pnpm/vega-selections@5.4.1/node_modules/vega-selections/build/vega-selection.module.js
function testPoint(datum2, entry2) {
  var fields = entry2.fields, values5 = entry2.values, n = fields.length, i = 0, dval, f;
  for (; i < n; ++i) {
    f = fields[i];
    f.getter = field2.getter || field2(f.field);
    dval = f.getter(datum2);
    if (isDate2(dval))
      dval = toNumber2(dval);
    if (isDate2(values5[i]))
      values5[i] = toNumber2(values5[i]);
    if (isDate2(values5[i][0]))
      values5[i] = values5[i].map(toNumber2);
    if (f.type === TYPE_ENUM) {
      if (isArray2(values5[i]) ? values5[i].indexOf(dval) < 0 : dval !== values5[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!inrange2(dval, values5[i]))
          return false;
      } else if (f.type === TYPE_RANGE_RE) {
        if (!inrange2(dval, values5[i], true, false))
          return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        if (!inrange2(dval, values5[i], false, false))
          return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!inrange2(dval, values5[i], false, true))
          return false;
      }
    }
  }
  return true;
}
function selectionTest(name4, datum2, op) {
  var data3 = this.context.data[name4], entries3 = data3 ? data3.values.value : [], unitIdx = data3 ? data3[UNIT_INDEX] && data3[UNIT_INDEX].value : void 0, intersect6 = op === Intersect, n = entries3.length, i = 0, entry2, miss, count5, unit3, b3;
  for (; i < n; ++i) {
    entry2 = entries3[i];
    if (unitIdx && intersect6) {
      miss = miss || {};
      count5 = miss[unit3 = entry2.unit] || 0;
      if (count5 === -1)
        continue;
      b3 = testPoint(datum2, entry2);
      miss[unit3] = b3 ? -1 : ++count5;
      if (b3 && unitIdx.size === 1)
        return true;
      if (!b3 && count5 === unitIdx.get(unit3).count)
        return false;
    } else {
      b3 = testPoint(datum2, entry2);
      if (intersect6 ^ b3)
        return b3;
    }
  }
  return n && intersect6;
}
function selectionIdTest(name4, datum2, op) {
  const data3 = this.context.data[name4], entries3 = data3 ? data3.values.value : [], unitIdx = data3 ? data3[UNIT_INDEX] && data3[UNIT_INDEX].value : void 0, intersect6 = op === Intersect, value4 = $selectionId(datum2), index8 = bisectLeft4(entries3, value4);
  if (index8 === entries3.length)
    return false;
  if ($selectionId(entries3[index8]) !== value4)
    return false;
  if (unitIdx && intersect6) {
    if (unitIdx.size === 1)
      return true;
    if (bisectRight4(entries3, value4) - index8 < unitIdx.size)
      return false;
  }
  return true;
}
function selectionTuples(array9, base3) {
  return array9.map((x7) => extend2(base3.fields ? {
    values: base3.fields.map((f) => (f.getter || (f.getter = field2(f.field)))(x7.datum))
  } : {
    [SelectionId]: $selectionId(x7.datum)
  }, base3));
}
function selectionResolve(name4, op, isMulti, vl5) {
  var data3 = this.context.data[name4], entries3 = data3 ? data3.values.value : [], resolved = {}, multiRes = {}, types4 = {}, entry2, fields, values5, unit3, field4, value4, res, resUnit, type4, union4, n = entries3.length, i = 0, j, m2;
  for (; i < n; ++i) {
    entry2 = entries3[i];
    unit3 = entry2.unit;
    fields = entry2.fields;
    values5 = entry2.values;
    if (fields && values5) {
      for (j = 0, m2 = fields.length; j < m2; ++j) {
        field4 = fields[j];
        res = resolved[field4.field] || (resolved[field4.field] = {});
        resUnit = res[unit3] || (res[unit3] = []);
        types4[field4.field] = type4 = field4.type.charAt(0);
        union4 = ops[`${type4}_union`];
        res[unit3] = union4(resUnit, array2(values5[j]));
      }
      if (isMulti) {
        resUnit = multiRes[unit3] || (multiRes[unit3] = []);
        resUnit.push(array2(values5).reduce((obj, curr, j2) => (obj[fields[j2].field] = curr, obj), {}));
      }
    } else {
      field4 = SelectionId;
      value4 = $selectionId(entry2);
      res = resolved[field4] || (resolved[field4] = {});
      resUnit = res[unit3] || (res[unit3] = []);
      resUnit.push(value4);
      if (isMulti) {
        resUnit = multiRes[unit3] || (multiRes[unit3] = []);
        resUnit.push({
          [SelectionId]: value4
        });
      }
    }
  }
  op = op || Union;
  if (resolved[SelectionId]) {
    resolved[SelectionId] = ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]));
  } else {
    Object.keys(resolved).forEach((field5) => {
      resolved[field5] = Object.keys(resolved[field5]).map((unit4) => resolved[field5][unit4]).reduce((acc, curr) => acc === void 0 ? curr : ops[`${types4[field5]}_${op}`](acc, curr));
    });
  }
  entries3 = Object.keys(multiRes);
  if (isMulti && entries3.length) {
    const key3 = vl5 ? VlPoint : VlMulti;
    resolved[key3] = op === Union ? {
      [Or]: entries3.reduce((acc, k4) => (acc.push(...multiRes[k4]), acc), [])
    } : {
      [And]: entries3.map((k4) => ({
        [Or]: multiRes[k4]
      }))
    };
  }
  return resolved;
}
function selectionVisitor(name4, args, scope, params2) {
  if (args[0].type !== Literal)
    error2("First argument to selection functions must be a string literal.");
  const data3 = args[0].value, op = args.length >= 2 && peek2(args).value, field4 = "unit", indexName = IndexPrefix + field4, dataName = DataPrefix + data3;
  if (op === Intersect && !has2(params2, indexName)) {
    params2[indexName] = scope.getData(data3).indataRef(scope, field4);
  }
  if (!has2(params2, dataName)) {
    params2[dataName] = scope.getData(data3).tuplesRef();
  }
}
var Intersect, Union, VlMulti, VlPoint, Or, And, SelectionId, $selectionId, TYPE_ENUM, TYPE_RANGE_INC, TYPE_RANGE_EXC, TYPE_RANGE_LE, TYPE_RANGE_RE, UNIT_INDEX, bisect, bisectLeft4, bisectRight4, ops, DataPrefix, IndexPrefix;
var init_vega_selection_module = __esm({
  "node_modules/.pnpm/vega-selections@5.4.1/node_modules/vega-selections/build/vega-selection.module.js"() {
    init_src33();
    init_vega_util_module2();
    init_vega_expression_module();
    Intersect = "intersect";
    Union = "union";
    VlMulti = "vlMulti";
    VlPoint = "vlPoint";
    Or = "or";
    And = "and";
    SelectionId = "_vgsid_";
    $selectionId = field2(SelectionId);
    TYPE_ENUM = "E";
    TYPE_RANGE_INC = "R";
    TYPE_RANGE_EXC = "R-E";
    TYPE_RANGE_LE = "R-LE";
    TYPE_RANGE_RE = "R-RE";
    UNIT_INDEX = "index:unit";
    bisect = bisector2($selectionId);
    bisectLeft4 = bisect.left;
    bisectRight4 = bisect.right;
    ops = {
      [`${SelectionId}_union`]: union3,
      [`${SelectionId}_intersect`]: intersection3,
      E_union: function(base3, value4) {
        if (!base3.length)
          return value4;
        var i = 0, n = value4.length;
        for (; i < n; ++i)
          if (base3.indexOf(value4[i]) < 0)
            base3.push(value4[i]);
        return base3;
      },
      E_intersect: function(base3, value4) {
        return !base3.length ? value4 : base3.filter((v) => value4.indexOf(v) >= 0);
      },
      R_union: function(base3, value4) {
        var lo = toNumber2(value4[0]), hi = toNumber2(value4[1]);
        if (lo > hi) {
          lo = value4[1];
          hi = value4[0];
        }
        if (!base3.length)
          return [lo, hi];
        if (base3[0] > lo)
          base3[0] = lo;
        if (base3[1] < hi)
          base3[1] = hi;
        return base3;
      },
      R_intersect: function(base3, value4) {
        var lo = toNumber2(value4[0]), hi = toNumber2(value4[1]);
        if (lo > hi) {
          lo = value4[1];
          hi = value4[0];
        }
        if (!base3.length)
          return [lo, hi];
        if (hi < base3[0] || base3[1] < lo) {
          return [];
        } else {
          if (base3[0] < lo)
            base3[0] = lo;
          if (base3[1] > hi)
            base3[1] = hi;
        }
        return base3;
      }
    };
    DataPrefix = ":";
    IndexPrefix = "@";
  }
});

// node_modules/.pnpm/vega-functions@5.12.1/node_modules/vega-functions/build/vega-functions.module.js
function data(name4) {
  const data3 = this.context.data[name4];
  return data3 ? data3.values.value : [];
}
function indata(name4, field4, value4) {
  const index8 = this.context.data[name4]["index:" + field4], entry2 = index8 ? index8.value.get(value4) : void 0;
  return entry2 ? entry2.count : entry2;
}
function setdata(name4, tuples) {
  const df = this.context.dataflow, data3 = this.context.data[name4], input = data3.input;
  df.pulse(input, df.changeset().remove(truthy).insert(tuples));
  return 1;
}
function encode(item, name4, retval) {
  if (item) {
    const df = this.context.dataflow, target2 = item.mark.source;
    df.pulse(target2, df.changeset().encode(item, name4));
  }
  return retval !== void 0 ? retval : item;
}
function time3(month2, day2, specifier) {
  if (!Number.isInteger(month2) || !Number.isInteger(day2))
    return "";
  dateObj.setYear(2e3);
  dateObj.setMonth(month2);
  dateObj.setDate(day2);
  return timeFormat3.call(this, dateObj, specifier);
}
function monthFormat(month2) {
  return time3.call(this, month2, 1, "%B");
}
function monthAbbrevFormat(month2) {
  return time3.call(this, month2, 1, "%b");
}
function dayFormat(day2) {
  return time3.call(this, 0, 2 + day2, "%A");
}
function dayAbbrevFormat(day2) {
  return time3.call(this, 0, 2 + day2, "%a");
}
function dataVisitor(name4, args, scope, params2) {
  if (args[0].type !== Literal) {
    error("First argument to data functions must be a string literal.");
  }
  const data3 = args[0].value, dataName = DataPrefix2 + data3;
  if (!has(dataName, params2)) {
    try {
      params2[dataName] = scope.getData(data3).tuplesRef();
    } catch (err) {
    }
  }
}
function indataVisitor(name4, args, scope, params2) {
  if (args[0].type !== Literal)
    error("First argument to indata must be a string literal.");
  if (args[1].type !== Literal)
    error("Second argument to indata must be a string literal.");
  const data3 = args[0].value, field4 = args[1].value, indexName = IndexPrefix2 + field4;
  if (!has(indexName, params2)) {
    params2[indexName] = scope.getData(data3).indataRef(scope, field4);
  }
}
function scaleVisitor(name4, args, scope, params2) {
  if (args[0].type === Literal) {
    addScaleDependency(scope, params2, args[0].value);
  } else {
    for (name4 in scope.scales) {
      addScaleDependency(scope, params2, name4);
    }
  }
}
function addScaleDependency(scope, params2, name4) {
  const scaleName = ScalePrefix + name4;
  if (!has(params2, scaleName)) {
    try {
      params2[scaleName] = scope.scaleRef(name4);
    } catch (err) {
    }
  }
}
function getScale(name4, ctx) {
  let s3;
  return isFunction(name4) ? name4 : isString(name4) ? (s3 = ctx.scales[name4]) && s3.value : void 0;
}
function internalScaleFunctions(codegen3, fnctx, visitors) {
  fnctx.__bandwidth = (s3) => s3 && s3.bandwidth ? s3.bandwidth() : 0;
  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor;
  const ref2 = (arg) => "_[" + (arg.type === Literal ? $(ScalePrefix + arg.value) : $(ScalePrefix) + "+" + codegen3(arg)) + "]";
  return {
    _bandwidth: (args) => `this.__bandwidth(${ref2(args[0])})`,
    _range: (args) => `${ref2(args[0])}.range()`,
    _scale: (args) => `${ref2(args[0])}(${codegen3(args[1])})`
  };
}
function geoMethod(methodName, globalMethod) {
  return function(projection3, geojson, group6) {
    if (projection3) {
      const p = getScale(projection3, (group6 || this).context);
      return p && p.path[methodName](geojson);
    } else {
      return globalMethod(geojson);
    }
  };
}
function inScope(item) {
  const group6 = this.context.group;
  let value4 = false;
  if (group6)
    while (item) {
      if (item === group6) {
        value4 = true;
        break;
      }
      item = item.mark.group;
    }
  return value4;
}
function log7(df, method3, args) {
  try {
    df[method3].apply(df, ["EXPRESSION"].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }
  return args[args.length - 1];
}
function warn() {
  return log7(this.context.dataflow, "warn", arguments);
}
function info() {
  return log7(this.context.dataflow, "info", arguments);
}
function debug() {
  return log7(this.context.dataflow, "debug", arguments);
}
function channel_luminance_value(channelValue) {
  const val = channelValue / 255;
  if (val <= 0.03928) {
    return val / 12.92;
  }
  return Math.pow((val + 0.055) / 1.055, 2.4);
}
function luminance(color7) {
  const c2 = rgb2(color7), r2 = channel_luminance_value(c2.r), g = channel_luminance_value(c2.g), b3 = channel_luminance_value(c2.b);
  return 0.2126 * r2 + 0.7152 * g + 0.0722 * b3;
}
function contrast(color1, color22) {
  const lum1 = luminance(color1), lum2 = luminance(color22), lumL = Math.max(lum1, lum2), lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}
function merge6() {
  const args = [].slice.call(arguments);
  args.unshift({});
  return extend(...args);
}
function equal(a4, b3) {
  return a4 === b3 || a4 !== a4 && b3 !== b3 ? true : isArray(a4) ? isArray(b3) && a4.length === b3.length ? equalArray(a4, b3) : false : isObject(a4) && isObject(b3) ? equalObject(a4, b3) : false;
}
function equalArray(a4, b3) {
  for (let i = 0, n = a4.length; i < n; ++i) {
    if (!equal(a4[i], b3[i]))
      return false;
  }
  return true;
}
function equalObject(a4, b3) {
  for (const key3 in a4) {
    if (!equal(a4[key3], b3[key3]))
      return false;
  }
  return true;
}
function removePredicate(props) {
  return (_) => equalObject(props, _);
}
function modify(name4, insert2, remove3, toggle2, modify2, values5) {
  const df = this.context.dataflow, data3 = this.context.data[name4], input = data3.input, stamp = df.stamp();
  let changes = data3.changes, predicate, key3;
  if (df._trigger === false || !(input.value.length || insert2 || toggle2)) {
    return 0;
  }
  if (!changes || changes.stamp < stamp) {
    data3.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data3.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }
  if (remove3) {
    predicate = remove3 === true ? truthy : isArray(remove3) || isTuple(remove3) ? remove3 : removePredicate(remove3);
    changes.remove(predicate);
  }
  if (insert2) {
    changes.insert(insert2);
  }
  if (toggle2) {
    predicate = removePredicate(toggle2);
    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle2);
    }
  }
  if (modify2) {
    for (key3 in values5) {
      changes.modify(modify2, key3, values5[key3]);
    }
  }
  return 1;
}
function pinchDistance(event3) {
  const t = event3.touches, dx = t[0].clientX - t[1].clientX, dy = t[0].clientY - t[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function pinchAngle(event3) {
  const t = event3.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
function pluck(data3, name4) {
  const accessor3 = accessors[name4] || (accessors[name4] = field(name4));
  return isArray(data3) ? data3.map(accessor3) : accessor3(data3);
}
function array7(seq) {
  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;
}
function sequence2(seq) {
  return array7(seq) || (isString(seq) ? seq : null);
}
function join3(seq, ...args) {
  return array7(seq).join(...args);
}
function indexof(seq, ...args) {
  return sequence2(seq).indexOf(...args);
}
function lastindexof(seq, ...args) {
  return sequence2(seq).lastIndexOf(...args);
}
function slice8(seq, ...args) {
  return sequence2(seq).slice(...args);
}
function replace2(str, pattern, repl) {
  if (isFunction(repl))
    error("Function argument passed to replace.");
  return String(str).replace(pattern, repl);
}
function reverse4(seq) {
  return array7(seq).slice().reverse();
}
function bandspace(count5, paddingInner2, paddingOuter2) {
  return bandSpace2(count5 || 0, paddingInner2 || 0, paddingOuter2 || 0);
}
function bandwidth(name4, group6) {
  const s3 = getScale(name4, (group6 || this).context);
  return s3 && s3.bandwidth ? s3.bandwidth() : 0;
}
function copy5(name4, group6) {
  const s3 = getScale(name4, (group6 || this).context);
  return s3 ? s3.copy() : void 0;
}
function domain(name4, group6) {
  const s3 = getScale(name4, (group6 || this).context);
  return s3 ? s3.domain() : [];
}
function invert(name4, range7, group6) {
  const s3 = getScale(name4, (group6 || this).context);
  return !s3 ? void 0 : isArray(range7) ? (s3.invertRange || s3.invert)(range7) : (s3.invert || s3.invertExtent)(range7);
}
function range4(name4, group6) {
  const s3 = getScale(name4, (group6 || this).context);
  return s3 && s3.range ? s3.range() : [];
}
function scale5(name4, value4, group6) {
  const s3 = getScale(name4, (group6 || this).context);
  return s3 ? s3(value4) : void 0;
}
function scaleGradient(scale8, p02, p1, count5, group6) {
  scale8 = getScale(scale8, (group6 || this).context);
  const gradient5 = Gradient(p02, p1);
  let stops = scale8.domain(), min8 = stops[0], max8 = peek(stops), fraction = identity;
  if (!(max8 - min8)) {
    scale8 = (scale8.interpolator ? scale3("sequential")().interpolator(scale8.interpolator()) : scale3("linear")().interpolate(scale8.interpolate()).range(scale8.range())).domain([min8 = 0, max8 = 1]);
  } else {
    fraction = scaleFraction(scale8, min8, max8);
  }
  if (scale8.ticks) {
    stops = scale8.ticks(+count5 || 15);
    if (min8 !== stops[0])
      stops.unshift(min8);
    if (max8 !== peek(stops))
      stops.push(max8);
  }
  stops.forEach((_) => gradient5.stop(fraction(_), scale8(_)));
  return gradient5;
}
function geoShape(projection3, geojson, group6) {
  const p = getScale(projection3, (group6 || this).context);
  return function(context4) {
    return p ? p.path.context(context4)(geojson) : "";
  };
}
function pathShape(path5) {
  let p = null;
  return function(context4) {
    return context4 ? pathRender2(context4, p = p || pathParse(path5)) : path5;
  };
}
function treeNodes(name4, context4) {
  const tree = data.call(context4, name4);
  return tree.root && tree.root.lookup || {};
}
function treePath(name4, source5, target2) {
  const nodes = treeNodes(name4, this), s3 = nodes[source5], t = nodes[target2];
  return s3 && t ? s3.path(t).map(datum) : void 0;
}
function treeAncestors(name4, node) {
  const n = treeNodes(name4, this)[node];
  return n ? n.ancestors().map(datum) : void 0;
}
function screen() {
  const w5 = _window();
  return w5 ? w5.screen : {};
}
function windowSize() {
  const w5 = _window();
  return w5 ? [w5.innerWidth, w5.innerHeight] : [void 0, void 0];
}
function containerSize() {
  const view = this.context.dataflow, el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [void 0, void 0];
}
function intersect5(b3, opt, group6) {
  if (!b3)
    return [];
  const [u, v] = b3, box = new Bounds2().set(u[0], u[1], v[0], v[1]), scene = group6 || this.context.dataflow.scenegraph().root;
  return intersect4(scene, box, filter5(opt));
}
function filter5(opt) {
  let p = null;
  if (opt) {
    const types4 = array(opt.marktype), names = array(opt.markname);
    p = (_) => (!types4.length || types4.some((t) => _.marktype === t)) && (!names.length || names.some((s3) => _.name === s3));
  }
  return p;
}
function buildFunctions(codegen3) {
  const fn = Functions(codegen3);
  eventFunctions.forEach((name4) => fn[name4] = eventPrefix + name4);
  for (const name4 in functionContext) {
    fn[name4] = thisPrefix + name4;
  }
  extend(fn, internalScaleFunctions(codegen3, functionContext, astVisitors));
  return fn;
}
function expressionFunction(name4, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name4];
  }
  functionContext[name4] = fn;
  if (visitor)
    astVisitors[name4] = visitor;
  if (codeGenerator)
    codeGenerator.functions[name4] = thisPrefix + name4;
  return this;
}
function parser2(expr2, scope) {
  const params2 = {};
  let ast;
  try {
    expr2 = isString(expr2) ? expr2 : $(expr2) + "";
    ast = parser(expr2);
  } catch (err) {
    error("Expression parse error: " + expr2);
  }
  ast.visit((node) => {
    if (node.type !== CallExpression)
      return;
    const name4 = node.callee.name, visit3 = codegenParams.visitors[name4];
    if (visit3)
      visit3(name4, node.arguments, scope, params2);
  });
  const gen = codeGenerator(ast);
  gen.globals.forEach((name4) => {
    const signalName = SignalPrefix + name4;
    if (!has(params2, signalName) && scope.getSignal(name4)) {
      params2[signalName] = scope.signalRef(name4);
    }
  });
  return {
    $expr: extend({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params2
  };
}
var wrap, format8, timeFormat3, utcFormat3, timeParse3, utcParse3, dateObj, DataPrefix2, IndexPrefix2, ScalePrefix, SignalPrefix, geoArea, geoBounds, geoCentroid, accessors, datum, _window, functionContext, eventFunctions, eventPrefix, thisPrefix, astVisitors, codegenParams, codeGenerator;
var init_vega_functions_module = __esm({
  "node_modules/.pnpm/vega-functions@5.12.1/node_modules/vega-functions/build/vega-functions.module.js"() {
    init_vega_util_module();
    init_vega_expression_module();
    init_src21();
    init_src17();
    init_vega_dataflow_module();
    init_vega_scale_module2();
    init_vega_scenegraph_module2();
    init_vega_selection_module();
    init_vega_statistics_module();
    init_vega_time_module2();
    init_src9();
    wrap = (method3) => function(value4, spec) {
      const locale7 = this.context.dataflow.locale();
      return locale7[method3](spec)(value4);
    };
    format8 = wrap("format");
    timeFormat3 = wrap("timeFormat");
    utcFormat3 = wrap("utcFormat");
    timeParse3 = wrap("timeParse");
    utcParse3 = wrap("utcParse");
    dateObj = new Date(2e3, 0, 1);
    DataPrefix2 = ":";
    IndexPrefix2 = "@";
    ScalePrefix = "%";
    SignalPrefix = "$";
    geoArea = geoMethod("area", area_default2);
    geoBounds = geoMethod("bounds", bounds_default);
    geoCentroid = geoMethod("centroid", centroid_default);
    accessors = {};
    datum = (d) => d.data;
    _window = () => typeof window !== "undefined" && window || null;
    functionContext = {
      random() {
        return random();
      },
      cumulativeNormal,
      cumulativeLogNormal,
      cumulativeUniform,
      densityNormal,
      densityLogNormal,
      densityUniform,
      quantileNormal,
      quantileLogNormal,
      quantileUniform,
      sampleNormal,
      sampleLogNormal,
      sampleUniform,
      isArray,
      isBoolean,
      isDate,
      isDefined(_) {
        return _ !== void 0;
      },
      isNumber,
      isObject,
      isRegExp,
      isString,
      isTuple,
      isValid(_) {
        return _ != null && _ === _;
      },
      toBoolean,
      toDate,
      toNumber,
      toString,
      indexof,
      join: join3,
      lastindexof,
      replace: replace2,
      reverse: reverse4,
      slice: slice8,
      flush,
      lerp,
      merge: merge6,
      pad,
      peek,
      pluck,
      span,
      inrange,
      truncate,
      rgb: rgb2,
      lab: lab3,
      hcl: hcl3,
      hsl: hsl3,
      luminance,
      contrast,
      sequence: range_default,
      format: format8,
      utcFormat: utcFormat3,
      utcParse: utcParse3,
      utcOffset,
      utcSequence,
      timeFormat: timeFormat3,
      timeParse: timeParse3,
      timeOffset,
      timeSequence,
      timeUnitSpecifier,
      monthFormat,
      monthAbbrevFormat,
      dayFormat,
      dayAbbrevFormat,
      quarter,
      utcquarter,
      week,
      utcweek,
      dayofyear,
      utcdayofyear,
      warn,
      info,
      debug,
      extent,
      inScope,
      intersect: intersect5,
      clampRange,
      pinchDistance,
      pinchAngle,
      screen,
      containerSize,
      windowSize,
      bandspace,
      setdata,
      pathShape,
      panLinear,
      panLog,
      panPow,
      panSymlog,
      zoomLinear,
      zoomLog,
      zoomPow,
      zoomSymlog,
      encode,
      modify
    };
    eventFunctions = ["view", "item", "group", "xy", "x", "y"];
    eventPrefix = "event.vega.";
    thisPrefix = "this.";
    astVisitors = {};
    codegenParams = {
      forbidden: ["_"],
      allowed: ["datum", "event", "item"],
      fieldvar: "datum",
      globalvar: (id4) => `_[${$(SignalPrefix + id4)}]`,
      functions: buildFunctions,
      constants: Constants,
      visitors: astVisitors
    };
    codeGenerator = codegen(codegenParams);
    expressionFunction("bandwidth", bandwidth, scaleVisitor);
    expressionFunction("copy", copy5, scaleVisitor);
    expressionFunction("domain", domain, scaleVisitor);
    expressionFunction("range", range4, scaleVisitor);
    expressionFunction("invert", invert, scaleVisitor);
    expressionFunction("scale", scale5, scaleVisitor);
    expressionFunction("gradient", scaleGradient, scaleVisitor);
    expressionFunction("geoArea", geoArea, scaleVisitor);
    expressionFunction("geoBounds", geoBounds, scaleVisitor);
    expressionFunction("geoCentroid", geoCentroid, scaleVisitor);
    expressionFunction("geoShape", geoShape, scaleVisitor);
    expressionFunction("indata", indata, indataVisitor);
    expressionFunction("data", data, dataVisitor);
    expressionFunction("treePath", treePath, dataVisitor);
    expressionFunction("treeAncestors", treeAncestors, dataVisitor);
    expressionFunction("vlSelectionTest", selectionTest, selectionVisitor);
    expressionFunction("vlSelectionIdTest", selectionIdTest, selectionVisitor);
    expressionFunction("vlSelectionResolve", selectionResolve, selectionVisitor);
    expressionFunction("vlSelectionTuples", selectionTuples);
  }
});

// node_modules/.pnpm/vega-runtime@6.1.4/node_modules/vega-runtime/build/vega-runtime.module.js
function parse6(spec) {
  const ctx = this, operators = spec.operators || [];
  if (spec.background) {
    ctx.background = spec.background;
  }
  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  }
  if (spec.locale) {
    ctx.locale = spec.locale;
  }
  operators.forEach((entry2) => ctx.parseOperator(entry2));
  operators.forEach((entry2) => ctx.parseOperatorParameters(entry2));
  (spec.streams || []).forEach((entry2) => ctx.parseStream(entry2));
  (spec.updates || []).forEach((entry2) => ctx.parseUpdate(entry2));
  return ctx.resolve();
}
function adjustSpatial(encode2, marktype) {
  let code = "";
  if (Skip[marktype])
    return code;
  if (encode2.x2) {
    if (encode2.x) {
      if (Swap[marktype]) {
        code += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;";
      }
      code += "o.width=o.x2-o.x;";
    } else {
      code += "o.x=o.x2-(o.width||0);";
    }
  }
  if (encode2.xc) {
    code += "o.x=o.xc-(o.width||0)/2;";
  }
  if (encode2.y2) {
    if (encode2.y) {
      if (Swap[marktype]) {
        code += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;";
      }
      code += "o.height=o.y2-o.y;";
    } else {
      code += "o.y=o.y2-(o.height||0);";
    }
  }
  if (encode2.yc) {
    code += "o.y=o.yc-(o.height||0)/2;";
  }
  return code;
}
function canonicalType(type4) {
  return (type4 + "").toLowerCase();
}
function isOperator(type4) {
  return canonicalType(type4) === "operator";
}
function isCollect(type4) {
  return canonicalType(type4) === "collect";
}
function expression(ctx, args, code) {
  if (!code.endsWith(";")) {
    code = "return(" + code + ");";
  }
  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
}
function _compare(u, v, lt, gt) {
  return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}
  : (u > v || v == null) && u != null ? ${gt}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}
  : v !== v && u === u ? ${gt} : `;
}
function parseOperator(spec) {
  const ctx = this;
  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}
function parseOperatorParameters(spec) {
  const ctx = this;
  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op)
      error2("Invalid operator id: " + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}
function parseParameters(spec, params2) {
  params2 = params2 || {};
  const ctx = this;
  for (const key3 in spec) {
    const value4 = spec[key3];
    params2[key3] = isArray2(value4) ? value4.map((v) => parseParameter(v, ctx, params2)) : parseParameter(value4, ctx, params2);
  }
  return params2;
}
function parseParameter(spec, ctx, params2) {
  if (!spec || !isObject2(spec))
    return spec;
  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];
    if (has2(spec, p.key)) {
      return p.parse(spec, ctx, params2);
    }
  }
  return spec;
}
function getOperator(_, ctx) {
  return ctx.get(_.$ref) || error2("Operator not defined: " + _.$ref);
}
function getExpression(_, ctx, params2) {
  if (_.$params) {
    ctx.parseParameters(_.$params, params2);
  }
  const k4 = "e:" + _.$expr.code;
  return ctx.fn[k4] || (ctx.fn[k4] = accessor2(ctx.parameterExpression(_.$expr), _.$fields));
}
function getKey(_, ctx) {
  const k4 = "k:" + _.$key + "_" + !!_.$flat;
  return ctx.fn[k4] || (ctx.fn[k4] = key2(_.$key, _.$flat, ctx.expr.codegen));
}
function getField2(_, ctx) {
  if (!_.$field)
    return null;
  const k4 = "f:" + _.$field + "_" + _.$name;
  return ctx.fn[k4] || (ctx.fn[k4] = field2(_.$field, _.$name, ctx.expr.codegen));
}
function getCompare(_, ctx) {
  const k4 = "c:" + _.$compare + "_" + _.$order, c2 = array2(_.$compare).map((_2) => _2 && _2.$tupleid ? tupleid : _2);
  return ctx.fn[k4] || (ctx.fn[k4] = compare3(c2, _.$order, ctx.expr.codegen));
}
function getEncode(_, ctx) {
  const spec = _.$encode, encode2 = {};
  for (const name4 in spec) {
    const enc = spec[name4];
    encode2[name4] = accessor2(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode2[name4].output = enc.$output;
  }
  return encode2;
}
function getContext(_, ctx) {
  return ctx;
}
function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function(dataflow, key3, parent) {
    const subctx = ctx.fork().parse(spec), op = subctx.get(spec.operators[0].id), p = subctx.signals.parent;
    if (p)
      p.set(parent);
    op.detachSubflow = () => ctx.detach(subctx);
    return op;
  };
}
function getTupleId() {
  return tupleid;
}
function parseStream(spec) {
  var ctx = this, filter6 = spec.filter != null ? ctx.eventExpression(spec.filter) : void 0, stream2 = spec.stream != null ? ctx.get(spec.stream) : void 0, args;
  if (spec.source) {
    stream2 = ctx.events(spec.source, spec.type, filter6);
  } else if (spec.merge) {
    args = spec.merge.map((_) => ctx.get(_));
    stream2 = args[0].merge.apply(args[0], args.slice(1));
  }
  if (spec.between) {
    args = spec.between.map((_) => ctx.get(_));
    stream2 = stream2.between(args[0], args[1]);
  }
  if (spec.filter) {
    stream2 = stream2.filter(filter6);
  }
  if (spec.throttle != null) {
    stream2 = stream2.throttle(+spec.throttle);
  }
  if (spec.debounce != null) {
    stream2 = stream2.debounce(+spec.debounce);
  }
  if (stream2 == null) {
    error2("Invalid stream definition: " + JSON.stringify(spec));
  }
  if (spec.consume)
    stream2.consume(true);
  ctx.stream(spec, stream2);
}
function parseUpdate(spec) {
  var ctx = this, srcid = isObject2(srcid = spec.source) ? srcid.$ref : srcid, source5 = ctx.get(srcid), target2 = null, update3 = spec.update, params2 = void 0;
  if (!source5)
    error2("Source not defined: " + spec.source);
  target2 = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);
  if (update3 && update3.$expr) {
    if (update3.$params) {
      params2 = ctx.parseParameters(update3.$params);
    }
    update3 = ctx.handlerExpression(update3.$expr);
  }
  ctx.update(spec, source5, target2, update3, params2);
}
function getState(options2) {
  var ctx = this, state = {};
  if (options2.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach((key3) => {
      const op = ctx.signals[key3];
      if (options2.signals(key3, op)) {
        signals[key3] = op.value;
      }
    });
  }
  if (options2.data) {
    var data3 = state.data = {};
    Object.keys(ctx.data).forEach((key3) => {
      const dataset = ctx.data[key3];
      if (options2.data(key3, dataset)) {
        data3[key3] = dataset.input.value;
      }
    });
  }
  if (ctx.subcontext && options2.recurse !== false) {
    state.subcontext = ctx.subcontext.map((ctx2) => ctx2.getState(options2));
  }
  return state;
}
function setState(state) {
  var ctx = this, df = ctx.dataflow, data3 = state.data, signals = state.signals;
  Object.keys(signals || {}).forEach((key3) => {
    df.update(ctx.signals[key3], signals[key3], SKIP3);
  });
  Object.keys(data3 || {}).forEach((key3) => {
    df.pulse(ctx.data[key3].input, df.changeset().remove(truthy2).insert(data3[key3]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx)
      subctx.setState(substate);
  });
}
function context3(df, transforms2, functions, expr2) {
  return new Context(df, transforms2, functions, expr2);
}
function Context(df, transforms2, functions, expr2) {
  this.dataflow = df;
  this.transforms = transforms2;
  this.events = df.events.bind(df);
  this.expr = expr2 || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};
  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}
function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);
  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}
var Skip, Swap, expressionCodegen, PARSERS, SKIP3;
var init_vega_runtime_module = __esm({
  "node_modules/.pnpm/vega-runtime@6.1.4/node_modules/vega-runtime/build/vega-runtime.module.js"() {
    init_vega_util_module2();
    init_vega_dataflow_module();
    Skip = toSet2(["rule"]);
    Swap = toSet2(["group", "image", "rect"]);
    expressionCodegen = {
      operator: (ctx, expr2) => expression(ctx, ["_"], expr2.code),
      parameter: (ctx, expr2) => expression(ctx, ["datum", "_"], expr2.code),
      event: (ctx, expr2) => expression(ctx, ["event"], expr2.code),
      handler: (ctx, expr2) => {
        const code = `var datum=event.item&&event.item.datum;return ${expr2.code};`;
        return expression(ctx, ["_", "event"], code);
      },
      encode: (ctx, encode2) => {
        const {
          marktype,
          channels
        } = encode2;
        let code = "var o=item,datum=o.datum,m=0,$;";
        for (const name4 in channels) {
          const o = "o[" + $2(name4) + "]";
          code += `$=${channels[name4].code};if(${o}!==$)${o}=$,m=1;`;
        }
        code += adjustSpatial(channels, marktype);
        code += "return m;";
        return expression(ctx, ["item", "_"], code);
      },
      codegen: {
        get(path5) {
          const ref2 = `[${path5.map($2).join("][")}]`;
          const get8 = Function("_", `return _${ref2};`);
          get8.path = ref2;
          return get8;
        },
        comparator(fields, orders) {
          let t;
          const map11 = (f, i) => {
            const o = orders[i];
            let u, v;
            if (f.path) {
              u = `a${f.path}`;
              v = `b${f.path}`;
            } else {
              (t = t || {})["f" + i] = f;
              u = `this.f${i}(a)`;
              v = `this.f${i}(b)`;
            }
            return _compare(u, v, -o, o);
          };
          const fn = Function("a", "b", "var u, v; return " + fields.map(map11).join("") + "0;");
          return t ? fn.bind(t) : fn;
        }
      }
    };
    PARSERS = [{
      key: "$ref",
      parse: getOperator
    }, {
      key: "$key",
      parse: getKey
    }, {
      key: "$expr",
      parse: getExpression
    }, {
      key: "$field",
      parse: getField2
    }, {
      key: "$encode",
      parse: getEncode
    }, {
      key: "$compare",
      parse: getCompare
    }, {
      key: "$context",
      parse: getContext
    }, {
      key: "$subflow",
      parse: getSubflow
    }, {
      key: "$tupleid",
      parse: getTupleId
    }];
    SKIP3 = {
      skip: true
    };
    Context.prototype = Subcontext.prototype = {
      fork() {
        const ctx = new Subcontext(this);
        (this.subcontext || (this.subcontext = [])).push(ctx);
        return ctx;
      },
      detach(ctx) {
        this.subcontext = this.subcontext.filter((c2) => c2 !== ctx);
        const keys5 = Object.keys(ctx.nodes);
        for (const key3 of keys5)
          ctx.nodes[key3]._targets = null;
        for (const key3 of keys5)
          ctx.nodes[key3].detach();
        ctx.nodes = null;
      },
      get(id4) {
        return this.nodes[id4];
      },
      set(id4, node) {
        return this.nodes[id4] = node;
      },
      add(spec, op) {
        const ctx = this, df = ctx.dataflow, data3 = spec.value;
        ctx.set(spec.id, op);
        if (isCollect(spec.type) && data3) {
          if (data3.$ingest) {
            df.ingest(op, data3.$ingest, data3.$format);
          } else if (data3.$request) {
            df.preload(op, data3.$request, data3.$format);
          } else {
            df.pulse(op, df.changeset().insert(data3));
          }
        }
        if (spec.root) {
          ctx.root = op;
        }
        if (spec.parent) {
          let p = ctx.get(spec.parent.$ref);
          if (p) {
            df.connect(p, [op]);
            op.targets().add(p);
          } else {
            (ctx.unresolved = ctx.unresolved || []).push(() => {
              p = ctx.get(spec.parent.$ref);
              df.connect(p, [op]);
              op.targets().add(p);
            });
          }
        }
        if (spec.signal) {
          ctx.signals[spec.signal] = op;
        }
        if (spec.scale) {
          ctx.scales[spec.scale] = op;
        }
        if (spec.data) {
          for (const name4 in spec.data) {
            const data4 = ctx.data[name4] || (ctx.data[name4] = {});
            spec.data[name4].forEach((role) => data4[role] = op);
          }
        }
      },
      resolve() {
        (this.unresolved || []).forEach((fn) => fn());
        delete this.unresolved;
        return this;
      },
      operator(spec, update3) {
        this.add(spec, this.dataflow.add(spec.value, update3));
      },
      transform(spec, type4) {
        this.add(spec, this.dataflow.add(this.transforms[canonicalType(type4)]));
      },
      stream(spec, stream2) {
        this.set(spec.id, stream2);
      },
      update(spec, stream2, target2, update3, params2) {
        this.dataflow.on(stream2, target2, update3, params2, spec.options);
      },
      operatorExpression(expr2) {
        return this.expr.operator(this, expr2);
      },
      parameterExpression(expr2) {
        return this.expr.parameter(this, expr2);
      },
      eventExpression(expr2) {
        return this.expr.event(this, expr2);
      },
      handlerExpression(expr2) {
        return this.expr.handler(this, expr2);
      },
      encodeExpression(encode2) {
        return this.expr.encode(this, encode2);
      },
      parse: parse6,
      parseOperator,
      parseOperatorParameters,
      parseParameters,
      parseStream,
      parseUpdate,
      getState,
      setState
    };
  }
});

// node_modules/.pnpm/vega-view@5.10.1/node_modules/vega-view/build/vega-view.module.js
function initializeAria(view) {
  const el = view.container();
  if (el) {
    el.setAttribute("role", "graphics-document");
    el.setAttribute("aria-roleDescription", "visualization");
    ariaLabel(el, view.description());
  }
}
function ariaLabel(el, desc) {
  if (el)
    desc == null ? el.removeAttribute("aria-label") : el.setAttribute("aria-label", desc);
}
function background3(view) {
  view.add(null, (_) => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}
function cursor(view) {
  const cursor3 = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  }));
  view.on(view.events("view", "mousemove"), cursor3, (_, event3) => {
    const value4 = cursor3.value, user = value4 ? isString(value4) ? value4 : value4.user : Default, item = event3.item && event3.item.cursor || null;
    return value4 && user === value4.user && item == value4.item ? value4 : {
      user,
      item
    };
  });
  view.add(null, function(_) {
    let user = _.cursor, item = this.value;
    if (!isString(user)) {
      item = user.item;
      user = user.user;
    }
    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor3
  });
}
function setCursor(view, cursor3) {
  const el = view.globalCursor() ? typeof document !== "undefined" && document.body : view.container();
  if (el) {
    return cursor3 == null ? el.style.removeProperty("cursor") : el.style.cursor = cursor3;
  }
}
function dataref(view, name4) {
  var data3 = view._runtime.data;
  if (!has(data3, name4)) {
    error("Unrecognized data set: " + name4);
  }
  return data3[name4];
}
function data2(name4, values5) {
  return arguments.length < 2 ? dataref(this, name4).values.value : change.call(this, name4, changeset().remove(truthy).insert(values5));
}
function change(name4, changes) {
  if (!isChangeSet(changes)) {
    error("Second argument to changes must be a changeset.");
  }
  const dataset = dataref(this, name4);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert(name4, _) {
  return change.call(this, name4, changeset().insert(_));
}
function remove(name4, _) {
  return change.call(this, name4, changeset().remove(_));
}
function width(view) {
  var padding3 = view.padding();
  return Math.max(0, view._viewWidth + padding3.left + padding3.right);
}
function height(view) {
  var padding3 = view.padding();
  return Math.max(0, view._viewHeight + padding3.top + padding3.bottom);
}
function offset4(view) {
  var padding3 = view.padding(), origin = view._origin;
  return [padding3.left + origin[0], padding3.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset4(view), w5 = width(view), h4 = height(view);
  view._renderer.background(view.background());
  view._renderer.resize(w5, h4, origin);
  view._handler.origin(origin);
  view._resizeListeners.forEach((handler) => {
    try {
      handler(w5, h4);
    } catch (error3) {
      view.error(error3);
    }
  });
}
function eventExtend(view, event3, item) {
  var r2 = view._renderer, el = r2 && r2.canvas(), p, e3, translate5;
  if (el) {
    translate5 = offset4(view);
    e3 = event3.changedTouches ? event3.changedTouches[0] : event3;
    p = point14(e3, el);
    p[0] -= translate5[0];
    p[1] -= translate5[1];
  }
  event3.dataflow = view;
  event3.item = item;
  event3.vega = extension(view, item, p);
  return event3;
}
function extension(view, item, point16) {
  const itemGroup = item ? item.mark.marktype === "group" ? item : item.mark.group : null;
  function group6(name4) {
    var g = itemGroup, i;
    if (name4)
      for (i = item; i; i = i.mark.group) {
        if (i.mark.name === name4) {
          g = i;
          break;
        }
      }
    return g && g.mark && g.mark.interactive ? g : {};
  }
  function xy(item2) {
    if (!item2)
      return point16;
    if (isString(item2))
      item2 = group6(item2);
    const p = point16.slice();
    while (item2) {
      p[0] -= item2.x || 0;
      p[1] -= item2.y || 0;
      item2 = item2.mark && item2.mark.group;
    }
    return p;
  }
  return {
    view: constant(view),
    item: constant(item || {}),
    group: group6,
    xy,
    x: (item2) => xy(item2)[0],
    y: (item2) => xy(item2)[1]
  };
}
function initializeEventConfig(config) {
  const events4 = extend({
    defaults: {}
  }, config);
  const unpack = (obj, keys5) => {
    keys5.forEach((k4) => {
      if (isArray(obj[k4]))
        obj[k4] = toSet(obj[k4]);
    });
  };
  unpack(events4.defaults, ["prevent", "allow"]);
  unpack(events4, ["view", "window", "selector"]);
  return events4;
}
function trackEventListener(view, sources, type4, handler) {
  view._eventListeners.push({
    type: type4,
    sources: array(sources),
    handler
  });
}
function prevent(view, type4) {
  var def3 = view._eventConfig.defaults, prevent2 = def3.prevent, allow = def3.allow;
  return prevent2 === false || allow === true ? false : prevent2 === true || allow === false ? true : prevent2 ? prevent2[type4] : allow ? !allow[type4] : view.preventDefault();
}
function permit(view, key3, type4) {
  const rule5 = view._eventConfig && view._eventConfig[key3];
  if (rule5 === false || isObject(rule5) && !rule5[type4]) {
    view.warn(`Blocked ${key3} ${type4} event listener.`);
    return false;
  }
  return true;
}
function events2(source5, type4, filter6) {
  var view = this, s3 = new EventStream(filter6), send = function(e3, item) {
    view.runAsync(null, () => {
      if (source5 === VIEW && prevent(view, type4)) {
        e3.preventDefault();
      }
      s3.receive(eventExtend(view, e3, item));
    });
  }, sources;
  if (source5 === TIMER) {
    if (permit(view, "timer", type4)) {
      view.timer(send, type4);
    }
  } else if (source5 === VIEW) {
    if (permit(view, "view", type4)) {
      view.addEventListener(type4, send, NO_TRAP);
    }
  } else {
    if (source5 === WINDOW) {
      if (permit(view, "window", type4) && typeof window !== "undefined") {
        sources = [window];
      }
    } else if (typeof document !== "undefined") {
      if (permit(view, "selector", type4)) {
        sources = document.querySelectorAll(source5);
      }
    }
    if (!sources) {
      view.warn("Can not resolve event source: " + source5);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type4, send);
      }
      trackEventListener(view, sources, type4, send);
    }
  }
  return s3;
}
function itemFilter(event3) {
  return event3.item;
}
function markTarget(event3) {
  return event3.item.mark.source;
}
function invoke(name4) {
  return function(_, event3) {
    return event3.vega.view().changeset().encode(event3.item, name4);
  };
}
function hover(hoverSet, leaveSet) {
  hoverSet = [hoverSet || "hover"];
  leaveSet = [leaveSet || "update", hoverSet[0]];
  this.on(this.events("view", "mouseover", itemFilter), markTarget, invoke(hoverSet));
  this.on(this.events("view", "mouseout", itemFilter), markTarget, invoke(leaveSet));
  return this;
}
function finalize() {
  var tooltip2 = this._tooltip, timers = this._timers, listeners = this._eventListeners, n, m2, e3;
  n = timers.length;
  while (--n >= 0) {
    timers[n].stop();
  }
  n = listeners.length;
  while (--n >= 0) {
    e3 = listeners[n];
    m2 = e3.sources.length;
    while (--m2 >= 0) {
      e3.sources[m2].removeEventListener(e3.type, e3.handler);
    }
  }
  if (tooltip2) {
    tooltip2.call(this, this._handler, null, null, null);
  }
  return this;
}
function element3(tag, attr3, text5) {
  const el = document.createElement(tag);
  for (const key3 in attr3)
    el.setAttribute(key3, attr3[key3]);
  if (text5 != null)
    el.textContent = text5;
  return el;
}
function bind3(view, el, binding) {
  if (!el)
    return;
  const param2 = binding.param;
  let bind4 = binding.state;
  if (!bind4) {
    bind4 = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: (value4) => {
        if (value4 != view.signal(param2.signal)) {
          view.runAsync(null, () => {
            bind4.source = true;
            view.signal(param2.signal, value4);
          });
        }
      }
    };
    if (param2.debounce) {
      bind4.update = debounce(param2.debounce, bind4.update);
    }
  }
  const create5 = param2.input == null && param2.element ? target : generate2;
  create5(bind4, el, param2, view);
  if (!bind4.active) {
    view.on(view._signals[param2.signal], null, () => {
      bind4.source ? bind4.source = false : bind4.set(view.signal(param2.signal));
    });
    bind4.active = true;
  }
  return bind4;
}
function target(bind4, node, param2, view) {
  const type4 = param2.event || "input";
  const handler = () => bind4.update(node.value);
  view.signal(param2.signal, node.value);
  node.addEventListener(type4, handler);
  trackEventListener(view, node, type4, handler);
  bind4.set = (value4) => {
    node.value = value4;
    node.dispatchEvent(event(type4));
  };
}
function event(type4) {
  return typeof Event !== "undefined" ? new Event(type4) : {
    type: type4
  };
}
function generate2(bind4, el, param2, view) {
  const value4 = view.signal(param2.signal);
  const div = element3("div", {
    "class": BindClass
  });
  const wrapper = param2.input === "radio" ? div : div.appendChild(element3("label"));
  wrapper.appendChild(element3("span", {
    "class": NameClass
  }, param2.name || param2.signal));
  el.appendChild(div);
  let input = form;
  switch (param2.input) {
    case "checkbox":
      input = checkbox;
      break;
    case "select":
      input = select;
      break;
    case "radio":
      input = radio;
      break;
    case "range":
      input = range5;
      break;
  }
  input(bind4, wrapper, param2, value4);
}
function form(bind4, el, param2, value4) {
  const node = element3("input");
  for (const key3 in param2) {
    if (key3 !== "signal" && key3 !== "element") {
      node.setAttribute(key3 === "input" ? "type" : key3, param2[key3]);
    }
  }
  node.setAttribute("name", param2.signal);
  node.value = value4;
  el.appendChild(node);
  node.addEventListener("input", () => bind4.update(node.value));
  bind4.elements = [node];
  bind4.set = (value5) => node.value = value5;
}
function checkbox(bind4, el, param2, value4) {
  const attr3 = {
    type: "checkbox",
    name: param2.signal
  };
  if (value4)
    attr3.checked = true;
  const node = element3("input", attr3);
  el.appendChild(node);
  node.addEventListener("change", () => bind4.update(node.checked));
  bind4.elements = [node];
  bind4.set = (value5) => node.checked = !!value5 || null;
}
function select(bind4, el, param2, value4) {
  const node = element3("select", {
    name: param2.signal
  }), labels3 = param2.labels || [];
  param2.options.forEach((option, i) => {
    const attr3 = {
      value: option
    };
    if (valuesEqual(option, value4))
      attr3.selected = true;
    node.appendChild(element3("option", attr3, (labels3[i] || option) + ""));
  });
  el.appendChild(node);
  node.addEventListener("change", () => {
    bind4.update(param2.options[node.selectedIndex]);
  });
  bind4.elements = [node];
  bind4.set = (value5) => {
    for (let i = 0, n = param2.options.length; i < n; ++i) {
      if (valuesEqual(param2.options[i], value5)) {
        node.selectedIndex = i;
        return;
      }
    }
  };
}
function radio(bind4, el, param2, value4) {
  const group6 = element3("span", {
    "class": RadioClass
  }), labels3 = param2.labels || [];
  el.appendChild(group6);
  bind4.elements = param2.options.map((option, i) => {
    const attr3 = {
      type: "radio",
      name: param2.signal,
      value: option
    };
    if (valuesEqual(option, value4))
      attr3.checked = true;
    const input = element3("input", attr3);
    input.addEventListener("change", () => bind4.update(option));
    const label = element3("label", {}, (labels3[i] || option) + "");
    label.prepend(input);
    group6.appendChild(label);
    return input;
  });
  bind4.set = (value5) => {
    const nodes = bind4.elements, n = nodes.length;
    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value5))
        nodes[i].checked = true;
    }
  };
}
function range5(bind4, el, param2, value4) {
  value4 = value4 !== void 0 ? value4 : (+param2.max + +param2.min) / 2;
  const max8 = param2.max != null ? param2.max : Math.max(100, +value4) || 100, min8 = param2.min || Math.min(0, max8, +value4) || 0, step = param2.step || tickStep2(min8, max8, 100);
  const node = element3("input", {
    type: "range",
    name: param2.signal,
    min: min8,
    max: max8,
    step
  });
  node.value = value4;
  const span3 = element3("span", {}, +value4);
  el.appendChild(node);
  el.appendChild(span3);
  const update3 = () => {
    span3.textContent = node.value;
    bind4.update(+node.value);
  };
  node.addEventListener("input", update3);
  node.addEventListener("change", update3);
  bind4.elements = [node];
  bind4.set = (value5) => {
    node.value = value5;
    span3.textContent = value5;
  };
}
function valuesEqual(a4, b3) {
  return a4 === b3 || a4 + "" === b3 + "";
}
function initializeRenderer(view, r2, el, constructor, scaleFactor, opt) {
  r2 = r2 || new constructor(view.loader());
  return r2.initialize(el, width(view), height(view), offset4(view), scaleFactor, opt).background(view.background());
}
function trap(view, fn) {
  return !fn ? null : function() {
    try {
      fn.apply(this, arguments);
    } catch (error3) {
      view.error(error3);
    }
  };
}
function initializeHandler(view, prevHandler, el, constructor) {
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset4(view), view);
  if (prevHandler) {
    prevHandler.handlers().forEach((h4) => {
      handler.on(h4.type, h4.handler);
    });
  }
  return handler;
}
function initialize3(el, elBind) {
  const view = this, type4 = view._renderType, config = view._eventConfig.bind, module4 = renderModule(type4);
  el = view._el = el ? lookup5(view, el, true) : null;
  initializeAria(view);
  if (!module4)
    view.error("Unrecognized renderer type: " + type4);
  const Handler4 = module4.handler || CanvasHandler2, Renderer3 = el ? module4.renderer : module4.headless;
  view._renderer = !Renderer3 ? null : initializeRenderer(view, view._renderer, el, Renderer3);
  view._handler = initializeHandler(view, view._handler, el, Handler4);
  view._redraw = true;
  if (el && config !== "none") {
    elBind = elBind ? view._elBind = lookup5(view, elBind, true) : el.appendChild(element3("form", {
      "class": "vega-bindings"
    }));
    view._bind.forEach((_) => {
      if (_.param.element && config !== "container") {
        _.element = lookup5(view, _.param.element, !!_.param.input);
      }
    });
    view._bind.forEach((_) => {
      bind3(view, _.element || elBind, _);
    });
  }
  return view;
}
function lookup5(view, el, clear2) {
  if (typeof el === "string") {
    if (typeof document !== "undefined") {
      el = document.querySelector(el);
      if (!el) {
        view.error("Signal bind element not found: " + el);
        return null;
      }
    } else {
      view.error("DOM document instance not found.");
      return null;
    }
  }
  if (el && clear2) {
    try {
      el.innerHTML = "";
    } catch (e3) {
      el = null;
      view.error(e3);
    }
  }
  return el;
}
function padding(_) {
  return isObject(_) ? {
    top: number10(_.top),
    bottom: number10(_.bottom),
    left: number10(_.left),
    right: number10(_.right)
  } : paddingObject(number10(_));
}
async function renderHeadless(view, type4, scaleFactor, opt) {
  const module4 = renderModule(type4), ctr = module4 && module4.headless;
  if (!ctr)
    error("Unrecognized renderer type: " + type4);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}
async function renderToImageURL(type4, scaleFactor) {
  if (type4 !== RenderType.Canvas && type4 !== RenderType.SVG && type4 !== RenderType.PNG) {
    error("Unrecognized image type: " + type4);
  }
  const r2 = await renderHeadless(this, type4, scaleFactor);
  return type4 === RenderType.SVG ? toBlobURL(r2.svg(), "image/svg+xml") : r2.canvas().toDataURL("image/png");
}
function toBlobURL(data3, mime) {
  const blob = new Blob([data3], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}
async function renderToCanvas(scaleFactor, opt) {
  const r2 = await renderHeadless(this, RenderType.Canvas, scaleFactor, opt);
  return r2.canvas();
}
async function renderToSVG(scaleFactor) {
  const r2 = await renderHeadless(this, RenderType.SVG, scaleFactor);
  return r2.svg();
}
function runtime(view, spec, expr2) {
  return context3(view, transforms, functionContext, expr2).parse(spec);
}
function scale6(name4) {
  var scales3 = this._runtime.scales;
  if (!has(scales3, name4)) {
    error("Unrecognized scale or projection: " + name4);
  }
  return scales3[name4].value;
}
function viewWidth(view, width2) {
  var a4 = view.autosize(), p = view.padding();
  return width2 - (a4 && a4.contains === Padding2 ? p.left + p.right : 0);
}
function viewHeight(view, height2) {
  var a4 = view.autosize(), p = view.padding();
  return height2 - (a4 && a4.contains === Padding2 ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s3 = view._signals, w5 = s3[Width], h4 = s3[Height], p = s3[Padding2];
  function resetSize() {
    view._autosize = view._resize = 1;
  }
  view._resizeWidth = view.add(null, (_) => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w5
  });
  view._resizeHeight = view.add(null, (_) => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h4
  });
  const resizePadding = view.add(null, resetSize, {
    pad: p
  });
  view._resizeWidth.rank = w5.rank + 1;
  view._resizeHeight.rank = h4.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth2, viewHeight2, width2, height2, origin, auto) {
  this.runAfter((view) => {
    let rerun2 = 0;
    view._autosize = 0;
    if (view.width() !== width2) {
      rerun2 = 1;
      view.signal(Width, width2, Skip2);
      view._resizeWidth.skip(true);
    }
    if (view.height() !== height2) {
      rerun2 = 1;
      view.signal(Height, height2, Skip2);
      view._resizeHeight.skip(true);
    }
    if (view._viewWidth !== viewWidth2) {
      view._resize = 1;
      view._viewWidth = viewWidth2;
    }
    if (view._viewHeight !== viewHeight2) {
      view._resize = 1;
      view._viewHeight = viewHeight2;
    }
    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    }
    if (rerun2)
      view.run("enter");
    if (auto)
      view.runAfter((v) => v.resize());
  }, false, 1);
}
function getState2(options2) {
  return this._runtime.getState(options2 || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}
function dataTest(name4, data3) {
  return data3.modified && isArray(data3.input.value) && name4.indexOf("_:vega:_");
}
function signalTest(name4, op) {
  return !(name4 === "parent" || op instanceof transforms.proxy);
}
function setState2(state) {
  this.runAsync(null, (v) => {
    v._trigger = false;
    v._runtime.setState(state);
  }, (v) => {
    v._trigger = true;
  });
  return this;
}
function timer2(callback, delay) {
  function tick2(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed
    });
  }
  this._timers.push(interval_default(tick2, delay));
}
function defaultTooltip3(handler, event3, item, value4) {
  const el = handler.element();
  if (el)
    el.setAttribute("title", formatTooltip(value4));
}
function formatTooltip(value4) {
  return value4 == null ? "" : isArray(value4) ? formatArray(value4) : isObject(value4) && !isDate(value4) ? formatObject(value4) : value4 + "";
}
function formatObject(obj) {
  return Object.keys(obj).map((key3) => {
    const v = obj[key3];
    return key3 + ": " + (isArray(v) ? formatArray(v) : formatValue3(v));
  }).join("\n");
}
function formatArray(value4) {
  return "[" + value4.map(formatValue3).join(", ") + "]";
}
function formatValue3(value4) {
  return isArray(value4) ? "[]" : isObject(value4) && !isDate(value4) ? "{}" : value4;
}
function View(spec, options2) {
  const view = this;
  options2 = options2 || {};
  Dataflow.call(view);
  if (options2.loader)
    view.loader(options2.loader);
  if (options2.logger)
    view.logger(options2.logger);
  if (options2.logLevel != null)
    view.logLevel(options2.logLevel);
  if (options2.locale || spec.locale) {
    const loc = extend({}, spec.locale, options2.locale);
    view.locale(locale6(loc.number, loc.time));
  }
  view._el = null;
  view._elBind = null;
  view._renderType = options2.renderer || RenderType.Canvas;
  view._scenegraph = new Scenegraph2();
  const root2 = view._scenegraph.root;
  view._renderer = null;
  view._tooltip = options2.tooltip || defaultTooltip3, view._redraw = true;
  view._handler = new CanvasHandler2().scene(root2);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = [];
  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor);
  const ctx = runtime(view, spec, options2.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map((_) => ({
    state: null,
    param: extend({}, _)
  }));
  if (ctx.root)
    ctx.root.set(root2);
  root2.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root2.items));
  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view);
  background3(view);
  cursor(view);
  view.description(spec.description);
  if (options2.hover)
    view.hover();
  if (options2.container)
    view.initialize(options2.container, options2.bind);
}
function lookupSignal(view, name4) {
  return has(view._signals, name4) ? view._signals[name4] : error("Unrecognized signal name: " + $(name4));
}
function findOperatorHandler(op, handler) {
  const h4 = (op._targets || []).filter((op2) => op2._update && op2._update.handler === handler);
  return h4.length ? h4[0] : null;
}
function addOperatorListener(view, name4, op, handler) {
  let h4 = findOperatorHandler(op, handler);
  if (!h4) {
    h4 = trap(view, () => handler(name4, op.value));
    h4.handler = handler;
    view.on(op, null, h4);
  }
  return view;
}
function removeOperatorListener(view, op, handler) {
  const h4 = findOperatorHandler(op, handler);
  if (h4)
    op._targets.remove(h4);
  return view;
}
var Default, VIEW, TIMER, WINDOW, NO_TRAP, BindClass, NameClass, RadioClass, number10, paddingObject, Width, Height, Padding2, Skip2;
var init_vega_view_module = __esm({
  "node_modules/.pnpm/vega-view@5.10.1/node_modules/vega-view/build/vega-view.module.js"() {
    init_vega_util_module();
    init_vega_dataflow_module();
    init_vega_scenegraph_module2();
    init_src9();
    init_vega_functions_module();
    init_vega_runtime_module();
    init_src25();
    init_vega_format_module2();
    Default = "default";
    VIEW = "view";
    TIMER = "timer";
    WINDOW = "window";
    NO_TRAP = {
      trap: false
    };
    BindClass = "vega-bind";
    NameClass = "vega-bind-name";
    RadioClass = "vega-bind-radio";
    number10 = (_) => +_ || 0;
    paddingObject = (_) => ({
      top: _,
      bottom: _,
      left: _,
      right: _
    });
    Width = "width";
    Height = "height";
    Padding2 = "padding";
    Skip2 = {
      skip: true
    };
    inherits(View, Dataflow, {
      async evaluate(encode2, prerun, postrun) {
        await Dataflow.prototype.evaluate.call(this, encode2, prerun);
        if (this._redraw || this._resize) {
          try {
            if (this._renderer) {
              if (this._resize) {
                this._resize = 0;
                resizeRenderer(this);
              }
              await this._renderer.renderAsync(this._scenegraph.root);
            }
            this._redraw = false;
          } catch (e3) {
            this.error(e3);
          }
        }
        if (postrun)
          asyncCallback(this, postrun);
        return this;
      },
      dirty(item) {
        this._redraw = true;
        this._renderer && this._renderer.dirty(item);
      },
      description(text5) {
        if (arguments.length) {
          const desc = text5 != null ? text5 + "" : null;
          if (desc !== this._desc)
            ariaLabel(this._el, this._desc = desc);
          return this;
        }
        return this._desc;
      },
      container() {
        return this._el;
      },
      scenegraph() {
        return this._scenegraph;
      },
      origin() {
        return this._origin.slice();
      },
      signal(name4, value4, options2) {
        const op = lookupSignal(this, name4);
        return arguments.length === 1 ? op.value : this.update(op, value4, options2);
      },
      width(_) {
        return arguments.length ? this.signal("width", _) : this.signal("width");
      },
      height(_) {
        return arguments.length ? this.signal("height", _) : this.signal("height");
      },
      padding(_) {
        return arguments.length ? this.signal("padding", padding(_)) : padding(this.signal("padding"));
      },
      autosize(_) {
        return arguments.length ? this.signal("autosize", _) : this.signal("autosize");
      },
      background(_) {
        return arguments.length ? this.signal("background", _) : this.signal("background");
      },
      renderer(type4) {
        if (!arguments.length)
          return this._renderType;
        if (!renderModule(type4))
          error("Unrecognized renderer type: " + type4);
        if (type4 !== this._renderType) {
          this._renderType = type4;
          this._resetRenderer();
        }
        return this;
      },
      tooltip(handler) {
        if (!arguments.length)
          return this._tooltip;
        if (handler !== this._tooltip) {
          this._tooltip = handler;
          this._resetRenderer();
        }
        return this;
      },
      loader(loader3) {
        if (!arguments.length)
          return this._loader;
        if (loader3 !== this._loader) {
          Dataflow.prototype.loader.call(this, loader3);
          this._resetRenderer();
        }
        return this;
      },
      resize() {
        this._autosize = 1;
        return this.touch(lookupSignal(this, "autosize"));
      },
      _resetRenderer() {
        if (this._renderer) {
          this._renderer = null;
          this.initialize(this._el, this._elBind);
        }
      },
      _resizeView: resizeView,
      addEventListener(type4, handler, options2) {
        let callback = handler;
        if (!(options2 && options2.trap === false)) {
          callback = trap(this, handler);
          callback.raw = handler;
        }
        this._handler.on(type4, callback);
        return this;
      },
      removeEventListener(type4, handler) {
        var handlers = this._handler.handlers(type4), i = handlers.length, h4, t;
        while (--i >= 0) {
          t = handlers[i].type;
          h4 = handlers[i].handler;
          if (type4 === t && (handler === h4 || handler === h4.raw)) {
            this._handler.off(t, h4);
            break;
          }
        }
        return this;
      },
      addResizeListener(handler) {
        const l = this._resizeListeners;
        if (l.indexOf(handler) < 0) {
          l.push(handler);
        }
        return this;
      },
      removeResizeListener(handler) {
        var l = this._resizeListeners, i = l.indexOf(handler);
        if (i >= 0) {
          l.splice(i, 1);
        }
        return this;
      },
      addSignalListener(name4, handler) {
        return addOperatorListener(this, name4, lookupSignal(this, name4), handler);
      },
      removeSignalListener(name4, handler) {
        return removeOperatorListener(this, lookupSignal(this, name4), handler);
      },
      addDataListener(name4, handler) {
        return addOperatorListener(this, name4, dataref(this, name4).values, handler);
      },
      removeDataListener(name4, handler) {
        return removeOperatorListener(this, dataref(this, name4).values, handler);
      },
      globalCursor(_) {
        if (arguments.length) {
          if (this._globalCursor !== !!_) {
            const prev = setCursor(this, null);
            this._globalCursor = !!_;
            if (prev)
              setCursor(this, prev);
          }
          return this;
        } else {
          return this._globalCursor;
        }
      },
      preventDefault(_) {
        if (arguments.length) {
          this._preventDefault = _;
          return this;
        } else {
          return this._preventDefault;
        }
      },
      timer: timer2,
      events: events2,
      finalize,
      hover,
      data: data2,
      change,
      insert,
      remove,
      scale: scale6,
      initialize: initialize3,
      toImageURL: renderToImageURL,
      toCanvas: renderToCanvas,
      toSVG: renderToSVG,
      getState: getState2,
      setState: setState2
    });
  }
});

// node_modules/.pnpm/vega-event-selector@3.0.1/node_modules/vega-event-selector/build/vega-event-selector.module.js
function eventSelector(selector, source5, marks) {
  DEFAULT_SOURCE = source5 || VIEW2;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}
function isMarkType(type4) {
  return MARKS[type4];
}
function find3(s3, i, endChar, pushChar, popChar) {
  const n = s3.length;
  let count5 = 0, c2;
  for (; i < n; ++i) {
    c2 = s3[i];
    if (!count5 && c2 === endChar)
      return i;
    else if (popChar && popChar.indexOf(c2) >= 0)
      --count5;
    else if (pushChar && pushChar.indexOf(c2) >= 0)
      ++count5;
  }
  return i;
}
function parseMerge(s3) {
  const output3 = [], n = s3.length;
  let start = 0, i = 0;
  while (i < n) {
    i = find3(s3, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output3.push(s3.substring(start, i).trim());
    start = ++i;
  }
  if (output3.length === 0) {
    throw "Empty event selector: " + s3;
  }
  return output3;
}
function parseSelector(s3) {
  return s3[0] === "[" ? parseBetween(s3) : parseStream2(s3);
}
function parseBetween(s3) {
  const n = s3.length;
  let i = 1, b3;
  i = find3(s3, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw "Empty between selector: " + s3;
  }
  b3 = parseMerge(s3.substring(1, i));
  if (b3.length !== 2) {
    throw "Between selector must have two elements: " + s3;
  }
  s3 = s3.slice(i + 1).trim();
  if (s3[0] !== GT) {
    throw "Expected '>' after between selector: " + s3;
  }
  b3 = b3.map(parseSelector);
  const stream2 = parseSelector(s3.slice(1).trim());
  if (stream2.between) {
    return {
      between: b3,
      stream: stream2
    };
  } else {
    stream2.between = b3;
  }
  return stream2;
}
function parseStream2(s3) {
  const stream2 = {
    source: DEFAULT_SOURCE
  }, source5 = [];
  let throttle = [0, 0], markname = 0, start = 0, n = s3.length, i = 0, j, filter6;
  if (s3[n - 1] === RBRACE) {
    i = s3.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s3.substring(i + 1, n - 1));
      } catch (e3) {
        throw "Invalid throttle specification: " + s3;
      }
      s3 = s3.slice(0, i).trim();
      n = s3.length;
    } else
      throw "Unmatched right brace: " + s3;
    i = 0;
  }
  if (!n)
    throw s3;
  if (s3[0] === NAME)
    markname = ++i;
  j = find3(s3, i, COLON);
  if (j < n) {
    source5.push(s3.substring(start, j).trim());
    start = i = ++j;
  }
  i = find3(s3, i, LBRACK);
  if (i === n) {
    source5.push(s3.substring(start, n).trim());
  } else {
    source5.push(s3.substring(start, i).trim());
    filter6 = [];
    start = ++i;
    if (start === n)
      throw "Unmatched left bracket: " + s3;
  }
  while (i < n) {
    i = find3(s3, i, RBRACK);
    if (i === n)
      throw "Unmatched left bracket: " + s3;
    filter6.push(s3.substring(start, i).trim());
    if (i < n - 1 && s3[++i] !== LBRACK)
      throw "Expected left bracket: " + s3;
    start = ++i;
  }
  if (!(n = source5.length) || ILLEGAL2.test(source5[n - 1])) {
    throw "Invalid event selector: " + s3;
  }
  if (n > 1) {
    stream2.type = source5[1];
    if (markname) {
      stream2.markname = source5[0].slice(1);
    } else if (isMarkType(source5[0])) {
      stream2.marktype = source5[0];
    } else {
      stream2.source = source5[0];
    }
  } else {
    stream2.type = source5[0];
  }
  if (stream2.type.slice(-1) === "!") {
    stream2.consume = true;
    stream2.type = stream2.type.slice(0, -1);
  }
  if (filter6 != null)
    stream2.filter = filter6;
  if (throttle[0])
    stream2.throttle = throttle[0];
  if (throttle[1])
    stream2.debounce = throttle[1];
  return stream2;
}
function parseThrottle(s3) {
  const a4 = s3.split(COMMA);
  if (!s3.length || a4.length > 2)
    throw s3;
  return a4.map((_) => {
    const x7 = +_;
    if (x7 !== x7)
      throw s3;
    return x7;
  });
}
var VIEW2, LBRACK, RBRACK, LBRACE, RBRACE, COLON, COMMA, NAME, GT, ILLEGAL2, DEFAULT_MARKS, DEFAULT_SOURCE, MARKS;
var init_vega_event_selector_module = __esm({
  "node_modules/.pnpm/vega-event-selector@3.0.1/node_modules/vega-event-selector/build/vega-event-selector.module.js"() {
    VIEW2 = "view";
    LBRACK = "[";
    RBRACK = "]";
    LBRACE = "{";
    RBRACE = "}";
    COLON = ":";
    COMMA = ",";
    NAME = "@";
    GT = ">";
    ILLEGAL2 = /[[\]{}]/;
    DEFAULT_MARKS = {
      "*": 1,
      arc: 1,
      area: 1,
      group: 1,
      image: 1,
      line: 1,
      path: 1,
      rect: 1,
      rule: 1,
      shape: 1,
      symbol: 1,
      text: 1,
      trail: 1
    };
  }
});

// node_modules/.pnpm/vega-parser@6.1.4/node_modules/vega-parser/build/vega-parser.module.js
function parseAutosize(spec) {
  return isObject(spec) ? spec : {
    type: spec || "pad"
  };
}
function parsePadding(spec) {
  return !isObject(spec) ? paddingObject2(number11(spec)) : spec.signal ? spec : {
    top: number11(spec.top),
    bottom: number11(spec.bottom),
    left: number11(spec.left),
    right: number11(spec.right)
  };
}
function addEncode(object2, name4, value4, set8) {
  if (value4 != null) {
    const isEncoder = isObject(value4) && !isArray(value4) || isArray(value4) && value4.length && isObject(value4[0]);
    if (isEncoder) {
      object2.update[name4] = value4;
    } else {
      object2[set8 || "enter"][name4] = {
        value: value4
      };
    }
    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object2, enter, update3) {
  for (const name4 in enter) {
    addEncode(object2, name4, enter[name4]);
  }
  for (const name4 in update3) {
    addEncode(object2, name4, update3[name4], "update");
  }
}
function extendEncode(encode2, extra, skip) {
  for (const name4 in extra) {
    if (skip && has(skip, name4))
      continue;
    encode2[name4] = extend(encode2[name4] || {}, extra[name4]);
  }
  return encode2;
}
function has3(key3, encode2) {
  return encode2 && (encode2.enter && encode2.enter[key3] || encode2.update && encode2.update[key3]);
}
function applyDefaults(encode2, type4, role, style3, config) {
  const defaults2 = {}, enter = {};
  let update3, key3, skip, props;
  key3 = "lineBreak";
  if (type4 === "text" && config[key3] != null && !has3(key3, encode2)) {
    applyDefault(defaults2, key3, config[key3]);
  }
  if (role == "legend" || String(role).startsWith("axis")) {
    role = null;
  }
  props = role === FrameRole2 ? config.group : role === MarkRole ? extend({}, config.mark, config[type4]) : null;
  for (key3 in props) {
    skip = has3(key3, encode2) || (key3 === "fill" || key3 === "stroke") && (has3("fill", encode2) || has3("stroke", encode2));
    if (!skip)
      applyDefault(defaults2, key3, props[key3]);
  }
  array(style3).forEach((name4) => {
    const props2 = config.style && config.style[name4];
    for (const key4 in props2) {
      if (!has3(key4, encode2)) {
        applyDefault(defaults2, key4, props2[key4]);
      }
    }
  });
  encode2 = extend({}, encode2);
  for (key3 in defaults2) {
    props = defaults2[key3];
    if (props.signal) {
      (update3 = update3 || {})[key3] = props;
    } else {
      enter[key3] = props;
    }
  }
  encode2.enter = extend(enter, encode2.enter);
  if (update3)
    encode2.update = extend(update3, encode2.update);
  return encode2;
}
function applyDefault(defaults2, key3, value4) {
  defaults2[key3] = value4 && value4.signal ? {
    signal: value4.signal
  } : {
    value: value4
  };
}
function entry$1(enc) {
  if (enc.gradient != null) {
    return gradient3(enc);
  }
  let value4 = enc.signal ? `(${enc.signal})` : enc.color ? color5(enc.color) : enc.field != null ? field3(enc.field) : enc.value !== void 0 ? $(enc.value) : void 0;
  if (enc.scale != null) {
    value4 = scale7(enc, value4);
  }
  if (value4 === void 0) {
    value4 = null;
  }
  if (enc.exponent != null) {
    value4 = `pow(${value4},${property(enc.exponent)})`;
  }
  if (enc.mult != null) {
    value4 += `*${property(enc.mult)}`;
  }
  if (enc.offset != null) {
    value4 += `+${property(enc.offset)}`;
  }
  if (enc.round) {
    value4 = `round(${value4})`;
  }
  return value4;
}
function color5(enc) {
  return enc.c ? _color("hcl", enc.h, enc.c, enc.l) : enc.h || enc.s ? _color("hsl", enc.h, enc.s, enc.l) : enc.l || enc.a ? _color("lab", enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color("rgb", enc.r, enc.g, enc.b) : null;
}
function gradient3(enc) {
  const args = [enc.start, enc.stop, enc.count].map((_) => _ == null ? null : $(_));
  while (args.length && peek(args) == null)
    args.pop();
  args.unshift(scaleRef(enc.gradient));
  return `gradient(${args.join(",")})`;
}
function property(property2) {
  return isObject(property2) ? "(" + entry$1(property2) + ")" : property2;
}
function field3(ref2) {
  return resolveField(isObject(ref2) ? ref2 : {
    datum: ref2
  });
}
function resolveField(ref2) {
  let object2, level, field4;
  if (ref2.signal) {
    object2 = "datum";
    field4 = ref2.signal;
  } else if (ref2.group || ref2.parent) {
    level = Math.max(1, ref2.level || 1);
    object2 = "item";
    while (level-- > 0) {
      object2 += ".mark.group";
    }
    if (ref2.parent) {
      field4 = ref2.parent;
      object2 += ".datum";
    } else {
      field4 = ref2.group;
    }
  } else if (ref2.datum) {
    object2 = "datum";
    field4 = ref2.datum;
  } else {
    error("Invalid field reference: " + $(ref2));
  }
  if (!ref2.signal) {
    field4 = isString(field4) ? splitAccessPath(field4).map($).join("][") : resolveField(field4);
  }
  return object2 + "[" + field4 + "]";
}
function scale7(enc, value4) {
  const scale8 = scaleRef(enc.scale);
  if (enc.range != null) {
    value4 = `lerp(_range(${scale8}), ${+enc.range})`;
  } else {
    if (value4 !== void 0)
      value4 = `_scale(${scale8}, ${value4})`;
    if (enc.band) {
      value4 = (value4 ? value4 + "+" : "") + `_bandwidth(${scale8})` + (+enc.band === 1 ? "" : "*" + property(enc.band));
      if (enc.extra) {
        value4 = `(datum.extra ? _scale(${scale8}, datum.extra.value) : ${value4})`;
      }
    }
    if (value4 == null)
      value4 = "0";
  }
  return value4;
}
function rule3(enc) {
  let code = "";
  enc.forEach((rule5) => {
    const value4 = entry$1(rule5);
    code += rule5.test ? `(${rule5.test})?${value4}:` : value4;
  });
  if (peek(code) === ":") {
    code += "null";
  }
  return code;
}
function parseEncode(encode2, type4, role, style3, scope, params2) {
  const enc = {};
  params2 = params2 || {};
  params2.encoders = {
    $encode: enc
  };
  encode2 = applyDefaults(encode2, type4, role, style3, scope.config);
  for (const key3 in encode2) {
    enc[key3] = parseBlock(encode2[key3], type4, params2, scope);
  }
  return params2;
}
function parseBlock(block, marktype, params2, scope) {
  const channels = {}, fields = {};
  for (const name4 in block) {
    if (block[name4] != null) {
      channels[name4] = parse$1(expr(block[name4]), scope, params2, fields);
    }
  }
  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}
function expr(enc) {
  return isArray(enc) ? rule3(enc) : entry$1(enc);
}
function parse$1(code, scope, params2, fields) {
  const expr2 = parser2(code, scope);
  expr2.$fields.forEach((name4) => fields[name4] = 1);
  extend(params2, expr2.$params);
  return expr2.$expr;
}
function outerError(prefix, name4) {
  error(prefix + ' for "outer" push: ' + $(name4));
}
function parseSignal(signal, scope) {
  const name4 = signal.name;
  if (signal.push === OUTER) {
    if (!scope.signals[name4])
      outerError("No prior signal definition", name4);
    OUTER_INVALID.forEach((prop) => {
      if (signal[prop] !== void 0)
        outerError("Invalid property ", prop);
    });
  } else {
    const op = scope.addSignal(name4, signal.value);
    if (signal.react === false)
      op.react = false;
    if (signal.bind)
      scope.addBinding(name4, signal.bind);
  }
}
function Entry(type4, value4, params2, parent) {
  this.id = -1;
  this.type = type4;
  this.value = value4;
  this.params = params2;
  if (parent)
    this.parent = parent;
}
function entry(type4, value4, params2, parent) {
  return new Entry(type4, value4, params2, parent);
}
function operator(value4, params2) {
  return entry("operator", value4, params2);
}
function ref(op) {
  const ref2 = {
    $ref: op.id
  };
  if (op.id < 0)
    (op.refs = op.refs || []).push(ref2);
  return ref2;
}
function fieldRef$1(field4, name4) {
  return name4 ? {
    $field: field4,
    $name: name4
  } : {
    $field: field4
  };
}
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat) {
  const ref2 = {
    $key: fields
  };
  if (flat)
    ref2.$flat = true;
  return ref2;
}
function sortKey(sort5) {
  return !isObject(sort5) ? "" : (sort5.order === Descending ? "-" : "+") + aggrField(sort5.op, sort5.field);
}
function aggrField(op, field4) {
  return (op && op.signal ? "$" + op.signal : op || "") + (op && field4 ? "_" : "") + (field4 && field4.signal ? "$" + field4.signal : field4 || "");
}
function isSignal(_) {
  return _ && _.signal;
}
function isExpr$1(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_))
    return true;
  if (isObject(_))
    for (const key3 in _) {
      if (hasSignal(_[key3]))
        return true;
    }
  return false;
}
function value3(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v) {
  return v && v.signal || v;
}
function parseStream3(stream2, scope) {
  const method3 = stream2.merge ? mergeStream : stream2.stream ? nestedStream : stream2.type ? eventStream : error("Invalid stream specification: " + $(stream2));
  return method3(stream2, scope);
}
function eventSource(source5) {
  return source5 === Scope$1 ? View2 : source5 || View2;
}
function mergeStream(stream2, scope) {
  const list = stream2.merge.map((s3) => parseStream3(s3, scope)), entry2 = streamParameters({
    merge: list
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function nestedStream(stream2, scope) {
  const id4 = parseStream3(stream2.stream, scope), entry2 = streamParameters({
    stream: id4
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function eventStream(stream2, scope) {
  let id4;
  if (stream2.type === Timer2) {
    id4 = scope.event(Timer2, stream2.throttle);
    stream2 = {
      between: stream2.between,
      filter: stream2.filter
    };
  } else {
    id4 = scope.event(eventSource(stream2.source), stream2.type);
  }
  const entry2 = streamParameters({
    stream: id4
  }, stream2, scope);
  return Object.keys(entry2).length === 1 ? id4 : scope.addStream(entry2).id;
}
function streamParameters(entry2, stream2, scope) {
  let param2 = stream2.between;
  if (param2) {
    if (param2.length !== 2) {
      error('Stream "between" parameter must have 2 entries: ' + $(stream2));
    }
    entry2.between = [parseStream3(param2[0], scope), parseStream3(param2[1], scope)];
  }
  param2 = stream2.filter ? [].concat(stream2.filter) : [];
  if (stream2.marktype || stream2.markname || stream2.markrole) {
    param2.push(filterMark(stream2.marktype, stream2.markname, stream2.markrole));
  }
  if (stream2.source === Scope$1) {
    param2.push("inScope(event.item)");
  }
  if (param2.length) {
    entry2.filter = parser2("(" + param2.join(")&&(") + ")", scope).$expr;
  }
  if ((param2 = stream2.throttle) != null) {
    entry2.throttle = +param2;
  }
  if ((param2 = stream2.debounce) != null) {
    entry2.debounce = +param2;
  }
  if (stream2.consume) {
    entry2.consume = true;
  }
  return entry2;
}
function filterMark(type4, name4, role) {
  const item = "event.item";
  return item + (type4 && type4 !== "*" ? "&&" + item + ".mark.marktype==='" + type4 + "'" : "") + (role ? "&&" + item + ".mark.role==='" + role + "'" : "") + (name4 ? "&&" + item + ".mark.name==='" + name4 + "'" : "");
}
function parseUpdate2(spec, scope, target2) {
  const encode2 = spec.encode, entry2 = {
    target: target2
  };
  let events4 = spec.events, update3 = spec.update, sources = [];
  if (!events4) {
    error("Signal update missing events specification.");
  }
  if (isString(events4)) {
    events4 = eventSelector(events4, scope.isSubscope() ? Scope$1 : View2);
  }
  events4 = array(events4).filter((s3) => s3.signal || s3.scale ? (sources.push(s3), 0) : 1);
  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  }
  if (events4.length) {
    sources.push(events4.length > 1 ? {
      merge: events4
    } : events4[0]);
  }
  if (encode2 != null) {
    if (update3)
      error("Signal encode and update are mutually exclusive.");
    update3 = "encode(item()," + $(encode2) + ")";
  }
  entry2.update = isString(update3) ? parser2(update3, scope) : update3.expr != null ? parser2(update3.expr, scope) : update3.value != null ? update3.value : update3.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update3.signal)
    }
  } : error("Invalid signal update specification.");
  if (spec.force) {
    entry2.options = {
      force: true
    };
  }
  sources.forEach((source5) => scope.addUpdate(extend(streamSource(source5, scope), entry2)));
}
function streamSource(stream2, scope) {
  return {
    source: stream2.signal ? scope.signalRef(stream2.signal) : stream2.scale ? scope.scaleRef(stream2.scale) : parseStream3(stream2, scope)
  };
}
function mergeSources(sources) {
  return {
    signal: "[" + sources.map((s3) => s3.scale ? 'scale("' + s3.scale + '")' : s3.signal) + "]"
  };
}
function parseSignalUpdates(signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr2 = signal.update;
  if (signal.init) {
    if (expr2) {
      error("Signals can not include both init and update expressions.");
    } else {
      expr2 = signal.init;
      op.initonly = true;
    }
  }
  if (expr2) {
    expr2 = parser2(expr2, scope);
    op.update = expr2.$expr;
    op.params = expr2.$params;
  }
  if (signal.on) {
    signal.on.forEach((_) => parseUpdate2(_, scope, op.id));
  }
}
function initScale(spec, scope) {
  const type4 = spec.type || "linear";
  if (!isValidScaleType2(type4)) {
    error("Unrecognized scale type: " + $(type4));
  }
  scope.addScale(spec.name, {
    type: type4,
    domain: void 0
  });
}
function parseScale(spec, scope) {
  const params2 = scope.getScale(spec.name).params;
  let key3;
  params2.domain = parseScaleDomain(spec.domain, spec, scope);
  if (spec.range != null) {
    params2.range = parseScaleRange(spec, scope, params2);
  }
  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params2);
  }
  if (spec.nice != null) {
    params2.nice = parseScaleNice(spec.nice);
  }
  if (spec.bins != null) {
    params2.bins = parseScaleBins(spec.bins, scope);
  }
  for (key3 in spec) {
    if (has(params2, key3) || key3 === "name")
      continue;
    params2[key3] = parseLiteral(spec[key3], scope);
  }
}
function parseLiteral(v, scope) {
  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error("Unsupported object: " + $(v));
}
function parseArray(v, scope) {
  return v.signal ? scope.signalRef(v.signal) : v.map((v2) => parseLiteral(v2, scope));
}
function dataLookupError(name4) {
  error("Can not find data set: " + $(name4));
}
function parseScaleDomain(domain4, spec, scope) {
  if (!domain4) {
    if (spec.domainMin != null || spec.domainMax != null) {
      error("No scale domain defined for domainMin/domainMax to override.");
    }
    return;
  }
  return domain4.signal ? scope.signalRef(domain4.signal) : (isArray(domain4) ? explicitDomain : domain4.fields ? multipleDomain : singularDomain)(domain4, spec, scope);
}
function explicitDomain(domain4, spec, scope) {
  return domain4.map((v) => parseLiteral(v, scope));
}
function singularDomain(domain4, spec, scope) {
  const data3 = scope.getData(domain4.data);
  if (!data3)
    dataLookupError(domain4.data);
  return isDiscrete2(spec.type) ? data3.valuesRef(scope, domain4.field, parseSort(domain4.sort, false)) : isQuantile(spec.type) ? data3.domainRef(scope, domain4.field) : data3.extentRef(scope, domain4.field);
}
function multipleDomain(domain4, spec, scope) {
  const data3 = domain4.data, fields = domain4.fields.reduce((dom, d) => {
    d = isString(d) ? {
      data: data3,
      field: d
    } : isArray(d) || d.signal ? fieldRef(d, scope) : d;
    dom.push(d);
    return dom;
  }, []);
  return (isDiscrete2(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain4, scope, fields);
}
function fieldRef(data3, scope) {
  const name4 = "_:vega:_" + FIELD_REF_ID++, coll = Collect2({});
  if (isArray(data3)) {
    coll.value = {
      $ingest: data3
    };
  } else if (data3.signal) {
    const code = "setdata(" + $(name4) + "," + data3.signal + ")";
    coll.params.input = scope.signalRef(code);
  }
  scope.addDataPipeline(name4, [coll, Sieve2({})]);
  return {
    data: name4,
    field: "data"
  };
}
function ordinalMultipleDomain(domain4, scope, fields) {
  const sort5 = parseSort(domain4.sort, true);
  let a4, v;
  const counts = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.countsRef(scope, f.field, sort5);
  });
  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };
  if (sort5) {
    a4 = sort5.op || "count";
    v = sort5.field ? aggrField(a4, sort5.field) : "count";
    p.ops = [MULTIDOMAIN_SORT_OPS[a4]];
    p.fields = [scope.fieldRef(v)];
    p.as = [v];
  }
  a4 = scope.add(Aggregate2(p));
  const c2 = scope.add(Collect2({
    pulse: ref(a4)
  }));
  v = scope.add(Values2({
    field: keyFieldRef,
    sort: scope.sortRef(sort5),
    pulse: ref(c2)
  }));
  return ref(v);
}
function parseSort(sort5, multidomain) {
  if (sort5) {
    if (!sort5.field && !sort5.op) {
      if (isObject(sort5))
        sort5.field = "key";
      else
        sort5 = {
          field: "key"
        };
    } else if (!sort5.field && sort5.op !== "count") {
      error("No field provided for sort aggregate op: " + sort5.op);
    } else if (multidomain && sort5.field) {
      if (sort5.op && !MULTIDOMAIN_SORT_OPS[sort5.op]) {
        error("Multiple domain scales can not be sorted using " + sort5.op);
      }
    }
  }
  return sort5;
}
function quantileMultipleDomain(domain4, scope, fields) {
  const values5 = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.domainRef(scope, f.field);
  });
  return ref(scope.add(MultiValues2({
    values: values5
  })));
}
function numericMultipleDomain(domain4, scope, fields) {
  const extents = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.extentRef(scope, f.field);
  });
  return ref(scope.add(MultiExtent2({
    extents
  })));
}
function parseScaleBins(v, scope) {
  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);
}
function parseScaleNice(nice7) {
  return isObject(nice7) ? {
    interval: parseLiteral(nice7.interval),
    step: parseLiteral(nice7.step)
  } : parseLiteral(nice7);
}
function parseScaleInterpolate(interpolate4, params2) {
  params2.interpolate = parseLiteral(interpolate4.type || interpolate4);
  if (interpolate4.gamma != null) {
    params2.interpolateGamma = parseLiteral(interpolate4.gamma);
  }
}
function parseScaleRange(spec, scope, params2) {
  const config = scope.config.range;
  let range7 = spec.range;
  if (range7.signal) {
    return scope.signalRef(range7.signal);
  } else if (isString(range7)) {
    if (config && has(config, range7)) {
      spec = extend({}, spec, {
        range: config[range7]
      });
      return parseScaleRange(spec, scope, params2);
    } else if (range7 === "width") {
      range7 = [0, {
        signal: "width"
      }];
    } else if (range7 === "height") {
      range7 = isDiscrete2(spec.type) ? [0, {
        signal: "height"
      }] : [{
        signal: "height"
      }, 0];
    } else {
      error("Unrecognized scale range value: " + $(range7));
    }
  } else if (range7.scheme) {
    params2.scheme = isArray(range7.scheme) ? parseArray(range7.scheme, scope) : parseLiteral(range7.scheme, scope);
    if (range7.extent)
      params2.schemeExtent = parseArray(range7.extent, scope);
    if (range7.count)
      params2.schemeCount = parseLiteral(range7.count, scope);
    return;
  } else if (range7.step) {
    params2.rangeStep = parseLiteral(range7.step, scope);
    return;
  } else if (isDiscrete2(spec.type) && !isArray(range7)) {
    return parseScaleDomain(range7, spec, scope);
  } else if (!isArray(range7)) {
    error("Unsupported range type: " + $(range7));
  }
  return range7.map((v) => (isArray(v) ? parseArray : parseLiteral)(v, scope));
}
function parseProjection(proj, scope) {
  const config = scope.config.projection || {}, params2 = {};
  for (const name4 in proj) {
    if (name4 === "name")
      continue;
    params2[name4] = parseParameter$1(proj[name4], name4, scope);
  }
  for (const name4 in config) {
    if (params2[name4] == null) {
      params2[name4] = parseParameter$1(config[name4], name4, scope);
    }
  }
  scope.addProjection(proj.name, params2);
}
function parseParameter$1(_, name4, scope) {
  return isArray(_) ? _.map((_2) => parseParameter$1(_2, name4, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name4 === "fit" ? _ : error("Unsupported parameter object: " + $(_));
}
function guideGroup(mark) {
  mark.type = GroupMark;
  mark.interactive = mark.interactive || false;
  return mark;
}
function lookup6(spec, config) {
  const _ = (name4, dflt) => value3(spec[name4], value3(config[name4], dflt));
  _.isVertical = (s3) => Vertical === value3(spec.direction, config.direction || (s3 ? config.symbolDirection : config.gradientDirection));
  _.gradientLength = () => value3(spec.gradientLength, config.gradientLength || config.gradientWidth);
  _.gradientThickness = () => value3(spec.gradientThickness, config.gradientThickness || config.gradientHeight);
  _.entryColumns = () => value3(spec.columns, value3(config.columns, +_.isVertical(true)));
  return _;
}
function getEncoding(name4, encode2) {
  const v = encode2 && (encode2.update && encode2.update[name4] || encode2.enter && encode2.enter[name4]);
  return v && v.signal ? v : v ? v.value : null;
}
function getStyle(name4, scope, style3) {
  const s3 = scope.config.style[style3];
  return s3 && s3[name4];
}
function anchorExpr(s3, e3, m2) {
  return `item.anchor === '${Start2}' ? ${s3} : item.anchor === '${End2}' ? ${e3} : ${m2}`;
}
function tickBand(_) {
  const v = _("tickBand");
  let offset5 = _("tickOffset"), band5, extra;
  if (!v) {
    band5 = _("bandPosition");
    extra = _("tickExtra");
  } else if (v.signal) {
    band5 = {
      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`
    };
    extra = {
      signal: `(${v.signal}) === 'extent'`
    };
    if (!isObject(offset5)) {
      offset5 = {
        signal: `(${v.signal}) === 'extent' ? 0 : ${offset5}`
      };
    }
  } else if (v === "extent") {
    band5 = 1;
    extra = true;
    offset5 = 0;
  } else {
    band5 = 0.5;
    extra = false;
  }
  return {
    extra,
    band: band5,
    offset: offset5
  };
}
function extendOffset(value4, offset5) {
  return !offset5 ? value4 : !value4 ? offset5 : !isObject(value4) ? {
    value: value4,
    offset: offset5
  } : Object.assign({}, value4, {
    offset: extendOffset(value4.offset, offset5)
  });
}
function guideMark(mark, extras) {
  if (extras) {
    mark.name = extras.name;
    mark.style = extras.style || mark.style;
    mark.interactive = !!extras.interactive;
    mark.encode = extendEncode(mark.encode, extras, Skip3);
  } else {
    mark.interactive = false;
  }
  return mark;
}
function legendGradient(spec, scale8, config, userEncode) {
  const _ = lookup6(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length4 = _.gradientLength();
  let enter, start, stop2, width2, height2;
  if (vertical) {
    start = [0, 1];
    stop2 = [0, 0];
    width2 = thickness;
    height2 = length4;
  } else {
    start = [0, 0];
    stop2 = [1, 0];
    width2 = length4;
    height2 = thickness;
  }
  const encode2 = {
    enter: enter = {
      opacity: zero7,
      x: zero7,
      y: zero7,
      width: encoder(width2),
      height: encoder(height2)
    },
    update: extend({}, enter, {
      opacity: one5,
      fill: {
        gradient: scale8,
        start,
        stop: stop2
      }
    }),
    exit: {
      opacity: zero7
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode: encode2
  }, userEncode);
}
function legendGradientDiscrete(spec, scale8, config, userEncode, dataRef) {
  const _ = lookup6(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length4 = _.gradientLength();
  let u, v, uu, vv, adjust = "";
  vertical ? (u = "y", uu = "y2", v = "x", vv = "width", adjust = "1-") : (u = "x", uu = "x2", v = "y", vv = "height");
  const enter = {
    opacity: zero7,
    fill: {
      scale: scale8,
      field: Value
    }
  };
  enter[u] = {
    signal: adjust + "datum." + Perc,
    mult: length4
  };
  enter[v] = zero7;
  enter[uu] = {
    signal: adjust + "datum." + Perc2,
    mult: length4
  };
  enter[vv] = encoder(thickness);
  const encode2 = {
    enter,
    update: extend({}, enter, {
      opacity: one5
    }),
    exit: {
      opacity: zero7
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function legendGradientLabels(spec, config, userEncode, dataRef) {
  const _ = lookup6(spec, config), vertical = _.isVertical(), thickness = encoder(_.gradientThickness()), length4 = _.gradientLength();
  let overlap = _("labelOverlap"), enter, update3, u, v, adjust = "";
  const encode2 = {
    enter: enter = {
      opacity: zero7
    },
    update: update3 = {
      opacity: one5,
      text: {
        field: Label2
      }
    },
    exit: {
      opacity: zero7
    }
  };
  addEncoders(encode2, {
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: value3(spec.labelLimit, config.gradientLabelLimit)
  });
  if (vertical) {
    enter.align = {
      value: "left"
    };
    enter.baseline = update3.baseline = {
      signal: baselineExpr
    };
    u = "y";
    v = "x";
    adjust = "1-";
  } else {
    enter.align = update3.align = {
      signal: alignExpr
    };
    enter.baseline = {
      value: "top"
    };
    u = "x";
    v = "y";
  }
  enter[u] = update3[u] = {
    signal: adjust + "datum." + Perc,
    mult: length4
  };
  enter[v] = update3[v] = thickness;
  thickness.offset = value3(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum." + Index
  } : void 0;
  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function legendSymbolGroups(spec, config, userEncode, dataRef, columns) {
  const _ = lookup6(spec, config), entries3 = userEncode.entries, interactive2 = !!(entries3 && entries3.interactive), name4 = entries3 ? entries3.name : void 0, height2 = _("clipHeight"), symbolOffset = _("symbolOffset"), valueRef = {
    data: "value"
  }, xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`, yEncode = height2 ? encoder(height2) : {
    field: Size
  }, index8 = `datum.${Index}`, ncols = `max(1, ${columns})`;
  let encode2, enter, update3, nrows, sort5;
  yEncode.mult = 0.5;
  encode2 = {
    enter: enter = {
      opacity: zero7,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one5,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero7
    }
  };
  let baseFill = null, baseStroke = null;
  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }
  addEncoders(encode2, {
    fill: _("symbolFillColor", baseFill),
    shape: _("symbolType"),
    size: _("symbolSize"),
    stroke: _("symbolStrokeColor", baseStroke),
    strokeDash: _("symbolDash"),
    strokeDashOffset: _("symbolDashOffset"),
    strokeWidth: _("symbolStrokeWidth")
  }, {
    opacity: _("symbolOpacity")
  });
  LegendScales.forEach((scale8) => {
    if (spec[scale8]) {
      update3[scale8] = enter[scale8] = {
        scale: spec[scale8],
        field: Value
      };
    }
  });
  const symbols7 = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height2 ? true : void 0,
    encode: encode2
  }, userEncode.symbols);
  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _("labelOffset");
  encode2 = {
    enter: enter = {
      opacity: zero7,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one5,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero7
    }
  };
  addEncoders(encode2, {
    align: _("labelAlign"),
    baseline: _("labelBaseline"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: _("labelLimit")
  });
  const labels3 = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode: encode2
  }, userEncode.labels);
  encode2 = {
    enter: {
      noBound: {
        value: !height2
      },
      width: zero7,
      height: height2 ? encoder(height2) : zero7,
      opacity: zero7
    },
    exit: {
      opacity: zero7
    },
    update: update3 = {
      opacity: one5,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  };
  if (_.isVertical(true)) {
    nrows = `ceil(item.mark.items.length / ${ncols})`;
    update3.row.signal = `${index8}%${nrows}`;
    update3.column.signal = `floor(${index8} / ${nrows})`;
    sort5 = {
      field: ["row", index8]
    };
  } else {
    update3.row.signal = `floor(${index8} / ${ncols})`;
    update3.column.signal = `${index8} % ${ncols}`;
    sort5 = {
      field: index8
    };
  }
  update3.column.signal = `(${columns})?${update3.column.signal}:${index8}`;
  dataRef = {
    facet: {
      data: dataRef,
      name: "value",
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole2,
    from: dataRef,
    encode: extendEncode(encode2, entries3, Skip3),
    marks: [symbols7, labels3],
    name: name4,
    interactive: interactive2,
    sort: sort5
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup6(spec, config);
  return {
    align: _("gridAlign"),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _("rowPadding"),
      column: _("columnPadding")
    }
  };
}
function legendTitle(spec, config, userEncode, dataRef) {
  const _ = lookup6(spec, config);
  const encode2 = {
    enter: {
      opacity: zero7
    },
    update: {
      opacity: one5,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: zero7
    }
  };
  addEncoders(encode2, {
    orient: _("titleOrient"),
    _anchor: _("titleAnchor"),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    align: _("titleAlign"),
    baseline: _("titleBaseline")
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function clip3(clip4, scope) {
  let expr2;
  if (isObject(clip4)) {
    if (clip4.signal) {
      expr2 = clip4.signal;
    } else if (clip4.path) {
      expr2 = "pathShape(" + param(clip4.path) + ")";
    } else if (clip4.sphere) {
      expr2 = "geoShape(" + param(clip4.sphere) + ', {type: "Sphere"})';
    }
  }
  return expr2 ? scope.signalRef(expr2) : !!clip4;
}
function param(value4) {
  return isObject(value4) && value4.signal ? value4.signal : $(value4);
}
function getRole(spec) {
  const role = spec.role || "";
  return !role.indexOf("axis") || !role.indexOf("legend") || !role.indexOf("title") ? role : spec.type === GroupMark ? ScopeRole2 : role || MarkRole;
}
function definition2(spec) {
  return {
    marktype: spec.type,
    name: spec.name || void 0,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || void 0,
    aria: spec.aria,
    description: spec.description
  };
}
function interactive(spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}
function parseTransform(spec, scope) {
  const def3 = definition(spec.type);
  if (!def3)
    error("Unrecognized transform type: " + $(spec.type));
  const t = entry(def3.type.toLowerCase(), null, parseParameters2(def3, spec, scope));
  if (spec.signal)
    scope.addSignal(spec.signal, scope.proxy(t));
  t.metadata = def3.metadata || {};
  return t;
}
function parseParameters2(def3, spec, scope) {
  const params2 = {}, n = def3.params.length;
  for (let i = 0; i < n; ++i) {
    const pdef = def3.params[i];
    params2[pdef.name] = parseParameter2(pdef, spec, scope);
  }
  return params2;
}
function parseParameter2(def3, spec, scope) {
  const type4 = def3.type, value4 = spec[def3.name];
  if (type4 === "index") {
    return parseIndexParameter(def3, spec, scope);
  } else if (value4 === void 0) {
    if (def3.required) {
      error("Missing required " + $(spec.type) + " parameter: " + $(def3.name));
    }
    return;
  } else if (type4 === "param") {
    return parseSubParameters(def3, spec, scope);
  } else if (type4 === "projection") {
    return scope.projectionRef(spec[def3.name]);
  }
  return def3.array && !isSignal(value4) ? value4.map((v) => parameterValue(def3, v, scope)) : parameterValue(def3, value4, scope);
}
function parameterValue(def3, value4, scope) {
  const type4 = def3.type;
  if (isSignal(value4)) {
    return isExpr(type4) ? error("Expression references can not be signals.") : isField(type4) ? scope.fieldRef(value4) : isCompare(type4) ? scope.compareRef(value4) : scope.signalRef(value4.signal);
  } else {
    const expr2 = def3.expr || isField(type4);
    return expr2 && outerExpr(value4) ? scope.exprRef(value4.expr, value4.as) : expr2 && outerField(value4) ? fieldRef$1(value4.field, value4.as) : isExpr(type4) ? parser2(value4, scope) : isData(type4) ? ref(scope.getData(value4).values) : isField(type4) ? fieldRef$1(value4) : isCompare(type4) ? scope.compareRef(value4) : value4;
  }
}
function parseIndexParameter(def3, spec, scope) {
  if (!isString(spec.from)) {
    error('Lookup "from" parameter must be a string literal.');
  }
  return scope.getData(spec.from).lookupRef(scope, spec.key);
}
function parseSubParameters(def3, spec, scope) {
  const value4 = spec[def3.name];
  if (def3.array) {
    if (!isArray(value4)) {
      error("Expected an array of sub-parameters. Instead: " + $(value4));
    }
    return value4.map((v) => parseSubParameter(def3, v, scope));
  } else {
    return parseSubParameter(def3, value4, scope);
  }
}
function parseSubParameter(def3, value4, scope) {
  const n = def3.params.length;
  let pdef;
  for (let i = 0; i < n; ++i) {
    pdef = def3.params[i];
    for (const k4 in pdef.key) {
      if (pdef.key[k4] !== value4[k4]) {
        pdef = null;
        break;
      }
    }
    if (pdef)
      break;
  }
  if (!pdef)
    error("Unsupported parameter: " + $(value4));
  const params2 = extend(parseParameters2(pdef, value4, scope), pdef.key);
  return ref(scope.add(Params3(params2)));
}
function parseData$1(from, group6, scope) {
  let facet, key3, op, dataRef, parent;
  if (!from) {
    dataRef = ref(scope.add(Collect2(null, [{}])));
  } else if (facet = from.facet) {
    if (!group6)
      error("Only group marks can be faceted.");
    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      if (!from.data) {
        op = parseTransform(extend({
          type: "aggregate",
          groupby: array(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from.data).aggregate);
      }
      key3 = scope.keyRef(facet.groupby, true);
    }
  }
  if (!dataRef) {
    dataRef = getDataRef(from, scope);
  }
  return {
    key: key3,
    pulse: dataRef,
    parent
  };
}
function getDataRef(from, scope) {
  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
}
function DataScope(scope, input, output3, values5, aggr) {
  this.scope = scope;
  this.input = input;
  this.output = output3;
  this.values = values5;
  this.aggregate = aggr;
  this.index = {};
}
function fieldKey(field4) {
  return isString(field4) ? field4 : null;
}
function addSortField(scope, p, sort5) {
  const as = aggrField(sort5.op, sort5.field);
  let s3;
  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as)
        return;
    }
  } else {
    p.ops = ["count"];
    p.fields = [null];
    p.as = ["count"];
  }
  if (sort5.op) {
    p.ops.push((s3 = sort5.op.signal) ? scope.signalRef(s3) : sort5.op);
    p.fields.push(scope.fieldRef(sort5.field));
    p.as.push(as);
  }
}
function cache(scope, ds, name4, optype, field4, counts, index8) {
  const cache3 = ds[name4] || (ds[name4] = {}), sort5 = sortKey(counts);
  let k4 = fieldKey(field4), v, op;
  if (k4 != null) {
    scope = ds.scope;
    k4 = k4 + (sort5 ? "|" + sort5 : "");
    v = cache3[k4];
  }
  if (!v) {
    const params2 = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field4, counts)
    } : {
      field: scope.fieldRef(field4),
      pulse: ref(ds.output)
    };
    if (sort5)
      params2.sort = scope.sortRef(counts);
    op = scope.add(entry(optype, void 0, params2));
    if (index8)
      ds.index[field4] = op;
    v = ref(op);
    if (k4 != null)
      cache3[k4] = v;
  }
  return v;
}
function parseFacet(spec, scope, group6) {
  const facet = spec.from.facet, name4 = facet.name, data3 = getDataRef(facet, scope);
  let op;
  if (!facet.name) {
    error("Facet must have a name: " + $(facet));
  }
  if (!facet.data) {
    error("Facet must reference a data set: " + $(facet));
  }
  if (facet.field) {
    op = scope.add(PreFacet2({
      field: scope.fieldRef(facet.field),
      pulse: data3
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet2({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group6.parent)),
      pulse: data3
    }));
  } else {
    error("Facet must specify groupby or field: " + $(facet));
  }
  const subscope = scope.fork(), source5 = subscope.add(Collect2()), values5 = subscope.add(Sieve2({
    pulse: ref(source5)
  }));
  subscope.addData(name4, new DataScope(subscope, source5, source5, values5));
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseSubflow(spec, scope, input) {
  const op = scope.add(PreFacet2({
    pulse: input.pulse
  })), subscope = scope.fork();
  subscope.add(Sieve2());
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseTrigger(spec, scope, name4) {
  const remove3 = spec.remove, insert2 = spec.insert, toggle2 = spec.toggle, modify2 = spec.modify, values5 = spec.values, op = scope.add(operator());
  const update3 = "if(" + spec.trigger + ',modify("' + name4 + '",' + [insert2, remove3, toggle2, modify2, values5].map((_) => _ == null ? "null" : _).join(",") + "),0)";
  const expr2 = parser2(update3, scope);
  op.update = expr2.$expr;
  op.params = expr2.$params;
}
function parseMark(spec, scope) {
  const role = getRole(spec), group6 = spec.type === GroupMark, facet = spec.from && spec.from.facet, overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole2 || role === FrameRole2, ops2, op, store, enc, name4, layoutRef, boundRef;
  const nested = role === MarkRole || layout || facet;
  const input = parseData$1(spec.from, group6, scope);
  op = scope.add(DataJoin2({
    key: input.key || (spec.key ? fieldRef$1(spec.key) : void 0),
    pulse: input.pulse,
    clean: !group6
  }));
  const joinRef = ref(op);
  op = store = scope.add(Collect2({
    pulse: joinRef
  }));
  op = scope.add(Mark2({
    markdef: definition2(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip3(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef("parent") : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op);
  op = enc = scope.add(Encode2(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  })));
  op.params.parent = scope.encode();
  if (spec.transform) {
    spec.transform.forEach((_) => {
      const tx = parseTransform(_, scope), md3 = tx.metadata;
      if (md3.generates || md3.changes) {
        error("Mark transforms should not generate new data.");
      }
      if (!md3.nomod)
        enc.params.mod = true;
      tx.params.pulse = ref(op);
      scope.add(op = tx);
    });
  }
  if (spec.sort) {
    op = scope.add(SortItems2({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }
  const encodeRef = ref(op);
  if (facet || layout) {
    layout = scope.add(ViewLayout2({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  }
  const bound3 = scope.add(Bound2({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound3);
  if (group6) {
    if (nested) {
      ops2 = scope.operators;
      ops2.pop();
      if (layout)
        ops2.pop();
    }
    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) : nested ? parseSubflow(spec, scope, input) : scope.parse(spec);
    scope.popState();
    if (nested) {
      if (layout)
        ops2.push(layout);
      ops2.push(bound3);
    }
  }
  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  }
  const render3 = scope.add(Render2({
    pulse: boundRef
  })), sieve = scope.add(Sieve2({
    pulse: ref(render3)
  }, void 0, scope.parent()));
  if (spec.name != null) {
    name4 = spec.name;
    scope.addData(name4, new DataScope(scope, store, render3, sieve));
    if (spec.on)
      spec.on.forEach((on2) => {
        if (on2.insert || on2.remove || on2.toggle) {
          error("Marks only support modify triggers.");
        }
        parseTrigger(on2, scope, name4);
      });
  }
}
function parseOverlap(overlap, source5, scope) {
  const method3 = overlap.method, bound3 = overlap.bound, sep = overlap.separation;
  const params2 = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method3) ? scope.signalRef(method3.signal) : method3,
    pulse: source5
  };
  if (overlap.order) {
    params2.sort = scope.compareRef({
      field: overlap.order
    });
  }
  if (bound3) {
    const tol = bound3.tolerance;
    params2.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params2.boundScale = scope.scaleRef(bound3.scale);
    params2.boundOrient = bound3.orient;
  }
  return ref(scope.add(Overlap2(params2)));
}
function parseLegend(spec, scope) {
  const config = scope.config.legend, encode2 = spec.encode || {}, _ = lookup6(spec, config), legendEncode = encode2.legend || {}, name4 = legendEncode.name || void 0, interactive2 = legendEncode.interactive, style3 = legendEncode.style, scales3 = {};
  let scale8 = 0, entryLayout, params2, children5;
  LegendScales.forEach((s3) => spec[s3] ? (scales3[s3] = spec[s3], scale8 = scale8 || spec[s3]) : 0);
  if (!scale8)
    error("Missing valid scale for legend.");
  const type4 = legendType(spec, scope.scaleType(scale8));
  const datum2 = {
    title: spec.title != null,
    scales: scales3,
    type: type4,
    vgrad: type4 !== "symbol" && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect2(null, [datum2])));
  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  };
  const entryRef = ref(scope.add(LegendEntries2(params2 = {
    type: type4,
    scale: scope.scaleRef(scale8),
    count: scope.objectProperty(_("tickCount")),
    limit: scope.property(_("symbolLimit")),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  if (type4 === Gradient2) {
    children5 = [legendGradient(spec, scale8, config, encode2.gradient), legendGradientLabels(spec, config, encode2.labels, entryRef)];
    params2.count = params2.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);
  } else if (type4 === Discrete3) {
    children5 = [legendGradientDiscrete(spec, scale8, config, encode2.gradient, entryRef), legendGradientLabels(spec, config, encode2.labels, entryRef)];
  } else {
    entryLayout = legendSymbolLayout(spec, config);
    children5 = [legendSymbolGroups(spec, config, encode2, entryRef, deref(entryLayout.columns))];
    params2.size = sizeExpression(spec, scope, children5[0].marks);
  }
  children5 = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children5,
    layout: entryLayout,
    interactive: interactive2
  })];
  if (datum2.title) {
    children5.push(legendTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: LegendRole2,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip3),
    marks: children5,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name4,
    interactive: interactive2,
    style: style3
  }), scope);
}
function legendType(spec, scaleType2) {
  let type4 = spec.type || Symbols2;
  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type4 = isContinuous(scaleType2) ? Gradient2 : isDiscretizing2(scaleType2) ? Discrete3 : Symbols2;
  }
  return type4 !== Gradient2 ? type4 : isDiscretizing2(scaleType2) ? Discrete3 : Gradient2;
}
function scaleCount(spec) {
  return LegendScales.reduce((count5, type4) => count5 + (spec[type4] ? 1 : 0), 0);
}
function buildLegendEncode(_, spec, config) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset"),
    padding: _("padding"),
    titlePadding: _("titlePadding"),
    cornerRadius: _("cornerRadius"),
    fill: _("fillColor"),
    stroke: _("strokeColor"),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _("legendX"),
    y: _("legendY"),
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel("size", spec, marks)), strokeWidth = deref(getChannel("strokeWidth", spec, marks)), fontSize3 = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return parser2(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize3})`, scope);
}
function getChannel(name4, spec, marks) {
  return spec[name4] ? `scale("${spec[name4]}",datum)` : getEncoding(name4, marks[0].encode);
}
function getFontSize(encode2, scope, style3) {
  return getEncoding("fontSize", encode2) || getStyle("fontSize", scope, style3);
}
function parseTitle(spec, scope) {
  spec = isString(spec) ? {
    text: spec
  } : spec;
  const _ = lookup6(spec, scope.config.title), encode2 = spec.encode || {}, userEncode = encode2.group || {}, name4 = userEncode.name || void 0, interactive2 = userEncode.interactive, style3 = userEncode.style, children5 = [];
  const datum2 = {}, dataRef = ref(scope.add(Collect2(null, [datum2])));
  children5.push(buildTitle(spec, _, titleEncode(spec), dataRef));
  if (spec.subtitle) {
    children5.push(buildSubTitle(spec, _, encode2.subtitle, dataRef));
  }
  return parseMark(guideGroup({
    role: TitleRole2,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children5,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name4,
    interactive: interactive2,
    style: style3
  }), scope);
}
function titleEncode(spec) {
  const encode2 = spec.encode;
  return encode2 && encode2.title || extend({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode2);
}
function groupEncode(_, userEncode) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    anchor: _("anchor"),
    align: {
      signal: alignExpr$1
    },
    angle: {
      signal: angleExpr
    },
    limit: _("limit"),
    frame: _("frame"),
    offset: _("offset") || 0,
    padding: _("subtitlePadding")
  });
  return extendEncode(encode2, userEncode, Skip3);
}
function buildTitle(spec, _, userEncode, dataRef) {
  const zero10 = {
    value: 0
  }, text5 = spec.text, encode2 = {
    enter: {
      opacity: zero10
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero10
    }
  };
  addEncoders(encode2, {
    text: text5,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("color"),
    font: _("font"),
    fontSize: _("fontSize"),
    fontStyle: _("fontStyle"),
    fontWeight: _("fontWeight"),
    lineHeight: _("lineHeight")
  }, {
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero10 = {
    value: 0
  }, text5 = spec.subtitle, encode2 = {
    enter: {
      opacity: zero10
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero10
    }
  };
  addEncoders(encode2, {
    text: text5,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("subtitleColor"),
    font: _("subtitleFont"),
    fontSize: _("subtitleFontSize"),
    fontStyle: _("subtitleFontStyle"),
    fontWeight: _("subtitleFontWeight"),
    lineHeight: _("subtitleLineHeight")
  }, {
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function parseData(data3, scope) {
  const transforms2 = [];
  if (data3.transform) {
    data3.transform.forEach((tx) => {
      transforms2.push(parseTransform(tx, scope));
    });
  }
  if (data3.on) {
    data3.on.forEach((on2) => {
      parseTrigger(on2, scope, data3.name);
    });
  }
  scope.addDataPipeline(data3.name, analyze(data3, scope, transforms2));
}
function analyze(data3, scope, ops2) {
  const output3 = [];
  let source5 = null, modify2 = false, generate3 = false, upstream, i, n, t, m2;
  if (data3.values) {
    if (isSignal(data3.values) || hasSignal(data3.format)) {
      output3.push(load3(scope, data3));
      output3.push(source5 = collect());
    } else {
      output3.push(source5 = collect({
        $ingest: data3.values,
        $format: data3.format
      }));
    }
  } else if (data3.url) {
    if (hasSignal(data3.url) || hasSignal(data3.format)) {
      output3.push(load3(scope, data3));
      output3.push(source5 = collect());
    } else {
      output3.push(source5 = collect({
        $request: data3.url,
        $format: data3.format
      }));
    }
  } else if (data3.source) {
    source5 = upstream = array(data3.source).map((d) => ref(scope.getData(d).output));
    output3.push(null);
  }
  for (i = 0, n = ops2.length; i < n; ++i) {
    t = ops2[i];
    m2 = t.metadata;
    if (!source5 && !m2.source) {
      output3.push(source5 = collect());
    }
    output3.push(t);
    if (m2.generates)
      generate3 = true;
    if (m2.modifies && !generate3)
      modify2 = true;
    if (m2.source)
      source5 = t;
    else if (m2.changes)
      source5 = null;
  }
  if (upstream) {
    n = upstream.length - 1;
    output3[0] = Relay2({
      derive: modify2,
      pulse: n ? upstream : upstream[0]
    });
    if (modify2 || n) {
      output3.splice(1, 0, collect());
    }
  }
  if (!source5)
    output3.push(collect());
  output3.push(Sieve2({}));
  return output3;
}
function collect(values5) {
  const s3 = Collect2({}, values5);
  s3.metadata = {
    source: true
  };
  return s3;
}
function load3(scope, data3) {
  return Load2({
    url: data3.url ? scope.property(data3.url) : void 0,
    async: data3.async ? scope.property(data3.async) : void 0,
    values: data3.values ? scope.property(data3.values) : void 0,
    format: scope.objectProperty(data3.format)
  });
}
function fallback(prop, config, axisConfig2, style3) {
  let styleProp;
  if (config && has(config, prop)) {
    return config[prop];
  } else if (has(axisConfig2, prop)) {
    return axisConfig2[prop];
  } else if (prop.startsWith("title")) {
    switch (prop) {
      case "titleColor":
        styleProp = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style3[GuideTitleStyle][styleProp];
  } else if (prop.startsWith("label")) {
    switch (prop) {
      case "labelColor":
        styleProp = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style3[GuideLabelStyle][styleProp];
  }
  return null;
}
function keys3(objects) {
  const map11 = {};
  for (const obj of objects) {
    if (!obj)
      continue;
    for (const key3 in obj)
      map11[key3] = 1;
  }
  return Object.keys(map11);
}
function axisConfig(spec, scope) {
  var config = scope.config, style3 = config.style, axis = config.axis, band5 = scope.scaleType(spec.scale) === "band" && config.axisBand, orient3 = spec.orient, xy, or3, key3;
  if (isSignal(orient3)) {
    const xyKeys = keys3([config.axisX, config.axisY]), orientKeys = keys3([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};
    for (key3 of xyKeys) {
      xy[key3] = ifX(orient3, fallback(key3, config.axisX, axis, style3), fallback(key3, config.axisY, axis, style3));
    }
    or3 = {};
    for (key3 of orientKeys) {
      or3[key3] = ifOrient(orient3.signal, fallback(key3, config.axisTop, axis, style3), fallback(key3, config.axisBottom, axis, style3), fallback(key3, config.axisLeft, axis, style3), fallback(key3, config.axisRight, axis, style3));
    }
  } else {
    xy = orient3 === Top2 || orient3 === Bottom2 ? config.axisX : config.axisY;
    or3 = config["axis" + orient3[0].toUpperCase() + orient3.slice(1)];
  }
  const result = xy || or3 || band5 ? extend({}, axis, xy, or3, band5) : axis;
  return result;
}
function axisDomain(spec, config, userEncode, dataRef) {
  const _ = lookup6(spec, config), orient3 = spec.orient;
  let enter, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero7
    },
    update: update3 = {
      opacity: one5
    },
    exit: {
      opacity: zero7
    }
  };
  addEncoders(encode2, {
    stroke: _("domainColor"),
    strokeCap: _("domainCap"),
    strokeDash: _("domainDash"),
    strokeDashOffset: _("domainDashOffset"),
    strokeWidth: _("domainWidth"),
    strokeOpacity: _("domainOpacity")
  });
  const pos0 = position(spec, 0);
  const pos1 = position(spec, 1);
  enter.x = update3.x = ifX(orient3, pos0, zero7);
  enter.x2 = update3.x2 = ifX(orient3, pos1);
  enter.y = update3.y = ifY(orient3, pos0, zero7);
  enter.y2 = update3.y2 = ifY(orient3, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function position(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}
function axisGrid(spec, config, userEncode, dataRef, band5) {
  const _ = lookup6(spec, config), orient3 = spec.orient, vscale = spec.gridScale, sign5 = getSign(orient3, 1, -1), offset5 = offsetValue2(spec.offset, sign5);
  let enter, exit, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero7
    },
    update: update3 = {
      opacity: one5
    },
    exit: exit = {
      opacity: zero7
    }
  };
  addEncoders(encode2, {
    stroke: _("gridColor"),
    strokeCap: _("gridCap"),
    strokeDash: _("gridDash"),
    strokeDashOffset: _("gridDashOffset"),
    strokeOpacity: _("gridOpacity"),
    strokeWidth: _("gridWidth")
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band5.band,
    extra: band5.extra,
    offset: band5.offset,
    round: _("tickRound")
  };
  const sz3 = ifX(orient3, {
    signal: "height"
  }, {
    signal: "width"
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign5,
    offset: offset5
  } : {
    value: 0,
    offset: offset5
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign5,
    offset: offset5
  } : extend(sz3, {
    mult: sign5,
    offset: offset5
  });
  enter.x = update3.x = ifX(orient3, tickPos, gridStart);
  enter.y = update3.y = ifY(orient3, tickPos, gridStart);
  enter.x2 = update3.x2 = ifY(orient3, gridEnd);
  enter.y2 = update3.y2 = ifX(orient3, gridEnd);
  exit.x = ifX(orient3, tickPos);
  exit.y = ifY(orient3, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function offsetValue2(offset5, sign5) {
  if (sign5 === 1)
    ;
  else if (!isObject(offset5)) {
    offset5 = isSignal(sign5) ? {
      signal: `(${sign5.signal}) * (${offset5 || 0})`
    } : sign5 * (offset5 || 0);
  } else {
    let entry2 = offset5 = extend({}, offset5);
    while (entry2.mult != null) {
      if (!isObject(entry2.mult)) {
        entry2.mult = isSignal(sign5) ? {
          signal: `(${entry2.mult}) * (${sign5.signal})`
        } : entry2.mult * sign5;
        return offset5;
      } else {
        entry2 = entry2.mult = extend({}, entry2.mult);
      }
    }
    entry2.mult = sign5;
  }
  return offset5;
}
function axisTicks(spec, config, userEncode, dataRef, size, band5) {
  const _ = lookup6(spec, config), orient3 = spec.orient, sign5 = getSign(orient3, -1, 1);
  let enter, exit, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero7
    },
    update: update3 = {
      opacity: one5
    },
    exit: exit = {
      opacity: zero7
    }
  };
  addEncoders(encode2, {
    stroke: _("tickColor"),
    strokeCap: _("tickCap"),
    strokeDash: _("tickDash"),
    strokeDashOffset: _("tickDashOffset"),
    strokeOpacity: _("tickOpacity"),
    strokeWidth: _("tickWidth")
  });
  const tickSize = encoder(size);
  tickSize.mult = sign5;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band5.band,
    extra: band5.extra,
    offset: band5.offset,
    round: _("tickRound")
  };
  update3.y = enter.y = ifX(orient3, zero7, tickPos);
  update3.y2 = enter.y2 = ifX(orient3, tickSize);
  exit.x = ifX(orient3, tickPos);
  update3.x = enter.x = ifY(orient3, zero7, tickPos);
  update3.x2 = enter.x2 = ifY(orient3, tickSize);
  exit.y = ifY(orient3, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function flushExpr(scale8, threshold3, a4, b3, c2) {
  return {
    signal: 'flush(range("' + scale8 + '"), scale("' + scale8 + '", datum.value), ' + threshold3 + "," + a4 + "," + b3 + "," + c2 + ")"
  };
}
function axisLabels(spec, config, userEncode, dataRef, size, band5) {
  const _ = lookup6(spec, config), orient3 = spec.orient, scale8 = spec.scale, sign5 = getSign(orient3, -1, 1), flush2 = deref(_("labelFlush")), flushOffset = deref(_("labelFlushOffset")), labelAlign = _("labelAlign"), labelBaseline = _("labelBaseline");
  let flushOn = flush2 === 0 || !!flush2, update3;
  const tickSize = encoder(size);
  tickSize.mult = sign5;
  tickSize.offset = encoder(_("labelPadding") || 0);
  tickSize.offset.mult = sign5;
  const tickPos = {
    scale: scale8,
    field: Value,
    band: 0.5,
    offset: extendOffset(band5.offset, _("labelOffset"))
  };
  const align2 = ifX(orient3, flushOn ? flushExpr(scale8, flush2, '"left"', '"right"', '"center"') : {
    value: "center"
  }, ifRight(orient3, "left", "right"));
  const baseline3 = ifX(orient3, ifTop(orient3, "bottom", "top"), flushOn ? flushExpr(scale8, flush2, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  });
  const offsetExpr = flushExpr(scale8, flush2, `-(${flushOffset})`, flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero7,
    x: ifX(orient3, tickPos, tickSize),
    y: ifY(orient3, tickPos, tickSize)
  };
  const encode2 = {
    enter,
    update: update3 = {
      opacity: one5,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y,
      align: align2,
      baseline: baseline3
    },
    exit: {
      opacity: zero7,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode2, {
    dx: !labelAlign && flushOn ? ifX(orient3, offsetExpr) : null,
    dy: !labelBaseline && flushOn ? ifY(orient3, offsetExpr) : null
  });
  addEncoders(encode2, {
    angle: _("labelAngle"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontWeight: _("labelFontWeight"),
    fontStyle: _("labelFontStyle"),
    limit: _("labelLimit"),
    lineHeight: _("labelLineHeight")
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });
  const bound3 = _("labelBound");
  let overlap = _("labelOverlap");
  overlap = overlap || bound3 ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum.index",
    bound: bound3 ? {
      scale: scale8,
      orient: orient3,
      tolerance: bound3
    } : null
  } : void 0;
  if (update3.align !== align2) {
    update3.align = patch(update3.align, align2);
  }
  if (update3.baseline !== baseline3) {
    update3.baseline = patch(update3.baseline, baseline3);
  }
  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function axisTitle(spec, config, userEncode, dataRef) {
  const _ = lookup6(spec, config), orient3 = spec.orient, sign5 = getSign(orient3, -1, 1);
  let enter, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero7,
      anchor: encoder(_("titleAnchor", null)),
      align: {
        signal: alignExpr$1
      }
    },
    update: update3 = extend({}, enter, {
      opacity: one5,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero7
    }
  };
  const titlePos = {
    signal: `lerp(range("${spec.scale}"), ${anchorExpr(0, 1, 0.5)})`
  };
  update3.x = ifX(orient3, titlePos);
  update3.y = ifY(orient3, titlePos);
  enter.angle = ifX(orient3, zero7, mult(sign5, 90));
  enter.baseline = ifX(orient3, ifTop(orient3, Bottom2, Top2), {
    value: Bottom2
  });
  update3.angle = enter.angle;
  update3.baseline = enter.baseline;
  addEncoders(encode2, {
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    align: _("titleAlign"),
    angle: _("titleAngle"),
    baseline: _("titleBaseline")
  });
  autoLayout(_, orient3, encode2, userEncode);
  encode2.update.align = patch(encode2.update.align, enter.align);
  encode2.update.angle = patch(encode2.update.angle, enter.angle);
  encode2.update.baseline = patch(encode2.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function autoLayout(_, orient3, encode2, userEncode) {
  const auto = (value4, dim) => value4 != null ? (encode2.update[dim] = patch(encoder(value4), encode2.update[dim]), false) : !has3(dim, userEncode) ? true : false;
  const autoY = auto(_("titleX"), "x"), autoX = auto(_("titleY"), "y");
  encode2.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient3, encoder(autoX), encoder(autoY));
}
function parseAxis(spec, scope) {
  const config = axisConfig(spec, scope), encode2 = spec.encode || {}, axisEncode = encode2.axis || {}, name4 = axisEncode.name || void 0, interactive2 = axisEncode.interactive, style3 = axisEncode.style, _ = lookup6(spec, config), band5 = tickBand(_);
  const datum2 = {
    scale: spec.scale,
    ticks: !!_("ticks"),
    labels: !!_("labels"),
    grid: !!_("grid"),
    domain: !!_("domain"),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect2({}, [datum2])));
  const ticksRef = ref(scope.add(AxisTicks2({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band5.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  const children5 = [];
  let size;
  if (datum2.grid) {
    children5.push(axisGrid(spec, config, encode2.grid, ticksRef, band5));
  }
  if (datum2.ticks) {
    size = _("tickSize");
    children5.push(axisTicks(spec, config, encode2.ticks, ticksRef, size, band5));
  }
  if (datum2.labels) {
    size = datum2.ticks ? size : 0;
    children5.push(axisLabels(spec, config, encode2.labels, ticksRef, size, band5));
  }
  if (datum2.domain) {
    children5.push(axisDomain(spec, config, encode2.domain, dataRef));
  }
  if (datum2.title) {
    children5.push(axisTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: AxisRole2,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip3),
    marks: children5,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name4,
    interactive: interactive2,
    style: style3
  }), scope);
}
function buildAxisEncode(_, spec) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset") || 0,
    position: value3(spec.position, 0),
    titlePadding: _("titlePadding"),
    minExtent: _("minExtent"),
    maxExtent: _("maxExtent"),
    range: {
      signal: `abs(span(range("${spec.scale}")))`
    },
    translate: _("translate"),
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function parseScope(spec, scope, preprocessed) {
  const signals = array(spec.signals), scales3 = array(spec.scales);
  if (!preprocessed)
    signals.forEach((_) => parseSignal(_, scope));
  array(spec.projections).forEach((_) => parseProjection(_, scope));
  scales3.forEach((_) => initScale(_, scope));
  array(spec.data).forEach((_) => parseData(_, scope));
  scales3.forEach((_) => parseScale(_, scope));
  (preprocessed || signals).forEach((_) => parseSignalUpdates(_, scope));
  array(spec.axes).forEach((_) => parseAxis(_, scope));
  array(spec.marks).forEach((_) => parseMark(_, scope));
  array(spec.legends).forEach((_) => parseLegend(_, scope));
  if (spec.title)
    parseTitle(spec.title, scope);
  scope.parseLambdas();
  return scope;
}
function parseView(spec, scope) {
  const config = scope.config;
  const root2 = ref(scope.root = scope.add(operator()));
  const signals = collectSignals(spec, config);
  signals.forEach((_) => parseSignal(_, scope));
  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale;
  const input = scope.add(Collect2());
  const encode2 = scope.add(Encode2(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole2, spec.style, scope, {
    pulse: ref(input)
  })));
  const parent = scope.add(ViewLayout2({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef("autosize"),
    mark: root2,
    pulse: ref(encode2)
  }));
  scope.operators.pop();
  scope.pushState(ref(encode2), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent);
  let op = scope.add(Bound2({
    mark: root2,
    pulse: ref(parent)
  }));
  op = scope.add(Render2({
    pulse: ref(op)
  }));
  op = scope.add(Sieve2({
    pulse: ref(op)
  }));
  scope.addData("root", new DataScope(scope, input, input, op));
  return scope;
}
function signalObject(name4, value4) {
  return value4 && value4.signal ? {
    name: name4,
    update: value4.signal
  } : {
    name: name4,
    value: value4
  };
}
function collectSignals(spec, config) {
  const _ = (name4) => value3(spec[name4], config[name4]), signals = [signalObject("background", _("background")), signalObject("autosize", parseAutosize(_("autosize"))), signalObject("padding", parsePadding(_("padding"))), signalObject("width", _("width") || 0), signalObject("height", _("height") || 0)], pre = signals.reduce((p, s3) => (p[s3.name] = s3, p), {}), map11 = {};
  array(spec.signals).forEach((s3) => {
    if (has(pre, s3.name)) {
      s3 = extend(pre[s3.name], s3);
    } else {
      signals.push(s3);
    }
    map11[s3.name] = s3;
  });
  array(config.signals).forEach((s3) => {
    if (!has(map11, s3.name) && !has(pre, s3.name)) {
      signals.push(s3);
    }
  });
  return signals;
}
function Scope(config, options2) {
  this.config = config || {};
  this.options = options2 || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}
function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}
function propertyLambda(spec) {
  return (isArray(spec) ? arrayLambda : objectLambda)(spec);
}
function arrayLambda(array9) {
  const n = array9.length;
  let code = "[";
  for (let i = 0; i < n; ++i) {
    const value4 = array9[i];
    code += (i > 0 ? "," : "") + (isObject(value4) ? value4.signal || propertyLambda(value4) : $(value4));
  }
  return code + "]";
}
function objectLambda(obj) {
  let code = "{", i = 0, key3, value4;
  for (key3 in obj) {
    value4 = obj[key3];
    code += (++i > 1 ? "," : "") + $(key3) + ":" + (isObject(value4) ? value4.signal || propertyLambda(value4) : $(value4));
  }
  return code + "}";
}
function defaults() {
  const defaultFont2 = "sans-serif", defaultSymbolSize = 30, defaultStrokeWidth = 2, defaultColor = "#4c78a8", black = "#000", gray3 = "#888", lightGray = "#ddd";
  return {
    description: "Vega visualization",
    padding: 0,
    autosize: "pad",
    background: null,
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    group: null,
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont2,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    style: {
      "guide-label": {
        fill: black,
        font: defaultFont2,
        fontSize: 10
      },
      "guide-title": {
        fill: black,
        font: defaultFont2,
        fontSize: 11,
        fontWeight: "bold"
      },
      "group-title": {
        fill: black,
        font: defaultFont2,
        fontSize: 13,
        fontWeight: "bold"
      },
      "group-subtitle": {
        fill: black,
        font: defaultFont2,
        fontSize: 12
      },
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "circle"
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "square"
      },
      cell: {
        fill: "transparent",
        stroke: lightGray
      }
    },
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray3,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray3,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    axisBand: {
      tickOffset: -0.5
    },
    projection: {
      type: "mercator"
    },
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: gray3,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function parse7(spec, config, options2) {
  if (!isObject(spec)) {
    error("Input Vega specification must be an object.");
  }
  config = mergeConfig(defaults(), config, spec.config);
  return parseView(spec, new Scope(config, options2)).toRuntime();
}
var number11, paddingObject2, encoder, MarkRole, FrameRole2, ScopeRole2, AxisRole2, AxisDomainRole, AxisGridRole, AxisLabelRole, AxisTickRole, AxisTitleRole, LegendRole2, LegendBandRole, LegendEntryRole, LegendGradientRole, LegendLabelRole, LegendSymbolRole, LegendTitleRole, TitleRole2, TitleTextRole, TitleSubtitleRole, scaleRef, _color, OUTER, OUTER_INVALID, keyFieldRef, Ascending, Descending, Scope$1, View2, Timer2, OP_VALUE_EXPR, transform3, Aggregate2, AxisTicks2, Bound2, Collect2, Compare2, DataJoin2, Encode2, Expression2, Facet2, Field2, Key2, LegendEntries2, Load2, Mark2, MultiExtent2, MultiValues2, Overlap2, Params3, PreFacet2, Projection2, Proxy2, Relay2, Render2, Scale2, Sieve2, SortItems2, ViewLayout2, Values2, FIELD_REF_ID, MULTIDOMAIN_SORT_OPS, Top2, Left2, Right2, Bottom2, Center2, Vertical, Start2, Middle2, End2, Index, Label2, Offset, Perc, Perc2, Value, GuideLabelStyle, GuideTitleStyle, GroupTitleStyle, GroupSubtitleStyle, Symbols2, Gradient2, Discrete3, Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity, LegendScales, Skip3, zero7, one5, GroupMark, RectMark, RuleMark, SymbolMark, TextMark, alignExpr$1, alignExpr, baselineExpr, isL, isR, isLR, isVG, baseline, alignFlip, exprAlign, exprAnchor, exprAngle, exprBaseline, outerExpr, outerField, isData, isExpr, isField, isCompare, angleExpr, isX, getSign, ifX, ifY, ifTop, ifRight, ifXEnc, ifYEnc, ifLeftTopExpr, ifTopExpr, ifRightExpr, ifEnc, isSimple, ifExpr, ifOrient, toExpr, mult, patch, rootEncode;
var init_vega_parser_module = __esm({
  "node_modules/.pnpm/vega-parser@6.1.4/node_modules/vega-parser/build/vega-parser.module.js"() {
    init_vega_util_module();
    init_vega_functions_module();
    init_vega_event_selector_module();
    init_vega_scale_module2();
    init_vega_dataflow_module();
    number11 = (_) => +_ || 0;
    paddingObject2 = (_) => ({
      top: _,
      bottom: _,
      left: _,
      right: _
    });
    encoder = (_) => isObject(_) && !isArray(_) ? extend({}, _) : {
      value: _
    };
    MarkRole = "mark";
    FrameRole2 = "frame";
    ScopeRole2 = "scope";
    AxisRole2 = "axis";
    AxisDomainRole = "axis-domain";
    AxisGridRole = "axis-grid";
    AxisLabelRole = "axis-label";
    AxisTickRole = "axis-tick";
    AxisTitleRole = "axis-title";
    LegendRole2 = "legend";
    LegendBandRole = "legend-band";
    LegendEntryRole = "legend-entry";
    LegendGradientRole = "legend-gradient";
    LegendLabelRole = "legend-label";
    LegendSymbolRole = "legend-symbol";
    LegendTitleRole = "legend-title";
    TitleRole2 = "title";
    TitleTextRole = "title-text";
    TitleSubtitleRole = "title-subtitle";
    scaleRef = (scale8) => isString(scale8) ? $(scale8) : scale8.signal ? `(${scale8.signal})` : field3(scale8);
    _color = (type4, x7, y7, z) => `(${type4}(${[x7, y7, z].map(entry$1).join(",")})+'')`;
    OUTER = "outer";
    OUTER_INVALID = ["value", "update", "init", "react", "bind"];
    keyFieldRef = fieldRef$1("key");
    Ascending = "ascending";
    Descending = "descending";
    Scope$1 = "scope";
    View2 = "view";
    Timer2 = "timer";
    OP_VALUE_EXPR = {
      code: "_.$value",
      ast: {
        type: "Identifier",
        value: "value"
      }
    };
    transform3 = (name4) => (params2, value4, parent) => entry(name4, value4, params2 || void 0, parent);
    Aggregate2 = transform3("aggregate");
    AxisTicks2 = transform3("axisticks");
    Bound2 = transform3("bound");
    Collect2 = transform3("collect");
    Compare2 = transform3("compare");
    DataJoin2 = transform3("datajoin");
    Encode2 = transform3("encode");
    Expression2 = transform3("expression");
    Facet2 = transform3("facet");
    Field2 = transform3("field");
    Key2 = transform3("key");
    LegendEntries2 = transform3("legendentries");
    Load2 = transform3("load");
    Mark2 = transform3("mark");
    MultiExtent2 = transform3("multiextent");
    MultiValues2 = transform3("multivalues");
    Overlap2 = transform3("overlap");
    Params3 = transform3("params");
    PreFacet2 = transform3("prefacet");
    Projection2 = transform3("projection");
    Proxy2 = transform3("proxy");
    Relay2 = transform3("relay");
    Render2 = transform3("render");
    Scale2 = transform3("scale");
    Sieve2 = transform3("sieve");
    SortItems2 = transform3("sortitems");
    ViewLayout2 = transform3("viewlayout");
    Values2 = transform3("values");
    FIELD_REF_ID = 0;
    MULTIDOMAIN_SORT_OPS = {
      min: "min",
      max: "max",
      count: "sum"
    };
    Top2 = "top";
    Left2 = "left";
    Right2 = "right";
    Bottom2 = "bottom";
    Center2 = "center";
    Vertical = "vertical";
    Start2 = "start";
    Middle2 = "middle";
    End2 = "end";
    Index = "index";
    Label2 = "label";
    Offset = "offset";
    Perc = "perc";
    Perc2 = "perc2";
    Value = "value";
    GuideLabelStyle = "guide-label";
    GuideTitleStyle = "guide-title";
    GroupTitleStyle = "group-title";
    GroupSubtitleStyle = "group-subtitle";
    Symbols2 = "symbol";
    Gradient2 = "gradient";
    Discrete3 = "discrete";
    Size = "size";
    Shape = "shape";
    Fill = "fill";
    Stroke = "stroke";
    StrokeWidth = "strokeWidth";
    StrokeDash = "strokeDash";
    Opacity = "opacity";
    LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
    Skip3 = {
      name: 1,
      style: 1,
      interactive: 1
    };
    zero7 = {
      value: 0
    };
    one5 = {
      value: 1
    };
    GroupMark = "group";
    RectMark = "rect";
    RuleMark = "rule";
    SymbolMark = "symbol";
    TextMark = "text";
    alignExpr$1 = anchorExpr($(Left2), $(Right2), $(Center2));
    alignExpr = `datum.${Perc}<=0?"${Left2}":datum.${Perc}>=1?"${Right2}":"${Center2}"`;
    baselineExpr = `datum.${Perc}<=0?"${Bottom2}":datum.${Perc}>=1?"${Top2}":"${Middle2}"`;
    isL = 'item.orient === "left"';
    isR = 'item.orient === "right"';
    isLR = `(${isL} || ${isR})`;
    isVG = `datum.vgrad && ${isLR}`;
    baseline = anchorExpr('"top"', '"bottom"', '"middle"');
    alignFlip = anchorExpr('"right"', '"left"', '"center"');
    exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`;
    exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`;
    exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`;
    exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline}) : "top"`;
    outerExpr = (_) => _ && _.expr;
    outerField = (_) => _ && _.field;
    isData = (_) => _ === "data";
    isExpr = (_) => _ === "expr";
    isField = (_) => _ === "field";
    isCompare = (_) => _ === "compare";
    DataScope.fromEntries = function(scope, entries3) {
      const n = entries3.length, values5 = entries3[n - 1], output3 = entries3[n - 2];
      let input = entries3[0], aggr = null, i = 1;
      if (input && input.type === "load") {
        input = entries3[1];
      }
      scope.add(entries3[0]);
      for (; i < n; ++i) {
        entries3[i].params.pulse = ref(entries3[i - 1]);
        scope.add(entries3[i]);
        if (entries3[i].type === "aggregate")
          aggr = entries3[i];
      }
      return new DataScope(scope, input, output3, values5, aggr);
    };
    DataScope.prototype = {
      countsRef(scope, field4, sort5) {
        const ds = this, cache3 = ds.counts || (ds.counts = {}), k4 = fieldKey(field4);
        let v, a4, p;
        if (k4 != null) {
          scope = ds.scope;
          v = cache3[k4];
        }
        if (!v) {
          p = {
            groupby: scope.fieldRef(field4, "key"),
            pulse: ref(ds.output)
          };
          if (sort5 && sort5.field)
            addSortField(scope, p, sort5);
          a4 = scope.add(Aggregate2(p));
          v = scope.add(Collect2({
            pulse: ref(a4)
          }));
          v = {
            agg: a4,
            ref: ref(v)
          };
          if (k4 != null)
            cache3[k4] = v;
        } else if (sort5 && sort5.field) {
          addSortField(scope, v.agg.params, sort5);
        }
        return v.ref;
      },
      tuplesRef() {
        return ref(this.values);
      },
      extentRef(scope, field4) {
        return cache(scope, this, "extent", "extent", field4, false);
      },
      domainRef(scope, field4) {
        return cache(scope, this, "domain", "values", field4, false);
      },
      valuesRef(scope, field4, sort5) {
        return cache(scope, this, "vals", "values", field4, sort5 || true);
      },
      lookupRef(scope, field4) {
        return cache(scope, this, "lookup", "tupleindex", field4, false);
      },
      indataRef(scope, field4) {
        return cache(scope, this, "indata", "tupleindex", field4, true, true);
      }
    };
    angleExpr = `item.orient==="${Left2}"?-90:item.orient==="${Right2}"?90:0`;
    isX = (orient3) => orient3 === Bottom2 || orient3 === Top2;
    getSign = (orient3, a4, b3) => isSignal(orient3) ? ifLeftTopExpr(orient3.signal, a4, b3) : orient3 === Left2 || orient3 === Top2 ? a4 : b3;
    ifX = (orient3, a4, b3) => isSignal(orient3) ? ifXEnc(orient3.signal, a4, b3) : isX(orient3) ? a4 : b3;
    ifY = (orient3, a4, b3) => isSignal(orient3) ? ifYEnc(orient3.signal, a4, b3) : isX(orient3) ? b3 : a4;
    ifTop = (orient3, a4, b3) => isSignal(orient3) ? ifTopExpr(orient3.signal, a4, b3) : orient3 === Top2 ? {
      value: a4
    } : {
      value: b3
    };
    ifRight = (orient3, a4, b3) => isSignal(orient3) ? ifRightExpr(orient3.signal, a4, b3) : orient3 === Right2 ? {
      value: a4
    } : {
      value: b3
    };
    ifXEnc = ($orient, a4, b3) => ifEnc(`${$orient} === '${Top2}' || ${$orient} === '${Bottom2}'`, a4, b3);
    ifYEnc = ($orient, a4, b3) => ifEnc(`${$orient} !== '${Top2}' && ${$orient} !== '${Bottom2}'`, a4, b3);
    ifLeftTopExpr = ($orient, a4, b3) => ifExpr(`${$orient} === '${Left2}' || ${$orient} === '${Top2}'`, a4, b3);
    ifTopExpr = ($orient, a4, b3) => ifExpr(`${$orient} === '${Top2}'`, a4, b3);
    ifRightExpr = ($orient, a4, b3) => ifExpr(`${$orient} === '${Right2}'`, a4, b3);
    ifEnc = (test2, a4, b3) => {
      a4 = a4 != null ? encoder(a4) : a4;
      b3 = b3 != null ? encoder(b3) : b3;
      if (isSimple(a4) && isSimple(b3)) {
        a4 = a4 ? a4.signal || $(a4.value) : null;
        b3 = b3 ? b3.signal || $(b3.value) : null;
        return {
          signal: `${test2} ? (${a4}) : (${b3})`
        };
      } else {
        return [extend({
          test: test2
        }, a4)].concat(b3 || []);
      }
    };
    isSimple = (enc) => enc == null || Object.keys(enc).length === 1;
    ifExpr = (test2, a4, b3) => ({
      signal: `${test2} ? (${toExpr(a4)}) : (${toExpr(b3)})`
    });
    ifOrient = ($orient, t, b3, l, r2) => ({
      signal: (l != null ? `${$orient} === '${Left2}' ? (${toExpr(l)}) : ` : "") + (b3 != null ? `${$orient} === '${Bottom2}' ? (${toExpr(b3)}) : ` : "") + (r2 != null ? `${$orient} === '${Right2}' ? (${toExpr(r2)}) : ` : "") + (t != null ? `${$orient} === '${Top2}' ? (${toExpr(t)}) : ` : "") + "(null)"
    });
    toExpr = (v) => isSignal(v) ? v.signal : v == null ? null : $(v);
    mult = (sign5, value4) => value4 === 0 ? 0 : isSignal(sign5) ? {
      signal: `(${sign5.signal}) * ${value4}`
    } : {
      value: sign5 * value4
    };
    patch = (value4, base3) => {
      const s3 = value4.signal;
      return s3 && s3.endsWith("(null)") ? {
        signal: s3.slice(0, -6) + base3.signal
      } : value4;
    };
    rootEncode = (spec) => extendEncode({
      enter: {
        x: {
          value: 0
        },
        y: {
          value: 0
        }
      },
      update: {
        width: {
          signal: "width"
        },
        height: {
          signal: "height"
        }
      }
    }, spec);
    Scope.prototype = Subscope.prototype = {
      parse(spec) {
        return parseScope(spec, this);
      },
      fork() {
        return new Subscope(this);
      },
      isSubscope() {
        return this._subid > 0;
      },
      toRuntime() {
        this.finish();
        return {
          description: this.description,
          operators: this.operators,
          streams: this.streams,
          updates: this.updates,
          bindings: this.bindings,
          eventConfig: this.eventConfig,
          locale: this.locale
        };
      },
      id() {
        return (this._subid ? this._subid + ":" : 0) + this._id++;
      },
      add(op) {
        this.operators.push(op);
        op.id = this.id();
        if (op.refs) {
          op.refs.forEach((ref2) => {
            ref2.$ref = op.id;
          });
          op.refs = null;
        }
        return op;
      },
      proxy(op) {
        const vref = op instanceof Entry ? ref(op) : op;
        return this.add(Proxy2({
          value: vref
        }));
      },
      addStream(stream2) {
        this.streams.push(stream2);
        stream2.id = this.id();
        return stream2;
      },
      addUpdate(update3) {
        this.updates.push(update3);
        return update3;
      },
      finish() {
        let name4, ds;
        if (this.root)
          this.root.root = true;
        for (name4 in this.signals) {
          this.signals[name4].signal = name4;
        }
        for (name4 in this.scales) {
          this.scales[name4].scale = name4;
        }
        function annotate(op, name5, type4) {
          let data3, list;
          if (op) {
            data3 = op.data || (op.data = {});
            list = data3[name5] || (data3[name5] = []);
            list.push(type4);
          }
        }
        for (name4 in this.data) {
          ds = this.data[name4];
          annotate(ds.input, name4, "input");
          annotate(ds.output, name4, "output");
          annotate(ds.values, name4, "values");
          for (const field4 in ds.index) {
            annotate(ds.index[field4], name4, "index:" + field4);
          }
        }
        return this;
      },
      pushState(encode2, parent, lookup7) {
        this._encode.push(ref(this.add(Sieve2({
          pulse: encode2
        }))));
        this._parent.push(parent);
        this._lookup.push(lookup7 ? ref(this.proxy(lookup7)) : null);
        this._markpath.push(-1);
      },
      popState() {
        this._encode.pop();
        this._parent.pop();
        this._lookup.pop();
        this._markpath.pop();
      },
      parent() {
        return peek(this._parent);
      },
      encode() {
        return peek(this._encode);
      },
      lookup() {
        return peek(this._lookup);
      },
      markpath() {
        const p = this._markpath;
        return ++p[p.length - 1];
      },
      fieldRef(field4, name4) {
        if (isString(field4))
          return fieldRef$1(field4, name4);
        if (!field4.signal) {
          error("Unsupported field reference: " + $(field4));
        }
        const s3 = field4.signal;
        let f = this.field[s3];
        if (!f) {
          const params2 = {
            name: this.signalRef(s3)
          };
          if (name4)
            params2.as = name4;
          this.field[s3] = f = ref(this.add(Field2(params2)));
        }
        return f;
      },
      compareRef(cmp) {
        let signal = false;
        const check = (_) => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;
        const fields = array(cmp.field).map(check), orders = array(cmp.order).map(check);
        return signal ? ref(this.add(Compare2({
          fields,
          orders
        }))) : compareRef(fields, orders);
      },
      keyRef(fields, flat) {
        let signal = false;
        const check = (_) => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;
        const sig = this.signals;
        fields = array(fields).map(check);
        return signal ? ref(this.add(Key2({
          fields,
          flat
        }))) : keyRef(fields, flat);
      },
      sortRef(sort5) {
        if (!sort5)
          return sort5;
        const a4 = aggrField(sort5.op, sort5.field), o = sort5.order || Ascending;
        return o.signal ? ref(this.add(Compare2({
          fields: a4,
          orders: this.signalRef(o.signal)
        }))) : compareRef(a4, o);
      },
      event(source5, type4) {
        const key3 = source5 + ":" + type4;
        if (!this.events[key3]) {
          const id4 = this.id();
          this.streams.push({
            id: id4,
            source: source5,
            type: type4
          });
          this.events[key3] = id4;
        }
        return this.events[key3];
      },
      hasOwnSignal(name4) {
        return has(this.signals, name4);
      },
      addSignal(name4, value4) {
        if (this.hasOwnSignal(name4)) {
          error("Duplicate signal name: " + $(name4));
        }
        const op = value4 instanceof Entry ? value4 : this.add(operator(value4));
        return this.signals[name4] = op;
      },
      getSignal(name4) {
        if (!this.signals[name4]) {
          error("Unrecognized signal name: " + $(name4));
        }
        return this.signals[name4];
      },
      signalRef(s3) {
        if (this.signals[s3]) {
          return ref(this.signals[s3]);
        } else if (!has(this.lambdas, s3)) {
          this.lambdas[s3] = this.add(operator(null));
        }
        return ref(this.lambdas[s3]);
      },
      parseLambdas() {
        const code = Object.keys(this.lambdas);
        for (let i = 0, n = code.length; i < n; ++i) {
          const s3 = code[i], e3 = parser2(s3, this), op = this.lambdas[s3];
          op.params = e3.$params;
          op.update = e3.$expr;
        }
      },
      property(spec) {
        return spec && spec.signal ? this.signalRef(spec.signal) : spec;
      },
      objectProperty(spec) {
        return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
      },
      exprRef(code, name4) {
        const params2 = {
          expr: parser2(code, this)
        };
        if (name4)
          params2.expr.$name = name4;
        return ref(this.add(Expression2(params2)));
      },
      addBinding(name4, bind4) {
        if (!this.bindings) {
          error("Nested signals do not support binding: " + $(name4));
        }
        this.bindings.push(extend({
          signal: name4
        }, bind4));
      },
      addScaleProj(name4, transform4) {
        if (has(this.scales, name4)) {
          error("Duplicate scale or projection name: " + $(name4));
        }
        this.scales[name4] = this.add(transform4);
      },
      addScale(name4, params2) {
        this.addScaleProj(name4, Scale2(params2));
      },
      addProjection(name4, params2) {
        this.addScaleProj(name4, Projection2(params2));
      },
      getScale(name4) {
        if (!this.scales[name4]) {
          error("Unrecognized scale name: " + $(name4));
        }
        return this.scales[name4];
      },
      scaleRef(name4) {
        return ref(this.getScale(name4));
      },
      scaleType(name4) {
        return this.getScale(name4).params.type;
      },
      projectionRef(name4) {
        return this.scaleRef(name4);
      },
      projectionType(name4) {
        return this.scaleType(name4);
      },
      addData(name4, dataScope) {
        if (has(this.data, name4)) {
          error("Duplicate data set name: " + $(name4));
        }
        return this.data[name4] = dataScope;
      },
      getData(name4) {
        if (!this.data[name4]) {
          error("Undefined data set name: " + $(name4));
        }
        return this.data[name4];
      },
      addDataPipeline(name4, entries3) {
        if (has(this.data, name4)) {
          error("Duplicate data set name: " + $(name4));
        }
        return this.addData(name4, DataScope.fromEntries(this, entries3));
      }
    };
  }
});

// node_modules/.pnpm/vega-expression@4.0.1/node_modules/vega-expression/build/vega-expression.module.js
function ASTNode2(type4) {
  this.type = type4;
}
function children3(node) {
  switch (node.type) {
    case ArrayExpression2:
      return node.elements;
    case BinaryExpression2:
    case LogicalExpression2:
      return [node.left, node.right];
    case CallExpression2:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression2:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression2:
      return [node.object, node.property];
    case ObjectExpression2:
      return node.properties;
    case Property2:
      return [node.key, node.value];
    case UnaryExpression2:
      return [node.argument];
    case Identifier3:
    case Literal2:
    case RawCode2:
    default:
      return [];
  }
}
function assert2(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit2(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit2(ch2) {
  return "0123456789abcdefABCDEF".indexOf(ch2) >= 0;
}
function isOctalDigit2(ch2) {
  return "01234567".indexOf(ch2) >= 0;
}
function isWhiteSpace2(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch2) >= 0;
}
function isLineTerminator2(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart2(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierStart2.test(String.fromCharCode(ch2));
}
function isIdentifierPart2(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 >= 48 && ch2 <= 57 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierPart2.test(String.fromCharCode(ch2));
}
function skipComment2() {
  while (index6 < length2) {
    const ch2 = source3.charCodeAt(index6);
    if (isWhiteSpace2(ch2) || isLineTerminator2(ch2)) {
      ++index6;
    } else {
      break;
    }
  }
}
function scanHexEscape2(prefix) {
  var i, len, ch2, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index6 < length2 && isHexDigit2(source3[index6])) {
      ch2 = source3[index6++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape2() {
  var ch2, code, cu1, cu2;
  ch2 = source3[index6];
  code = 0;
  if (ch2 === "}") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  while (index6 < length2) {
    ch2 = source3[index6++];
    if (!isHexDigit2(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier2() {
  var ch2, id4;
  ch2 = source3.charCodeAt(index6++);
  id4 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source3.charCodeAt(index6) !== 117) {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
    ++index6;
    ch2 = scanHexEscape2("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart2(ch2.charCodeAt(0))) {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
    id4 = ch2;
  }
  while (index6 < length2) {
    ch2 = source3.charCodeAt(index6);
    if (!isIdentifierPart2(ch2)) {
      break;
    }
    ++index6;
    id4 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id4 = id4.substr(0, id4.length - 1);
      if (source3.charCodeAt(index6) !== 117) {
        throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
      }
      ++index6;
      ch2 = scanHexEscape2("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart2(ch2.charCodeAt(0))) {
        throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
      }
      id4 += ch2;
    }
  }
  return id4;
}
function getIdentifier2() {
  var start, ch2;
  start = index6++;
  while (index6 < length2) {
    ch2 = source3.charCodeAt(index6);
    if (ch2 === 92) {
      index6 = start;
      return getEscapedIdentifier2();
    }
    if (isIdentifierPart2(ch2)) {
      ++index6;
    } else {
      break;
    }
  }
  return source3.slice(start, index6);
}
function scanIdentifier2() {
  var start, id4, type4;
  start = index6;
  id4 = source3.charCodeAt(index6) === 92 ? getEscapedIdentifier2() : getIdentifier2();
  if (id4.length === 1) {
    type4 = TokenIdentifier2;
  } else if (keywords2.hasOwnProperty(id4)) {
    type4 = TokenKeyword2;
  } else if (id4 === "null") {
    type4 = TokenNullLiteral2;
  } else if (id4 === "true" || id4 === "false") {
    type4 = TokenBooleanLiteral2;
  } else {
    type4 = TokenIdentifier2;
  }
  return {
    type: type4,
    value: id4,
    start,
    end: index6
  };
}
function scanPunctuator2() {
  var start = index6, code = source3.charCodeAt(index6), code2, ch1 = source3[index6], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index6;
      return {
        type: TokenPunctuator2,
        value: String.fromCharCode(code),
        start,
        end: index6
      };
    default:
      code2 = source3.charCodeAt(index6 + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index6 += 2;
            return {
              type: TokenPunctuator2,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index6
            };
          case 33:
          case 61:
            index6 += 2;
            if (source3.charCodeAt(index6) === 61) {
              ++index6;
            }
            return {
              type: TokenPunctuator2,
              value: source3.slice(start, index6),
              start,
              end: index6
            };
        }
      }
  }
  ch4 = source3.substr(index6, 4);
  if (ch4 === ">>>=") {
    index6 += 4;
    return {
      type: TokenPunctuator2,
      value: ch4,
      start,
      end: index6
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index6 += 3;
    return {
      type: TokenPunctuator2,
      value: ch3,
      start,
      end: index6
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index6 += 2;
    return {
      type: TokenPunctuator2,
      value: ch2,
      start,
      end: index6
    };
  }
  if (ch2 === "//") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index6;
    return {
      type: TokenPunctuator2,
      value: ch1,
      start,
      end: index6
    };
  }
  throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
}
function scanHexLiteral2(start) {
  let number12 = "";
  while (index6 < length2) {
    if (!isHexDigit2(source3[index6])) {
      break;
    }
    number12 += source3[index6++];
  }
  if (number12.length === 0) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  if (isIdentifierStart2(source3.charCodeAt(index6))) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenNumericLiteral2,
    value: parseInt("0x" + number12, 16),
    start,
    end: index6
  };
}
function scanOctalLiteral2(start) {
  let number12 = "0" + source3[index6++];
  while (index6 < length2) {
    if (!isOctalDigit2(source3[index6])) {
      break;
    }
    number12 += source3[index6++];
  }
  if (isIdentifierStart2(source3.charCodeAt(index6)) || isDecimalDigit2(source3.charCodeAt(index6))) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenNumericLiteral2,
    value: parseInt(number12, 8),
    octal: true,
    start,
    end: index6
  };
}
function scanNumericLiteral2() {
  var number12, start, ch2;
  ch2 = source3[index6];
  assert2(isDecimalDigit2(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index6;
  number12 = "";
  if (ch2 !== ".") {
    number12 = source3[index6++];
    ch2 = source3[index6];
    if (number12 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index6;
        return scanHexLiteral2(start);
      }
      if (isOctalDigit2(ch2)) {
        return scanOctalLiteral2(start);
      }
      if (ch2 && isDecimalDigit2(ch2.charCodeAt(0))) {
        throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
      }
    }
    while (isDecimalDigit2(source3.charCodeAt(index6))) {
      number12 += source3[index6++];
    }
    ch2 = source3[index6];
  }
  if (ch2 === ".") {
    number12 += source3[index6++];
    while (isDecimalDigit2(source3.charCodeAt(index6))) {
      number12 += source3[index6++];
    }
    ch2 = source3[index6];
  }
  if (ch2 === "e" || ch2 === "E") {
    number12 += source3[index6++];
    ch2 = source3[index6];
    if (ch2 === "+" || ch2 === "-") {
      number12 += source3[index6++];
    }
    if (isDecimalDigit2(source3.charCodeAt(index6))) {
      while (isDecimalDigit2(source3.charCodeAt(index6))) {
        number12 += source3[index6++];
      }
    } else {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
  }
  if (isIdentifierStart2(source3.charCodeAt(index6))) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenNumericLiteral2,
    value: parseFloat(number12),
    start,
    end: index6
  };
}
function scanStringLiteral2() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source3[index6];
  assert2(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index6;
  ++index6;
  while (index6 < length2) {
    ch2 = source3[index6++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source3[index6++];
      if (!ch2 || !isLineTerminator2(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source3[index6] === "{") {
              ++index6;
              str += scanUnicodeCodePointEscape2();
            } else {
              str += scanHexEscape2(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit2(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index6 < length2 && isOctalDigit2(source3[index6])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source3[index6++]);
                if ("0123".indexOf(ch2) >= 0 && index6 < length2 && isOctalDigit2(source3[index6])) {
                  code = code * 8 + "01234567".indexOf(source3[index6++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source3[index6] === "\n") {
          ++index6;
        }
      }
    } else if (isLineTerminator2(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenStringLiteral2,
    value: str,
    octal,
    start,
    end: index6
  };
}
function testRegExp2(pattern, flags) {
  let tmp = pattern;
  if (flags.indexOf("u") >= 0) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError2({}, MessageInvalidRegExp2);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e3) {
    throwError2({}, MessageInvalidRegExp2);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody2() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source3[index6];
  assert2(ch2 === "/", "Regular expression literal must start with a slash");
  str = source3[index6++];
  classMarker = false;
  terminated = false;
  while (index6 < length2) {
    ch2 = source3[index6++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source3[index6++];
      if (isLineTerminator2(ch2.charCodeAt(0))) {
        throwError2({}, MessageUnterminatedRegExp2);
      }
      str += ch2;
    } else if (isLineTerminator2(ch2.charCodeAt(0))) {
      throwError2({}, MessageUnterminatedRegExp2);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError2({}, MessageUnterminatedRegExp2);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags2() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index6 < length2) {
    ch2 = source3[index6];
    if (!isIdentifierPart2(ch2.charCodeAt(0))) {
      break;
    }
    ++index6;
    if (ch2 === "\\" && index6 < length2) {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError2({}, MessageInvalidRegExp2, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp2() {
  var start, body, flags, value4;
  lookahead2 = null;
  skipComment2();
  start = index6;
  body = scanRegExpBody2();
  flags = scanRegExpFlags2();
  value4 = testRegExp2(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value4,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index6
  };
}
function isIdentifierName2(token) {
  return token.type === TokenIdentifier2 || token.type === TokenKeyword2 || token.type === TokenBooleanLiteral2 || token.type === TokenNullLiteral2;
}
function advance2() {
  skipComment2();
  if (index6 >= length2) {
    return {
      type: TokenEOF2,
      start: index6,
      end: index6
    };
  }
  const ch2 = source3.charCodeAt(index6);
  if (isIdentifierStart2(ch2)) {
    return scanIdentifier2();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator2();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral2();
  }
  if (ch2 === 46) {
    if (isDecimalDigit2(source3.charCodeAt(index6 + 1))) {
      return scanNumericLiteral2();
    }
    return scanPunctuator2();
  }
  if (isDecimalDigit2(ch2)) {
    return scanNumericLiteral2();
  }
  return scanPunctuator2();
}
function lex2() {
  const token = lookahead2;
  index6 = token.end;
  lookahead2 = advance2();
  index6 = token.end;
  return token;
}
function peek4() {
  const pos = index6;
  lookahead2 = advance2();
  index6 = pos;
}
function finishArrayExpression2(elements) {
  const node = new ASTNode2(SyntaxArrayExpression2);
  node.elements = elements;
  return node;
}
function finishBinaryExpression2(operator2, left, right) {
  const node = new ASTNode2(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression2 : SyntaxBinaryExpression2);
  node.operator = operator2;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression2(callee, args) {
  const node = new ASTNode2(SyntaxCallExpression2);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression2(test2, consequent, alternate) {
  const node = new ASTNode2(SyntaxConditionalExpression2);
  node.test = test2;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier2(name4) {
  const node = new ASTNode2(SyntaxIdentifier2);
  node.name = name4;
  return node;
}
function finishLiteral2(token) {
  const node = new ASTNode2(SyntaxLiteral2);
  node.value = token.value;
  node.raw = source3.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression2(accessor3, object2, property2) {
  const node = new ASTNode2(SyntaxMemberExpression2);
  node.computed = accessor3 === "[";
  node.object = object2;
  node.property = property2;
  if (!node.computed)
    property2.member = true;
  return node;
}
function finishObjectExpression2(properties) {
  const node = new ASTNode2(SyntaxObjectExpression2);
  node.properties = properties;
  return node;
}
function finishProperty2(kind, key3, value4) {
  const node = new ASTNode2(SyntaxProperty2);
  node.key = key3;
  node.value = value4;
  node.kind = kind;
  return node;
}
function finishUnaryExpression2(operator2, argument) {
  const node = new ASTNode2(SyntaxUnaryExpression2);
  node.operator = operator2;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError2(token, messageFormat) {
  var error3, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index8) => {
    assert2(index8 < args.length, "Message reference must be in range");
    return args[index8];
  });
  error3 = new Error(msg);
  error3.index = index6;
  error3.description = msg;
  throw error3;
}
function throwUnexpected2(token) {
  if (token.type === TokenEOF2) {
    throwError2(token, MessageUnexpectedEOS2);
  }
  if (token.type === TokenNumericLiteral2) {
    throwError2(token, MessageUnexpectedNumber2);
  }
  if (token.type === TokenStringLiteral2) {
    throwError2(token, MessageUnexpectedString2);
  }
  if (token.type === TokenIdentifier2) {
    throwError2(token, MessageUnexpectedIdentifier2);
  }
  if (token.type === TokenKeyword2) {
    throwError2(token, MessageUnexpectedReserved2);
  }
  throwError2(token, MessageUnexpectedToken2, token.value);
}
function expect2(value4) {
  const token = lex2();
  if (token.type !== TokenPunctuator2 || token.value !== value4) {
    throwUnexpected2(token);
  }
}
function match2(value4) {
  return lookahead2.type === TokenPunctuator2 && lookahead2.value === value4;
}
function matchKeyword2(keyword) {
  return lookahead2.type === TokenKeyword2 && lookahead2.value === keyword;
}
function parseArrayInitialiser2() {
  const elements = [];
  index6 = lookahead2.start;
  expect2("[");
  while (!match2("]")) {
    if (match2(",")) {
      lex2();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression2());
      if (!match2("]")) {
        expect2(",");
      }
    }
  }
  lex2();
  return finishArrayExpression2(elements);
}
function parseObjectPropertyKey2() {
  index6 = lookahead2.start;
  const token = lex2();
  if (token.type === TokenStringLiteral2 || token.type === TokenNumericLiteral2) {
    if (token.octal) {
      throwError2(token, MessageStrictOctalLiteral2);
    }
    return finishLiteral2(token);
  }
  return finishIdentifier2(token.value);
}
function parseObjectProperty2() {
  var token, key3, id4, value4;
  index6 = lookahead2.start;
  token = lookahead2;
  if (token.type === TokenIdentifier2) {
    id4 = parseObjectPropertyKey2();
    expect2(":");
    value4 = parseConditionalExpression2();
    return finishProperty2("init", id4, value4);
  }
  if (token.type === TokenEOF2 || token.type === TokenPunctuator2) {
    throwUnexpected2(token);
  } else {
    key3 = parseObjectPropertyKey2();
    expect2(":");
    value4 = parseConditionalExpression2();
    return finishProperty2("init", key3, value4);
  }
}
function parseObjectInitialiser2() {
  var properties = [], property2, name4, key3, map11 = {}, toString3 = String;
  index6 = lookahead2.start;
  expect2("{");
  while (!match2("}")) {
    property2 = parseObjectProperty2();
    if (property2.key.type === SyntaxIdentifier2) {
      name4 = property2.key.name;
    } else {
      name4 = toString3(property2.key.value);
    }
    key3 = "$" + name4;
    if (Object.prototype.hasOwnProperty.call(map11, key3)) {
      throwError2({}, MessageStrictDuplicateProperty2);
    } else {
      map11[key3] = true;
    }
    properties.push(property2);
    if (!match2("}")) {
      expect2(",");
    }
  }
  expect2("}");
  return finishObjectExpression2(properties);
}
function parseGroupExpression2() {
  expect2("(");
  const expr2 = parseExpression2();
  expect2(")");
  return expr2;
}
function parsePrimaryExpression2() {
  var type4, token, expr2;
  if (match2("(")) {
    return parseGroupExpression2();
  }
  if (match2("[")) {
    return parseArrayInitialiser2();
  }
  if (match2("{")) {
    return parseObjectInitialiser2();
  }
  type4 = lookahead2.type;
  index6 = lookahead2.start;
  if (type4 === TokenIdentifier2 || legalKeywords2[lookahead2.value]) {
    expr2 = finishIdentifier2(lex2().value);
  } else if (type4 === TokenStringLiteral2 || type4 === TokenNumericLiteral2) {
    if (lookahead2.octal) {
      throwError2(lookahead2, MessageStrictOctalLiteral2);
    }
    expr2 = finishLiteral2(lex2());
  } else if (type4 === TokenKeyword2) {
    throw new Error(DISABLED2);
  } else if (type4 === TokenBooleanLiteral2) {
    token = lex2();
    token.value = token.value === "true";
    expr2 = finishLiteral2(token);
  } else if (type4 === TokenNullLiteral2) {
    token = lex2();
    token.value = null;
    expr2 = finishLiteral2(token);
  } else if (match2("/") || match2("/=")) {
    expr2 = finishLiteral2(scanRegExp2());
    peek4();
  } else {
    throwUnexpected2(lex2());
  }
  return expr2;
}
function parseArguments2() {
  const args = [];
  expect2("(");
  if (!match2(")")) {
    while (index6 < length2) {
      args.push(parseConditionalExpression2());
      if (match2(")")) {
        break;
      }
      expect2(",");
    }
  }
  expect2(")");
  return args;
}
function parseNonComputedProperty2() {
  index6 = lookahead2.start;
  const token = lex2();
  if (!isIdentifierName2(token)) {
    throwUnexpected2(token);
  }
  return finishIdentifier2(token.value);
}
function parseNonComputedMember2() {
  expect2(".");
  return parseNonComputedProperty2();
}
function parseComputedMember2() {
  expect2("[");
  const expr2 = parseExpression2();
  expect2("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall2() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression2();
  for (; ; ) {
    if (match2(".")) {
      property2 = parseNonComputedMember2();
      expr2 = finishMemberExpression2(".", expr2, property2);
    } else if (match2("(")) {
      args = parseArguments2();
      expr2 = finishCallExpression2(expr2, args);
    } else if (match2("[")) {
      property2 = parseComputedMember2();
      expr2 = finishMemberExpression2("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression2() {
  const expr2 = parseLeftHandSideExpressionAllowCall2();
  if (lookahead2.type === TokenPunctuator2) {
    if (match2("++") || match2("--")) {
      throw new Error(DISABLED2);
    }
  }
  return expr2;
}
function parseUnaryExpression2() {
  var token, expr2;
  if (lookahead2.type !== TokenPunctuator2 && lookahead2.type !== TokenKeyword2) {
    expr2 = parsePostfixExpression2();
  } else if (match2("++") || match2("--")) {
    throw new Error(DISABLED2);
  } else if (match2("+") || match2("-") || match2("~") || match2("!")) {
    token = lex2();
    expr2 = parseUnaryExpression2();
    expr2 = finishUnaryExpression2(token.value, expr2);
  } else if (matchKeyword2("delete") || matchKeyword2("void") || matchKeyword2("typeof")) {
    throw new Error(DISABLED2);
  } else {
    expr2 = parsePostfixExpression2();
  }
  return expr2;
}
function binaryPrecedence2(token) {
  let prec = 0;
  if (token.type !== TokenPunctuator2 && token.type !== TokenKeyword2) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
  }
  return prec;
}
function parseBinaryExpression2() {
  var marker, markers, expr2, token, prec, stack3, right, operator2, left, i;
  marker = lookahead2;
  left = parseUnaryExpression2();
  token = lookahead2;
  prec = binaryPrecedence2(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex2();
  markers = [marker, lookahead2];
  right = parseUnaryExpression2();
  stack3 = [left, token, right];
  while ((prec = binaryPrecedence2(lookahead2)) > 0) {
    while (stack3.length > 2 && prec <= stack3[stack3.length - 2].prec) {
      right = stack3.pop();
      operator2 = stack3.pop().value;
      left = stack3.pop();
      markers.pop();
      expr2 = finishBinaryExpression2(operator2, left, right);
      stack3.push(expr2);
    }
    token = lex2();
    token.prec = prec;
    stack3.push(token);
    markers.push(lookahead2);
    expr2 = parseUnaryExpression2();
    stack3.push(expr2);
  }
  i = stack3.length - 1;
  expr2 = stack3[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression2(stack3[i - 1].value, stack3[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression2() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression2();
  if (match2("?")) {
    lex2();
    consequent = parseConditionalExpression2();
    expect2(":");
    alternate = parseConditionalExpression2();
    expr2 = finishConditionalExpression2(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression2() {
  const expr2 = parseConditionalExpression2();
  if (match2(",")) {
    throw new Error(DISABLED2);
  }
  return expr2;
}
function parser3(code) {
  source3 = code;
  index6 = 0;
  length2 = source3.length;
  lookahead2 = null;
  peek4();
  const expr2 = parseExpression2();
  if (lookahead2.type !== TokenEOF2) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}
function Functions2(codegen3) {
  function fncall(name4, args, cast, type4) {
    let obj = codegen3(args[0]);
    if (cast) {
      obj = cast + "(" + obj + ")";
      if (cast.lastIndexOf("new ", 0) === 0)
        obj = "(" + obj + ")";
    }
    return obj + "." + name4 + (type4 < 0 ? "" : type4 === 0 ? "()" : "(" + args.slice(1).map(codegen3).join(",") + ")");
  }
  function fn(name4, cast, type4) {
    return (args) => fncall(name4, args, cast, type4);
  }
  const DATE3 = "new Date", STRING = "String", REGEXP = "RegExp";
  return {
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(args) {
      if (args.length < 3)
        error("Missing arguments to clamp function.");
      if (args.length > 3)
        error("Too many arguments to clamp function.");
      const a4 = args.map(codegen3);
      return "Math.max(" + a4[1] + ", Math.min(" + a4[2] + "," + a4[0] + "))";
    },
    now: "Date.now",
    utc: "Date.UTC",
    datetime: DATE3,
    date: fn("getDate", DATE3, 0),
    day: fn("getDay", DATE3, 0),
    year: fn("getFullYear", DATE3, 0),
    month: fn("getMonth", DATE3, 0),
    hours: fn("getHours", DATE3, 0),
    minutes: fn("getMinutes", DATE3, 0),
    seconds: fn("getSeconds", DATE3, 0),
    milliseconds: fn("getMilliseconds", DATE3, 0),
    time: fn("getTime", DATE3, 0),
    timezoneoffset: fn("getTimezoneOffset", DATE3, 0),
    utcdate: fn("getUTCDate", DATE3, 0),
    utcday: fn("getUTCDay", DATE3, 0),
    utcyear: fn("getUTCFullYear", DATE3, 0),
    utcmonth: fn("getUTCMonth", DATE3, 0),
    utchours: fn("getUTCHours", DATE3, 0),
    utcminutes: fn("getUTCMinutes", DATE3, 0),
    utcseconds: fn("getUTCSeconds", DATE3, 0),
    utcmilliseconds: fn("getUTCMilliseconds", DATE3, 0),
    length: fn("length", null, -1),
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: fn("toUpperCase", STRING, 0),
    lower: fn("toLowerCase", STRING, 0),
    substring: fn("substring", STRING),
    split: fn("split", STRING),
    trim: fn("trim", STRING, 0),
    regexp: REGEXP,
    test: fn("test", REGEXP),
    if: function(args) {
      if (args.length < 3)
        error("Missing arguments to if function.");
      if (args.length > 3)
        error("Too many arguments to if function.");
      const a4 = args.map(codegen3);
      return "(" + a4[0] + "?" + a4[1] + ":" + a4[2] + ")";
    }
  };
}
function stripQuotes2(s3) {
  const n = s3 && s3.length - 1;
  return n && (s3[0] === '"' && s3[n] === '"' || s3[0] === "'" && s3[n] === "'") ? s3.slice(1, -1) : s3;
}
function codegen2(opt) {
  opt = opt || {};
  const allowed = opt.allowed ? toSet(opt.allowed) : {}, forbidden = opt.forbidden ? toSet(opt.forbidden) : {}, constants3 = opt.constants || Constants2, functions = (opt.functions || Functions2)(visit3), globalvar = opt.globalvar, fieldvar = opt.fieldvar, outputGlobal = isFunction(globalvar) ? globalvar : (id4) => "".concat(globalvar, '["').concat(id4, '"]');
  let globals = {}, fields = {}, memberDepth = 0;
  function visit3(ast) {
    if (isString(ast))
      return ast;
    const generator = Generators[ast.type];
    if (generator == null)
      error("Unsupported type: " + ast.type);
    return generator(ast);
  }
  const Generators = {
    Literal: (n) => n.raw,
    Identifier: (n) => {
      const id4 = n.name;
      if (memberDepth > 0) {
        return id4;
      } else if (has(forbidden, id4)) {
        return error("Illegal identifier: " + id4);
      } else if (has(constants3, id4)) {
        return constants3[id4];
      } else if (has(allowed, id4)) {
        return id4;
      } else {
        globals[id4] = 1;
        return outputGlobal(id4);
      }
    },
    MemberExpression: (n) => {
      const d = !n.computed, o = visit3(n.object);
      if (d)
        memberDepth += 1;
      const p = visit3(n.property);
      if (o === fieldvar) {
        fields[stripQuotes2(p)] = 1;
      }
      if (d)
        memberDepth -= 1;
      return o + (d ? "." + p : "[" + p + "]");
    },
    CallExpression: (n) => {
      if (n.callee.type !== "Identifier") {
        error("Illegal callee type: " + n.callee.type);
      }
      const callee = n.callee.name, args = n.arguments, fn = has(functions, callee) && functions[callee];
      if (!fn)
        error("Unrecognized function: " + callee);
      return isFunction(fn) ? fn(args) : fn + "(" + args.map(visit3).join(",") + ")";
    },
    ArrayExpression: (n) => "[" + n.elements.map(visit3).join(",") + "]",
    BinaryExpression: (n) => "(" + visit3(n.left) + " " + n.operator + " " + visit3(n.right) + ")",
    UnaryExpression: (n) => "(" + n.operator + visit3(n.argument) + ")",
    ConditionalExpression: (n) => "(" + visit3(n.test) + "?" + visit3(n.consequent) + ":" + visit3(n.alternate) + ")",
    LogicalExpression: (n) => "(" + visit3(n.left) + n.operator + visit3(n.right) + ")",
    ObjectExpression: (n) => "{" + n.properties.map(visit3).join(",") + "}",
    Property: (n) => {
      memberDepth += 1;
      const k4 = visit3(n.key);
      memberDepth -= 1;
      return k4 + ":" + visit3(n.value);
    }
  };
  function codegen3(ast) {
    const result = {
      code: visit3(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }
  codegen3.functions = functions;
  codegen3.constants = constants3;
  return codegen3;
}
var RawCode2, Literal2, Property2, Identifier3, ArrayExpression2, BinaryExpression2, CallExpression2, ConditionalExpression2, LogicalExpression2, MemberExpression2, ObjectExpression2, UnaryExpression2, TokenName2, source3, index6, length2, lookahead2, TokenBooleanLiteral2, TokenEOF2, TokenIdentifier2, TokenKeyword2, TokenNullLiteral2, TokenNumericLiteral2, TokenPunctuator2, TokenStringLiteral2, TokenRegularExpression2, SyntaxArrayExpression2, SyntaxBinaryExpression2, SyntaxCallExpression2, SyntaxConditionalExpression2, SyntaxIdentifier2, SyntaxLiteral2, SyntaxLogicalExpression2, SyntaxMemberExpression2, SyntaxObjectExpression2, SyntaxProperty2, SyntaxUnaryExpression2, MessageUnexpectedToken2, MessageUnexpectedNumber2, MessageUnexpectedString2, MessageUnexpectedIdentifier2, MessageUnexpectedReserved2, MessageUnexpectedEOS2, MessageInvalidRegExp2, MessageUnterminatedRegExp2, MessageStrictOctalLiteral2, MessageStrictDuplicateProperty2, ILLEGAL3, DISABLED2, RegexNonAsciiIdentifierStart2, RegexNonAsciiIdentifierPart2, keywords2, legalKeywords2, Constants2;
var init_vega_expression_module2 = __esm({
  "node_modules/.pnpm/vega-expression@4.0.1/node_modules/vega-expression/build/vega-expression.module.js"() {
    init_vega_util_module();
    RawCode2 = "RawCode";
    Literal2 = "Literal";
    Property2 = "Property";
    Identifier3 = "Identifier";
    ArrayExpression2 = "ArrayExpression";
    BinaryExpression2 = "BinaryExpression";
    CallExpression2 = "CallExpression";
    ConditionalExpression2 = "ConditionalExpression";
    LogicalExpression2 = "LogicalExpression";
    MemberExpression2 = "MemberExpression";
    ObjectExpression2 = "ObjectExpression";
    UnaryExpression2 = "UnaryExpression";
    ASTNode2.prototype.visit = function(visitor) {
      let c2, i, n;
      if (visitor(this))
        return 1;
      for (c2 = children3(this), i = 0, n = c2.length; i < n; ++i) {
        if (c2[i].visit(visitor))
          return 1;
      }
    };
    TokenBooleanLiteral2 = 1;
    TokenEOF2 = 2;
    TokenIdentifier2 = 3;
    TokenKeyword2 = 4;
    TokenNullLiteral2 = 5;
    TokenNumericLiteral2 = 6;
    TokenPunctuator2 = 7;
    TokenStringLiteral2 = 8;
    TokenRegularExpression2 = 9;
    TokenName2 = {};
    TokenName2[TokenBooleanLiteral2] = "Boolean";
    TokenName2[TokenEOF2] = "<end>";
    TokenName2[TokenIdentifier2] = "Identifier";
    TokenName2[TokenKeyword2] = "Keyword";
    TokenName2[TokenNullLiteral2] = "Null";
    TokenName2[TokenNumericLiteral2] = "Numeric";
    TokenName2[TokenPunctuator2] = "Punctuator";
    TokenName2[TokenStringLiteral2] = "String";
    TokenName2[TokenRegularExpression2] = "RegularExpression";
    SyntaxArrayExpression2 = "ArrayExpression";
    SyntaxBinaryExpression2 = "BinaryExpression";
    SyntaxCallExpression2 = "CallExpression";
    SyntaxConditionalExpression2 = "ConditionalExpression";
    SyntaxIdentifier2 = "Identifier";
    SyntaxLiteral2 = "Literal";
    SyntaxLogicalExpression2 = "LogicalExpression";
    SyntaxMemberExpression2 = "MemberExpression";
    SyntaxObjectExpression2 = "ObjectExpression";
    SyntaxProperty2 = "Property";
    SyntaxUnaryExpression2 = "UnaryExpression";
    MessageUnexpectedToken2 = "Unexpected token %0";
    MessageUnexpectedNumber2 = "Unexpected number";
    MessageUnexpectedString2 = "Unexpected string";
    MessageUnexpectedIdentifier2 = "Unexpected identifier";
    MessageUnexpectedReserved2 = "Unexpected reserved word";
    MessageUnexpectedEOS2 = "Unexpected end of input";
    MessageInvalidRegExp2 = "Invalid regular expression";
    MessageUnterminatedRegExp2 = "Invalid regular expression: missing /";
    MessageStrictOctalLiteral2 = "Octal literals are not allowed in strict mode.";
    MessageStrictDuplicateProperty2 = "Duplicate data property in object literal not allowed in strict mode";
    ILLEGAL3 = "ILLEGAL";
    DISABLED2 = "Disabled.";
    RegexNonAsciiIdentifierStart2 = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
    RegexNonAsciiIdentifierPart2 = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
    keywords2 = {
      "if": 1,
      "in": 1,
      "do": 1,
      "var": 1,
      "for": 1,
      "new": 1,
      "try": 1,
      "let": 1,
      "this": 1,
      "else": 1,
      "case": 1,
      "void": 1,
      "with": 1,
      "enum": 1,
      "while": 1,
      "break": 1,
      "catch": 1,
      "throw": 1,
      "const": 1,
      "yield": 1,
      "class": 1,
      "super": 1,
      "return": 1,
      "typeof": 1,
      "delete": 1,
      "switch": 1,
      "export": 1,
      "import": 1,
      "public": 1,
      "static": 1,
      "default": 1,
      "finally": 1,
      "extends": 1,
      "package": 1,
      "private": 1,
      "function": 1,
      "continue": 1,
      "debugger": 1,
      "interface": 1,
      "protected": 1,
      "instanceof": 1,
      "implements": 1
    };
    legalKeywords2 = {
      "if": 1
    };
    Constants2 = {
      NaN: "NaN",
      E: "Math.E",
      LN2: "Math.LN2",
      LN10: "Math.LN10",
      LOG2E: "Math.LOG2E",
      LOG10E: "Math.LOG10E",
      PI: "Math.PI",
      SQRT1_2: "Math.SQRT1_2",
      SQRT2: "Math.SQRT2",
      MIN_VALUE: "Number.MIN_VALUE",
      MAX_VALUE: "Number.MAX_VALUE"
    };
  }
});

// node_modules/.pnpm/vega-event-selector@2.0.6/node_modules/vega-event-selector/build/vega-event-selector.module.js
function eventSelector2(selector, source5, marks) {
  DEFAULT_SOURCE2 = source5 || VIEW3;
  MARKS2 = marks || DEFAULT_MARKS2;
  return parseMerge2(selector.trim()).map(parseSelector2);
}
function isMarkType2(type4) {
  return MARKS2[type4];
}
function find4(s3, i, endChar, pushChar, popChar) {
  const n = s3.length;
  let count5 = 0, c2;
  for (; i < n; ++i) {
    c2 = s3[i];
    if (!count5 && c2 === endChar)
      return i;
    else if (popChar && popChar.indexOf(c2) >= 0)
      --count5;
    else if (pushChar && pushChar.indexOf(c2) >= 0)
      ++count5;
  }
  return i;
}
function parseMerge2(s3) {
  const output3 = [], n = s3.length;
  let start = 0, i = 0;
  while (i < n) {
    i = find4(s3, i, COMMA2, LBRACK2 + LBRACE2, RBRACK2 + RBRACE2);
    output3.push(s3.substring(start, i).trim());
    start = ++i;
  }
  if (output3.length === 0) {
    throw "Empty event selector: " + s3;
  }
  return output3;
}
function parseSelector2(s3) {
  return s3[0] === "[" ? parseBetween2(s3) : parseStream4(s3);
}
function parseBetween2(s3) {
  const n = s3.length;
  let i = 1, b3;
  i = find4(s3, i, RBRACK2, LBRACK2, RBRACK2);
  if (i === n) {
    throw "Empty between selector: " + s3;
  }
  b3 = parseMerge2(s3.substring(1, i));
  if (b3.length !== 2) {
    throw "Between selector must have two elements: " + s3;
  }
  s3 = s3.slice(i + 1).trim();
  if (s3[0] !== GT2) {
    throw "Expected '>' after between selector: " + s3;
  }
  b3 = b3.map(parseSelector2);
  const stream2 = parseSelector2(s3.slice(1).trim());
  if (stream2.between) {
    return {
      between: b3,
      stream: stream2
    };
  } else {
    stream2.between = b3;
  }
  return stream2;
}
function parseStream4(s3) {
  const stream2 = {
    source: DEFAULT_SOURCE2
  }, source5 = [];
  let throttle = [0, 0], markname = 0, start = 0, n = s3.length, i = 0, j, filter6;
  if (s3[n - 1] === RBRACE2) {
    i = s3.lastIndexOf(LBRACE2);
    if (i >= 0) {
      try {
        throttle = parseThrottle2(s3.substring(i + 1, n - 1));
      } catch (e3) {
        throw "Invalid throttle specification: " + s3;
      }
      s3 = s3.slice(0, i).trim();
      n = s3.length;
    } else
      throw "Unmatched right brace: " + s3;
    i = 0;
  }
  if (!n)
    throw s3;
  if (s3[0] === NAME2)
    markname = ++i;
  j = find4(s3, i, COLON2);
  if (j < n) {
    source5.push(s3.substring(start, j).trim());
    start = i = ++j;
  }
  i = find4(s3, i, LBRACK2);
  if (i === n) {
    source5.push(s3.substring(start, n).trim());
  } else {
    source5.push(s3.substring(start, i).trim());
    filter6 = [];
    start = ++i;
    if (start === n)
      throw "Unmatched left bracket: " + s3;
  }
  while (i < n) {
    i = find4(s3, i, RBRACK2);
    if (i === n)
      throw "Unmatched left bracket: " + s3;
    filter6.push(s3.substring(start, i).trim());
    if (i < n - 1 && s3[++i] !== LBRACK2)
      throw "Expected left bracket: " + s3;
    start = ++i;
  }
  if (!(n = source5.length) || ILLEGAL4.test(source5[n - 1])) {
    throw "Invalid event selector: " + s3;
  }
  if (n > 1) {
    stream2.type = source5[1];
    if (markname) {
      stream2.markname = source5[0].slice(1);
    } else if (isMarkType2(source5[0])) {
      stream2.marktype = source5[0];
    } else {
      stream2.source = source5[0];
    }
  } else {
    stream2.type = source5[0];
  }
  if (stream2.type.slice(-1) === "!") {
    stream2.consume = true;
    stream2.type = stream2.type.slice(0, -1);
  }
  if (filter6 != null)
    stream2.filter = filter6;
  if (throttle[0])
    stream2.throttle = throttle[0];
  if (throttle[1])
    stream2.debounce = throttle[1];
  return stream2;
}
function parseThrottle2(s3) {
  const a4 = s3.split(COMMA2);
  if (!s3.length || a4.length > 2)
    throw s3;
  return a4.map((_) => {
    const x7 = +_;
    if (x7 !== x7)
      throw s3;
    return x7;
  });
}
var VIEW3, LBRACK2, RBRACK2, LBRACE2, RBRACE2, COLON2, COMMA2, NAME2, GT2, ILLEGAL4, DEFAULT_MARKS2, DEFAULT_SOURCE2, MARKS2;
var init_vega_event_selector_module2 = __esm({
  "node_modules/.pnpm/vega-event-selector@2.0.6/node_modules/vega-event-selector/build/vega-event-selector.module.js"() {
    VIEW3 = "view";
    LBRACK2 = "[";
    RBRACK2 = "]";
    LBRACE2 = "{";
    RBRACE2 = "}";
    COLON2 = ":";
    COMMA2 = ",";
    NAME2 = "@";
    GT2 = ">";
    ILLEGAL4 = /[[\]{}]/;
    DEFAULT_MARKS2 = {
      "*": 1,
      arc: 1,
      area: 1,
      group: 1,
      image: 1,
      line: 1,
      path: 1,
      rect: 1,
      rule: 1,
      shape: 1,
      symbol: 1,
      text: 1,
      trail: 1
    };
  }
});

// node_modules/.pnpm/vega@5.20.0/node_modules/vega/build/vega.module.js
var vega_module_exports = {};
__export(vega_module_exports, {
  Bounds: () => Bounds2,
  CanvasHandler: () => CanvasHandler2,
  CanvasRenderer: () => CanvasRenderer2,
  DATE: () => DATE2,
  DAY: () => DAY2,
  DAYOFYEAR: () => DAYOFYEAR2,
  Dataflow: () => Dataflow,
  Debug: () => Debug,
  Error: () => Error$1,
  EventStream: () => EventStream,
  Gradient: () => Gradient,
  GroupItem: () => GroupItem2,
  HOURS: () => HOURS2,
  Handler: () => Handler2,
  Info: () => Info,
  Item: () => Item2,
  MILLISECONDS: () => MILLISECONDS2,
  MINUTES: () => MINUTES2,
  MONTH: () => MONTH2,
  Marks: () => Marks2,
  MultiPulse: () => MultiPulse,
  None: () => None,
  Operator: () => Operator,
  Parameters: () => Parameters,
  Pulse: () => Pulse,
  QUARTER: () => QUARTER2,
  RenderType: () => RenderType,
  Renderer: () => Renderer2,
  ResourceLoader: () => ResourceLoader2,
  SECONDS: () => SECONDS2,
  SVGHandler: () => SVGHandler2,
  SVGRenderer: () => SVGRenderer2,
  SVGStringRenderer: () => SVGStringRenderer2,
  Scenegraph: () => Scenegraph2,
  TIME_UNITS: () => TIME_UNITS2,
  Transform: () => Transform,
  View: () => View,
  WEEK: () => WEEK2,
  Warn: () => Warn,
  YEAR: () => YEAR2,
  accessor: () => accessor,
  accessorFields: () => accessorFields,
  accessorName: () => accessorName,
  array: () => array,
  ascending: () => ascending,
  bandwidthNRD: () => estimateBandwidth,
  bin: () => bin2,
  bootstrapCI: () => bootstrapCI,
  boundClip: () => boundClip2,
  boundContext: () => boundContext2,
  boundItem: () => boundItem3,
  boundMark: () => boundMark2,
  boundStroke: () => boundStroke2,
  changeset: () => changeset,
  clampRange: () => clampRange,
  codegenExpression: () => codegen2,
  compare: () => compare2,
  constant: () => constant,
  cumulativeLogNormal: () => cumulativeLogNormal,
  cumulativeNormal: () => cumulativeNormal,
  cumulativeUniform: () => cumulativeUniform,
  dayofyear: () => dayofyear,
  debounce: () => debounce,
  defaultLocale: () => defaultLocale7,
  definition: () => definition,
  densityLogNormal: () => densityLogNormal,
  densityNormal: () => densityNormal,
  densityUniform: () => densityUniform,
  domChild: () => domChild2,
  domClear: () => domClear2,
  domCreate: () => domCreate2,
  domFind: () => domFind2,
  dotbin: () => dotbin,
  error: () => error,
  expressionFunction: () => expressionFunction,
  extend: () => extend,
  extent: () => extent,
  extentIndex: () => extentIndex,
  falsy: () => falsy,
  fastmap: () => fastmap,
  field: () => field,
  flush: () => flush,
  font: () => font2,
  fontFamily: () => fontFamily2,
  fontSize: () => fontSize2,
  format: () => format7,
  formatLocale: () => numberFormatDefaultLocale2,
  formats: () => formats4,
  hasOwnProperty: () => has,
  id: () => id,
  identity: () => identity,
  inferType: () => inferType2,
  inferTypes: () => inferTypes2,
  ingest: () => ingest$1,
  inherits: () => inherits,
  inrange: () => inrange,
  interpolate: () => interpolate2,
  interpolateColors: () => interpolateColors2,
  interpolateRange: () => interpolateRange,
  intersect: () => intersect4,
  intersectBoxLine: () => intersectBoxLine2,
  intersectPath: () => intersectPath2,
  intersectPoint: () => intersectPoint2,
  intersectRule: () => intersectRule2,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isFunction: () => isFunction,
  isIterable: () => isIterable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isTuple: () => isTuple,
  key: () => key,
  lerp: () => lerp,
  lineHeight: () => lineHeight2,
  loader: () => loader2,
  locale: () => locale6,
  logger: () => logger,
  lruCache: () => lruCache,
  markup: () => markup2,
  merge: () => merge,
  mergeConfig: () => mergeConfig,
  multiLineOffset: () => multiLineOffset2,
  one: () => one,
  pad: () => pad,
  panLinear: () => panLinear,
  panLog: () => panLog,
  panPow: () => panPow,
  panSymlog: () => panSymlog,
  parse: () => parse7,
  parseExpression: () => parser3,
  parseSelector: () => eventSelector2,
  pathCurves: () => curves2,
  pathEqual: () => pathEqual,
  pathParse: () => pathParse,
  pathRectangle: () => vg_rect2,
  pathRender: () => pathRender2,
  pathSymbols: () => symbols5,
  pathTrail: () => vg_trail2,
  peek: () => peek,
  point: () => point14,
  projection: () => projection2,
  quantileLogNormal: () => quantileLogNormal,
  quantileNormal: () => quantileNormal,
  quantileUniform: () => quantileUniform,
  quantiles: () => quantiles,
  quantizeInterpolator: () => quantizeInterpolator,
  quarter: () => quarter,
  quartiles: () => quartiles,
  random: () => random,
  randomInteger: () => integer,
  randomKDE: () => kde,
  randomLCG: () => lcg,
  randomLogNormal: () => lognormal,
  randomMixture: () => mixture,
  randomNormal: () => gaussian,
  randomUniform: () => uniform,
  read: () => read2,
  regressionExp: () => exp2,
  regressionLinear: () => linear,
  regressionLoess: () => loess,
  regressionLog: () => log2,
  regressionPoly: () => poly,
  regressionPow: () => pow2,
  regressionQuad: () => quad,
  renderModule: () => renderModule,
  repeat: () => repeat,
  resetDefaultLocale: () => resetDefaultLocale,
  resetSVGClipId: () => resetSVGClipId,
  resetSVGDefIds: () => resetSVGDefIds,
  responseType: () => responseType2,
  runtimeContext: () => context3,
  sampleCurve: () => sampleCurve,
  sampleLogNormal: () => sampleLogNormal,
  sampleNormal: () => sampleNormal,
  sampleUniform: () => sampleUniform,
  scale: () => scale3,
  sceneEqual: () => sceneEqual,
  sceneFromJSON: () => sceneFromJSON2,
  scenePickVisit: () => pickVisit2,
  sceneToJSON: () => sceneToJSON2,
  sceneVisit: () => visit2,
  sceneZOrder: () => zorder2,
  scheme: () => scheme2,
  serializeXML: () => serializeXML2,
  setRandom: () => setRandom,
  span: () => span,
  splitAccessPath: () => splitAccessPath,
  stringValue: () => $,
  textMetrics: () => textMetrics2,
  timeBin: () => bin3,
  timeFloor: () => timeFloor,
  timeFormatLocale: () => timeFormatDefaultLocale2,
  timeInterval: () => timeInterval3,
  timeOffset: () => timeOffset,
  timeSequence: () => timeSequence,
  timeUnitSpecifier: () => timeUnitSpecifier,
  timeUnits: () => timeUnits,
  toBoolean: () => toBoolean,
  toDate: () => toDate,
  toNumber: () => toNumber,
  toSet: () => toSet,
  toString: () => toString,
  transform: () => transform,
  transforms: () => transforms,
  truncate: () => truncate,
  truthy: () => truthy,
  tupleid: () => tupleid,
  typeParsers: () => typeParsers2,
  utcFloor: () => utcFloor,
  utcInterval: () => utcInterval2,
  utcOffset: () => utcOffset,
  utcSequence: () => utcSequence,
  utcdayofyear: () => utcdayofyear,
  utcquarter: () => utcquarter,
  utcweek: () => utcweek,
  version: () => version,
  visitArray: () => visitArray,
  week: () => week,
  writeConfig: () => writeConfig,
  zero: () => zero,
  zoomLinear: () => zoomLinear,
  zoomLog: () => zoomLog,
  zoomPow: () => zoomPow,
  zoomSymlog: () => zoomSymlog
});
var name, version$1, description, keywords3, license, author, main, module, unpkg, jsdelivr, types, repository, scripts, dependencies, devDependencies, gitHead, pkg, version;
var init_vega_module = __esm({
  "node_modules/.pnpm/vega@5.20.0/node_modules/vega/build/vega.module.js"() {
    init_vega_util_module();
    init_vega_util_module();
    init_vega_dataflow_module();
    init_vega_dataflow_module();
    init_vega_transforms_module();
    init_vega_view_transforms_module();
    init_vega_encode_module();
    init_vega_geo_module();
    init_vega_force_module();
    init_vega_hierarchy_module();
    init_vega_label_module();
    init_vega_regression_module();
    init_vega_voronoi_module();
    init_vega_wordcloud_module();
    init_vega_crossfilter_module();
    init_vega_statistics_module();
    init_vega_time_module2();
    init_vega_loader_browser_module2();
    init_vega_scenegraph_module2();
    init_vega_scale_module2();
    init_vega_projection_module();
    init_vega_view_module();
    init_vega_format_module2();
    init_vega_functions_module();
    init_vega_parser_module();
    init_vega_runtime_module();
    init_vega_expression_module2();
    init_vega_event_selector_module2();
    name = "vega";
    version$1 = "5.20.0";
    description = "The Vega visualization grammar.";
    keywords3 = [
      "vega",
      "visualization",
      "interaction",
      "dataflow",
      "library",
      "data",
      "d3"
    ];
    license = "BSD-3-Clause";
    author = "UW Interactive Data Lab (http://idl.cs.washington.edu)";
    main = "build/vega-node.js";
    module = "build/vega.module.js";
    unpkg = "build/vega.min.js";
    jsdelivr = "build/vega.min.js";
    types = "index.d.ts";
    repository = "vega/vega";
    scripts = {
      bundle: "rollup -c --config-bundle",
      prebuild: "rimraf build && rimraf build-es5",
      build: "rollup -c --config-core --config-bundle --config-ie",
      postbuild: "node schema-copy",
      pretest: "yarn build --config-test",
      test: "TZ=America/Los_Angeles tape 'test/**/*-test.js'",
      prepublishOnly: "yarn test && yarn build",
      postpublish: "./schema-deploy.sh"
    };
    dependencies = {
      "vega-crossfilter": "~4.0.5",
      "vega-dataflow": "~5.7.3",
      "vega-encode": "~4.8.3",
      "vega-event-selector": "~2.0.6",
      "vega-expression": "~4.0.1",
      "vega-force": "~4.0.7",
      "vega-format": "~1.0.4",
      "vega-functions": "~5.12.0",
      "vega-geo": "~4.3.8",
      "vega-hierarchy": "~4.0.9",
      "vega-label": "~1.0.0",
      "vega-loader": "~4.4.0",
      "vega-parser": "~6.1.3",
      "vega-projection": "~1.4.5",
      "vega-regression": "~1.0.9",
      "vega-runtime": "~6.1.3",
      "vega-scale": "~7.1.1",
      "vega-scenegraph": "~4.9.4",
      "vega-statistics": "~1.7.9",
      "vega-time": "~2.0.4",
      "vega-transforms": "~4.9.3",
      "vega-typings": "~0.20.0",
      "vega-util": "~1.16.1",
      "vega-view": "~5.10.0",
      "vega-view-transforms": "~4.5.8",
      "vega-voronoi": "~4.1.5",
      "vega-wordcloud": "~4.1.3"
    };
    devDependencies = {
      "vega-schema": "*"
    };
    gitHead = "f262105e75449760b0f35fda70e6b576a31d68a4";
    pkg = {
      name,
      version: version$1,
      description,
      keywords: keywords3,
      license,
      author,
      main,
      module,
      unpkg,
      jsdelivr,
      types,
      repository,
      scripts,
      dependencies,
      devDependencies,
      gitHead
    };
    extend(transforms, vega_transforms_module_exports, vega_view_transforms_module_exports, vega_encode_module_exports, vega_geo_module_exports, vega_force_module_exports, vega_label_module_exports, vega_hierarchy_module_exports, vega_regression_module_exports, vega_voronoi_module_exports, vega_wordcloud_module_exports, vega_crossfilter_module_exports);
    version = pkg.version;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/package.json
var package_default;
var init_package = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/package.json"() {
    package_default = {
      name: "vega-lite",
      author: 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer',
      version: "4.13.1",
      collaborators: [
        "Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)",
        "Dominik Moritz (https://www.domoritz.de)",
        "Arvind Satyanarayan (https://arvindsatya.com)",
        "Jeffrey Heer (https://jheer.org)"
      ],
      homepage: "https://vega.github.io/vega-lite/",
      description: "Vega-Lite is a concise high-level language for interactive visualization.",
      main: "build/vega-lite.js",
      unpkg: "build/vega-lite.min.js",
      jsdelivr: "build/vega-lite.min.js",
      module: "build/src/index",
      types: "build/src/index.d.ts",
      bin: {
        vl2png: "./bin/vl2png",
        vl2svg: "./bin/vl2svg",
        vl2pdf: "./bin/vl2pdf",
        vl2vg: "./bin/vl2vg"
      },
      directories: {
        test: "test"
      },
      scripts: {
        changelog: "conventional-changelog -p angular -r 2",
        build: "yarn build:only",
        "build:only": "yarn tsc:src && rollup -c",
        postbuild: "terser build/vega-lite.js -cm --source-map content=build/vega-lite.js.map,filename=build/vega-lite.min.js.map -o build/vega-lite.min.js && yarn schema && babel build/vega-lite.js --out-dir build-es5 --config-file ./babel.config.js",
        "prebuild:examples": "yarn build:only",
        "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
        "prebuild:examples-full": "yarn build:only",
        "build:examples-full": "TZ=America/Los_Angeles scripts/build-examples.sh 1",
        "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
        "build:toc": "yarn build:jekyll && scripts/generate-toc",
        "build:site": "yarn tsc:site && rollup -c site/rollup.config.js",
        "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
        "build:versions": "scripts/update-version.sh",
        clean: "find build ! -name 'vega-lite-schema.json' -type f -delete && rm -rf site/data/* && rm -f examples/compiled/*.png && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
        "predeploy:site": "yarn presite",
        "deploy:site": "gh-pages -d site",
        data: "rsync -r node_modules/vega-datasets/data/* site/data",
        schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
        renameschema: "scripts/rename-schema.sh",
        presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
        site: "pushd site && bundle exec jekyll serve -I -l && popd",
        "tsc:src": "tsc -b src/tsconfig.src.json",
        "tsc:site": "tsc -b site/tsconfig.site.json",
        prettierbase: "prettier '**/*.{md,css,yml}'",
        eslintbase: "eslint .",
        format: "yarn eslintbase --fix && yarn prettierbase --write",
        lint: "yarn eslintbase && yarn prettierbase --check",
        test: "jest test/ && yarn lint && yarn schema && jest examples/ && yarn test:runtime",
        "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand test",
        "test:runtime": "TZ=America/Los_Angeles jest test-runtime/",
        "test:runtime:generate": "yarn build:only && rm -Rf test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
        "watch:build": "yarn build:only && concurrently --kill-others -n Typescript,Rollup 'yarn tsc:src -w' 'rollup -c -w'",
        "watch:site": "concurrently --kill-others -n Typescript,Rollup 'yarn tsc:site -w' 'rollup -c site/rollup.config.js -w'",
        "watch:test": "jest --watch"
      },
      repository: {
        type: "git",
        url: "https://github.com/vega/vega-lite.git"
      },
      license: "BSD-3-Clause",
      bugs: {
        url: "https://github.com/vega/vega-lite/issues"
      },
      devDependencies: {
        "@babel/cli": "^7.10.1",
        "@babel/core": "^7.10.1",
        "@babel/preset-env": "^7.10.1",
        "@rollup/plugin-commonjs": "12.0.0",
        "@rollup/plugin-json": "^4.0.3",
        "@rollup/plugin-node-resolve": "^8.0.0",
        "@types/chai": "^4.2.11",
        "@types/d3": "^5.7.2",
        "@types/jest": "^25.2.3",
        "@types/mkdirp": "^1.0.0",
        "@types/puppeteer": "^3.0.0",
        "@typescript-eslint/eslint-plugin": "^3.0.2",
        "@typescript-eslint/parser": "^3.0.2",
        ajv: "^6.12.2",
        chai: "^4.2.0",
        cheerio: "^1.0.0-rc.3",
        codecov: "^3.7.0",
        concurrently: "^5.2.0",
        "conventional-changelog-cli": "^2.0.34",
        d3: "^5.16.0",
        eslint: "^7.1.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-jest": "^23.13.2",
        "eslint-plugin-prettier": "^3.1.3",
        "gh-pages": "^2.2.0",
        "highlight.js": "^10.0.3",
        "http-server": "^0.12.3",
        jest: "^26.0.1",
        "jest-puppeteer": "^4.4.0",
        mkdirp: "^1.0.4",
        prettier: "^2.0.5",
        puppeteer: "^3.1.0",
        rollup: "^2.11.0",
        "rollup-plugin-sourcemaps": "^0.6.2",
        "rollup-plugin-terser": "^6.1.0",
        "svg2png-many": "^0.0.7",
        terser: "^4.7.0",
        "ts-jest": "^26.0.0",
        "ts-json-schema-generator": "^0.68.1",
        typescript: "~3.9.3",
        "vega-cli": "^5.12.1",
        "vega-datasets": "^1.30.2",
        "vega-embed": "^6.8.0",
        "vega-tooltip": "^0.23.0",
        "vega-typings": "^0.17.0",
        "yaml-front-matter": "^4.1.0"
      },
      dependencies: {
        "@types/clone": "~0.1.30",
        "@types/fast-json-stable-stringify": "^2.0.0",
        "array-flat-polyfill": "^1.0.1",
        clone: "~2.1.2",
        "fast-deep-equal": "~3.1.1",
        "fast-json-stable-stringify": "~2.1.0",
        "json-stringify-pretty-compact": "~2.0.0",
        tslib: "~2.0.0",
        "vega-event-selector": "~2.0.3",
        "vega-expression": "~2.6.5",
        "vega-util": "~1.14.0",
        yargs: "~15.3.1"
      },
      peerDependencies: {
        vega: "^5.12.1"
      },
      jest: {
        preset: "jest-puppeteer",
        transform: {
          "^.+\\.tsx?$": "ts-jest"
        },
        testRegex: "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
        moduleFileExtensions: [
          "ts",
          "tsx",
          "js",
          "jsx",
          "json",
          "node"
        ],
        testPathIgnorePatterns: [
          "<rootDir>/node_modules",
          "<rootDir>/build",
          "<rootDir>/_site",
          "<rootDir>/src"
        ],
        coverageDirectory: "./coverage/",
        collectCoverage: false
      }
    };
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/accessor.js
function accessor_default(fn, fields, name4) {
  fn.fields = fields || [];
  fn.fname = name4;
  return fn;
}
var init_accessor = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/accessor.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/getter.js
function getter_default(path5) {
  return path5.length === 1 ? get13(path5[0]) : getN3(path5);
}
var get13, getN3;
var init_getter = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/getter.js"() {
    get13 = (field4) => function(obj) {
      return obj[field4];
    };
    getN3 = (path5) => {
      const len = path5.length;
      return function(obj) {
        for (let i = 0; i < len; ++i) {
          obj = obj[path5[i]];
        }
        return obj;
      };
    };
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/error.js
function error_default(message) {
  throw Error(message);
}
var init_error = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/error.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/splitAccessPath.js
function splitAccessPath_default(p) {
  var path5 = [], q = null, b3 = 0, n = p.length, s3 = "", i, j, c2;
  p = p + "";
  function push() {
    path5.push(s3 + p.substring(i, j));
    s3 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c2 = p[j];
    if (c2 === "\\") {
      s3 += p.substring(i, j);
      s3 += p.substring(++j, ++j);
      i = j;
    } else if (c2 === q) {
      push();
      q = null;
      b3 = -1;
    } else if (q) {
      continue;
    } else if (i === b3 && c2 === '"') {
      i = j + 1;
      q = c2;
    } else if (i === b3 && c2 === "'") {
      i = j + 1;
      q = c2;
    } else if (c2 === "." && !b3) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c2 === "[") {
      if (j > i)
        push();
      b3 = i = j + 1;
    } else if (c2 === "]") {
      if (!b3)
        error_default("Access path missing open bracket: " + p);
      if (b3 > 0)
        push();
      b3 = 0;
      i = j + 1;
    }
  }
  if (b3)
    error_default("Access path missing closing bracket: " + p);
  if (q)
    error_default("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path5;
}
var init_splitAccessPath = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/splitAccessPath.js"() {
    init_error();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/field.js
function field_default(field4, name4, opt) {
  const path5 = splitAccessPath_default(field4);
  field4 = path5.length === 1 ? path5[0] : field4;
  return accessor_default(
    (opt && opt.get || getter_default)(path5),
    [field4],
    name4 || field4
  );
}
var init_field = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/field.js"() {
    init_accessor();
    init_getter();
    init_splitAccessPath();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/accessors.js
var empty, id3, identity11, zero8, one6, truthy3, falsy3;
var init_accessors2 = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/accessors.js"() {
    init_accessor();
    init_field();
    empty = [];
    id3 = field_default("id");
    identity11 = accessor_default(function(_) {
      return _;
    }, empty, "identity");
    zero8 = accessor_default(function() {
      return 0;
    }, empty, "zero");
    one6 = accessor_default(function() {
      return 1;
    }, empty, "one");
    truthy3 = accessor_default(function() {
      return true;
    }, empty, "true");
    falsy3 = accessor_default(function() {
      return false;
    }, empty, "false");
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/logger.js
function log8(method3, level, input) {
  var args = [level].concat([].slice.call(input));
  console[method3].apply(console, args);
}
function logger_default(_, method3) {
  var level = _ || None6;
  return {
    level: function(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error: function() {
      if (level >= Error2)
        log8(method3 || "error", "ERROR", arguments);
      return this;
    },
    warn: function() {
      if (level >= Warn3)
        log8(method3 || "warn", "WARN", arguments);
      return this;
    },
    info: function() {
      if (level >= Info3)
        log8(method3 || "log", "INFO", arguments);
      return this;
    },
    debug: function() {
      if (level >= Debug3)
        log8(method3 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var None6, Error2, Warn3, Info3, Debug3;
var init_logger = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/logger.js"() {
    None6 = 0;
    Error2 = 1;
    Warn3 = 2;
    Info3 = 3;
    Debug3 = 4;
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isArray.js
var isArray_default;
var init_isArray = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isArray.js"() {
    isArray_default = Array.isArray;
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isObject.js
function isObject_default(_) {
  return _ === Object(_);
}
var init_isObject = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isObject.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/mergeConfig.js
function mergeConfig2(...configs) {
  return configs.reduce((out, source5) => {
    for (var key3 in source5) {
      if (key3 === "signals") {
        out.signals = mergeNamed2(out.signals, source5.signals);
      } else {
        var r2 = key3 === "legend" ? { layout: 1 } : key3 === "style" ? true : null;
        writeConfig2(out, key3, source5[key3], r2);
      }
    }
    return out;
  }, {});
}
function writeConfig2(output3, key3, value4, recurse3) {
  if (!isLegalKey2(key3))
    return;
  var k4, o;
  if (isObject_default(value4) && !isArray_default(value4)) {
    o = isObject_default(output3[key3]) ? output3[key3] : output3[key3] = {};
    for (k4 in value4) {
      if (recurse3 && (recurse3 === true || recurse3[k4])) {
        writeConfig2(o, k4, value4[k4]);
      } else if (isLegalKey2(k4)) {
        o[k4] = value4[k4];
      }
    }
  } else {
    output3[key3] = value4;
  }
}
function mergeNamed2(a4, b3) {
  if (a4 == null)
    return b3;
  const map11 = {}, out = [];
  function add7(_) {
    if (!map11[_.name]) {
      map11[_.name] = 1;
      out.push(_);
    }
  }
  b3.forEach(add7);
  a4.forEach(add7);
  return out;
}
var isLegalKey2;
var init_mergeConfig = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/mergeConfig.js"() {
    init_isArray();
    init_isObject();
    isLegalKey2 = (key3) => key3 !== "__proto__";
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/peek.js
var init_peek = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/peek.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/toNumber.js
var init_toNumber = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/toNumber.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/transform.js
var init_transform5 = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/transform.js"() {
    init_accessors2();
    init_peek();
    init_toNumber();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/quarter.js
var init_quarter = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/quarter.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/array.js
function array_default6(_) {
  return _ != null ? isArray_default(_) ? _ : [_] : [];
}
var init_array9 = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/array.js"() {
    init_isArray();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/clampRange.js
var init_clampRange = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/clampRange.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isFunction.js
function isFunction_default(_) {
  return typeof _ === "function";
}
var init_isFunction = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isFunction.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/compare.js
var init_compare = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/compare.js"() {
    init_accessor();
    init_array9();
    init_field();
    init_isFunction();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/constant.js
var init_constant13 = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/constant.js"() {
    init_isFunction();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/debounce.js
var init_debounce = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/debounce.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/extend.js
var init_extend = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/extend.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/extent.js
var init_extent6 = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/extent.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/extentIndex.js
var init_extentIndex = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/extentIndex.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/hasOwnProperty.js
function hasOwnProperty_default(object2, property2) {
  return hop3.call(object2, property2);
}
var hop3;
var init_hasOwnProperty = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/hasOwnProperty.js"() {
    hop3 = Object.prototype.hasOwnProperty;
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/fastmap.js
var init_fastmap = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/fastmap.js"() {
    init_hasOwnProperty();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/flush.js
var init_flush = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/flush.js"() {
    init_peek();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/inherits.js
var init_inherits = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/inherits.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/inrange.js
var init_inrange = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/inrange.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isBoolean.js
function isBoolean_default(_) {
  return typeof _ === "boolean";
}
var init_isBoolean = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isBoolean.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isDate.js
var init_isDate = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isDate.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isNumber.js
function isNumber_default(_) {
  return typeof _ === "number";
}
var init_isNumber = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isNumber.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isRegExp.js
var init_isRegExp = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isRegExp.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isString.js
function isString_default(_) {
  return typeof _ === "string";
}
var init_isString = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/isString.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/key.js
var init_key = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/key.js"() {
    init_accessor();
    init_array9();
    init_getter();
    init_splitAccessPath();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/lerp.js
var init_lerp = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/lerp.js"() {
    init_peek();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/lruCache.js
var init_lruCache = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/lruCache.js"() {
    init_hasOwnProperty();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/merge.js
var init_merge5 = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/merge.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/repeat.js
var init_repeat = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/repeat.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/pad.js
var init_pad = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/pad.js"() {
    init_repeat();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/span.js
var init_span = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/span.js"() {
    init_peek();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/stringValue.js
function $3(x7) {
  return isArray_default(x7) ? "[" + x7.map($3) + "]" : isObject_default(x7) || isString_default(x7) ? JSON.stringify(x7).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : x7;
}
var init_stringValue = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/stringValue.js"() {
    init_isArray();
    init_isObject();
    init_isString();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/toBoolean.js
var init_toBoolean = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/toBoolean.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/toDate.js
var init_toDate = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/toDate.js"() {
    init_isDate();
    init_isNumber();
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/toString.js
var init_toString = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/toString.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/toSet.js
function toSet_default(_) {
  for (var s3 = {}, i = 0, n = _.length; i < n; ++i)
    s3[_[i]] = true;
  return s3;
}
var init_toSet = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/toSet.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/truncate.js
var init_truncate = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/truncate.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/visitArray.js
var init_visitArray = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/src/visitArray.js"() {
  }
});

// node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/index.js
var init_vega_util = __esm({
  "node_modules/.pnpm/vega-util@1.14.1/node_modules/vega-util/index.js"() {
    init_accessor();
    init_accessors2();
    init_logger();
    init_mergeConfig();
    init_transform5();
    init_quarter();
    init_array9();
    init_clampRange();
    init_compare();
    init_constant13();
    init_debounce();
    init_error();
    init_extend();
    init_extent6();
    init_extentIndex();
    init_fastmap();
    init_field();
    init_flush();
    init_hasOwnProperty();
    init_inherits();
    init_inrange();
    init_isArray();
    init_isBoolean();
    init_isDate();
    init_isFunction();
    init_isNumber();
    init_isObject();
    init_isRegExp();
    init_isString();
    init_key();
    init_lerp();
    init_lruCache();
    init_merge5();
    init_pad();
    init_peek();
    init_repeat();
    init_span();
    init_splitAccessPath();
    init_stringValue();
    init_toBoolean();
    init_toDate();
    init_toNumber();
    init_toString();
    init_toSet();
    init_truncate();
    init_visitArray();
  }
});

// node_modules/.pnpm/tslib@2.0.3/node_modules/tslib/tslib.es6.js
function __rest(s3, e3) {
  var t = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e3.indexOf(p) < 0)
      t[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s3); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i]))
        t[p[i]] = s3[p[i]];
    }
  return t;
}
var init_tslib_es6 = __esm({
  "node_modules/.pnpm/tslib@2.0.3/node_modules/tslib/tslib.es6.js"() {
  }
});

// node_modules/.pnpm/array-flat-polyfill@1.0.1/node_modules/array-flat-polyfill/index.mjs
var init_array_flat_polyfill = __esm({
  "node_modules/.pnpm/array-flat-polyfill@1.0.1/node_modules/array-flat-polyfill/index.mjs"() {
    Array.prototype.flat || Object.defineProperty(Array.prototype, "flat", { configurable: true, value: function r() {
      var t = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
      return t ? Array.prototype.reduce.call(this, function(a4, e3) {
        return Array.isArray(e3) ? a4.push.apply(a4, r.call(e3, t - 1)) : a4.push(e3), a4;
      }, []) : Array.prototype.slice.call(this);
    }, writable: true }), Array.prototype.flatMap || Object.defineProperty(Array.prototype, "flatMap", { configurable: true, value: function(r2) {
      return Array.prototype.map.apply(this, arguments).flat();
    }, writable: true });
  }
});

// node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js"(exports, module4) {
    var clone = function() {
      "use strict";
      function _instanceof(obj, type4) {
        return type4 != null && obj instanceof type4;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone2(parent, circular, depth, prototype2, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype2 = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve2, reject) {
              parent2.then(function(value4) {
                resolve2(_clone(value4, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex)
              child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype2 == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype2);
              proto = prototype2;
            }
          }
          if (circular) {
            var index8 = allParents.indexOf(parent2);
            if (index8 != -1) {
              return allChildren[index8];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value4, key3) {
              var keyChild = _clone(key3, depth2 - 1);
              var valueChild = _clone(value4, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value4) {
              var entryChild = _clone(value4, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols7 = Object.getOwnPropertySymbols(parent2);
            for (var i = 0; i < symbols7.length; i++) {
              var symbol3 = symbols7[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol3);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol3] = _clone(parent2[symbol3], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol3, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i = 0; i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c2 = function() {
        };
        c2.prototype = parent;
        return new c2();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re4) {
        var flags = "";
        if (re4.global)
          flags += "g";
        if (re4.ignoreCase)
          flags += "i";
        if (re4.multiline)
          flags += "m";
        return flags;
      }
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module4 === "object" && module4.exports) {
      module4.exports = clone;
    }
  }
});

// node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module4) {
    "use strict";
    module4.exports = function equal2(a4, b3) {
      if (a4 === b3)
        return true;
      if (a4 && b3 && typeof a4 == "object" && typeof b3 == "object") {
        if (a4.constructor !== b3.constructor)
          return false;
        var length4, i, keys5;
        if (Array.isArray(a4)) {
          length4 = a4.length;
          if (length4 != b3.length)
            return false;
          for (i = length4; i-- !== 0; )
            if (!equal2(a4[i], b3[i]))
              return false;
          return true;
        }
        if (a4.constructor === RegExp)
          return a4.source === b3.source && a4.flags === b3.flags;
        if (a4.valueOf !== Object.prototype.valueOf)
          return a4.valueOf() === b3.valueOf();
        if (a4.toString !== Object.prototype.toString)
          return a4.toString() === b3.toString();
        keys5 = Object.keys(a4);
        length4 = keys5.length;
        if (length4 !== Object.keys(b3).length)
          return false;
        for (i = length4; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b3, keys5[i]))
            return false;
        for (i = length4; i-- !== 0; ) {
          var key3 = keys5[i];
          if (!equal2(a4[key3], b3[key3]))
            return false;
        }
        return true;
      }
      return a4 !== a4 && b3 !== b3;
    };
  }
});

// node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js"(exports, module4) {
    "use strict";
    module4.exports = function(data3, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a4, b3) {
            var aobj = { key: a4, value: node[a4] };
            var bobj = { key: b3, value: node[b3] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify5(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify5(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys5 = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys5.length; i++) {
          var key3 = keys5[i];
          var value4 = stringify5(node[key3]);
          if (!value4)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key3) + ":" + value4;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data3);
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/logical.js
function isLogicalOr(op) {
  return !!op.or;
}
function isLogicalAnd(op) {
  return !!op.and;
}
function isLogicalNot(op) {
  return !!op.not;
}
function forEachLeaf(op, fn) {
  if (isLogicalNot(op)) {
    forEachLeaf(op.not, fn);
  } else if (isLogicalAnd(op)) {
    for (const subop of op.and) {
      forEachLeaf(subop, fn);
    }
  } else if (isLogicalOr(op)) {
    for (const subop of op.or) {
      forEachLeaf(subop, fn);
    }
  } else {
    fn(op);
  }
}
function normalizeLogicalComposition(op, normalizer2) {
  if (isLogicalNot(op)) {
    return { not: normalizeLogicalComposition(op.not, normalizer2) };
  } else if (isLogicalAnd(op)) {
    return { and: op.and.map((o) => normalizeLogicalComposition(o, normalizer2)) };
  } else if (isLogicalOr(op)) {
    return { or: op.or.map((o) => normalizeLogicalComposition(o, normalizer2)) };
  } else {
    return normalizer2(op);
  }
}
var init_logical = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/logical.js"() {
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/util.js
function pick3(obj, props) {
  const copy6 = {};
  for (const prop of props) {
    if (hasOwnProperty_default(obj, prop)) {
      copy6[prop] = obj[prop];
    }
  }
  return copy6;
}
function omit(obj, props) {
  const copy6 = Object.assign({}, obj);
  for (const prop of props) {
    delete copy6[prop];
  }
  return copy6;
}
function hash(a4) {
  if (isNumber_default(a4)) {
    return a4;
  }
  const str = isString_default(a4) ? a4 : (0, import_fast_json_stable_stringify.default)(a4);
  if (str.length < 250) {
    return str;
  }
  let h4 = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    h4 = (h4 << 5) - h4 + char;
    h4 = h4 & h4;
  }
  return h4;
}
function isNullOrFalse(x7) {
  return x7 === false || x7 === null;
}
function contains2(array9, item) {
  return array9.indexOf(item) > -1;
}
function some4(arr, f) {
  let i = 0;
  for (const [k4, a4] of arr.entries()) {
    if (f(a4, k4, i++)) {
      return true;
    }
  }
  return false;
}
function every4(arr, f) {
  let i = 0;
  for (const [k4, a4] of arr.entries()) {
    if (!f(a4, k4, i++)) {
      return false;
    }
  }
  return true;
}
function mergeDeep(dest, ...src) {
  for (const s3 of src) {
    deepMerge_(dest, s3 !== null && s3 !== void 0 ? s3 : {});
  }
  return dest;
}
function deepMerge_(dest, src) {
  for (const property2 of keys4(src)) {
    writeConfig2(dest, property2, src[property2], true);
  }
}
function unique(values5, f) {
  const results = [];
  const u = {};
  let v;
  for (const val of values5) {
    v = f(val);
    if (v in u) {
      continue;
    }
    u[v] = 1;
    results.push(val);
  }
  return results;
}
function setEqual(a4, b3) {
  if (a4.size !== b3.size) {
    return false;
  }
  for (const e3 of a4) {
    if (!b3.has(e3)) {
      return false;
    }
  }
  return true;
}
function hasIntersection(a4, b3) {
  for (const key3 of a4) {
    if (b3.has(key3)) {
      return true;
    }
  }
  return false;
}
function prefixGenerator(a4) {
  const prefixes4 = /* @__PURE__ */ new Set();
  for (const x7 of a4) {
    const splitField = splitAccessPath_default(x7);
    const wrappedWithAccessors = splitField.map((y7, i) => i === 0 ? y7 : `[${y7}]`);
    const computedPrefixes = wrappedWithAccessors.map((_, i) => wrappedWithAccessors.slice(0, i + 1).join(""));
    for (const y7 of computedPrefixes) {
      prefixes4.add(y7);
    }
  }
  return prefixes4;
}
function fieldIntersection(a4, b3) {
  if (a4 === void 0 || b3 === void 0) {
    return true;
  }
  return hasIntersection(prefixGenerator(a4), prefixGenerator(b3));
}
function isEmpty(obj) {
  return keys4(obj).length === 0;
}
function entries(x7) {
  const _entries = [];
  for (const k4 in x7) {
    if (hasOwnProperty_default(x7, k4)) {
      _entries.push({
        key: k4,
        value: x7[k4]
      });
    }
  }
  return _entries;
}
function isBoolean4(b3) {
  return b3 === true || b3 === false;
}
function varName(s3) {
  const alphanumericS = s3.replace(/\W/g, "_");
  return (s3.match(/^\d+/) ? "_" : "") + alphanumericS;
}
function logicalExpr(op, cb) {
  if (isLogicalNot(op)) {
    return "!(" + logicalExpr(op.not, cb) + ")";
  } else if (isLogicalAnd(op)) {
    return "(" + op.and.map((and) => logicalExpr(and, cb)).join(") && (") + ")";
  } else if (isLogicalOr(op)) {
    return "(" + op.or.map((or3) => logicalExpr(or3, cb)).join(") || (") + ")";
  } else {
    return cb(op);
  }
}
function deleteNestedProperty(obj, orderedProps) {
  if (orderedProps.length === 0) {
    return true;
  }
  const prop = orderedProps.shift();
  if (prop in obj && deleteNestedProperty(obj[prop], orderedProps)) {
    delete obj[prop];
  }
  return isEmpty(obj);
}
function titleCase(s3) {
  return s3.charAt(0).toUpperCase() + s3.substr(1);
}
function accessPathWithDatum(path5, datum2 = "datum") {
  const pieces = splitAccessPath_default(path5);
  const prefixes4 = [];
  for (let i = 1; i <= pieces.length; i++) {
    const prefix = `[${pieces.slice(0, i).map($3).join("][")}]`;
    prefixes4.push(`${datum2}${prefix}`);
  }
  return prefixes4.join(" && ");
}
function flatAccessWithDatum(path5, datum2 = "datum") {
  return `${datum2}[${$3(splitAccessPath_default(path5).join("."))}]`;
}
function escapePathAccess(string) {
  return string.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function replacePathInField(path5) {
  return `${splitAccessPath_default(path5).map(escapePathAccess).join("\\.")}`;
}
function replaceAll(string, find5, replacement) {
  return string.replace(new RegExp(find5.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), replacement);
}
function removePathFromField(path5) {
  return `${splitAccessPath_default(path5).join(".")}`;
}
function accessPathDepth(path5) {
  if (!path5) {
    return 0;
  }
  return splitAccessPath_default(path5).length;
}
function getFirstDefined(...args) {
  for (const arg of args) {
    if (arg !== void 0) {
      return arg;
    }
  }
  return void 0;
}
function uniqueId(prefix) {
  const id4 = ++idCounter;
  return prefix ? String(prefix) + id4 : id4;
}
function internalField(name4) {
  return isInternalField(name4) ? name4 : `__${name4}`;
}
function isInternalField(name4) {
  return name4.indexOf("__") === 0;
}
function normalizeAngle(angle2) {
  if (angle2 === void 0) {
    return void 0;
  }
  return (angle2 % 360 + 360) % 360;
}
function isNumeric(value4) {
  if (isNumber_default(value4)) {
    return true;
  }
  return !isNaN(value4) && !isNaN(parseFloat(value4));
}
var import_clone, import_fast_deep_equal, import_fast_json_stable_stringify, deepEqual, duplicate, stringify, keys4, vals, idCounter;
var init_util = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/util.js"() {
    init_array_flat_polyfill();
    import_clone = __toESM(require_clone());
    import_fast_deep_equal = __toESM(require_fast_deep_equal());
    import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify());
    init_vega_util();
    init_logical();
    deepEqual = import_fast_deep_equal.default;
    duplicate = import_clone.default;
    Set.prototype["toJSON"] = function() {
      return `Set(${[...this].map((x7) => (0, import_fast_json_stable_stringify.default)(x7)).join(",")})`;
    };
    stringify = import_fast_json_stable_stringify.default;
    keys4 = Object.keys;
    vals = Object.values;
    idCounter = 42;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/axis.js
function isConditionalAxisValue(v) {
  return v && v["condition"];
}
function isAxisProperty(prop) {
  return !!AXIS_PROPERTIES_INDEX[prop];
}
var CONDITIONAL_AXIS_PROP_INDEX, AXIS_PARTS, AXIS_PROPERTY_TYPE, COMMON_AXIS_PROPERTIES_INDEX, AXIS_PROPERTIES_INDEX, AXIS_PROPERTIES;
var init_axis = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/axis.js"() {
    init_util();
    CONDITIONAL_AXIS_PROP_INDEX = {
      domainColor: {
        part: "domain",
        vgProp: "stroke"
      },
      labelAlign: {
        part: "labels",
        vgProp: "align"
      },
      labelBaseline: {
        part: "labels",
        vgProp: "baseline"
      },
      labelColor: {
        part: "labels",
        vgProp: "fill"
      },
      labelFont: {
        part: "labels",
        vgProp: "font"
      },
      labelFontSize: {
        part: "labels",
        vgProp: "fontSize"
      },
      labelFontStyle: {
        part: "labels",
        vgProp: "fontStyle"
      },
      labelFontWeight: {
        part: "labels",
        vgProp: "fontWeight"
      },
      labelOpacity: {
        part: "labels",
        vgProp: "opacity"
      },
      labelOffset: null,
      labelPadding: null,
      gridColor: {
        part: "grid",
        vgProp: "stroke"
      },
      gridDash: {
        part: "grid",
        vgProp: "strokeDash"
      },
      gridDashOffset: {
        part: "grid",
        vgProp: "strokeDash"
      },
      gridOpacity: {
        part: "grid",
        vgProp: "opacity"
      },
      gridWidth: {
        part: "grid",
        vgProp: "strokeWidth"
      },
      tickColor: {
        part: "ticks",
        vgProp: "stroke"
      },
      tickDash: {
        part: "ticks",
        vgProp: "strokeDash"
      },
      tickDashOffset: {
        part: "ticks",
        vgProp: "strokeDash"
      },
      tickOpacity: {
        part: "ticks",
        vgProp: "opacity"
      },
      tickSize: null,
      tickWidth: {
        part: "ticks",
        vgProp: "strokeWidth"
      },
      titleColor: {
        part: "title",
        vgProp: "fill"
      },
      title: null
    };
    AXIS_PARTS = ["domain", "grid", "labels", "ticks", "title"];
    AXIS_PROPERTY_TYPE = {
      grid: "grid",
      gridCap: "grid",
      gridColor: "grid",
      gridDash: "grid",
      gridDashOffset: "grid",
      gridOpacity: "grid",
      gridScale: "grid",
      gridWidth: "grid",
      orient: "main",
      bandPosition: "both",
      aria: "main",
      description: "main",
      domain: "main",
      domainCap: "main",
      domainColor: "main",
      domainDash: "main",
      domainDashOffset: "main",
      domainOpacity: "main",
      domainWidth: "main",
      format: "main",
      formatType: "main",
      labelAlign: "main",
      labelAngle: "main",
      labelBaseline: "main",
      labelBound: "main",
      labelColor: "main",
      labelFlush: "main",
      labelFlushOffset: "main",
      labelFont: "main",
      labelFontSize: "main",
      labelFontStyle: "main",
      labelFontWeight: "main",
      labelLimit: "main",
      labelLineHeight: "main",
      labelOffset: "main",
      labelOpacity: "main",
      labelOverlap: "main",
      labelPadding: "main",
      labels: "main",
      labelSeparation: "main",
      maxExtent: "main",
      minExtent: "main",
      offset: "both",
      position: "main",
      tickCap: "main",
      tickColor: "main",
      tickDash: "main",
      tickDashOffset: "main",
      tickMinStep: "main",
      tickOffset: "both",
      tickOpacity: "main",
      tickRound: "both",
      ticks: "main",
      tickSize: "main",
      tickWidth: "both",
      title: "main",
      titleAlign: "main",
      titleAnchor: "main",
      titleAngle: "main",
      titleBaseline: "main",
      titleColor: "main",
      titleFont: "main",
      titleFontSize: "main",
      titleFontStyle: "main",
      titleFontWeight: "main",
      titleLimit: "main",
      titleLineHeight: "main",
      titleOpacity: "main",
      titlePadding: "main",
      titleX: "main",
      titleY: "main",
      encode: "both",
      scale: "both",
      tickBand: "both",
      tickCount: "both",
      tickExtra: "both",
      translate: "both",
      values: "both",
      zindex: "both"
    };
    COMMON_AXIS_PROPERTIES_INDEX = {
      orient: 1,
      aria: 1,
      bandPosition: 1,
      description: 1,
      domain: 1,
      domainCap: 1,
      domainColor: 1,
      domainDash: 1,
      domainDashOffset: 1,
      domainOpacity: 1,
      domainWidth: 1,
      format: 1,
      formatType: 1,
      grid: 1,
      gridCap: 1,
      gridColor: 1,
      gridDash: 1,
      gridDashOffset: 1,
      gridOpacity: 1,
      gridWidth: 1,
      labelAlign: 1,
      labelAngle: 1,
      labelBaseline: 1,
      labelBound: 1,
      labelColor: 1,
      labelFlush: 1,
      labelFlushOffset: 1,
      labelFont: 1,
      labelFontSize: 1,
      labelFontStyle: 1,
      labelFontWeight: 1,
      labelLimit: 1,
      labelLineHeight: 1,
      labelOffset: 1,
      labelOpacity: 1,
      labelOverlap: 1,
      labelPadding: 1,
      labels: 1,
      labelSeparation: 1,
      maxExtent: 1,
      minExtent: 1,
      offset: 1,
      position: 1,
      tickBand: 1,
      tickCap: 1,
      tickColor: 1,
      tickCount: 1,
      tickDash: 1,
      tickDashOffset: 1,
      tickExtra: 1,
      tickMinStep: 1,
      tickOffset: 1,
      tickOpacity: 1,
      tickRound: 1,
      ticks: 1,
      tickSize: 1,
      tickWidth: 1,
      title: 1,
      titleAlign: 1,
      titleAnchor: 1,
      titleAngle: 1,
      titleBaseline: 1,
      titleColor: 1,
      titleFont: 1,
      titleFontSize: 1,
      titleFontStyle: 1,
      titleFontWeight: 1,
      titleLimit: 1,
      titleLineHeight: 1,
      titleOpacity: 1,
      titlePadding: 1,
      titleX: 1,
      titleY: 1,
      translate: 1,
      values: 1,
      zindex: 1
    };
    AXIS_PROPERTIES_INDEX = Object.assign(Object.assign({}, COMMON_AXIS_PROPERTIES_INDEX), { style: 1, labelExpr: 1, encoding: 1 });
    AXIS_PROPERTIES = keys4(AXIS_PROPERTIES_INDEX);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/mark.js
function isPathMark(m2) {
  return contains2(["line", "area", "trail"], m2);
}
function isRectBasedMark(m2) {
  return contains2(["rect", "bar", "image", "arc"], m2);
}
function isMarkDef(mark) {
  return mark["type"];
}
function getMarkType(m2) {
  return isMarkDef(m2) ? m2.type : m2;
}
var Mark3, ARC, AREA, BAR, IMAGE, LINE, POINT, RECT, RULE, TEXT, TICK, TRAIL, CIRCLE, SQUARE, GEOSHAPE, PRIMITIVE_MARKS, PRIMITIVE_MARK_INDEX, STROKE_CONFIG, FILL_CONFIG, FILL_STROKE_CONFIG, VL_ONLY_MARK_CONFIG_INDEX, VL_ONLY_MARK_CONFIG_PROPERTIES, VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX, defaultMarkConfig, BAR_CORNER_RADIUS_INDEX, DEFAULT_RECT_BAND_SIZE, defaultBarConfig, defaultRectConfig, defaultTickConfig;
var init_mark = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/mark.js"() {
    init_vega_util();
    init_util();
    Mark3 = {
      arc: "arc",
      area: "area",
      bar: "bar",
      image: "image",
      line: "line",
      point: "point",
      rect: "rect",
      rule: "rule",
      text: "text",
      tick: "tick",
      trail: "trail",
      circle: "circle",
      square: "square",
      geoshape: "geoshape"
    };
    ARC = Mark3.arc;
    AREA = Mark3.area;
    BAR = Mark3.bar;
    IMAGE = Mark3.image;
    LINE = Mark3.line;
    POINT = Mark3.point;
    RECT = Mark3.rect;
    RULE = Mark3.rule;
    TEXT = Mark3.text;
    TICK = Mark3.tick;
    TRAIL = Mark3.trail;
    CIRCLE = Mark3.circle;
    SQUARE = Mark3.square;
    GEOSHAPE = Mark3.geoshape;
    PRIMITIVE_MARKS = keys4(Mark3);
    PRIMITIVE_MARK_INDEX = toSet_default(PRIMITIVE_MARKS);
    STROKE_CONFIG = [
      "stroke",
      "strokeWidth",
      "strokeDash",
      "strokeDashOffset",
      "strokeOpacity",
      "strokeJoin",
      "strokeMiterLimit"
    ];
    FILL_CONFIG = ["fill", "fillOpacity"];
    FILL_STROKE_CONFIG = [...STROKE_CONFIG, ...FILL_CONFIG];
    VL_ONLY_MARK_CONFIG_INDEX = {
      color: 1,
      filled: 1,
      invalid: 1,
      order: 1,
      radius2: 1,
      theta2: 1,
      timeUnitBand: 1,
      timeUnitBandPosition: 1
    };
    VL_ONLY_MARK_CONFIG_PROPERTIES = keys4(VL_ONLY_MARK_CONFIG_INDEX);
    VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
      area: ["line", "point"],
      bar: ["binSpacing", "continuousBandSize", "discreteBandSize"],
      rect: ["binSpacing", "continuousBandSize", "discreteBandSize"],
      line: ["point"],
      tick: ["bandSize", "thickness"]
    };
    defaultMarkConfig = {
      color: "#4c78a8",
      invalid: "filter",
      timeUnitBand: 1
    };
    BAR_CORNER_RADIUS_INDEX = {
      horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
      vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
    };
    DEFAULT_RECT_BAND_SIZE = 5;
    defaultBarConfig = {
      binSpacing: 1,
      continuousBandSize: DEFAULT_RECT_BAND_SIZE,
      timeUnitBandPosition: 0.5
    };
    defaultRectConfig = {
      binSpacing: 0,
      continuousBandSize: DEFAULT_RECT_BAND_SIZE,
      timeUnitBandPosition: 0.5
    };
    defaultTickConfig = {
      thickness: 1
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/unit.js
function isUnitSpec(spec) {
  return "mark" in spec;
}
var init_unit = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/unit.js"() {
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/base.js
var CompositeMarkNormalizer;
var init_base = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/base.js"() {
    init_mark();
    init_unit();
    CompositeMarkNormalizer = class {
      constructor(name4, run2) {
        this.name = name4;
        this.run = run2;
      }
      hasMatchingType(spec) {
        if (isUnitSpec(spec)) {
          return getMarkType(spec.mark) === this.name;
        }
        return false;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/aggregate.js
function isArgminDef(a4) {
  return !!a4 && !!a4["argmin"];
}
function isArgmaxDef(a4) {
  return !!a4 && !!a4["argmax"];
}
function isAggregateOp(a4) {
  return isString_default(a4) && !!AGGREGATE_OP_INDEX[a4];
}
function isCountingAggregateOp(aggregate) {
  return isString_default(aggregate) && contains2(COUNTING_OPS, aggregate);
}
function isMinMaxOp(aggregate) {
  return isString_default(aggregate) && contains2(["min", "max"], aggregate);
}
var AGGREGATE_OP_INDEX, MULTIDOMAIN_SORT_OP_INDEX, AGGREGATE_OPS, COUNTING_OPS, SUM_OPS, SHARED_DOMAIN_OPS, SHARED_DOMAIN_OP_INDEX;
var init_aggregate = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/aggregate.js"() {
    init_vega_util();
    init_util();
    AGGREGATE_OP_INDEX = {
      argmax: 1,
      argmin: 1,
      average: 1,
      count: 1,
      distinct: 1,
      product: 1,
      max: 1,
      mean: 1,
      median: 1,
      min: 1,
      missing: 1,
      q1: 1,
      q3: 1,
      ci0: 1,
      ci1: 1,
      stderr: 1,
      stdev: 1,
      stdevp: 1,
      sum: 1,
      valid: 1,
      values: 1,
      variance: 1,
      variancep: 1
    };
    MULTIDOMAIN_SORT_OP_INDEX = {
      count: 1,
      min: 1,
      max: 1
    };
    AGGREGATE_OPS = keys4(AGGREGATE_OP_INDEX);
    COUNTING_OPS = ["count", "valid", "missing", "distinct"];
    SUM_OPS = ["count", "sum", "distinct", "valid", "missing"];
    SHARED_DOMAIN_OPS = ["mean", "average", "median", "q1", "q3", "min", "max"];
    SHARED_DOMAIN_OP_INDEX = toSet_default(SHARED_DOMAIN_OPS);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/channel.js
function isPolarPositionChannel(c2) {
  return c2 in POLAR_POSITION_CHANNEL_INDEX;
}
function getPositionChannelFromLatLong(channel) {
  switch (channel) {
    case LATITUDE:
      return "y";
    case LATITUDE2:
      return "y2";
    case LONGITUDE:
      return "x";
    case LONGITUDE2:
      return "x2";
  }
}
function isGeoPositionChannel(c2) {
  return c2 in GEO_POSIITON_CHANNEL_INDEX;
}
function isColorChannel(channel) {
  return channel === COLOR || channel === FILL || channel === STROKE;
}
function isSingleDefUnitChannel(str) {
  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];
}
function isChannel(str) {
  return !!CHANNEL_INDEX[str];
}
function isSecondaryRangeChannel(c2) {
  const main5 = getMainRangeChannel(c2);
  return main5 !== c2;
}
function getMainRangeChannel(channel) {
  switch (channel) {
    case X23:
      return X3;
    case Y23:
      return Y3;
    case LATITUDE2:
      return LATITUDE;
    case LONGITUDE2:
      return LONGITUDE;
    case THETA2:
      return THETA;
    case RADIUS2:
      return RADIUS;
  }
  return channel;
}
function getVgPositionChannel(channel) {
  if (isPolarPositionChannel(channel)) {
    switch (channel) {
      case THETA:
        return "startAngle";
      case THETA2:
        return "endAngle";
      case RADIUS:
        return "outerRadius";
      case RADIUS2:
        return "innerRadius";
    }
  }
  return channel;
}
function getSecondaryRangeChannel(channel) {
  switch (channel) {
    case X3:
      return X23;
    case Y3:
      return Y23;
    case LATITUDE:
      return LATITUDE2;
    case LONGITUDE:
      return LONGITUDE2;
    case THETA:
      return THETA2;
    case RADIUS:
      return RADIUS2;
  }
  return void 0;
}
function getSizeChannel(channel) {
  switch (channel) {
    case X3:
    case X23:
      return "width";
    case Y3:
    case Y23:
      return "height";
  }
  return void 0;
}
function getOffsetChannel(channel) {
  switch (channel) {
    case X3:
      return "xOffset";
    case Y3:
      return "yOffset";
    case X23:
      return "x2Offset";
    case Y23:
      return "y2Offset";
    case THETA:
      return "thetaOffset";
    case RADIUS:
      return "radiusOffset";
    case THETA2:
      return "theta2Offset";
    case RADIUS2:
      return "radius2Offset";
  }
  return void 0;
}
function isXorY(channel) {
  return channel in POSITION_SCALE_CHANNEL_INDEX;
}
function getPositionScaleChannel(sizeType) {
  return sizeType === "width" ? X3 : Y3;
}
function isNonPositionScaleChannel(channel) {
  return !!NONPOSITION_CHANNEL_INDEX[channel];
}
function supportLegend(channel) {
  switch (channel) {
    case COLOR:
    case FILL:
    case STROKE:
    case SIZE2:
    case SHAPE:
    case OPACITY:
    case STROKEWIDTH:
    case STROKEDASH:
      return true;
    case FILLOPACITY:
    case STROKEOPACITY:
    case ANGLE:
      return false;
  }
}
function isScaleChannel(channel) {
  return !!SCALE_CHANNEL_INDEX[channel];
}
function supportMark(channel, mark) {
  return getSupportedMark(channel)[mark];
}
function getSupportedMark(channel) {
  switch (channel) {
    case COLOR:
    case FILL:
    case STROKE:
    case DESCRIPTION:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case ORDER:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    case FACET:
    case ROW:
    case COLUMN:
      return ALL_MARKS;
    case X3:
    case Y3:
    case LATITUDE:
    case LONGITUDE:
      return ALL_MARKS_EXCEPT_GEOSHAPE;
    case X23:
    case Y23:
    case LATITUDE2:
    case LONGITUDE2:
      return {
        area: "always",
        bar: "always",
        image: "always",
        rect: "always",
        rule: "always",
        circle: "binned",
        point: "binned",
        square: "binned",
        tick: "binned",
        line: "binned",
        trail: "binned"
      };
    case SIZE2:
      return {
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        text: "always",
        line: "always",
        trail: "always"
      };
    case STROKEDASH:
      return {
        line: "always",
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        geoshape: "always"
      };
    case SHAPE:
      return { point: "always", geoshape: "always" };
    case TEXT2:
      return { text: "always" };
    case ANGLE:
      return { point: "always", square: "always", text: "always" };
    case URL2:
      return { image: "always" };
    case THETA:
      return { text: "always", arc: "always" };
    case RADIUS:
      return { text: "always", arc: "always" };
    case THETA2:
    case RADIUS2:
      return { arc: "always" };
  }
}
function rangeType(channel) {
  switch (channel) {
    case X3:
    case Y3:
    case THETA:
    case RADIUS:
    case SIZE2:
    case ANGLE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case X23:
    case Y23:
    case THETA2:
    case RADIUS2:
      return void 0;
    case FACET:
    case ROW:
    case COLUMN:
    case SHAPE:
    case STROKEDASH:
    case TEXT2:
    case TOOLTIP:
    case HREF:
    case URL2:
    case DESCRIPTION:
      return "discrete";
    case COLOR:
    case FILL:
    case STROKE:
      return "flexible";
    case LATITUDE:
    case LONGITUDE:
    case LATITUDE2:
    case LONGITUDE2:
    case DETAIL:
    case KEY:
    case ORDER:
      return void 0;
  }
}
var ROW, COLUMN, FACET, X3, Y3, X23, Y23, RADIUS, RADIUS2, THETA, THETA2, LATITUDE, LONGITUDE, LATITUDE2, LONGITUDE2, COLOR, FILL, STROKE, SHAPE, SIZE2, ANGLE, OPACITY, FILLOPACITY, STROKEOPACITY, STROKEWIDTH, STROKEDASH, TEXT2, ORDER, DETAIL, KEY, TOOLTIP, HREF, URL2, DESCRIPTION, POSITION_CHANNEL_INDEX, POLAR_POSITION_CHANNEL_INDEX, GEO_POSIITON_CHANNEL_INDEX, GEOPOSITION_CHANNELS, UNIT_CHANNEL_INDEX, FACET_CHANNEL_INDEX, FACET_CHANNELS, CHANNEL_INDEX, CHANNELS, _o, _d, _tt1, SINGLE_DEF_CHANNEL_INDEX, _r, _c, _f, SINGLE_DEF_UNIT_CHANNEL_INDEX, SINGLE_DEF_CHANNELS, SINGLE_DEF_UNIT_CHANNELS, SECONDARY_RANGE_CHANNEL, UNIT_CHANNELS, _x, _y, _x2, _y2, _latitude, _longitude, _latitude2, _longitude2, _theta, _theta2, _radius, _radius2, NONPOSITION_CHANNEL_INDEX, NONPOSITION_CHANNELS, POSITION_SCALE_CHANNEL_INDEX, POSITION_SCALE_CHANNELS, POLAR_POSITION_SCALE_CHANNEL_INDEX, POLAR_POSITION_SCALE_CHANNELS, _t, _tt, _hr, _u, _al, _dd, _k, _oo, NONPOSITION_SCALE_CHANNEL_INDEX, NONPOSITION_SCALE_CHANNELS, SCALE_CHANNEL_INDEX, SCALE_CHANNELS, ALL_MARKS, _g, ALL_MARKS_EXCEPT_GEOSHAPE;
var init_channel = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/channel.js"() {
    init_tslib_es6();
    init_util();
    ROW = "row";
    COLUMN = "column";
    FACET = "facet";
    X3 = "x";
    Y3 = "y";
    X23 = "x2";
    Y23 = "y2";
    RADIUS = "radius";
    RADIUS2 = "radius2";
    THETA = "theta";
    THETA2 = "theta2";
    LATITUDE = "latitude";
    LONGITUDE = "longitude";
    LATITUDE2 = "latitude2";
    LONGITUDE2 = "longitude2";
    COLOR = "color";
    FILL = "fill";
    STROKE = "stroke";
    SHAPE = "shape";
    SIZE2 = "size";
    ANGLE = "angle";
    OPACITY = "opacity";
    FILLOPACITY = "fillOpacity";
    STROKEOPACITY = "strokeOpacity";
    STROKEWIDTH = "strokeWidth";
    STROKEDASH = "strokeDash";
    TEXT2 = "text";
    ORDER = "order";
    DETAIL = "detail";
    KEY = "key";
    TOOLTIP = "tooltip";
    HREF = "href";
    URL2 = "url";
    DESCRIPTION = "description";
    POSITION_CHANNEL_INDEX = {
      x: 1,
      y: 1,
      x2: 1,
      y2: 1
    };
    POLAR_POSITION_CHANNEL_INDEX = {
      theta: 1,
      theta2: 1,
      radius: 1,
      radius2: 1
    };
    GEO_POSIITON_CHANNEL_INDEX = {
      longitude: 1,
      longitude2: 1,
      latitude: 1,
      latitude2: 1
    };
    GEOPOSITION_CHANNELS = keys4(GEO_POSIITON_CHANNEL_INDEX);
    UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), POLAR_POSITION_CHANNEL_INDEX), GEO_POSIITON_CHANNEL_INDEX), {
      color: 1,
      fill: 1,
      stroke: 1,
      opacity: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeDash: 1,
      size: 1,
      angle: 1,
      shape: 1,
      order: 1,
      text: 1,
      detail: 1,
      key: 1,
      tooltip: 1,
      href: 1,
      url: 1,
      description: 1
    });
    FACET_CHANNEL_INDEX = {
      row: 1,
      column: 1,
      facet: 1
    };
    FACET_CHANNELS = keys4(FACET_CHANNEL_INDEX);
    CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);
    CHANNELS = keys4(CHANNEL_INDEX);
    ({ order: _o, detail: _d, tooltip: _tt1 } = CHANNEL_INDEX);
    SINGLE_DEF_CHANNEL_INDEX = __rest(CHANNEL_INDEX, ["order", "detail", "tooltip"]);
    ({ row: _r, column: _c, facet: _f } = SINGLE_DEF_CHANNEL_INDEX);
    SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest(SINGLE_DEF_CHANNEL_INDEX, ["row", "column", "facet"]);
    SINGLE_DEF_CHANNELS = keys4(SINGLE_DEF_CHANNEL_INDEX);
    SINGLE_DEF_UNIT_CHANNELS = keys4(SINGLE_DEF_UNIT_CHANNEL_INDEX);
    SECONDARY_RANGE_CHANNEL = [X23, Y23, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];
    UNIT_CHANNELS = keys4(UNIT_CHANNEL_INDEX);
    ({
      x: _x,
      y: _y,
      x2: _x2,
      y2: _y2,
      latitude: _latitude,
      longitude: _longitude,
      latitude2: _latitude2,
      longitude2: _longitude2,
      theta: _theta,
      theta2: _theta2,
      radius: _radius,
      radius2: _radius2
    } = UNIT_CHANNEL_INDEX);
    NONPOSITION_CHANNEL_INDEX = __rest(UNIT_CHANNEL_INDEX, ["x", "y", "x2", "y2", "latitude", "longitude", "latitude2", "longitude2", "theta", "theta2", "radius", "radius2"]);
    NONPOSITION_CHANNELS = keys4(NONPOSITION_CHANNEL_INDEX);
    POSITION_SCALE_CHANNEL_INDEX = {
      x: 1,
      y: 1
    };
    POSITION_SCALE_CHANNELS = keys4(POSITION_SCALE_CHANNEL_INDEX);
    POLAR_POSITION_SCALE_CHANNEL_INDEX = {
      theta: 1,
      radius: 1
    };
    POLAR_POSITION_SCALE_CHANNELS = keys4(POLAR_POSITION_SCALE_CHANNEL_INDEX);
    ({
      text: _t,
      tooltip: _tt,
      href: _hr,
      url: _u,
      description: _al,
      detail: _dd,
      key: _k,
      order: _oo
    } = NONPOSITION_CHANNEL_INDEX);
    NONPOSITION_SCALE_CHANNEL_INDEX = __rest(NONPOSITION_CHANNEL_INDEX, ["text", "tooltip", "href", "url", "description", "detail", "key", "order"]);
    NONPOSITION_SCALE_CHANNELS = keys4(NONPOSITION_SCALE_CHANNEL_INDEX);
    SCALE_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), POLAR_POSITION_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);
    SCALE_CHANNELS = keys4(SCALE_CHANNEL_INDEX);
    ALL_MARKS = {
      arc: "always",
      area: "always",
      bar: "always",
      circle: "always",
      geoshape: "always",
      image: "always",
      line: "always",
      rule: "always",
      point: "always",
      rect: "always",
      square: "always",
      trail: "always",
      text: "always",
      tick: "always"
    };
    ({ geoshape: _g } = ALL_MARKS);
    ALL_MARKS_EXCEPT_GEOSHAPE = __rest(ALL_MARKS, ["geoshape"]);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/bin.js
function binToString(bin5) {
  if (isBoolean_default(bin5)) {
    bin5 = normalizeBin(bin5, void 0);
  }
  return "bin" + keys4(bin5).map((p) => isSelectionExtent(bin5[p]) ? varName(`_${p}_${Object.entries(bin5[p])}`) : varName(`_${p}_${bin5[p]}`)).join("");
}
function isBinning(bin5) {
  return bin5 === true || isBinParams(bin5) && !bin5.binned;
}
function isBinned(bin5) {
  return bin5 === "binned" || isBinParams(bin5) && bin5.binned === true;
}
function isBinParams(bin5) {
  return isObject_default(bin5);
}
function isSelectionExtent(extent5) {
  return extent5 === null || extent5 === void 0 ? void 0 : extent5["selection"];
}
function autoMaxBins(channel) {
  switch (channel) {
    case ROW:
    case COLUMN:
    case SIZE2:
    case COLOR:
    case FILL:
    case STROKE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case SHAPE:
      return 6;
    case STROKEDASH:
      return 4;
    default:
      return 10;
  }
}
var init_bin4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/bin.js"() {
    init_vega_util();
    init_channel();
    init_channeldef();
    init_util();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/log/message.js
var message_exports = {};
__export(message_exports, {
  CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN: () => CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN,
  CONCAT_CANNOT_SHARE_AXIS: () => CONCAT_CANNOT_SHARE_AXIS,
  FACETED_INDEPENDENT_DIFFERENT_SOURCES: () => FACETED_INDEPENDENT_DIFFERENT_SOURCES,
  FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES: () => FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES,
  FACETED_INDEPENDENT_SAME_SOURCE: () => FACETED_INDEPENDENT_SAME_SOURCE,
  FIT_NON_SINGLE: () => FIT_NON_SINGLE,
  INVALID_CHANNEL_FOR_AXIS: () => INVALID_CHANNEL_FOR_AXIS,
  LEGEND_BINDINGS_PROJECT_LENGTH: () => LEGEND_BINDINGS_PROJECT_LENGTH,
  LINE_WITH_VARYING_SIZE: () => LINE_WITH_VARYING_SIZE,
  MORE_THAN_ONE_SORT: () => MORE_THAN_ONE_SORT,
  NO_FIELDS_NEEDS_AS: () => NO_FIELDS_NEEDS_AS,
  RANGE_STEP_DEPRECATED: () => RANGE_STEP_DEPRECATED,
  REPLACE_ANGLE_WITH_THETA: () => REPLACE_ANGLE_WITH_THETA,
  SCALE_BINDINGS_CONTINUOUS: () => SCALE_BINDINGS_CONTINUOUS,
  cannotApplySizeToNonOrientedMark: () => cannotApplySizeToNonOrientedMark,
  cannotProjectAggregate: () => cannotProjectAggregate,
  cannotProjectOnChannelWithoutField: () => cannotProjectOnChannelWithoutField,
  cannotStackNonLinearScale: () => cannotStackNonLinearScale,
  cannotStackRangedMark: () => cannotStackRangedMark,
  cannotUseScalePropertyWithNonColor: () => cannotUseScalePropertyWithNonColor,
  channelRequiredForBinned: () => channelRequiredForBinned,
  columnsNotSupportByRowCol: () => columnsNotSupportByRowCol,
  containerSizeNonSingle: () => containerSizeNonSingle,
  containerSizeNotCompatibleWithAutosize: () => containerSizeNotCompatibleWithAutosize,
  customFormatTypeNotAllowed: () => customFormatTypeNotAllowed,
  differentParse: () => differentParse,
  discreteChannelCannotEncode: () => discreteChannelCannotEncode,
  domainRequiredForThresholdScale: () => domainRequiredForThresholdScale,
  domainSortDropped: () => domainSortDropped,
  droppedDay: () => droppedDay,
  droppingColor: () => droppingColor,
  droppingFit: () => droppingFit,
  emptyFieldDef: () => emptyFieldDef,
  encodingOverridden: () => encodingOverridden,
  errorBand1DNotSupport: () => errorBand1DNotSupport,
  errorBarCenterAndExtentAreNotNeeded: () => errorBarCenterAndExtentAreNotNeeded,
  errorBarCenterIsNotNeeded: () => errorBarCenterIsNotNeeded,
  errorBarCenterIsUsedWithWrongExtent: () => errorBarCenterIsUsedWithWrongExtent,
  errorBarContinuousAxisHasCustomizedAggregate: () => errorBarContinuousAxisHasCustomizedAggregate,
  facetChannelDropped: () => facetChannelDropped,
  facetChannelShouldBeDiscrete: () => facetChannelShouldBeDiscrete,
  incompatibleChannel: () => incompatibleChannel,
  independentScaleMeansIndependentGuide: () => independentScaleMeansIndependentGuide,
  invalidAggregate: () => invalidAggregate,
  invalidEncodingChannel: () => invalidEncodingChannel,
  invalidFieldType: () => invalidFieldType,
  invalidFieldTypeForCountAggregate: () => invalidFieldTypeForCountAggregate,
  invalidSpec: () => invalidSpec,
  invalidTimeUnit: () => invalidTimeUnit,
  invalidTransformIgnored: () => invalidTransformIgnored,
  latLongDeprecated: () => latLongDeprecated,
  lineWithRange: () => lineWithRange,
  mergeConflictingDomainProperty: () => mergeConflictingDomainProperty,
  mergeConflictingProperty: () => mergeConflictingProperty,
  missingFieldType: () => missingFieldType,
  nearestNotSupportForContinuous: () => nearestNotSupportForContinuous,
  noSameUnitLookup: () => noSameUnitLookup,
  noSuchRepeatedValue: () => noSuchRepeatedValue,
  orientOverridden: () => orientOverridden,
  primitiveChannelDef: () => primitiveChannelDef,
  projectionOverridden: () => projectionOverridden,
  scalePropertyNotWorkWithScaleType: () => scalePropertyNotWorkWithScaleType,
  scaleTypeNotWorkWithChannel: () => scaleTypeNotWorkWithChannel,
  scaleTypeNotWorkWithFieldDef: () => scaleTypeNotWorkWithFieldDef,
  scaleTypeNotWorkWithMark: () => scaleTypeNotWorkWithMark,
  selectionNotFound: () => selectionNotFound,
  selectionNotSupported: () => selectionNotSupported,
  stackNonSummativeAggregate: () => stackNonSummativeAggregate,
  stepDropped: () => stepDropped,
  unaggregateDomainHasNoEffectForRawField: () => unaggregateDomainHasNoEffectForRawField,
  unaggregateDomainWithNonSharedDomainOp: () => unaggregateDomainWithNonSharedDomainOp,
  unaggregatedDomainWithLogScale: () => unaggregatedDomainWithLogScale,
  unrecognizedParse: () => unrecognizedParse
});
function invalidSpec(spec) {
  return `Invalid specification ${JSON.stringify(spec)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
function containerSizeNonSingle(name4) {
  const uName = name4 == "width" ? "Width" : "Height";
  return `${uName} "container" only works for single views and layered views.`;
}
function containerSizeNotCompatibleWithAutosize(name4) {
  const uName = name4 == "width" ? "Width" : "Height";
  const fitDirection = name4 == "width" ? "x" : "y";
  return `${uName} "container" only works well with autosize "fit" or "fit-${fitDirection}".`;
}
function droppingFit(channel) {
  return channel ? `Dropping "fit-${channel}" because spec has discrete ${getSizeChannel(channel)}.` : `Dropping "fit" because spec has discrete size.`;
}
function cannotProjectOnChannelWithoutField(channel) {
  return `Cannot project a selection on encoding channel "${channel}", which has no field.`;
}
function cannotProjectAggregate(channel, aggregate) {
  return `Cannot project a selection on encoding channel "${channel}" as it uses an aggregate function ("${aggregate}").`;
}
function nearestNotSupportForContinuous(mark) {
  return `The "nearest" transform is not supported for ${mark} marks.`;
}
function selectionNotSupported(mark) {
  return `Selection not supported for ${mark} yet.`;
}
function selectionNotFound(name4) {
  return `Cannot find a selection named "${name4}".`;
}
function noSameUnitLookup(name4) {
  return `Cannot define and lookup the "${name4}" selection in the same view. Try moving the lookup into a second, layered view?`;
}
function noSuchRepeatedValue(field4) {
  return `Unknown repeated value "${field4}".`;
}
function columnsNotSupportByRowCol(type4) {
  return `The "columns" property cannot be used when "${type4}" has nested row/column.`;
}
function unrecognizedParse(p) {
  return `Unrecognized parse "${p}".`;
}
function differentParse(field4, local2, ancestor) {
  return `An ancestor parsed field "${field4}" as ${ancestor} but a child wants to parse the field as ${local2}.`;
}
function invalidTransformIgnored(transform4) {
  return `Ignoring an invalid transform: ${stringify(transform4)}.`;
}
function customFormatTypeNotAllowed(channel) {
  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;
}
function encodingOverridden(channels) {
  return `Layer's shared ${channels.join(",")} channel ${channels.length === 1 ? "is" : "are"} overriden.`;
}
function projectionOverridden(opt) {
  const { parentProjection, projection: projection3 } = opt;
  return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection3)}.`;
}
function primitiveChannelDef(channel, type4, value4) {
  return `Channel ${channel} is a ${type4}. Converted to {value: ${stringify(value4)}}.`;
}
function invalidFieldType(type4) {
  return `Invalid field type "${type4}".`;
}
function invalidFieldTypeForCountAggregate(type4, aggregate) {
  return `Invalid field type "${type4}" for aggregate: "${aggregate}", using "quantitative" instead.`;
}
function invalidAggregate(aggregate) {
  return `Invalid aggregation operator "${aggregate}".`;
}
function missingFieldType(channel, newType) {
  return `Missing type for channel "${channel}", using "${newType}" instead.`;
}
function droppingColor(type4, opt) {
  const { fill: fill3, stroke: stroke3 } = opt;
  return `Dropping color ${type4} as the plot also has ${fill3 && stroke3 ? "fill and stroke" : fill3 ? "fill" : "stroke"}.`;
}
function emptyFieldDef(fieldDef, channel) {
  return `Dropping ${stringify(fieldDef)} from channel "${channel}" since it does not contain any data field, datum, value, or signal.`;
}
function latLongDeprecated(channel, type4, newChannel) {
  return `${channel}-encoding with type ${type4} is deprecated. Replacing with ${newChannel}-encoding.`;
}
function incompatibleChannel(channel, markOrFacet, when) {
  return `${channel} dropped as it is incompatible with "${markOrFacet}"${when ? ` when ${when}` : ""}.`;
}
function invalidEncodingChannel(channel) {
  return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;
}
function facetChannelShouldBeDiscrete(channel) {
  return `${channel} encoding should be discrete (ordinal / nominal / binned).`;
}
function facetChannelDropped(channels) {
  return `Facet encoding dropped as ${channels.join(" and ")} ${channels.length > 1 ? "are" : "is"} also specified.`;
}
function discreteChannelCannotEncode(channel, type4) {
  return `Using discrete channel "${channel}" to encode "${type4}" field can be misleading as it does not encode ${type4 === "ordinal" ? "order" : "magnitude"}.`;
}
function lineWithRange(hasX2, hasY2) {
  const channels = hasX2 && hasY2 ? "x2 and y2" : hasX2 ? "x2" : "y2";
  return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;
}
function orientOverridden(original, actual) {
  return `Specified orient "${original}" overridden with "${actual}".`;
}
function cannotUseScalePropertyWithNonColor(prop) {
  return `Cannot use the scale property "${prop}" with non-color channel.`;
}
function unaggregateDomainHasNoEffectForRawField(fieldDef) {
  return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;
}
function unaggregateDomainWithNonSharedDomainOp(aggregate) {
  return `Unaggregated domain not applicable for "${aggregate}" since it produces values outside the origin domain of the source data.`;
}
function unaggregatedDomainWithLogScale(fieldDef) {
  return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;
}
function cannotApplySizeToNonOrientedMark(mark) {
  return `Cannot apply size to non-oriented mark "${mark}".`;
}
function scaleTypeNotWorkWithChannel(channel, scaleType2, defaultScaleType) {
  return `Channel "${channel}" does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
}
function scaleTypeNotWorkWithFieldDef(scaleType2, defaultScaleType) {
  return `FieldDef does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
}
function scalePropertyNotWorkWithScaleType(scaleType2, propName, channel) {
  return `${channel}-scale's "${propName}" is dropped as it does not work with ${scaleType2} scale.`;
}
function scaleTypeNotWorkWithMark(mark, scaleType2) {
  return `Scale type "${scaleType2}" does not work with mark "${mark}".`;
}
function stepDropped(channel) {
  return `The step for "${channel}" is dropped because the ${channel === "width" ? "x" : "y"} is continuous.`;
}
function mergeConflictingProperty(property2, propertyOf, v1, v2) {
  return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`;
}
function mergeConflictingDomainProperty(property2, propertyOf, v1, v2) {
  return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify(v1)} and ${stringify(v2)}). Using the union of the two domains.`;
}
function independentScaleMeansIndependentGuide(channel) {
  return `Setting the scale to be independent for "${channel}" means we also have to set the guide (axis or legend) to be independent.`;
}
function domainSortDropped(sort5) {
  return `Dropping sort property ${stringify(sort5)} as unioned domains only support boolean or op "count", "min", and "max".`;
}
function cannotStackRangedMark(channel) {
  return `Cannot stack "${channel}" if there is already "${channel}2".`;
}
function cannotStackNonLinearScale(scaleType2) {
  return `Cannot stack non-linear scale (${scaleType2}).`;
}
function stackNonSummativeAggregate(aggregate) {
  return `Stacking is applied even though the aggregate function is non-summative ("${aggregate}").`;
}
function invalidTimeUnit(unitName2, value4) {
  return `Invalid ${unitName2}: ${stringify(value4)}.`;
}
function droppedDay(d) {
  return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;
}
function errorBarCenterAndExtentAreNotNeeded(center, extent5) {
  return `${extent5 ? "extent " : ""}${extent5 && center ? "and " : ""}${center ? "center " : ""}${extent5 && center ? "are " : "is "}not needed when data are aggregated.`;
}
function errorBarCenterIsUsedWithWrongExtent(center, extent5, mark) {
  return `${center} is not usually used with ${extent5} for ${mark}.`;
}
function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {
  return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;
}
function errorBarCenterIsNotNeeded(extent5, mark) {
  return `Center is not needed to be specified in ${mark} when extent is ${extent5}.`;
}
function errorBand1DNotSupport(property2) {
  return `1D error band does not support ${property2}.`;
}
function channelRequiredForBinned(channel) {
  return `Channel ${channel} is required for "binned" bin.`;
}
function domainRequiredForThresholdScale(channel) {
  return `Domain for ${channel} is required for threshold scale.`;
}
var FIT_NON_SINGLE, SCALE_BINDINGS_CONTINUOUS, LEGEND_BINDINGS_PROJECT_LENGTH, CONCAT_CANNOT_SHARE_AXIS, NO_FIELDS_NEEDS_AS, REPLACE_ANGLE_WITH_THETA, LINE_WITH_VARYING_SIZE, CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN, RANGE_STEP_DEPRECATED, MORE_THAN_ONE_SORT, FACETED_INDEPENDENT_DIFFERENT_SOURCES, FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES, FACETED_INDEPENDENT_SAME_SOURCE, INVALID_CHANNEL_FOR_AXIS;
var init_message = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/log/message.js"() {
    init_channel();
    init_util();
    FIT_NON_SINGLE = 'Autosize "fit" only works for single views and layered views.';
    SCALE_BINDINGS_CONTINUOUS = "Scale bindings are currently only supported for scales with unbinned, continuous domains.";
    LEGEND_BINDINGS_PROJECT_LENGTH = "Legend bindings are only supported for selections over an individual field or encoding channel.";
    CONCAT_CANNOT_SHARE_AXIS = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
    NO_FIELDS_NEEDS_AS = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
    REPLACE_ANGLE_WITH_THETA = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
    LINE_WITH_VARYING_SIZE = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
    CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = "Custom domain scale cannot be unioned with default field-based domain.";
    RANGE_STEP_DEPRECATED = `Scale's "rangeStep" is deprecated and will be removed in Vega-Lite 5.0. Please use "width"/"height": {"step": ...} instead. See https://vega.github.io/vega-lite/docs/size.html.`;
    MORE_THAN_ONE_SORT = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.";
    FACETED_INDEPENDENT_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.";
    FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.";
    FACETED_INDEPENDENT_SAME_SOURCE = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
    INVALID_CHANNEL_FOR_AXIS = "Invalid channel for axis.";
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/log/index.js
function set7(newLogger) {
  current = newLogger;
  return current;
}
function reset2() {
  current = main2;
  return current;
}
function warn2(...args) {
  current.warn(...args);
}
function debug2(...args) {
  current.debug(...args);
}
var main2, current;
var init_log3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/log/index.js"() {
    init_vega_util();
    init_message();
    main2 = logger_default(Warn3);
    current = main2;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/datetime.js
function isDateTime(o) {
  if (o && isObject_default(o)) {
    for (const part of TIMEUNIT_PARTS) {
      if (part in o) {
        return true;
      }
    }
  }
  return false;
}
function normalizeQuarter(q) {
  if (isNumeric(q)) {
    q = +q;
  }
  if (isNumber_default(q)) {
    if (q > 4) {
      warn2(message_exports.invalidTimeUnit("quarter", q));
    }
    return q - 1;
  } else {
    throw new Error(message_exports.invalidTimeUnit("quarter", q));
  }
}
function normalizeMonth(m2) {
  if (isNumeric(m2)) {
    m2 = +m2;
  }
  if (isNumber_default(m2)) {
    return m2 - 1;
  } else {
    const lowerM = m2.toLowerCase();
    const monthIndex = MONTHS.indexOf(lowerM);
    if (monthIndex !== -1) {
      return monthIndex;
    }
    const shortM = lowerM.substr(0, 3);
    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);
    if (shortMonthIndex !== -1) {
      return shortMonthIndex;
    }
    throw new Error(message_exports.invalidTimeUnit("month", m2));
  }
}
function normalizeDay(d) {
  if (isNumeric(d)) {
    d = +d;
  }
  if (isNumber_default(d)) {
    return d % 7;
  } else {
    const lowerD = d.toLowerCase();
    const dayIndex = DAYS.indexOf(lowerD);
    if (dayIndex !== -1) {
      return dayIndex;
    }
    const shortD = lowerD.substr(0, 3);
    const shortDayIndex = SHORT_DAYS.indexOf(shortD);
    if (shortDayIndex !== -1) {
      return shortDayIndex;
    }
    throw new Error(message_exports.invalidTimeUnit("day", d));
  }
}
function dateTimeParts(d, normalize4) {
  const parts = [];
  if (normalize4 && d.day !== void 0) {
    if (keys4(d).length > 1) {
      warn2(message_exports.droppedDay(d));
      d = duplicate(d);
      delete d.day;
    }
  }
  if (d.year !== void 0) {
    parts.push(d.year);
  } else {
    parts.push(2012);
  }
  if (d.month !== void 0) {
    const month2 = normalize4 ? normalizeMonth(d.month) : d.month;
    parts.push(month2);
  } else if (d.quarter !== void 0) {
    const quarter3 = normalize4 ? normalizeQuarter(d.quarter) : d.quarter;
    parts.push(isNumber_default(quarter3) ? quarter3 * 3 : quarter3 + "*3");
  } else {
    parts.push(0);
  }
  if (d.date !== void 0) {
    parts.push(d.date);
  } else if (d.day !== void 0) {
    const day2 = normalize4 ? normalizeDay(d.day) : d.day;
    parts.push(isNumber_default(day2) ? day2 + 1 : day2 + "+1");
  } else {
    parts.push(1);
  }
  for (const timeUnit of ["hours", "minutes", "seconds", "milliseconds"]) {
    const unit3 = d[timeUnit];
    parts.push(typeof unit3 === "undefined" ? 0 : unit3);
  }
  return parts;
}
function dateTimeToExpr(d) {
  const parts = dateTimeParts(d, true);
  const string = parts.join(", ");
  if (d.utc) {
    return `utc(${string})`;
  } else {
    return `datetime(${string})`;
  }
}
function dateTimeExprToExpr(d) {
  const parts = dateTimeParts(d, false);
  const string = parts.join(", ");
  if (d.utc) {
    return `utc(${string})`;
  } else {
    return `datetime(${string})`;
  }
}
function dateTimeToTimestamp(d) {
  const parts = dateTimeParts(d, true);
  if (d.utc) {
    return +new Date(Date.UTC(...parts));
  } else {
    return +new Date(...parts);
  }
}
var MONTHS, SHORT_MONTHS, DAYS, SHORT_DAYS;
var init_datetime = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/datetime.js"() {
    init_vega_util();
    init_log3();
    init_timeunit();
    init_util();
    MONTHS = [
      "january",
      "february",
      "march",
      "april",
      "may",
      "june",
      "july",
      "august",
      "september",
      "october",
      "november",
      "december"
    ];
    SHORT_MONTHS = MONTHS.map((m2) => m2.substr(0, 3));
    DAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
    SHORT_DAYS = DAYS.map((d) => d.substr(0, 3));
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/timeunit.js
function isLocalSingleTimeUnit(timeUnit) {
  return !!LOCAL_SINGLE_TIMEUNIT_INDEX[timeUnit];
}
function isUTCTimeUnit(t) {
  return t.startsWith("utc");
}
function getLocalTimeUnit(t) {
  return t.substr(3);
}
function getTimeUnitParts(timeUnit) {
  const parts = [];
  for (const part of TIMEUNIT_PARTS) {
    if (containsTimeUnit(timeUnit, part)) {
      parts.push(part);
    }
  }
  return parts;
}
function containsTimeUnit(fullTimeUnit, timeUnit) {
  const index8 = fullTimeUnit.indexOf(timeUnit);
  if (index8 < 0) {
    return false;
  }
  if (index8 > 0 && timeUnit === "seconds" && fullTimeUnit.charAt(index8 - 1) === "i") {
    return false;
  }
  if (fullTimeUnit.length > index8 + 3 && timeUnit === "day" && fullTimeUnit.charAt(index8 + 3) === "o") {
    return false;
  }
  if (index8 > 0 && timeUnit === "year" && fullTimeUnit.charAt(index8 - 1) === "f") {
    return false;
  }
  return true;
}
function fieldExpr(fullTimeUnit, field4, { end } = { end: false }) {
  const fieldRef2 = accessPathWithDatum(field4);
  const utc = isUTCTimeUnit(fullTimeUnit) ? "utc" : "";
  function func(timeUnit) {
    if (timeUnit === "quarter") {
      return `(${utc}quarter(${fieldRef2})-1)`;
    } else {
      return `${utc}${timeUnit}(${fieldRef2})`;
    }
  }
  let lastTimeUnit;
  const dateExpr = {};
  for (const part of TIMEUNIT_PARTS) {
    if (containsTimeUnit(fullTimeUnit, part)) {
      dateExpr[part] = func(part);
      lastTimeUnit = part;
    }
  }
  if (end) {
    dateExpr[lastTimeUnit] += "+1";
  }
  return dateTimeExprToExpr(dateExpr);
}
function timeUnitSpecifierExpression(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  const timeUnitParts = getTimeUnitParts(timeUnit);
  return `timeUnitSpecifier(${(0, import_fast_json_stable_stringify2.default)(timeUnitParts)}, ${(0, import_fast_json_stable_stringify2.default)(VEGALITE_TIMEFORMAT)})`;
}
function formatExpression(timeUnit, field4, isUTCScale) {
  if (!timeUnit) {
    return void 0;
  }
  const expr2 = timeUnitSpecifierExpression(timeUnit);
  const utc = isUTCScale || isUTCTimeUnit(timeUnit);
  return `${utc ? "utc" : "time"}Format(${field4}, ${expr2})`;
}
function normalizeTimeUnit(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  let params2;
  if (isString_default(timeUnit)) {
    params2 = {
      unit: timeUnit
    };
  } else if (isObject_default(timeUnit)) {
    params2 = Object.assign(Object.assign({}, timeUnit), timeUnit.unit ? { unit: timeUnit.unit } : {});
  }
  if (isUTCTimeUnit(params2.unit)) {
    params2.utc = true;
    params2.unit = getLocalTimeUnit(params2.unit);
  }
  return params2;
}
function timeUnitToString(tu) {
  const _a2 = normalizeTimeUnit(tu), { utc } = _a2, rest = __rest(_a2, ["utc"]);
  if (rest.unit) {
    return (utc ? "utc" : "") + keys4(rest).map((p) => varName(`${p === "unit" ? "" : `_${p}_`}${rest[p]}`)).join("");
  } else {
    return (utc ? "utc" : "") + "timeunit" + keys4(rest).map((p) => varName(`_${p}_${rest[p]}`)).join("");
  }
}
var import_fast_json_stable_stringify2, LOCAL_SINGLE_TIMEUNIT_INDEX, TIMEUNIT_PARTS, VEGALITE_TIMEFORMAT;
var init_timeunit = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/timeunit.js"() {
    init_tslib_es6();
    import_fast_json_stable_stringify2 = __toESM(require_fast_json_stable_stringify());
    init_vega_util();
    init_datetime();
    init_util();
    LOCAL_SINGLE_TIMEUNIT_INDEX = {
      year: 1,
      quarter: 1,
      month: 1,
      week: 1,
      day: 1,
      dayofyear: 1,
      date: 1,
      hours: 1,
      minutes: 1,
      seconds: 1,
      milliseconds: 1
    };
    TIMEUNIT_PARTS = keys4(LOCAL_SINGLE_TIMEUNIT_INDEX);
    VEGALITE_TIMEFORMAT = {
      "year-month": "%b %Y ",
      "year-month-date": "%b %d, %Y "
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/vega.schema.js
function isSignalRef(o) {
  return o && !!o["signal"];
}
function isVgRangeStep(range7) {
  return !!range7["step"];
}
function isDataRefUnionedDomain(domain4) {
  if (!isArray_default(domain4)) {
    return "fields" in domain4 && !("data" in domain4);
  }
  return false;
}
function isFieldRefUnionDomain(domain4) {
  if (!isArray_default(domain4)) {
    return "fields" in domain4 && "data" in domain4;
  }
  return false;
}
function isDataRefDomain(domain4) {
  if (!isArray_default(domain4)) {
    return "field" in domain4 && "data" in domain4;
  }
  return false;
}
var VG_MARK_CONFIG_INDEX, VG_MARK_CONFIGS, VG_MARK_INDEX, VG_CORNERRADIUS_CHANNELS;
var init_vega_schema = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/vega.schema.js"() {
    init_vega_util();
    init_util();
    VG_MARK_CONFIG_INDEX = {
      aria: 1,
      description: 1,
      ariaRole: 1,
      ariaRoleDescription: 1,
      blend: 1,
      opacity: 1,
      fill: 1,
      fillOpacity: 1,
      stroke: 1,
      strokeCap: 1,
      strokeWidth: 1,
      strokeOpacity: 1,
      strokeDash: 1,
      strokeDashOffset: 1,
      strokeJoin: 1,
      strokeOffset: 1,
      strokeMiterLimit: 1,
      startAngle: 1,
      endAngle: 1,
      padAngle: 1,
      innerRadius: 1,
      outerRadius: 1,
      size: 1,
      shape: 1,
      interpolate: 1,
      tension: 1,
      orient: 1,
      align: 1,
      baseline: 1,
      text: 1,
      dir: 1,
      dx: 1,
      dy: 1,
      ellipsis: 1,
      limit: 1,
      radius: 1,
      theta: 1,
      angle: 1,
      font: 1,
      fontSize: 1,
      fontWeight: 1,
      fontStyle: 1,
      lineBreak: 1,
      lineHeight: 1,
      cursor: 1,
      href: 1,
      tooltip: 1,
      cornerRadius: 1,
      cornerRadiusTopLeft: 1,
      cornerRadiusTopRight: 1,
      cornerRadiusBottomLeft: 1,
      cornerRadiusBottomRight: 1,
      aspect: 1,
      width: 1,
      height: 1
    };
    VG_MARK_CONFIGS = keys4(VG_MARK_CONFIG_INDEX);
    VG_MARK_INDEX = {
      arc: 1,
      area: 1,
      group: 1,
      image: 1,
      line: 1,
      path: 1,
      rect: 1,
      rule: 1,
      shape: 1,
      symbol: 1,
      text: 1,
      trail: 1
    };
    VG_CORNERRADIUS_CHANNELS = [
      "cornerRadius",
      "cornerRadiusTopLeft",
      "cornerRadiusTopRight",
      "cornerRadiusBottomLeft",
      "cornerRadiusBottomRight"
    ];
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/predicate.js
function isSelectionPredicate(predicate) {
  return predicate === null || predicate === void 0 ? void 0 : predicate["selection"];
}
function isFieldEqualPredicate(predicate) {
  return predicate && !!predicate.field && predicate.equal !== void 0;
}
function isFieldLTPredicate(predicate) {
  return predicate && !!predicate.field && predicate.lt !== void 0;
}
function isFieldLTEPredicate(predicate) {
  return predicate && !!predicate.field && predicate.lte !== void 0;
}
function isFieldGTPredicate(predicate) {
  return predicate && !!predicate.field && predicate.gt !== void 0;
}
function isFieldGTEPredicate(predicate) {
  return predicate && !!predicate.field && predicate.gte !== void 0;
}
function isFieldRangePredicate(predicate) {
  if (predicate && predicate.field) {
    if (isArray_default(predicate.range) && predicate.range.length === 2) {
      return true;
    } else if (isSignalRef(predicate.range)) {
      return true;
    }
  }
  return false;
}
function isFieldOneOfPredicate(predicate) {
  return predicate && !!predicate.field && (isArray_default(predicate.oneOf) || isArray_default(predicate.in));
}
function isFieldValidPredicate(predicate) {
  return predicate && !!predicate.field && predicate.valid !== void 0;
}
function isFieldPredicate(predicate) {
  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);
}
function predicateValueExpr(v, timeUnit) {
  return valueExpr(v, { timeUnit, wrapTime: true });
}
function predicateValuesExpr(vals2, timeUnit) {
  return vals2.map((v) => predicateValueExpr(v, timeUnit));
}
function fieldFilterExpression(predicate, useInRange = true) {
  var _a2;
  const { field: field4 } = predicate;
  const timeUnit = (_a2 = normalizeTimeUnit(predicate.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit;
  const fieldExpr2 = timeUnit ? "time(" + fieldExpr(timeUnit, field4) + ")" : vgField(predicate, { expr: "datum" });
  if (isFieldEqualPredicate(predicate)) {
    return fieldExpr2 + "===" + predicateValueExpr(predicate.equal, timeUnit);
  } else if (isFieldLTPredicate(predicate)) {
    const upper = predicate.lt;
    return `${fieldExpr2}<${predicateValueExpr(upper, timeUnit)}`;
  } else if (isFieldGTPredicate(predicate)) {
    const lower2 = predicate.gt;
    return `${fieldExpr2}>${predicateValueExpr(lower2, timeUnit)}`;
  } else if (isFieldLTEPredicate(predicate)) {
    const upper = predicate.lte;
    return `${fieldExpr2}<=${predicateValueExpr(upper, timeUnit)}`;
  } else if (isFieldGTEPredicate(predicate)) {
    const lower2 = predicate.gte;
    return `${fieldExpr2}>=${predicateValueExpr(lower2, timeUnit)}`;
  } else if (isFieldOneOfPredicate(predicate)) {
    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(",")}], ${fieldExpr2}) !== -1`;
  } else if (isFieldValidPredicate(predicate)) {
    return fieldValidPredicate(fieldExpr2, predicate.valid);
  } else if (isFieldRangePredicate(predicate)) {
    const { range: range7 } = predicate;
    const lower2 = isSignalRef(range7) ? { signal: `${range7.signal}[0]` } : range7[0];
    const upper = isSignalRef(range7) ? { signal: `${range7.signal}[1]` } : range7[1];
    if (lower2 !== null && upper !== null && useInRange) {
      return "inrange(" + fieldExpr2 + ", [" + predicateValueExpr(lower2, timeUnit) + ", " + predicateValueExpr(upper, timeUnit) + "])";
    }
    const exprs = [];
    if (lower2 !== null) {
      exprs.push(`${fieldExpr2} >= ${predicateValueExpr(lower2, timeUnit)}`);
    }
    if (upper !== null) {
      exprs.push(`${fieldExpr2} <= ${predicateValueExpr(upper, timeUnit)}`);
    }
    return exprs.length > 0 ? exprs.join(" && ") : "true";
  }
  throw new Error(`Invalid field predicate: ${JSON.stringify(predicate)}`);
}
function fieldValidPredicate(fieldExpr2, valid = true) {
  if (valid) {
    return `isValid(${fieldExpr2}) && isFinite(+${fieldExpr2})`;
  } else {
    return `!isValid(${fieldExpr2}) || !isFinite(+${fieldExpr2})`;
  }
}
function normalizePredicate(f) {
  var _a2;
  if (isFieldPredicate(f) && f.timeUnit) {
    return Object.assign(Object.assign({}, f), { timeUnit: (_a2 = normalizeTimeUnit(f.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit });
  }
  return f;
}
var init_predicate = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/predicate.js"() {
    init_vega_util();
    init_channeldef();
    init_timeunit();
    init_vega_schema();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/type.js
function getFullName(type4) {
  if (type4) {
    type4 = type4.toLowerCase();
    switch (type4) {
      case "q":
      case QUANTITATIVE:
        return "quantitative";
      case "t":
      case TEMPORAL:
        return "temporal";
      case "o":
      case ORDINAL:
        return "ordinal";
      case "n":
      case NOMINAL:
        return "nominal";
      case GEOJSON:
        return "geojson";
    }
  }
  return void 0;
}
var Type, QUANTITATIVE, ORDINAL, TEMPORAL, NOMINAL, GEOJSON, TYPES;
var init_type = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/type.js"() {
    init_util();
    Type = {
      quantitative: "quantitative",
      ordinal: "ordinal",
      temporal: "temporal",
      nominal: "nominal",
      geojson: "geojson"
    };
    QUANTITATIVE = Type.quantitative;
    ORDINAL = Type.ordinal;
    TEMPORAL = Type.temporal;
    NOMINAL = Type.nominal;
    GEOJSON = Type.geojson;
    TYPES = keys4(Type);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/scale.js
function scaleCompatible(scaleType1, scaleType2) {
  const scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];
  const scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];
  return scaleCategory1 === scaleCategory2 || scaleCategory1 === "ordinal-position" && scaleCategory2 === "time" || scaleCategory2 === "ordinal-position" && scaleCategory1 === "time";
}
function scaleTypePrecedence(scaleType2) {
  return SCALE_PRECEDENCE_INDEX[scaleType2];
}
function isQuantitative(type4) {
  return type4 in QUANTITATIVE_SCALES_INDEX;
}
function hasDiscreteDomain(type4) {
  return type4 in DISCRETE_DOMAIN_INDEX;
}
function hasContinuousDomain(type4) {
  return type4 in CONTINUOUS_DOMAIN_INDEX;
}
function isContinuousToContinuous(type4) {
  return type4 in CONTINUOUS_TO_CONTINUOUS_INDEX;
}
function isContinuousToDiscrete(type4) {
  return type4 in CONTINUOUS_TO_DISCRETE_INDEX;
}
function isExtendedScheme(scheme4) {
  return !isString_default(scheme4) && !!scheme4["name"];
}
function isSelectionDomain(domain4) {
  return domain4 === null || domain4 === void 0 ? void 0 : domain4["selection"];
}
function isDomainUnionWith(domain4) {
  return domain4 && domain4["unionWith"];
}
function scaleTypeSupportProperty(scaleType2, propName) {
  switch (propName) {
    case "type":
    case "domain":
    case "reverse":
    case "range":
      return true;
    case "scheme":
    case "interpolate":
      return !contains2(["point", "band", "identity"], scaleType2);
    case "bins":
      return !contains2(["point", "band", "identity", "ordinal"], scaleType2);
    case "round":
      return isContinuousToContinuous(scaleType2) || scaleType2 === "band" || scaleType2 === "point";
    case "padding":
      return isContinuousToContinuous(scaleType2) || contains2(["point", "band"], scaleType2);
    case "paddingOuter":
    case "align":
      return contains2(["point", "band"], scaleType2);
    case "paddingInner":
      return scaleType2 === "band";
    case "domainMid":
    case "clamp":
      return isContinuousToContinuous(scaleType2);
    case "nice":
      return isContinuousToContinuous(scaleType2) || scaleType2 === "quantize" || scaleType2 === "threshold";
    case "exponent":
      return scaleType2 === "pow";
    case "base":
      return scaleType2 === "log";
    case "constant":
      return scaleType2 === "symlog";
    case "zero":
      return hasContinuousDomain(scaleType2) && !contains2([
        "log",
        "time",
        "utc",
        "threshold",
        "quantile"
      ], scaleType2);
  }
}
function channelScalePropertyIncompatability(channel, propName) {
  switch (propName) {
    case "interpolate":
    case "scheme":
    case "domainMid":
      if (!isColorChannel(channel)) {
        return message_exports.cannotUseScalePropertyWithNonColor(channel);
      }
      return void 0;
    case "align":
    case "type":
    case "bins":
    case "domain":
    case "range":
    case "base":
    case "exponent":
    case "constant":
    case "nice":
    case "padding":
    case "paddingInner":
    case "paddingOuter":
    case "reverse":
    case "round":
    case "clamp":
    case "zero":
      return void 0;
  }
}
function scaleTypeSupportDataType(specifiedType, fieldDefType) {
  if (contains2([ORDINAL, NOMINAL], fieldDefType)) {
    return specifiedType === void 0 || hasDiscreteDomain(specifiedType);
  } else if (fieldDefType === TEMPORAL) {
    return contains2([ScaleType.TIME, ScaleType.UTC, void 0], specifiedType);
  } else if (fieldDefType === QUANTITATIVE) {
    return contains2([
      ScaleType.LOG,
      ScaleType.POW,
      ScaleType.SQRT,
      ScaleType.SYMLOG,
      ScaleType.QUANTILE,
      ScaleType.QUANTIZE,
      ScaleType.THRESHOLD,
      ScaleType.LINEAR,
      void 0
    ], specifiedType);
  }
  return true;
}
function channelSupportScaleType(channel, scaleType2) {
  if (!isScaleChannel(channel)) {
    return false;
  }
  switch (channel) {
    case X3:
    case Y3:
    case THETA:
    case RADIUS:
      return isContinuousToContinuous(scaleType2) || contains2(["band", "point"], scaleType2);
    case SIZE2:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case ANGLE:
      return isContinuousToContinuous(scaleType2) || isContinuousToDiscrete(scaleType2) || contains2(["band", "point", "ordinal"], scaleType2);
    case COLOR:
    case FILL:
    case STROKE:
      return scaleType2 !== "band";
    case STROKEDASH:
      return scaleType2 === "ordinal" || isContinuousToDiscrete(scaleType2);
    case SHAPE:
      return scaleType2 === "ordinal";
  }
}
function generateScaleTypeIndex() {
  var _a2;
  const index8 = {};
  for (const channel of CHANNELS) {
    for (const fieldDefType of TYPES) {
      for (const scaleType2 of SCALE_TYPES) {
        const key3 = generateScaleTypeIndexKey(channel, fieldDefType);
        if (channelSupportScaleType(channel, scaleType2) && scaleTypeSupportDataType(scaleType2, fieldDefType)) {
          index8[key3] = (_a2 = index8[key3]) !== null && _a2 !== void 0 ? _a2 : [];
          index8[key3].push(scaleType2);
        }
      }
    }
  }
  return index8;
}
function generateScaleTypeIndexKey(channel, fieldDefType) {
  return channel + "_" + fieldDefType;
}
var ScaleType, SCALE_CATEGORY_INDEX, SCALE_TYPES, SCALE_PRECEDENCE_INDEX, CONTINUOUS_TO_CONTINUOUS_SCALES, CONTINUOUS_TO_CONTINUOUS_INDEX, QUANTITATIVE_SCALES, QUANTITATIVE_SCALES_INDEX, CONTINUOUS_TO_DISCRETE_SCALES, CONTINUOUS_TO_DISCRETE_INDEX, CONTINUOUS_DOMAIN_SCALES, CONTINUOUS_DOMAIN_INDEX, DISCRETE_DOMAIN_SCALES, DISCRETE_DOMAIN_INDEX, defaultScaleConfig, SCALE_PROPERTY_INDEX, SCALE_PROPERTIES, type3, domain2, range6, scheme3, NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX, NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, SCALE_TYPE_INDEX;
var init_scale = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/scale.js"() {
    init_tslib_es6();
    init_vega_util();
    init_channel();
    init_channel();
    init_log3();
    init_type();
    init_util();
    ScaleType = {
      LINEAR: "linear",
      LOG: "log",
      POW: "pow",
      SQRT: "sqrt",
      SYMLOG: "symlog",
      IDENTITY: "identity",
      SEQUENTIAL: "sequential",
      TIME: "time",
      UTC: "utc",
      QUANTILE: "quantile",
      QUANTIZE: "quantize",
      THRESHOLD: "threshold",
      BIN_ORDINAL: "bin-ordinal",
      ORDINAL: "ordinal",
      POINT: "point",
      BAND: "band"
    };
    SCALE_CATEGORY_INDEX = {
      linear: "numeric",
      log: "numeric",
      pow: "numeric",
      sqrt: "numeric",
      symlog: "numeric",
      identity: "numeric",
      sequential: "numeric",
      time: "time",
      utc: "time",
      ordinal: "ordinal",
      "bin-ordinal": "bin-ordinal",
      point: "ordinal-position",
      band: "ordinal-position",
      quantile: "discretizing",
      quantize: "discretizing",
      threshold: "discretizing"
    };
    SCALE_TYPES = keys4(SCALE_CATEGORY_INDEX);
    SCALE_PRECEDENCE_INDEX = {
      linear: 0,
      log: 1,
      pow: 1,
      sqrt: 1,
      symlog: 1,
      identity: 1,
      sequential: 1,
      time: 0,
      utc: 0,
      point: 10,
      band: 11,
      ordinal: 0,
      "bin-ordinal": 0,
      quantile: 0,
      quantize: 0,
      threshold: 0
    };
    CONTINUOUS_TO_CONTINUOUS_SCALES = ["linear", "log", "pow", "sqrt", "symlog", "time", "utc"];
    CONTINUOUS_TO_CONTINUOUS_INDEX = toSet_default(CONTINUOUS_TO_CONTINUOUS_SCALES);
    QUANTITATIVE_SCALES = ["linear", "log", "pow", "sqrt", "symlog"];
    QUANTITATIVE_SCALES_INDEX = toSet_default(QUANTITATIVE_SCALES);
    CONTINUOUS_TO_DISCRETE_SCALES = ["quantile", "quantize", "threshold"];
    CONTINUOUS_TO_DISCRETE_INDEX = toSet_default(CONTINUOUS_TO_DISCRETE_SCALES);
    CONTINUOUS_DOMAIN_SCALES = CONTINUOUS_TO_CONTINUOUS_SCALES.concat([
      "quantile",
      "quantize",
      "threshold",
      "sequential",
      "identity"
    ]);
    CONTINUOUS_DOMAIN_INDEX = toSet_default(CONTINUOUS_DOMAIN_SCALES);
    DISCRETE_DOMAIN_SCALES = ["ordinal", "bin-ordinal", "point", "band"];
    DISCRETE_DOMAIN_INDEX = toSet_default(DISCRETE_DOMAIN_SCALES);
    defaultScaleConfig = {
      pointPadding: 0.5,
      barBandPaddingInner: 0.1,
      rectBandPaddingInner: 0,
      minBandSize: 2,
      minFontSize: 8,
      maxFontSize: 40,
      minOpacity: 0.3,
      maxOpacity: 0.8,
      minSize: 9,
      minStrokeWidth: 1,
      maxStrokeWidth: 4,
      quantileCount: 4,
      quantizeCount: 4
    };
    SCALE_PROPERTY_INDEX = {
      type: 1,
      domain: 1,
      domainMid: 1,
      align: 1,
      range: 1,
      scheme: 1,
      bins: 1,
      reverse: 1,
      round: 1,
      clamp: 1,
      nice: 1,
      base: 1,
      exponent: 1,
      constant: 1,
      interpolate: 1,
      zero: 1,
      padding: 1,
      paddingInner: 1,
      paddingOuter: 1
    };
    SCALE_PROPERTIES = keys4(SCALE_PROPERTY_INDEX);
    ({ type: type3, domain: domain2, range: range6, scheme: scheme3 } = SCALE_PROPERTY_INDEX);
    NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX = __rest(SCALE_PROPERTY_INDEX, ["type", "domain", "range", "scheme"]);
    NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys4(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);
    SCALE_TYPE_INDEX = generateScaleTypeIndex();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/valueref.js
function midPointRefWithPositionInvalidTest(params2) {
  const { channel, channelDef, markDef, scale: scale8, config } = params2;
  const ref2 = midPoint(params2);
  if (isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && scale8 && isContinuousToContinuous(scale8.get("type")) && scale8.get("zero") === false) {
    return wrapPositionInvalidTest({
      fieldDef: channelDef,
      channel,
      markDef,
      ref: ref2,
      config
    });
  }
  return ref2;
}
function wrapPositionInvalidTest({ fieldDef, channel, markDef, ref: ref2, config }) {
  if (isPathMark(markDef.type)) {
    return ref2;
  }
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid === null) {
    return ref2;
  }
  return [fieldInvalidTestValueRef(fieldDef, channel), ref2];
}
function fieldInvalidTestValueRef(fieldDef, channel) {
  const test2 = fieldInvalidPredicate(fieldDef, true);
  const mainChannel = getMainRangeChannel(channel);
  const zeroValueRef = mainChannel === "y" ? { field: { group: "height" } } : { value: 0 };
  return Object.assign({ test: test2 }, zeroValueRef);
}
function fieldInvalidPredicate(field4, invalid = true) {
  return fieldValidPredicate(isString_default(field4) ? field4 : vgField(field4, { expr: "datum" }), !invalid);
}
function datumDefToExpr(datumDef) {
  const { datum: datum2 } = datumDef;
  if (isDateTime(datum2)) {
    return dateTimeToExpr(datum2);
  }
  return `${JSON.stringify(datum2)}`;
}
function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode2) {
  const ref2 = {};
  if (scaleName) {
    ref2.scale = scaleName;
  }
  if (isDatumDef(fieldDef)) {
    const { datum: datum2 } = fieldDef;
    if (isDateTime(datum2)) {
      ref2.signal = dateTimeToExpr(datum2);
    } else if (isSignalRef(datum2)) {
      ref2.signal = datum2.signal;
    } else {
      ref2.value = datum2;
    }
  } else {
    ref2.field = vgField(fieldDef, opt);
  }
  if (encode2) {
    const { offset: offset5, band: band5 } = encode2;
    if (offset5) {
      ref2.offset = offset5;
    }
    if (band5) {
      ref2.band = band5;
    }
  }
  return ref2;
}
function interpolatedSignalRef({ scaleName, fieldOrDatumDef, fieldOrDatumDef2, offset: offset5, startSuffix, band: band5 = 0.5 }) {
  const expr2 = 0 < band5 && band5 < 1 ? "datum" : void 0;
  const start = vgField(fieldOrDatumDef, { expr: expr2, suffix: startSuffix });
  const end = fieldOrDatumDef2 !== void 0 ? vgField(fieldOrDatumDef2, { expr: expr2 }) : vgField(fieldOrDatumDef, { suffix: "end", expr: expr2 });
  const ref2 = {};
  if (band5 === 0 || band5 === 1) {
    ref2.scale = scaleName;
    const val = band5 === 0 ? start : end;
    ref2.field = val;
  } else {
    const datum2 = `${band5} * ${start} + ${1 - band5} * ${end}`;
    ref2.signal = `scale("${scaleName}", ${datum2})`;
  }
  if (offset5) {
    ref2.offset = offset5;
  }
  return ref2;
}
function midPoint({ channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale8, stack: stack3, offset: offset5, defaultRef, band: band5 }) {
  var _a2;
  if (channelDef) {
    if (isFieldOrDatumDef(channelDef)) {
      if (isTypedFieldDef(channelDef)) {
        band5 = band5 !== null && band5 !== void 0 ? band5 : getBand({
          channel,
          fieldDef: channelDef,
          fieldDef2: channel2Def,
          markDef,
          stack: stack3,
          config,
          isMidPoint: true
        });
        const { bin: bin5, timeUnit, type: type4 } = channelDef;
        if (isBinning(bin5) || band5 && timeUnit && type4 === TEMPORAL) {
          if (stack3 && stack3.impute) {
            return valueRefForFieldOrDatumDef(channelDef, scaleName, { binSuffix: "mid" }, { offset: offset5 });
          }
          if (band5) {
            return interpolatedSignalRef({ scaleName, fieldOrDatumDef: channelDef, band: band5, offset: offset5 });
          }
          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? { binSuffix: "range" } : {}, {
            offset: offset5
          });
        } else if (isBinned(bin5)) {
          if (isFieldDef(channel2Def)) {
            return interpolatedSignalRef({
              scaleName,
              fieldOrDatumDef: channelDef,
              fieldOrDatumDef2: channel2Def,
              band: band5,
              offset: offset5
            });
          } else {
            const channel2 = channel === X3 ? X23 : Y23;
            warn2(message_exports.channelRequiredForBinned(channel2));
          }
        }
      }
      const scaleType2 = scale8 === null || scale8 === void 0 ? void 0 : scale8.get("type");
      return valueRefForFieldOrDatumDef(
        channelDef,
        scaleName,
        hasDiscreteDomain(scaleType2) ? { binSuffix: "range" } : {},
        {
          offset: offset5,
          band: scaleType2 === "band" ? (_a2 = band5 !== null && band5 !== void 0 ? band5 : channelDef.band) !== null && _a2 !== void 0 ? _a2 : 0.5 : void 0
        }
      );
    } else if (isValueDef(channelDef)) {
      const value4 = channelDef.value;
      const offsetMixins = offset5 ? { offset: offset5 } : {};
      return Object.assign(Object.assign({}, widthHeightValueOrSignalRef(channel, value4)), offsetMixins);
    }
  }
  if (isFunction_default(defaultRef)) {
    defaultRef = defaultRef();
  }
  if (defaultRef) {
    return Object.assign(Object.assign({}, defaultRef), offset5 ? { offset: offset5 } : {});
  }
  return defaultRef;
}
function widthHeightValueOrSignalRef(channel, value4) {
  if (contains2(["x", "x2"], channel) && value4 === "width") {
    return { field: { group: "width" } };
  } else if (contains2(["y", "y2"], channel) && value4 === "height") {
    return { field: { group: "height" } };
  }
  return signalOrValueRef(value4);
}
var init_valueref = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/valueref.js"() {
    init_vega_util();
    init_aggregate();
    init_bin4();
    init_channel();
    init_channeldef();
    init_datetime();
    init_log3();
    init_mark();
    init_predicate();
    init_scale();
    init_type();
    init_util();
    init_vega_schema();
    init_common();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/format.js
function isCustomFormatType(formatType) {
  return formatType && formatType !== "number" && formatType !== "time";
}
function customFormatExpr(formatType, field4, format9) {
  return `${formatType}(${field4}${format9 ? `, ${JSON.stringify(format9)}` : ""})`;
}
function formatSignalRef({ fieldOrDatumDef, format: format9, formatType, expr: expr2, normalizeStack, config }) {
  var _a2, _b;
  if (isCustomFormatType(formatType)) {
    return formatCustomType({
      fieldOrDatumDef,
      format: format9,
      formatType,
      expr: expr2,
      config
    });
  }
  const field4 = fieldToFormat(fieldOrDatumDef, expr2, normalizeStack);
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const signal = timeFormatExpression(field4, isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit : void 0, format9, config.timeFormat, isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC);
    return signal ? { signal } : void 0;
  }
  format9 = numberFormat(channelDefType(fieldOrDatumDef), format9, config);
  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, { expr: expr2, binSuffix: "end" });
    return {
      signal: binFormatExpression(field4, endField, format9, formatType, config)
    };
  } else if (format9 || channelDefType(fieldOrDatumDef) === "quantitative") {
    return {
      signal: `${formatExpr(field4, format9)}`
    };
  } else {
    return { signal: `isValid(${field4}) ? ${field4} : ""+${field4}` };
  }
}
function fieldToFormat(fieldOrDatumDef, expr2, normalizeStack) {
  if (isFieldDef(fieldOrDatumDef)) {
    if (normalizeStack) {
      return `${vgField(fieldOrDatumDef, { expr: expr2, suffix: "end" })}-${vgField(fieldOrDatumDef, {
        expr: expr2,
        suffix: "start"
      })}`;
    } else {
      return vgField(fieldOrDatumDef, { expr: expr2 });
    }
  } else {
    return datumDefToExpr(fieldOrDatumDef);
  }
}
function formatCustomType({ fieldOrDatumDef, format: format9, formatType, expr: expr2, normalizeStack, config, field: field4 }) {
  field4 = field4 !== null && field4 !== void 0 ? field4 : fieldToFormat(fieldOrDatumDef, expr2, normalizeStack);
  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, { expr: expr2, binSuffix: "end" });
    return {
      signal: binFormatExpression(field4, endField, format9, formatType, config)
    };
  }
  return { signal: customFormatExpr(formatType, field4, format9) };
}
function guideFormat(fieldOrDatumDef, type4, format9, formatType, config, omitTimeFormatConfig) {
  var _a2;
  if (isCustomFormatType(formatType)) {
    return void 0;
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit : void 0;
    return timeFormat4(format9, timeUnit, config, omitTimeFormatConfig);
  }
  return numberFormat(type4, format9, config);
}
function guideFormatType(formatType, fieldOrDatumDef, scaleType2) {
  if (formatType && (isSignalRef(formatType) || formatType === "number" || formatType === "time")) {
    return formatType;
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType2 !== "time" && scaleType2 !== "utc") {
    return "time";
  }
  return void 0;
}
function numberFormat(type4, specifiedFormat, config) {
  if (isString_default(specifiedFormat)) {
    return specifiedFormat;
  }
  if (type4 === QUANTITATIVE) {
    return config.numberFormat;
  }
  return void 0;
}
function timeFormat4(specifiedFormat, timeUnit, config, omitTimeFormatConfig) {
  if (specifiedFormat) {
    return specifiedFormat;
  }
  if (timeUnit) {
    return {
      signal: timeUnitSpecifierExpression(timeUnit)
    };
  }
  return omitTimeFormatConfig ? void 0 : config.timeFormat;
}
function formatExpr(field4, format9) {
  return `format(${field4}, "${format9 || ""}")`;
}
function binNumberFormatExpr(field4, format9, formatType, config) {
  var _a2;
  if (isCustomFormatType(formatType)) {
    return customFormatExpr(formatType, field4, format9);
  }
  return formatExpr(field4, (_a2 = isString_default(format9) ? format9 : void 0) !== null && _a2 !== void 0 ? _a2 : config.numberFormat);
}
function binFormatExpression(startField, endField, format9, formatType, config) {
  const start = binNumberFormatExpr(startField, format9, formatType, config);
  const end = binNumberFormatExpr(endField, format9, formatType, config);
  return `${fieldValidPredicate(startField, false)} ? "null" : ${start} + "${BIN_RANGE_DELIMITER}" + ${end}`;
}
function timeFormatExpression(field4, timeUnit, format9, rawTimeFormat, isUTCScale) {
  if (!timeUnit || format9) {
    format9 = isString_default(format9) ? format9 : rawTimeFormat;
    return `${isUTCScale ? "utc" : "time"}Format(${field4}, '${format9}')`;
  } else {
    return formatExpression(timeUnit, field4, isUTCScale);
  }
}
var BIN_RANGE_DELIMITER;
var init_format = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/format.js"() {
    init_vega_util();
    init_bin4();
    init_channeldef();
    init_predicate();
    init_scale();
    init_timeunit();
    init_type();
    init_vega_schema();
    init_valueref();
    BIN_RANGE_DELIMITER = "  ";
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/sort.js
function isSortByChannel(c2) {
  return c2 in SORT_BY_CHANNEL_INDEX;
}
function isSortByEncoding(sort5) {
  return !!sort5 && !!sort5["encoding"];
}
function isSortField(sort5) {
  return !!sort5 && (sort5["op"] === "count" || !!sort5["field"]);
}
function isSortArray(sort5) {
  return !!sort5 && isArray_default(sort5);
}
var DEFAULT_SORT_OP, SORT_BY_CHANNEL_INDEX;
var init_sort5 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/sort.js"() {
    init_vega_util();
    DEFAULT_SORT_OP = "min";
    SORT_BY_CHANNEL_INDEX = {
      x: 1,
      y: 1,
      color: 1,
      fill: 1,
      stroke: 1,
      strokeWidth: 1,
      size: 1,
      shape: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      opacity: 1,
      text: 1
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/facet.js
function isFacetMapping(f) {
  return "row" in f || "column" in f;
}
function isFacetFieldDef(channelDef) {
  return !!channelDef && "header" in channelDef;
}
function isFacetSpec(spec) {
  return "facet" in spec;
}
var init_facet = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/facet.js"() {
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/channeldef.js
function isConditionalSelection(c2) {
  return c2["selection"];
}
function isRepeatRef(field4) {
  return field4 && !isString_default(field4) && "repeat" in field4;
}
function toFieldDefBase(fieldDef) {
  const { field: field4, timeUnit, bin: bin5, aggregate } = fieldDef;
  return Object.assign(Object.assign(Object.assign(Object.assign({}, timeUnit ? { timeUnit } : {}), bin5 ? { bin: bin5 } : {}), aggregate ? { aggregate } : {}), { field: field4 });
}
function isSortableFieldDef(fieldDef) {
  return isTypedFieldDef(fieldDef) && "sort" in fieldDef;
}
function getBand({ channel, fieldDef, fieldDef2, markDef: mark, stack: stack3, config, isMidPoint }) {
  if (isFieldOrDatumDef(fieldDef) && fieldDef.band !== void 0) {
    return fieldDef.band;
  }
  if (isFieldDef(fieldDef)) {
    const { timeUnit, bin: bin5 } = fieldDef;
    if (timeUnit && !fieldDef2) {
      if (isMidPoint) {
        return getMarkConfig("timeUnitBandPosition", mark, config);
      } else {
        return isRectBasedMark(mark.type) ? getMarkConfig("timeUnitBand", mark, config) : 0;
      }
    } else if (isBinning(bin5)) {
      return isRectBasedMark(mark.type) && !isMidPoint ? 1 : 0.5;
    }
  }
  if ((stack3 === null || stack3 === void 0 ? void 0 : stack3.fieldChannel) === channel && isMidPoint) {
    return 0.5;
  }
  return void 0;
}
function hasBand(channel, fieldDef, fieldDef2, stack3, markDef, config) {
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === "temporal") {
    return !!getBand({ channel, fieldDef, fieldDef2, stack: stack3, markDef, config });
  }
  return false;
}
function isConditionalDef(channelDef) {
  return !!channelDef && "condition" in channelDef;
}
function hasConditionalFieldDef(channelDef) {
  const condition = channelDef && channelDef["condition"];
  return !!condition && !isArray_default(condition) && isFieldDef(condition);
}
function hasConditionalFieldOrDatumDef(channelDef) {
  const condition = channelDef && channelDef["condition"];
  return !!condition && !isArray_default(condition) && isFieldOrDatumDef(condition);
}
function hasConditionalValueDef(channelDef) {
  const condition = channelDef && channelDef["condition"];
  return !!condition && (isArray_default(condition) || isValueDef(condition));
}
function isFieldDef(channelDef) {
  return !!channelDef && (!!channelDef["field"] || channelDef["aggregate"] === "count");
}
function channelDefType(channelDef) {
  return channelDef && channelDef["type"];
}
function isDatumDef(channelDef) {
  return !!channelDef && "datum" in channelDef;
}
function isContinuousFieldOrDatumDef(cd) {
  return isTypedFieldDef(cd) && isContinuous2(cd) || isNumericDataDef(cd);
}
function isNumericDataDef(cd) {
  return isDatumDef(cd) && isNumber_default(cd.datum);
}
function isFieldOrDatumDef(channelDef) {
  return isFieldDef(channelDef) || isDatumDef(channelDef);
}
function isTypedFieldDef(channelDef) {
  return !!channelDef && ("field" in channelDef && "type" in channelDef || channelDef["aggregate"] === "count");
}
function isValueDef(channelDef) {
  return channelDef && "value" in channelDef && "value" in channelDef;
}
function isScaleFieldDef(channelDef) {
  return !!channelDef && ("scale" in channelDef || "sort" in channelDef);
}
function isPositionFieldOrDatumDef(channelDef) {
  return channelDef && ("axis" in channelDef || "stack" in channelDef || "impute" in channelDef);
}
function isMarkPropFieldOrDatumDef(channelDef) {
  return !!channelDef && "legend" in channelDef;
}
function isTextFieldOrDatumDef(channelDef) {
  return !!channelDef && ("format" in channelDef || "formatType" in channelDef);
}
function isOpFieldDef(fieldDef) {
  return "op" in fieldDef;
}
function vgField(fieldDef, opt = {}) {
  var _a2, _b, _c2;
  let field4 = fieldDef.field;
  const prefix = opt.prefix;
  let suffix = opt.suffix;
  let argAccessor = "";
  if (isCount(fieldDef)) {
    field4 = internalField("count");
  } else {
    let fn;
    if (!opt.nofn) {
      if (isOpFieldDef(fieldDef)) {
        fn = fieldDef.op;
      } else {
        const { bin: bin5, aggregate, timeUnit } = fieldDef;
        if (isBinning(bin5)) {
          fn = binToString(bin5);
          suffix = ((_a2 = opt.binSuffix) !== null && _a2 !== void 0 ? _a2 : "") + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : "");
        } else if (aggregate) {
          if (isArgmaxDef(aggregate)) {
            argAccessor = `["${field4}"]`;
            field4 = `argmax_${aggregate.argmax}`;
          } else if (isArgminDef(aggregate)) {
            argAccessor = `["${field4}"]`;
            field4 = `argmin_${aggregate.argmin}`;
          } else {
            fn = String(aggregate);
          }
        } else if (timeUnit) {
          fn = timeUnitToString(timeUnit);
          suffix = (!contains2(["range", "mid"], opt.binSuffix) && opt.binSuffix || "") + ((_c2 = opt.suffix) !== null && _c2 !== void 0 ? _c2 : "");
        }
      }
    }
    if (fn) {
      field4 = field4 ? `${fn}_${field4}` : fn;
    }
  }
  if (suffix) {
    field4 = `${field4}_${suffix}`;
  }
  if (prefix) {
    field4 = `${prefix}_${field4}`;
  }
  if (opt.forAs) {
    return removePathFromField(field4);
  } else if (opt.expr) {
    return flatAccessWithDatum(field4, opt.expr) + argAccessor;
  } else {
    return replacePathInField(field4) + argAccessor;
  }
}
function isDiscrete3(def3) {
  switch (def3.type) {
    case "nominal":
    case "ordinal":
    case "geojson":
      return true;
    case "quantitative":
      return isFieldDef(def3) && !!def3.bin;
    case "temporal":
      return false;
  }
  throw new Error(message_exports.invalidFieldType(def3.type));
}
function isContinuous2(fieldDef) {
  return !isDiscrete3(fieldDef);
}
function isCount(fieldDef) {
  return fieldDef.aggregate === "count";
}
function verbalTitleFormatter(fieldDef, config) {
  var _a2;
  const { field: field4, bin: bin5, timeUnit, aggregate } = fieldDef;
  if (aggregate === "count") {
    return config.countTitle;
  } else if (isBinning(bin5)) {
    return `${field4} (binned)`;
  } else if (timeUnit) {
    const unit3 = (_a2 = normalizeTimeUnit(timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit;
    if (unit3) {
      return `${field4} (${getTimeUnitParts(unit3).join("-")})`;
    }
  } else if (aggregate) {
    if (isArgmaxDef(aggregate)) {
      return `${field4} for max ${aggregate.argmax}`;
    } else if (isArgminDef(aggregate)) {
      return `${field4} for min ${aggregate.argmin}`;
    } else {
      return `${titleCase(aggregate)} of ${field4}`;
    }
  }
  return field4;
}
function functionalTitleFormatter(fieldDef) {
  const { aggregate, bin: bin5, timeUnit, field: field4 } = fieldDef;
  if (isArgmaxDef(aggregate)) {
    return `${field4} for argmax(${aggregate.argmax})`;
  } else if (isArgminDef(aggregate)) {
    return `${field4} for argmin(${aggregate.argmin})`;
  }
  const timeUnitParams = normalizeTimeUnit(timeUnit);
  const fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && "timeunit" || isBinning(bin5) && "bin";
  if (fn) {
    return fn.toUpperCase() + "(" + field4 + ")";
  } else {
    return field4;
  }
}
function setTitleFormatter(formatter) {
  titleFormatter = formatter;
}
function resetTitleFormatter() {
  setTitleFormatter(defaultTitleFormatter);
}
function title(fieldOrDatumDef, config, { allowDisabling, includeDefault = true }) {
  var _a2, _b;
  const guide = (_a2 = getGuide(fieldOrDatumDef)) !== null && _a2 !== void 0 ? _a2 : {};
  const guideTitle = guide.title;
  if (!isFieldDef(fieldOrDatumDef)) {
    return guideTitle;
  }
  const fieldDef = fieldOrDatumDef;
  const def3 = includeDefault ? defaultTitle(fieldDef, config) : void 0;
  if (allowDisabling) {
    return getFirstDefined(guideTitle, fieldDef.title, def3);
  } else {
    return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def3;
  }
}
function getGuide(fieldDef) {
  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {
    return fieldDef.axis;
  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {
    return fieldDef.legend;
  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {
    return fieldDef.header;
  }
  return void 0;
}
function defaultTitle(fieldDef, config) {
  return titleFormatter(fieldDef, config);
}
function getFormatMixins(fieldDef) {
  var _a2;
  if (isTextFieldOrDatumDef(fieldDef)) {
    const { format: format9, formatType } = fieldDef;
    return { format: format9, formatType };
  } else {
    const guide = (_a2 = getGuide(fieldDef)) !== null && _a2 !== void 0 ? _a2 : {};
    const { format: format9, formatType } = guide;
    return { format: format9, formatType };
  }
}
function defaultType(fieldDef, channel) {
  if (fieldDef.timeUnit) {
    return "temporal";
  }
  if (isBinning(fieldDef.bin)) {
    return "quantitative";
  }
  switch (rangeType(channel)) {
    case "continuous":
      return "quantitative";
    case "discrete":
      return "nominal";
    case "flexible":
      return "nominal";
    default:
      return "quantitative";
  }
}
function getFieldDef(channelDef) {
  if (isFieldDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function getFieldOrDatumDef(channelDef) {
  if (isFieldOrDatumDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function initChannelDef(channelDef, channel, config) {
  if (isString_default(channelDef) || isNumber_default(channelDef) || isBoolean_default(channelDef)) {
    const primitiveType = isString_default(channelDef) ? "string" : isNumber_default(channelDef) ? "number" : "boolean";
    warn2(message_exports.primitiveChannelDef(channel, primitiveType, channelDef));
    return { value: channelDef };
  }
  if (isFieldOrDatumDef(channelDef)) {
    return initFieldOrDatumDef(channelDef, channel, config);
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return Object.assign(Object.assign({}, channelDef), {
      condition: initFieldOrDatumDef(channelDef.condition, channel, config)
    });
  }
  return channelDef;
}
function initFieldOrDatumDef(fd, channel, config) {
  if (isTextFieldOrDatumDef(fd)) {
    const { format: format9, formatType } = fd, rest = __rest(fd, ["format", "formatType"]);
    if (isCustomFormatType(formatType) && !config.customFormatTypes) {
      warn2(message_exports.customFormatTypeNotAllowed(channel));
      return initFieldOrDatumDef(rest, channel, config);
    }
  } else {
    const guideType = isPositionFieldOrDatumDef(fd) ? "axis" : isMarkPropFieldOrDatumDef(fd) ? "legend" : isFacetFieldDef(fd) ? "header" : null;
    if (guideType && fd[guideType]) {
      const _a2 = fd[guideType], { format: format9, formatType } = _a2, newGuide = __rest(_a2, ["format", "formatType"]);
      if (isCustomFormatType(formatType) && !config.customFormatTypes) {
        warn2(message_exports.customFormatTypeNotAllowed(channel));
        return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), { [guideType]: newGuide }), channel, config);
      }
    }
  }
  if (isFieldDef(fd)) {
    return initFieldDef(fd, channel);
  }
  return initDatumDef(fd);
}
function initDatumDef(datumDef) {
  let type4 = datumDef["type"];
  if (type4) {
    return datumDef;
  }
  const { datum: datum2 } = datumDef;
  type4 = isNumber_default(datum2) ? "quantitative" : isString_default(datum2) ? "nominal" : isDateTime(datum2) ? "temporal" : void 0;
  return Object.assign(Object.assign({}, datumDef), { type: type4 });
}
function initFieldDef(fd, channel) {
  const { aggregate, timeUnit, bin: bin5, field: field4 } = fd;
  const fieldDef = Object.assign({}, fd);
  if (aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
    warn2(message_exports.invalidAggregate(aggregate));
    delete fieldDef.aggregate;
  }
  if (timeUnit) {
    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);
  }
  if (field4) {
    fieldDef.field = `${field4}`;
  }
  if (isBinning(bin5)) {
    fieldDef.bin = normalizeBin(bin5, channel);
  }
  if (isBinned(bin5) && !isXorY(channel)) {
    warn2(`Channel ${channel} should not be used with "binned" bin.`);
  }
  if (isTypedFieldDef(fieldDef)) {
    const { type: type4 } = fieldDef;
    const fullType = getFullName(type4);
    if (type4 !== fullType) {
      fieldDef.type = fullType;
    }
    if (type4 !== "quantitative") {
      if (isCountingAggregateOp(aggregate)) {
        warn2(message_exports.invalidFieldTypeForCountAggregate(type4, aggregate));
        fieldDef.type = "quantitative";
      }
    }
  } else if (!isSecondaryRangeChannel(channel)) {
    const newType = defaultType(fieldDef, channel);
    warn2(message_exports.missingFieldType(channel, newType));
    fieldDef["type"] = newType;
  }
  if (isTypedFieldDef(fieldDef)) {
    const { compatible, warning } = channelCompatibility(fieldDef, channel);
    if (!compatible) {
      warn2(warning);
    }
  }
  if (isSortableFieldDef(fieldDef) && isString_default(fieldDef.sort)) {
    const { sort: sort5 } = fieldDef;
    if (isSortByChannel(sort5)) {
      return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sort5 } });
    }
    const sub = sort5.substr(1);
    if (sort5.charAt(0) === "-" && isSortByChannel(sub)) {
      return Object.assign(Object.assign({}, fieldDef), { sort: { encoding: sub, order: "descending" } });
    }
  }
  if (isFacetFieldDef(fieldDef)) {
    const { header } = fieldDef;
    const { orient: orient3 } = header, rest = __rest(header, ["orient"]);
    if (orient3) {
      return Object.assign(Object.assign({}, fieldDef), { header: Object.assign(Object.assign({}, rest), { labelOrient: header.labelOrient || orient3, titleOrient: header.titleOrient || orient3 }) });
    }
  }
  return fieldDef;
}
function normalizeBin(bin5, channel) {
  if (isBoolean_default(bin5)) {
    return { maxbins: autoMaxBins(channel) };
  } else if (bin5 === "binned") {
    return {
      binned: true
    };
  } else if (!bin5.maxbins && !bin5.step) {
    return Object.assign(Object.assign({}, bin5), { maxbins: autoMaxBins(channel) });
  } else {
    return bin5;
  }
}
function channelCompatibility(fieldDef, channel) {
  const type4 = fieldDef.type;
  if (type4 === "geojson" && channel !== "shape") {
    return {
      compatible: false,
      warning: `Channel ${channel} should not be used with a geojson data.`
    };
  }
  switch (channel) {
    case ROW:
    case COLUMN:
    case FACET:
      if (isContinuous2(fieldDef)) {
        return {
          compatible: false,
          warning: message_exports.facetChannelShouldBeDiscrete(channel)
        };
      }
      return COMPATIBLE;
    case X3:
    case Y3:
    case COLOR:
    case FILL:
    case STROKE:
    case TEXT2:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case URL2:
    case ANGLE:
    case THETA:
    case RADIUS:
    case DESCRIPTION:
      return COMPATIBLE;
    case LONGITUDE:
    case LONGITUDE2:
    case LATITUDE:
    case LATITUDE2:
      if (type4 !== QUANTITATIVE) {
        return {
          compatible: false,
          warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`
        };
      }
      return COMPATIBLE;
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    case SIZE2:
    case THETA2:
    case RADIUS2:
    case X23:
    case Y23:
      if (type4 === "nominal" && !fieldDef["sort"]) {
        return {
          compatible: false,
          warning: `Channel ${channel} should not be used with an unsorted discrete field.`
        };
      }
      return COMPATIBLE;
    case STROKEDASH:
      if (!contains2(["ordinal", "nominal"], fieldDef.type)) {
        return {
          compatible: false,
          warning: "StrokeDash channel should be used with only discrete data."
        };
      }
      return COMPATIBLE;
    case SHAPE:
      if (!contains2(["ordinal", "nominal", "geojson"], fieldDef.type)) {
        return {
          compatible: false,
          warning: "Shape channel should be used with only either discrete or geojson data."
        };
      }
      return COMPATIBLE;
    case ORDER:
      if (fieldDef.type === "nominal" && !("sort" in fieldDef)) {
        return {
          compatible: false,
          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`
        };
      }
      return COMPATIBLE;
  }
}
function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {
  const { formatType } = getFormatMixins(fieldOrDatumDef);
  return formatType === "time" || !formatType && isTimeFieldDef(fieldOrDatumDef);
}
function isTimeFieldDef(def3) {
  return def3 && (def3["type"] === "temporal" || isFieldDef(def3) && !!def3.timeUnit);
}
function valueExpr(v, { timeUnit, type: type4, wrapTime, undefinedIfExprNotRequired }) {
  var _a2;
  const unit3 = timeUnit && ((_a2 = normalizeTimeUnit(timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit);
  let isTime = unit3 || type4 === "temporal";
  let expr2;
  if (isSignalRef(v)) {
    expr2 = v.signal;
  } else if (isDateTime(v)) {
    isTime = true;
    expr2 = dateTimeToExpr(v);
  } else if (isString_default(v) || isNumber_default(v)) {
    if (isTime) {
      expr2 = `datetime(${JSON.stringify(v)})`;
      if (isLocalSingleTimeUnit(unit3)) {
        if (isNumber_default(v) && v < 1e4 || isString_default(v) && isNaN(Date.parse(v))) {
          expr2 = dateTimeToExpr({ [unit3]: v });
        }
      }
    }
  }
  if (expr2) {
    return wrapTime && isTime ? `time(${expr2})` : expr2;
  }
  return undefinedIfExprNotRequired ? void 0 : JSON.stringify(v);
}
function valueArray(fieldOrDatumDef, values5) {
  const { type: type4 } = fieldOrDatumDef;
  return values5.map((v) => {
    const expr2 = valueExpr(v, {
      timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : void 0,
      type: type4,
      undefinedIfExprNotRequired: true
    });
    if (expr2 !== void 0) {
      return { signal: expr2 };
    }
    return v;
  });
}
function binRequiresRange(fieldDef, channel) {
  if (!isBinning(fieldDef.bin)) {
    console.warn("Only call this method for binned field defs.");
    return false;
  }
  return isScaleChannel(channel) && contains2(["ordinal", "nominal"], fieldDef.type);
}
var defaultTitleFormatter, titleFormatter, COMPATIBLE;
var init_channeldef = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/channeldef.js"() {
    init_tslib_es6();
    init_vega_util();
    init_aggregate();
    init_bin4();
    init_channel();
    init_common();
    init_format();
    init_datetime();
    init_log3();
    init_mark();
    init_sort5();
    init_facet();
    init_timeunit();
    init_type();
    init_util();
    init_vega_schema();
    defaultTitleFormatter = (fieldDef, config) => {
      switch (config.fieldTitle) {
        case "plain":
          return fieldDef.field;
        case "functional":
          return functionalTitleFormatter(fieldDef);
        default:
          return verbalTitleFormatter(fieldDef, config);
      }
    };
    titleFormatter = defaultTitleFormatter;
    COMPATIBLE = { compatible: true };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/title.js
function extractTitleConfig(titleConfig) {
  const {
    anchor,
    frame: frame2,
    offset: offset5,
    orient: orient3,
    color: color7,
    subtitleColor,
    subtitleFont,
    subtitleFontSize,
    subtitleFontStyle,
    subtitleFontWeight,
    subtitleLineHeight,
    subtitlePadding
  } = titleConfig, rest = __rest(titleConfig, ["anchor", "frame", "offset", "orient", "color", "subtitleColor", "subtitleFont", "subtitleFontSize", "subtitleFontStyle", "subtitleFontWeight", "subtitleLineHeight", "subtitlePadding"]);
  const titleMarkConfig = Object.assign(Object.assign({}, rest), color7 ? { fill: color7 } : {});
  const nonMark = Object.assign(Object.assign(Object.assign(Object.assign({}, anchor ? { anchor } : {}), frame2 ? { frame: frame2 } : {}), offset5 ? { offset: offset5 } : {}), orient3 ? { orient: orient3 } : {});
  const subtitle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, subtitleColor ? { subtitleColor } : {}), subtitleFont ? { subtitleFont } : {}), subtitleFontSize ? { subtitleFontSize } : {}), subtitleFontStyle ? { subtitleFontStyle } : {}), subtitleFontWeight ? { subtitleFontWeight } : {}), subtitleLineHeight ? { subtitleLineHeight } : {}), subtitlePadding ? { subtitlePadding } : {});
  const subtitleMarkConfig = pick3(titleMarkConfig, ["align", "baseline", "dx", "dy", "limit"]);
  return { titleMarkConfig, subtitleMarkConfig, nonMark, subtitle };
}
function isText(v) {
  return isString_default(v) || isArray_default(v) && isString_default(v[0]);
}
var init_title = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/title.js"() {
    init_tslib_es6();
    init_vega_util();
    init_util();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/common.js
function signalOrValueRef(value4) {
  if (isSignalRef(value4)) {
    return value4;
  }
  return value4 !== void 0 ? { value: value4 } : void 0;
}
function exprFromValueOrSignalRef(ref2) {
  if (isSignalRef(ref2)) {
    return ref2.signal;
  }
  return $3(ref2.value);
}
function signalOrStringValue(v) {
  if (isSignalRef(v)) {
    return v.signal;
  }
  return v == null ? null : $3(v);
}
function applyMarkConfig(e3, model, propsList) {
  for (const property2 of propsList) {
    const value4 = getMarkConfig(property2, model.markDef, model.config);
    if (value4 !== void 0) {
      e3[property2] = signalOrValueRef(value4);
    }
  }
  return e3;
}
function getStyles(mark) {
  var _a2;
  return [].concat(mark.type, (_a2 = mark.style) !== null && _a2 !== void 0 ? _a2 : []);
}
function getMarkPropOrConfig(channel, mark, config, opt = {}) {
  const { vgChannel, ignoreVgConfig } = opt;
  if (vgChannel && mark[vgChannel] !== void 0) {
    return mark[vgChannel];
  } else if (mark[channel] !== void 0) {
    return mark[channel];
  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {
    return void 0;
  }
  return getMarkConfig(channel, mark, config, opt);
}
function getMarkConfig(channel, mark, config, { vgChannel } = {}) {
  return getFirstDefined(
    vgChannel ? getMarkStyleConfig(channel, mark, config.style) : void 0,
    getMarkStyleConfig(channel, mark, config.style),
    vgChannel ? config[mark.type][vgChannel] : void 0,
    config[mark.type][channel],
    vgChannel ? config.mark[vgChannel] : config.mark[channel]
  );
}
function getMarkStyleConfig(prop, mark, styleConfigIndex) {
  return getStyleConfig(prop, getStyles(mark), styleConfigIndex);
}
function getStyleConfig(p, styles2, styleConfigIndex) {
  styles2 = array_default6(styles2);
  let value4;
  for (const style3 of styles2) {
    const styleConfig = styleConfigIndex[style3];
    if (styleConfig && styleConfig[p] !== void 0) {
      value4 = styleConfig[p];
    }
  }
  return value4;
}
function sortParams(orderDef, fieldRefOption) {
  return array_default6(orderDef).reduce((s3, orderChannelDef) => {
    var _a2;
    s3.field.push(vgField(orderChannelDef, fieldRefOption));
    s3.order.push((_a2 = orderChannelDef.sort) !== null && _a2 !== void 0 ? _a2 : "ascending");
    return s3;
  }, { field: [], order: [] });
}
function mergeTitleFieldDefs(f1, f2) {
  const merged = [...f1];
  f2.forEach((fdToMerge) => {
    for (const fieldDef1 of merged) {
      if (deepEqual(fieldDef1, fdToMerge)) {
        return;
      }
    }
    merged.push(fdToMerge);
  });
  return merged;
}
function mergeTitle(title1, title2) {
  if (deepEqual(title1, title2) || !title2) {
    return title1;
  } else if (!title1) {
    return title2;
  } else {
    return [...array_default6(title1), ...array_default6(title2)].join(", ");
  }
}
function mergeTitleComponent(v1, v2) {
  const v1Val = v1.value;
  const v2Val = v2.value;
  if (v1Val == null || v2Val === null) {
    return {
      explicit: v1.explicit,
      value: null
    };
  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {
    return {
      explicit: v1.explicit,
      value: mergeTitle(v1Val, v2Val)
    };
  } else if (isText(v1Val) || isSignalRef(v1Val)) {
    return {
      explicit: v1.explicit,
      value: v1Val
    };
  } else if (isText(v2Val) || isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: v2Val
    };
  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: mergeTitleFieldDefs(v1Val, v2Val)
    };
  }
  throw new Error("It should never reach here");
}
var init_common = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/common.js"() {
    init_vega_util();
    init_channeldef();
    init_title();
    init_util();
    init_vega_schema();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/encoding.js
function channelHasField(encoding, channel) {
  const channelDef = encoding && encoding[channel];
  if (channelDef) {
    if (isArray_default(channelDef)) {
      return some4(channelDef, (fieldDef) => !!fieldDef.field);
    } else {
      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);
    }
  }
  return false;
}
function isAggregate(encoding) {
  return some4(CHANNELS, (channel) => {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      if (isArray_default(channelDef)) {
        return some4(channelDef, (fieldDef) => !!fieldDef.aggregate);
      } else {
        const fieldDef = getFieldDef(channelDef);
        return fieldDef && !!fieldDef.aggregate;
      }
    }
    return false;
  });
}
function extractTransformsFromEncoding(oldEncoding, config) {
  const groupby = [];
  const bins2 = [];
  const timeUnits2 = [];
  const aggregate = [];
  const encoding = {};
  forEach(oldEncoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      const { field: field4, aggregate: aggOp, bin: bin5, timeUnit } = channelDef, remaining = __rest(channelDef, ["field", "aggregate", "bin", "timeUnit"]);
      if (aggOp || timeUnit || bin5) {
        const guide = getGuide(channelDef);
        const isTitleDefined = guide && guide.title;
        let newField = vgField(channelDef, { forAs: true });
        const newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : { title: title(channelDef, config, { allowDisabling: true }) }), remaining), {
          field: newField
        });
        if (aggOp) {
          let op;
          if (isArgmaxDef(aggOp)) {
            op = "argmax";
            newField = vgField({ op: "argmax", field: aggOp.argmax }, { forAs: true });
            newFieldDef.field = `${newField}.${field4}`;
          } else if (isArgminDef(aggOp)) {
            op = "argmin";
            newField = vgField({ op: "argmin", field: aggOp.argmin }, { forAs: true });
            newFieldDef.field = `${newField}.${field4}`;
          } else if (aggOp !== "boxplot" && aggOp !== "errorbar" && aggOp !== "errorband") {
            op = aggOp;
          }
          if (op) {
            const aggregateEntry = {
              op,
              as: newField
            };
            if (field4) {
              aggregateEntry.field = field4;
            }
            aggregate.push(aggregateEntry);
          }
        } else {
          groupby.push(newField);
          if (isTypedFieldDef(channelDef) && isBinning(bin5)) {
            bins2.push({ bin: bin5, field: field4, as: newField });
            groupby.push(vgField(channelDef, { binSuffix: "end" }));
            if (binRequiresRange(channelDef, channel)) {
              groupby.push(vgField(channelDef, { binSuffix: "range" }));
            }
            if (isXorY(channel)) {
              const secondaryChannel = {
                field: newField + "_end"
              };
              encoding[channel + "2"] = secondaryChannel;
            }
            newFieldDef.bin = "binned";
            if (!isSecondaryRangeChannel(channel)) {
              newFieldDef["type"] = QUANTITATIVE;
            }
          } else if (timeUnit) {
            timeUnits2.push({
              timeUnit,
              field: field4,
              as: newField
            });
            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && "time";
            if (formatType) {
              if (channel === TEXT2 || channel === TOOLTIP) {
                newFieldDef["formatType"] = formatType;
              } else if (isNonPositionScaleChannel(channel)) {
                newFieldDef["legend"] = Object.assign({ formatType }, newFieldDef["legend"]);
              } else if (isXorY(channel)) {
                newFieldDef["axis"] = Object.assign({ formatType }, newFieldDef["axis"]);
              }
            }
          }
        }
        encoding[channel] = newFieldDef;
      } else {
        groupby.push(field4);
        encoding[channel] = oldEncoding[channel];
      }
    } else {
      encoding[channel] = oldEncoding[channel];
    }
  });
  return {
    bins: bins2,
    timeUnits: timeUnits2,
    aggregate,
    groupby,
    encoding
  };
}
function markChannelCompatible(encoding, channel, mark) {
  const markSupported = supportMark(channel, mark);
  if (!markSupported) {
    return false;
  } else if (markSupported === "binned") {
    const primaryFieldDef = encoding[channel === X23 ? X3 : Y3];
    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {
      return true;
    } else {
      return false;
    }
  }
  return true;
}
function initEncoding(encoding, markDef, config) {
  const mark = markDef.type;
  return keys4(encoding).reduce((normalizedEncoding, channel) => {
    if (!isChannel(channel)) {
      warn2(message_exports.invalidEncodingChannel(channel));
      return normalizedEncoding;
    }
    const channelDef = encoding[channel];
    if (channel === "angle" && mark === "arc" && !encoding.theta) {
      warn2(message_exports.REPLACE_ANGLE_WITH_THETA);
      channel = THETA;
    }
    if (!markChannelCompatible(encoding, channel, mark)) {
      warn2(message_exports.incompatibleChannel(channel, mark));
      return normalizedEncoding;
    }
    if (channel === SIZE2 && mark === "line") {
      const fieldDef = getFieldDef(encoding[channel]);
      if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.aggregate) {
        warn2(message_exports.LINE_WITH_VARYING_SIZE);
        return normalizedEncoding;
      }
    }
    if (channel === COLOR && (markDef.filled ? "fill" in encoding : "stroke" in encoding)) {
      warn2(message_exports.droppingColor("encoding", { fill: "fill" in encoding, stroke: "stroke" in encoding }));
      return normalizedEncoding;
    }
    if (channel === DETAIL || channel === ORDER && !isArray_default(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray_default(channelDef)) {
      if (channelDef) {
        normalizedEncoding[channel] = array_default6(channelDef).reduce((defs, fieldDef) => {
          if (!isFieldDef(fieldDef)) {
            warn2(message_exports.emptyFieldDef(fieldDef, channel));
          } else {
            defs.push(initFieldDef(fieldDef, channel));
          }
          return defs;
        }, []);
      }
    } else {
      if (channel === TOOLTIP && channelDef === null) {
        normalizedEncoding[channel] = null;
      } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {
        warn2(message_exports.emptyFieldDef(channelDef, channel));
        return normalizedEncoding;
      }
      normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);
    }
    return normalizedEncoding;
  }, {});
}
function fieldDefs(encoding) {
  const arr = [];
  for (const channel of keys4(encoding)) {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      const channelDefArray = array_default6(channelDef);
      for (const def3 of channelDefArray) {
        if (isFieldDef(def3)) {
          arr.push(def3);
        } else if (hasConditionalFieldDef(def3)) {
          arr.push(def3.condition);
        }
      }
    }
  }
  return arr;
}
function forEach(mapping, f, thisArg) {
  if (!mapping) {
    return;
  }
  for (const channel of keys4(mapping)) {
    const el = mapping[channel];
    if (isArray_default(el)) {
      for (const channelDef of el) {
        f.call(thisArg, channelDef, channel);
      }
    } else {
      f.call(thisArg, el, channel);
    }
  }
}
function reduce4(mapping, f, init2, thisArg) {
  if (!mapping) {
    return init2;
  }
  return keys4(mapping).reduce((r2, channel) => {
    const map11 = mapping[channel];
    if (isArray_default(map11)) {
      return map11.reduce((r1, channelDef) => {
        return f.call(thisArg, r1, channelDef, channel);
      }, r2);
    } else {
      return f.call(thisArg, r2, map11, channel);
    }
  }, init2);
}
function pathGroupingFields(mark, encoding) {
  return keys4(encoding).reduce((details, channel) => {
    switch (channel) {
      case X3:
      case Y3:
      case HREF:
      case DESCRIPTION:
      case URL2:
      case X23:
      case Y23:
      case THETA:
      case THETA2:
      case RADIUS:
      case RADIUS2:
      case LATITUDE:
      case LONGITUDE:
      case LATITUDE2:
      case LONGITUDE2:
      case TEXT2:
      case SHAPE:
      case ANGLE:
      case TOOLTIP:
        return details;
      case ORDER:
        if (mark === "line" || mark === "trail") {
          return details;
        }
      case DETAIL:
      case KEY: {
        const channelDef = encoding[channel];
        if (isArray_default(channelDef) || isFieldDef(channelDef)) {
          for (const fieldDef of array_default6(channelDef)) {
            if (!fieldDef.aggregate) {
              details.push(vgField(fieldDef, {}));
            }
          }
        }
        return details;
      }
      case SIZE2:
        if (mark === "trail") {
          return details;
        }
      case COLOR:
      case FILL:
      case STROKE:
      case OPACITY:
      case FILLOPACITY:
      case STROKEOPACITY:
      case STROKEDASH:
      case STROKEWIDTH: {
        const fieldDef = getFieldDef(encoding[channel]);
        if (fieldDef && !fieldDef.aggregate) {
          details.push(vgField(fieldDef, {}));
        }
        return details;
      }
    }
  }, []);
}
var init_encoding = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/encoding.js"() {
    init_tslib_es6();
    init_vega_util();
    init_aggregate();
    init_bin4();
    init_channel();
    init_channeldef();
    init_log3();
    init_type();
    init_util();
    init_vega_schema();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/common.js
function filterTooltipWithAggregatedField(oldEncoding) {
  const { tooltip: tooltip2 } = oldEncoding, filteredEncoding = __rest(oldEncoding, ["tooltip"]);
  if (!tooltip2) {
    return { filteredEncoding: oldEncoding };
  }
  let customTooltipWithAggregatedField;
  let customTooltipWithoutAggregatedField;
  if (isArray_default(tooltip2)) {
    for (const t of tooltip2) {
      if (t.aggregate) {
        if (!customTooltipWithAggregatedField) {
          customTooltipWithAggregatedField = [];
        }
        customTooltipWithAggregatedField.push(t);
      } else {
        if (!customTooltipWithoutAggregatedField) {
          customTooltipWithoutAggregatedField = [];
        }
        customTooltipWithoutAggregatedField.push(t);
      }
    }
    if (customTooltipWithAggregatedField) {
      filteredEncoding.tooltip = customTooltipWithAggregatedField;
    }
  } else {
    if (tooltip2["aggregate"]) {
      filteredEncoding.tooltip = tooltip2;
    } else {
      customTooltipWithoutAggregatedField = tooltip2;
    }
  }
  if (isArray_default(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {
    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];
  }
  return { customTooltipWithoutAggregatedField, filteredEncoding };
}
function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {
  if ("tooltip" in encodingWithoutContinuousAxis) {
    return { tooltip: encodingWithoutContinuousAxis.tooltip };
  }
  const fiveSummaryTooltip = tooltipSummary.map(({ fieldPrefix, titlePrefix }) => {
    const mainTitle = withFieldName ? ` of ${continuousAxisChannelDef.field}` : "";
    return {
      field: fieldPrefix + continuousAxisChannelDef.field,
      type: continuousAxisChannelDef.type,
      title: isSignalRef(titlePrefix) ? { signal: titlePrefix + `"${escape(mainTitle)}"` } : titlePrefix + mainTitle
    };
  });
  return {
    tooltip: [
      ...fiveSummaryTooltip,
      ...fieldDefs(encodingWithoutContinuousAxis)
    ]
  };
}
function getTitle(continuousAxisChannelDef) {
  const { axis, title: title2, field: field4 } = continuousAxisChannelDef;
  return axis && axis.title !== void 0 ? void 0 : getFirstDefined(title2, field4);
}
function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {
  const { scale: scale8, axis } = continuousAxisChannelDef;
  return ({ partName, mark, positionPrefix, endPositionPrefix = void 0, aria: aria2, extraEncoding = {} }) => {
    const title2 = getTitle(continuousAxisChannelDef);
    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, aria2, {
      mark,
      encoding: Object.assign(Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: positionPrefix + "_" + continuousAxisChannelDef.field, type: continuousAxisChannelDef.type }, title2 !== void 0 ? { title: title2 } : {}), scale8 !== void 0 ? { scale: scale8 } : {}), axis !== void 0 ? { axis } : {}) }, isString_default(endPositionPrefix) ? {
        [continuousAxis + "2"]: {
          field: endPositionPrefix + "_" + continuousAxisChannelDef.field
        }
      } : {}), sharedEncoding), extraEncoding)
    });
  };
}
function partLayerMixins(markDef, part, compositeMarkConfig, aria2, partBaseSpec) {
  const { clip: clip4, color: color7, opacity: opacity2 } = markDef;
  const mark = markDef.type;
  if (markDef[part] || markDef[part] === void 0 && compositeMarkConfig[part]) {
    return [
      Object.assign(Object.assign({}, partBaseSpec), { mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip4 ? { clip: clip4 } : {}), color7 ? { color: color7 } : {}), opacity2 ? { opacity: opacity2 } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : { type: partBaseSpec.mark }), { style: `${mark}-${part}` }), isBoolean_default(markDef[part]) ? {} : markDef[part]), aria2 === false ? { aria: aria2 } : {}) })
    ];
  }
  return [];
}
function compositeMarkContinuousAxis(spec, orient3, compositeMark) {
  const { encoding } = spec;
  const continuousAxis = orient3 === "vertical" ? "y" : "x";
  const continuousAxisChannelDef = encoding[continuousAxis];
  const continuousAxisChannelDef2 = encoding[continuousAxis + "2"];
  const continuousAxisChannelDefError = encoding[continuousAxis + "Error"];
  const continuousAxisChannelDefError2 = encoding[continuousAxis + "Error2"];
  return {
    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),
    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),
    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),
    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),
    continuousAxis
  };
}
function filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {
  if (continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {
    const { aggregate } = continuousAxisChannelDef, continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, ["aggregate"]);
    if (aggregate !== compositeMark) {
      warn2(message_exports.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));
    }
    return continuousAxisWithoutAggregate;
  } else {
    return continuousAxisChannelDef;
  }
}
function compositeMarkOrient(spec, compositeMark) {
  const { mark, encoding } = spec;
  const { x: x7, y: y7 } = encoding;
  if (isContinuousFieldOrDatumDef(x7)) {
    if (isContinuousFieldOrDatumDef(y7)) {
      const xAggregate = isFieldDef(x7) && x7.aggregate;
      const yAggregate = isFieldDef(y7) && y7.aggregate;
      if (!xAggregate && yAggregate === compositeMark) {
        return "vertical";
      } else if (!yAggregate && xAggregate === compositeMark) {
        return "horizontal";
      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {
        throw new Error("Both x and y cannot have aggregate");
      } else {
        if (isMarkDef(mark) && mark.orient) {
          return mark.orient;
        }
        return "vertical";
      }
    }
    return "horizontal";
  } else if (isContinuousFieldOrDatumDef(y7)) {
    return "vertical";
  } else {
    throw new Error("Need a valid continuous axis for " + compositeMark + "s");
  }
}
var init_common2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/common.js"() {
    init_tslib_es6();
    init_vega_util();
    init_channeldef();
    init_encoding();
    init_log3();
    init_mark();
    init_util();
    init_vega_schema();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/boxplot.js
function getBoxPlotType(extent5) {
  if (isNumber_default(extent5)) {
    return "tukey";
  }
  return extent5;
}
function normalizeBoxPlot(spec, { config }) {
  var _a2, _b;
  const { mark, encoding: _encoding, selection: selection2, projection: _p } = spec, outerSpec = __rest(spec, ["mark", "encoding", "selection", "projection"]);
  const markDef = isMarkDef(mark) ? mark : { type: mark };
  if (selection2) {
    warn2(message_exports.selectionNotSupported("boxplot"));
  }
  const extent5 = (_a2 = markDef.extent) !== null && _a2 !== void 0 ? _a2 : config.boxplot.extent;
  const sizeValue = getMarkPropOrConfig(
    "size",
    markDef,
    config
  );
  const boxPlotType = getBoxPlotType(extent5);
  const { transform: transform4, continuousAxisChannelDef, continuousAxis, groupby, aggregate, encodingWithoutContinuousAxis, ticksOrient, boxOrient, customTooltipWithoutAggregatedField } = boxParams(spec, extent5, config);
  const { color: color7, size } = encodingWithoutContinuousAxis, encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, ["color", "size"]);
  const makeBoxPlotPart = (sharedEncoding) => {
    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);
  };
  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);
  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);
  const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? { size } : {}));
  const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([
    { fieldPrefix: boxPlotType === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
    { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
    { fieldPrefix: "mid_box_", titlePrefix: "Median" },
    { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
    { fieldPrefix: boxPlotType === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
  ], continuousAxisChannelDef, encodingWithoutContinuousAxis);
  const endTick = { type: "tick", color: "black", opacity: 1, orient: ticksOrient, invalid: null };
  const whiskerTooltipEncoding = boxPlotType === "min-max" ? fiveSummaryTooltipEncoding : getCompositeMarkTooltip([
    { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
    { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
  ], continuousAxisChannelDef, encodingWithoutContinuousAxis);
  const whiskerLayers = [
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: { type: "rule", invalid: null },
      positionPrefix: "lower_whisker",
      endPositionPrefix: "lower_box",
      aria: false,
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: { type: "rule", invalid: null },
      positionPrefix: "upper_box",
      endPositionPrefix: "upper_whisker",
      aria: false,
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "lower_whisker",
      aria: false,
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "upper_whisker",
      aria: false,
      extraEncoding: whiskerTooltipEncoding
    })
  ];
  const boxLayers = [
    ...boxPlotType !== "tukey" ? whiskerLayers : [],
    ...makeBoxPlotBox({
      partName: "box",
      mark: Object.assign(Object.assign({ type: "bar" }, sizeValue ? { size: sizeValue } : {}), { orient: boxOrient, invalid: null }),
      positionPrefix: "lower_box",
      endPositionPrefix: "upper_box",
      aria: false,
      extraEncoding: fiveSummaryTooltipEncoding
    }),
    ...makeBoxPlotMidTick({
      partName: "median",
      mark: Object.assign(Object.assign(Object.assign({ type: "tick", invalid: null }, isObject_default(config.boxplot.median) && config.boxplot.median.color ? { color: config.boxplot.median.color } : {}), sizeValue ? { size: sizeValue } : {}), { orient: ticksOrient, ariaRoleDescription: "box" }),
      positionPrefix: "mid_box",
      extraEncoding: fiveSummaryTooltipEncoding
    })
  ];
  let filteredLayersMixins;
  if (boxPlotType !== "min-max") {
    const lowerBoxExpr = `datum["lower_box_${continuousAxisChannelDef.field}"]`;
    const upperBoxExpr = `datum["upper_box_${continuousAxisChannelDef.field}"]`;
    const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;
    const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent5} * ${iqrExpr}`;
    const upperWhiskerExpr = `${upperBoxExpr} + ${extent5} * ${iqrExpr}`;
    const fieldExpr2 = `datum["${continuousAxisChannelDef.field}"]`;
    const joinaggregateTransform = {
      joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),
      groupby
    };
    let filteredWhiskerSpec = void 0;
    if (boxPlotType === "tukey") {
      filteredWhiskerSpec = {
        transform: [
          {
            filter: `(${lowerWhiskerExpr} <= ${fieldExpr2}) && (${fieldExpr2} <= ${upperWhiskerExpr})`
          },
          {
            aggregate: [
              {
                op: "min",
                field: continuousAxisChannelDef.field,
                as: "lower_whisker_" + continuousAxisChannelDef.field
              },
              {
                op: "max",
                field: continuousAxisChannelDef.field,
                as: "upper_whisker_" + continuousAxisChannelDef.field
              },
              {
                op: "min",
                field: "lower_box_" + continuousAxisChannelDef.field,
                as: "lower_box_" + continuousAxisChannelDef.field
              },
              {
                op: "max",
                field: "upper_box_" + continuousAxisChannelDef.field,
                as: "upper_box_" + continuousAxisChannelDef.field
              },
              ...aggregate
            ],
            groupby
          }
        ],
        layer: whiskerLayers
      };
    }
    const { tooltip: tooltip2 } = encodingWithoutSizeColorAndContinuousAxis, encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, ["tooltip"]);
    const { scale: scale8, axis } = continuousAxisChannelDef;
    const title2 = getTitle(continuousAxisChannelDef);
    const outlierLayersMixins = partLayerMixins(markDef, "outliers", config.boxplot, true, {
      transform: [{ filter: `(${fieldExpr2} < ${lowerWhiskerExpr}) || (${fieldExpr2} > ${upperWhiskerExpr})` }],
      mark: "point",
      encoding: Object.assign(Object.assign({ [continuousAxis]: Object.assign(Object.assign(Object.assign({ field: continuousAxisChannelDef.field, type: continuousAxisChannelDef.type }, title2 !== void 0 ? { title: title2 } : {}), scale8 !== void 0 ? { scale: scale8 } : {}), axis !== void 0 ? { axis } : {}) }, encodingWithoutSizeColorContinuousAxisAndTooltip), customTooltipWithoutAggregatedField ? { tooltip: customTooltipWithoutAggregatedField } : {})
    })[0];
    if (outlierLayersMixins && filteredWhiskerSpec) {
      filteredLayersMixins = {
        transform: [joinaggregateTransform],
        layer: [outlierLayersMixins, filteredWhiskerSpec]
      };
    } else if (outlierLayersMixins) {
      filteredLayersMixins = outlierLayersMixins;
      filteredLayersMixins.transform.unshift(joinaggregateTransform);
    } else if (filteredWhiskerSpec) {
      filteredLayersMixins = filteredWhiskerSpec;
      filteredLayersMixins.transform.unshift(joinaggregateTransform);
    }
  }
  if (filteredLayersMixins) {
    return Object.assign(Object.assign({}, outerSpec), { layer: [
      filteredLayersMixins,
      {
        transform: transform4,
        layer: boxLayers
      }
    ] });
  }
  return Object.assign(Object.assign({}, outerSpec), { transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform4), layer: boxLayers });
}
function boxParamsQuartiles(continousAxisField) {
  return [
    {
      op: "q1",
      field: continousAxisField,
      as: "lower_box_" + continousAxisField
    },
    {
      op: "q3",
      field: continousAxisField,
      as: "upper_box_" + continousAxisField
    }
  ];
}
function boxParams(spec, extent5, config) {
  const orient3 = compositeMarkOrient(spec, BOXPLOT);
  const { continuousAxisChannelDef, continuousAxis } = compositeMarkContinuousAxis(spec, orient3, BOXPLOT);
  const continuousFieldName = continuousAxisChannelDef.field;
  const boxPlotType = getBoxPlotType(extent5);
  const boxplotSpecificAggregate = [
    ...boxParamsQuartiles(continuousFieldName),
    {
      op: "median",
      field: continuousFieldName,
      as: "mid_box_" + continuousFieldName
    },
    {
      op: "min",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "lower_whisker_" : "min_") + continuousFieldName
    },
    {
      op: "max",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "upper_whisker_" : "max_") + continuousFieldName
    }
  ];
  const postAggregateCalculates = boxPlotType === "min-max" || boxPlotType === "tukey" ? [] : [
    {
      calculate: `datum["upper_box_${continuousFieldName}"] - datum["lower_box_${continuousFieldName}"]`,
      as: "iqr_" + continuousFieldName
    },
    {
      calculate: `min(datum["upper_box_${continuousFieldName}"] + datum["iqr_${continuousFieldName}"] * ${extent5}, datum["max_${continuousFieldName}"])`,
      as: "upper_whisker_" + continuousFieldName
    },
    {
      calculate: `max(datum["lower_box_${continuousFieldName}"] - datum["iqr_${continuousFieldName}"] * ${extent5}, datum["min_${continuousFieldName}"])`,
      as: "lower_whisker_" + continuousFieldName
    }
  ];
  const _a2 = spec.encoding, _b = continuousAxis, oldContinuousAxisChannelDef = _a2[_b], oldEncodingWithoutContinuousAxis = __rest(_a2, [typeof _b === "symbol" ? _b : _b + ""]);
  const { customTooltipWithoutAggregatedField, filteredEncoding } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);
  const { bins: bins2, timeUnits: timeUnits2, aggregate, groupby, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(filteredEncoding, config);
  const ticksOrient = orient3 === "vertical" ? "horizontal" : "vertical";
  const boxOrient = orient3;
  const transform4 = [
    ...bins2,
    ...timeUnits2,
    {
      aggregate: [...aggregate, ...boxplotSpecificAggregate],
      groupby
    },
    ...postAggregateCalculates
  ];
  return {
    transform: transform4,
    groupby,
    aggregate,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient,
    boxOrient,
    customTooltipWithoutAggregatedField
  };
}
var BOXPLOT, BOXPLOT_PARTS, boxPlotNormalizer;
var init_boxplot = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/boxplot.js"() {
    init_tslib_es6();
    init_vega_util();
    init_common();
    init_encoding();
    init_log3();
    init_mark();
    init_base();
    init_common2();
    BOXPLOT = "boxplot";
    BOXPLOT_PARTS = ["box", "median", "outliers", "rule", "ticks"];
    boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/errorbar.js
function normalizeErrorBar(spec, { config }) {
  const { transform: transform4, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAR, config);
  const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);
  const tick2 = { type: "tick", orient: ticksOrient };
  const layer = [
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "lower",
      aria: false,
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "upper",
      aria: false,
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "rule",
      mark: {
        type: "rule",
        ariaRoleDescription: "errorbar"
      },
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    })
  ];
  return Object.assign(Object.assign(Object.assign({}, outerSpec), { transform: transform4 }), layer.length > 1 ? { layer } : Object.assign({}, layer[0]));
}
function errorBarOrientAndInputType(spec, compositeMark) {
  const { encoding } = spec;
  if (errorBarIsInputTypeRaw(encoding)) {
    return {
      orient: compositeMarkOrient(spec, compositeMark),
      inputType: "raw"
    };
  }
  const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);
  const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);
  const x7 = encoding.x;
  const y7 = encoding.y;
  if (isTypeAggregatedUpperLower) {
    if (isTypeAggregatedError) {
      throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);
    }
    const x22 = encoding.x2;
    const y22 = encoding.y2;
    if (isFieldOrDatumDef(x22) && isFieldOrDatumDef(y22)) {
      throw new Error(`${compositeMark} cannot have both x2 and y2`);
    } else if (isFieldOrDatumDef(x22)) {
      if (isContinuousFieldOrDatumDef(x7)) {
        return { orient: "horizontal", inputType: "aggregated-upper-lower" };
      } else {
        throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);
      }
    } else if (isFieldOrDatumDef(y22)) {
      if (isContinuousFieldOrDatumDef(y7)) {
        return { orient: "vertical", inputType: "aggregated-upper-lower" };
      } else {
        throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);
      }
    }
    throw new Error("No ranged axis");
  } else {
    const xError = encoding.xError;
    const xError2 = encoding.xError2;
    const yError = encoding.yError;
    const yError2 = encoding.yError2;
    if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {
      throw new Error(`${compositeMark} cannot have xError2 without xError`);
    }
    if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have yError2 without yError`);
    }
    if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);
    } else if (isFieldOrDatumDef(xError)) {
      if (isContinuousFieldOrDatumDef(x7)) {
        return { orient: "horizontal", inputType: "aggregated-error" };
      } else {
        throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
      }
    } else if (isFieldOrDatumDef(yError)) {
      if (isContinuousFieldOrDatumDef(y7)) {
        return { orient: "vertical", inputType: "aggregated-error" };
      } else {
        throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
      }
    }
    throw new Error("No ranged axis");
  }
}
function errorBarIsInputTypeRaw(encoding) {
  return (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) && !isFieldOrDatumDef(encoding.x2) && !isFieldOrDatumDef(encoding.y2) && !isFieldOrDatumDef(encoding.xError) && !isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(encoding.yError) && !isFieldOrDatumDef(encoding.yError2);
}
function errorBarIsInputTypeAggregatedUpperLower(encoding) {
  return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);
}
function errorBarIsInputTypeAggregatedError(encoding) {
  return isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);
}
function errorBarParams(spec, compositeMark, config) {
  var _a2;
  const { mark, encoding, selection: selection2, projection: _p } = spec, outerSpec = __rest(spec, ["mark", "encoding", "selection", "projection"]);
  const markDef = isMarkDef(mark) ? mark : { type: mark };
  if (selection2) {
    warn2(message_exports.selectionNotSupported(compositeMark));
  }
  const { orient: orient3, inputType } = errorBarOrientAndInputType(spec, compositeMark);
  const { continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, continuousAxis } = compositeMarkContinuousAxis(spec, orient3, compositeMark);
  const { errorBarSpecificAggregate, postAggregateCalculates, tooltipSummary, tooltipTitleWithFieldName } = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);
  const _b = encoding, _c2 = continuousAxis, oldContinuousAxisChannelDef = _b[_c2], _d2 = continuousAxis === "x" ? "x2" : "y2", oldContinuousAxisChannelDef2 = _b[_d2], _e = continuousAxis === "x" ? "xError" : "yError", oldContinuousAxisChannelDefError = _b[_e], _f2 = continuousAxis === "x" ? "xError2" : "yError2", oldContinuousAxisChannelDefError2 = _b[_f2], oldEncodingWithoutContinuousAxis = __rest(_b, [typeof _c2 === "symbol" ? _c2 : _c2 + "", typeof _d2 === "symbol" ? _d2 : _d2 + "", typeof _e === "symbol" ? _e : _e + "", typeof _f2 === "symbol" ? _f2 : _f2 + ""]);
  const { bins: bins2, timeUnits: timeUnits2, aggregate: oldAggregate, groupby: oldGroupBy, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);
  const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];
  const groupby = inputType !== "raw" ? [] : oldGroupBy;
  const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);
  return {
    transform: [
      ...(_a2 = outerSpec.transform) !== null && _a2 !== void 0 ? _a2 : [],
      ...bins2,
      ...timeUnits2,
      ...aggregate.length === 0 ? [] : [{ aggregate, groupby }],
      ...postAggregateCalculates
    ],
    groupby,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient: orient3 === "vertical" ? "horizontal" : "vertical",
    markDef,
    outerSpec,
    tooltipEncoding
  };
}
function errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {
  let errorBarSpecificAggregate = [];
  let postAggregateCalculates = [];
  const continuousFieldName = continuousAxisChannelDef.field;
  let tooltipSummary;
  let tooltipTitleWithFieldName = false;
  if (inputType === "raw") {
    const center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === "iqr" ? "median" : "mean" : config.errorbar.center;
    const extent5 = markDef.extent ? markDef.extent : center === "mean" ? "stderr" : "iqr";
    if (center === "median" !== (extent5 === "iqr")) {
      warn2(message_exports.errorBarCenterIsUsedWithWrongExtent(center, extent5, compositeMark));
    }
    if (extent5 === "stderr" || extent5 === "stdev") {
      errorBarSpecificAggregate = [
        { op: extent5, field: continuousFieldName, as: "extent_" + continuousFieldName },
        { op: center, field: continuousFieldName, as: "center_" + continuousFieldName }
      ];
      postAggregateCalculates = [
        {
          calculate: `datum["center_${continuousFieldName}"] + datum["extent_${continuousFieldName}"]`,
          as: "upper_" + continuousFieldName
        },
        {
          calculate: `datum["center_${continuousFieldName}"] - datum["extent_${continuousFieldName}"]`,
          as: "lower_" + continuousFieldName
        }
      ];
      tooltipSummary = [
        { fieldPrefix: "center_", titlePrefix: titleCase(center) },
        { fieldPrefix: "upper_", titlePrefix: getTitlePrefix(center, extent5, "+") },
        { fieldPrefix: "lower_", titlePrefix: getTitlePrefix(center, extent5, "-") }
      ];
      tooltipTitleWithFieldName = true;
    } else {
      if (markDef.center && markDef.extent) {
        warn2(message_exports.errorBarCenterIsNotNeeded(markDef.extent, compositeMark));
      }
      let centerOp;
      let lowerExtentOp;
      let upperExtentOp;
      if (extent5 === "ci") {
        centerOp = "mean";
        lowerExtentOp = "ci0";
        upperExtentOp = "ci1";
      } else {
        centerOp = "median";
        lowerExtentOp = "q1";
        upperExtentOp = "q3";
      }
      errorBarSpecificAggregate = [
        { op: lowerExtentOp, field: continuousFieldName, as: "lower_" + continuousFieldName },
        { op: upperExtentOp, field: continuousFieldName, as: "upper_" + continuousFieldName },
        { op: centerOp, field: continuousFieldName, as: "center_" + continuousFieldName }
      ];
      tooltipSummary = [
        {
          fieldPrefix: "upper_",
          titlePrefix: title({ field: continuousFieldName, aggregate: upperExtentOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "lower_",
          titlePrefix: title({ field: continuousFieldName, aggregate: lowerExtentOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "center_",
          titlePrefix: title({ field: continuousFieldName, aggregate: centerOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        }
      ];
    }
  } else {
    if (markDef.center || markDef.extent) {
      warn2(message_exports.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));
    }
    if (inputType === "aggregated-upper-lower") {
      tooltipSummary = [];
      postAggregateCalculates = [
        { calculate: `datum["${continuousAxisChannelDef2.field}"]`, as: "upper_" + continuousFieldName },
        { calculate: `datum["${continuousFieldName}"]`, as: "lower_" + continuousFieldName }
      ];
    } else if (inputType === "aggregated-error") {
      tooltipSummary = [{ fieldPrefix: "", titlePrefix: continuousFieldName }];
      postAggregateCalculates = [
        {
          calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError.field}"]`,
          as: "upper_" + continuousFieldName
        }
      ];
      if (continuousAxisChannelDefError2) {
        postAggregateCalculates.push({
          calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError2.field}"]`,
          as: "lower_" + continuousFieldName
        });
      } else {
        postAggregateCalculates.push({
          calculate: `datum["${continuousFieldName}"] - datum["${continuousAxisChannelDefError.field}"]`,
          as: "lower_" + continuousFieldName
        });
      }
    }
    for (const postAggregateCalculate of postAggregateCalculates) {
      tooltipSummary.push({
        fieldPrefix: postAggregateCalculate.as.substring(0, 6),
        titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum["', ""), '"]', "")
      });
    }
  }
  return { postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName };
}
function getTitlePrefix(center, extent5, operation) {
  return titleCase(center) + " " + operation + " " + extent5;
}
var ERRORBAR, ERRORBAR_PARTS, errorBarNormalizer;
var init_errorbar = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/errorbar.js"() {
    init_tslib_es6();
    init_channeldef();
    init_encoding();
    init_log3();
    init_mark();
    init_util();
    init_base();
    init_common2();
    ERRORBAR = "errorbar";
    ERRORBAR_PARTS = ["ticks", "rule"];
    errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/errorband.js
function normalizeErrorBand(spec, { config }) {
  const { transform: transform4, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAND, config);
  const errorBandDef = markDef;
  const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);
  const is2D = spec.encoding.x !== void 0 && spec.encoding.y !== void 0;
  let bandMark = { type: is2D ? "area" : "rect" };
  let bordersMark = { type: is2D ? "line" : "rule" };
  const interpolate4 = Object.assign(Object.assign({}, errorBandDef.interpolate ? { interpolate: errorBandDef.interpolate } : {}), errorBandDef.tension && errorBandDef.interpolate ? { tension: errorBandDef.tension } : {});
  if (is2D) {
    bandMark = Object.assign(Object.assign(Object.assign({}, bandMark), interpolate4), { ariaRoleDescription: "errorband" });
    bordersMark = Object.assign(Object.assign({}, bordersMark), interpolate4);
  } else if (errorBandDef.interpolate) {
    warn2(message_exports.errorBand1DNotSupport("interpolate"));
  } else if (errorBandDef.tension) {
    warn2(message_exports.errorBand1DNotSupport("tension"));
  }
  return Object.assign(Object.assign({}, outerSpec), { transform: transform4, layer: [
    ...makeErrorBandPart({
      partName: "band",
      mark: bandMark,
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBandPart({
      partName: "borders",
      mark: bordersMark,
      positionPrefix: "lower",
      aria: false,
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBandPart({
      partName: "borders",
      mark: bordersMark,
      positionPrefix: "upper",
      aria: false,
      extraEncoding: tooltipEncoding
    })
  ] });
}
var ERRORBAND, ERRORBAND_PARTS, errorBandNormalizer;
var init_errorband = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/errorband.js"() {
    init_log3();
    init_base();
    init_common2();
    init_errorbar();
    ERRORBAND = "errorband";
    ERRORBAND_PARTS = ["band", "borders"];
    errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/index.js
function add6(mark, run2, parts) {
  const normalizer2 = new CompositeMarkNormalizer(mark, run2);
  compositeMarkRegistry[mark] = { normalizer: normalizer2, parts };
}
function getAllCompositeMarks() {
  return keys4(compositeMarkRegistry);
}
var compositeMarkRegistry;
var init_compositemark = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compositemark/index.js"() {
    init_util();
    init_base();
    init_boxplot();
    init_errorband();
    init_errorbar();
    compositeMarkRegistry = {};
    add6(BOXPLOT, normalizeBoxPlot, BOXPLOT_PARTS);
    add6(ERRORBAR, normalizeErrorBar, ERRORBAR_PARTS);
    add6(ERRORBAND, normalizeErrorBand, ERRORBAND_PARTS);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/guide.js
var VL_ONLY_LEGEND_CONFIG;
var init_guide = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/guide.js"() {
    VL_ONLY_LEGEND_CONFIG = [
      "gradientHorizontalMaxLength",
      "gradientHorizontalMinLength",
      "gradientVerticalMaxLength",
      "gradientVerticalMinLength",
      "unselectedOpacity"
    ];
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/legend.js
var LEGEND_SCALE_CHANNELS, SIGNAL_LEGEND_PROP_INDEX, defaultLegendConfig, COMMON_LEGEND_PROPERTY_INDEX, LEGEND_PROPERTIES;
var init_legend = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/legend.js"() {
    init_util();
    LEGEND_SCALE_CHANNELS = [
      "size",
      "shape",
      "fill",
      "stroke",
      "strokeDash",
      "strokeWidth",
      "opacity"
    ];
    SIGNAL_LEGEND_PROP_INDEX = {
      fillColor: {
        part: "legend",
        vgProp: "fill"
      },
      gradientStrokeColor: {
        part: "gradient",
        vgProp: "stroke"
      },
      labelColor: {
        part: "labels",
        vgProp: "fill"
      },
      strokeColor: {
        part: "legend",
        vgProp: "stroke"
      },
      symbolFillColor: {
        part: "symbols",
        vgProp: "fill"
      },
      symbolStrokeColor: {
        part: "symbols",
        vgProp: "stroke"
      },
      titleColor: {
        part: "title",
        vgProp: "fill"
      }
    };
    defaultLegendConfig = {
      gradientHorizontalMaxLength: 200,
      gradientHorizontalMinLength: 100,
      gradientVerticalMaxLength: 200,
      gradientVerticalMinLength: 64,
      unselectedOpacity: 0.35
    };
    COMMON_LEGEND_PROPERTY_INDEX = {
      aria: 1,
      clipHeight: 1,
      columnPadding: 1,
      columns: 1,
      cornerRadius: 1,
      description: 1,
      direction: 1,
      fillColor: 1,
      format: 1,
      formatType: 1,
      gradientLength: 1,
      gradientOpacity: 1,
      gradientStrokeColor: 1,
      gradientStrokeWidth: 1,
      gradientThickness: 1,
      gridAlign: 1,
      labelAlign: 1,
      labelBaseline: 1,
      labelColor: 1,
      labelFont: 1,
      labelFontSize: 1,
      labelFontStyle: 1,
      labelFontWeight: 1,
      labelLimit: 1,
      labelOffset: 1,
      labelOpacity: 1,
      labelOverlap: 1,
      labelPadding: 1,
      labelSeparation: 1,
      legendX: 1,
      legendY: 1,
      offset: 1,
      orient: 1,
      padding: 1,
      rowPadding: 1,
      strokeColor: 1,
      symbolDash: 1,
      symbolDashOffset: 1,
      symbolFillColor: 1,
      symbolLimit: 1,
      symbolOffset: 1,
      symbolOpacity: 1,
      symbolSize: 1,
      symbolStrokeColor: 1,
      symbolStrokeWidth: 1,
      symbolType: 1,
      tickCount: 1,
      tickMinStep: 1,
      title: 1,
      titleAlign: 1,
      titleAnchor: 1,
      titleBaseline: 1,
      titleColor: 1,
      titleFont: 1,
      titleFontSize: 1,
      titleFontStyle: 1,
      titleFontWeight: 1,
      titleLimit: 1,
      titleLineHeight: 1,
      titleOpacity: 1,
      titleOrient: 1,
      titlePadding: 1,
      type: 1,
      values: 1,
      zindex: 1
    };
    LEGEND_PROPERTIES = keys4(COMMON_LEGEND_PROPERTY_INDEX);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/selection.js
function isLegendBinding(bind4) {
  return !!bind4 && (bind4 === "legend" || !!bind4.legend);
}
function isLegendStreamBinding(bind4) {
  return isLegendBinding(bind4) && isObject_default(bind4);
}
var SELECTION_ID, defaultConfig;
var init_selection = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/selection.js"() {
    init_vega_util();
    SELECTION_ID = "_vgsid_";
    defaultConfig = {
      single: {
        on: "click",
        fields: [SELECTION_ID],
        resolve: "global",
        empty: "all",
        clear: "dblclick"
      },
      multi: {
        on: "click",
        fields: [SELECTION_ID],
        toggle: "event.shiftKey",
        resolve: "global",
        empty: "all",
        clear: "dblclick"
      },
      interval: {
        on: "[mousedown, window:mouseup] > window:mousemove!",
        encodings: ["x", "y"],
        translate: "[mousedown, window:mouseup] > window:mousemove!",
        zoom: "wheel!",
        mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
        resolve: "global",
        clear: "dblclick"
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/concat.js
function isAnyConcatSpec(spec) {
  return isVConcatSpec(spec) || isHConcatSpec(spec) || isConcatSpec(spec);
}
function isConcatSpec(spec) {
  return "concat" in spec;
}
function isVConcatSpec(spec) {
  return "vconcat" in spec;
}
function isHConcatSpec(spec) {
  return "hconcat" in spec;
}
var init_concat = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/concat.js"() {
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/base.js
function isStep(size) {
  return isObject_default(size) && size["step"] !== void 0;
}
function isFrameMixins(o) {
  return o["view"] || o["width"] || o["height"];
}
function extractCompositionLayout(spec, specType, config) {
  var _a2, _b;
  const compositionConfig = config[specType];
  const layout = {};
  const { spacing: spacingConfig, columns } = compositionConfig;
  if (spacingConfig !== void 0) {
    layout.spacing = spacingConfig;
  }
  if (columns !== void 0) {
    if (isFacetSpec(spec) && !isFacetMapping(spec.facet) || isConcatSpec(spec)) {
      layout.columns = columns;
    }
  }
  if (isVConcatSpec(spec)) {
    layout.columns = 1;
  }
  for (const prop of COMPOSITION_LAYOUT_PROPERTIES) {
    if (spec[prop] !== void 0) {
      if (prop === "spacing") {
        const spacing = spec[prop];
        layout[prop] = isNumber_default(spacing) ? spacing : {
          row: (_a2 = spacing.row) !== null && _a2 !== void 0 ? _a2 : spacingConfig,
          column: (_b = spacing.column) !== null && _b !== void 0 ? _b : spacingConfig
        };
      } else {
        layout[prop] = spec[prop];
      }
    }
  }
  return layout;
}
var DEFAULT_SPACING, COMPOSITION_LAYOUT_INDEX, COMPOSITION_LAYOUT_PROPERTIES;
var init_base2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/base.js"() {
    init_vega_util();
    init_util();
    init_concat();
    init_facet();
    DEFAULT_SPACING = 20;
    COMPOSITION_LAYOUT_INDEX = {
      align: 1,
      bounds: 1,
      center: 1,
      columns: 1,
      spacing: 1
    };
    COMPOSITION_LAYOUT_PROPERTIES = keys4(COMPOSITION_LAYOUT_INDEX);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/config.js
function getViewConfigContinuousSize(viewConfig, channel) {
  var _a2;
  return (_a2 = viewConfig[channel]) !== null && _a2 !== void 0 ? _a2 : viewConfig[channel === "width" ? "continuousWidth" : "continuousHeight"];
}
function getViewConfigDiscreteStep(viewConfig, channel) {
  const size = getViewConfigDiscreteSize(viewConfig, channel);
  return isStep(size) ? size.step : DEFAULT_STEP;
}
function getViewConfigDiscreteSize(viewConfig, channel) {
  var _a2;
  const size = (_a2 = viewConfig[channel]) !== null && _a2 !== void 0 ? _a2 : viewConfig[channel === "width" ? "discreteWidth" : "discreteHeight"];
  return getFirstDefined(size, { step: viewConfig.step });
}
function colorSignalConfig(color7 = {}) {
  return {
    signals: [
      {
        name: "color",
        value: isObject_default(color7) ? Object.assign(Object.assign({}, DEFAULT_COLOR), color7) : DEFAULT_COLOR
      }
    ],
    mark: { color: { signal: "color.blue" } },
    rule: { color: { signal: "color.gray0" } },
    text: {
      color: { signal: "color.gray0" }
    },
    style: {
      "guide-label": {
        fill: { signal: "color.gray0" }
      },
      "guide-title": {
        fill: { signal: "color.gray0" }
      },
      "group-title": {
        fill: { signal: "color.gray0" }
      },
      "group-subtitle": {
        fill: { signal: "color.gray0" }
      },
      cell: {
        stroke: { signal: "color.gray8" }
      }
    },
    axis: {
      domainColor: { signal: "color.gray13" },
      gridColor: { signal: "color.gray8" },
      tickColor: { signal: "color.gray13" }
    },
    range: {
      category: [
        { signal: "color.blue" },
        { signal: "color.orange" },
        { signal: "color.red" },
        { signal: "color.teal" },
        { signal: "color.green" },
        { signal: "color.yellow" },
        { signal: "color.purple" },
        { signal: "color.pink" },
        { signal: "color.brown" },
        { signal: "color.grey8" }
      ]
    }
  };
}
function fontSizeSignalConfig(fontSize3) {
  return {
    signals: [
      {
        name: "fontSize",
        value: isObject_default(fontSize3) ? Object.assign(Object.assign({}, DEFAULT_FONT_SIZE), fontSize3) : DEFAULT_FONT_SIZE
      }
    ],
    text: {
      fontSize: { signal: "fontSize.text" }
    },
    style: {
      "guide-label": {
        fontSize: { signal: "fontSize.guideLabel" }
      },
      "guide-title": {
        fontSize: { signal: "fontSize.guideTitle" }
      },
      "group-title": {
        fontSize: { signal: "fontSize.groupTitle" }
      },
      "group-subtitle": {
        fontSize: { signal: "fontSize.groupSubtitle" }
      }
    }
  };
}
function fontConfig(font4) {
  return {
    text: { font: font4 },
    style: {
      "guide-label": { font: font4 },
      "guide-title": { font: font4 },
      "group-title": { font: font4 },
      "group-subtitle": { font: font4 }
    }
  };
}
function initConfig(config = {}) {
  const { color: color7, font: font4, fontSize: fontSize3 } = config, restConfig = __rest(config, ["color", "font", "fontSize"]);
  return mergeConfig2({}, defaultConfig2, font4 ? fontConfig(font4) : {}, color7 ? colorSignalConfig(color7) : {}, fontSize3 ? fontSizeSignalConfig(fontSize3) : {}, restConfig || {});
}
function stripAndRedirectConfig(config) {
  config = duplicate(config);
  for (const prop of VL_ONLY_CONFIG_PROPERTIES) {
    delete config[prop];
  }
  if (config.axis) {
    for (const prop in config.axis) {
      if (isConditionalAxisValue(config.axis[prop])) {
        delete config.axis[prop];
      }
    }
  }
  if (config.legend) {
    for (const prop of VL_ONLY_LEGEND_CONFIG) {
      delete config.legend[prop];
    }
  }
  if (config.mark) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config.mark[prop];
    }
    if (config.mark.tooltip && isObject_default(config.mark.tooltip)) {
      delete config.mark.tooltip;
    }
  }
  for (const markType2 of MARK_STYLES) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config[markType2][prop];
    }
    const vlOnlyMarkSpecificConfigs = VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType2];
    if (vlOnlyMarkSpecificConfigs) {
      for (const prop of vlOnlyMarkSpecificConfigs) {
        delete config[markType2][prop];
      }
    }
    redirectConfigToStyleConfig(config, markType2);
  }
  for (const m2 of getAllCompositeMarks()) {
    delete config[m2];
  }
  redirectTitleConfig(config);
  for (const prop in config) {
    if (isObject_default(config[prop]) && isEmpty(config[prop])) {
      delete config[prop];
    }
  }
  return isEmpty(config) ? void 0 : config;
}
function redirectTitleConfig(config) {
  const { titleMarkConfig, subtitleMarkConfig, subtitle } = extractTitleConfig(config.title);
  if (!isEmpty(titleMarkConfig)) {
    config.style["group-title"] = Object.assign(
      Object.assign({}, config.style["group-title"]),
      titleMarkConfig
    );
  }
  if (!isEmpty(subtitleMarkConfig)) {
    config.style["group-subtitle"] = Object.assign(Object.assign({}, config.style["group-subtitle"]), subtitleMarkConfig);
  }
  if (!isEmpty(subtitle)) {
    config.title = subtitle;
  } else {
    delete config.title;
  }
}
function redirectConfigToStyleConfig(config, prop, toProp, compositeMarkPart) {
  const propConfig = compositeMarkPart ? config[prop][compositeMarkPart] : config[prop];
  if (prop === "view") {
    toProp = "cell";
  }
  const style3 = Object.assign(Object.assign({}, propConfig), config.style[toProp !== null && toProp !== void 0 ? toProp : prop]);
  if (!isEmpty(style3)) {
    config.style[toProp !== null && toProp !== void 0 ? toProp : prop] = style3;
  }
  if (!compositeMarkPart) {
    delete config[prop];
  }
}
var DEFAULT_STEP, defaultViewConfig, defaultConfig2, tab10, DEFAULT_FONT_SIZE, DEFAULT_COLOR, MARK_STYLES, VL_ONLY_CONFIG_PROPERTIES, VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX;
var init_config = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/config.js"() {
    init_tslib_es6();
    init_vega_util();
    init_axis();
    init_compositemark();
    init_guide();
    init_legend();
    init_mark();
    init_mark();
    init_scale();
    init_selection();
    init_base2();
    init_title();
    init_util();
    DEFAULT_STEP = 20;
    defaultViewConfig = {
      continuousWidth: 200,
      continuousHeight: 200,
      step: DEFAULT_STEP
    };
    defaultConfig2 = {
      background: "white",
      padding: 5,
      timeFormat: "%b %d, %Y",
      countTitle: "Count of Records",
      view: defaultViewConfig,
      mark: defaultMarkConfig,
      arc: {},
      area: {},
      bar: defaultBarConfig,
      circle: {},
      geoshape: {},
      image: {},
      line: {},
      point: {},
      rect: defaultRectConfig,
      rule: { color: "black" },
      square: {},
      text: { color: "black" },
      tick: defaultTickConfig,
      trail: {},
      boxplot: {
        size: 14,
        extent: 1.5,
        box: {},
        median: { color: "white" },
        outliers: {},
        rule: {},
        ticks: null
      },
      errorbar: {
        center: "mean",
        rule: true,
        ticks: false
      },
      errorband: {
        band: {
          opacity: 0.3
        },
        borders: false
      },
      scale: defaultScaleConfig,
      projection: {},
      legend: defaultLegendConfig,
      header: { titlePadding: 10, labelPadding: 10 },
      headerColumn: {},
      headerRow: {},
      headerFacet: {},
      selection: defaultConfig,
      style: {},
      title: {},
      facet: { spacing: DEFAULT_SPACING },
      concat: { spacing: DEFAULT_SPACING }
    };
    tab10 = [
      "#4c78a8",
      "#f58518",
      "#e45756",
      "#72b7b2",
      "#54a24b",
      "#eeca3b",
      "#b279a2",
      "#ff9da6",
      "#9d755d",
      "#bab0ac"
    ];
    DEFAULT_FONT_SIZE = {
      text: 11,
      guideLabel: 10,
      guideTitle: 11,
      groupTitle: 13,
      groupSubtitle: 12
    };
    DEFAULT_COLOR = {
      blue: tab10[0],
      orange: tab10[1],
      red: tab10[2],
      teal: tab10[3],
      green: tab10[4],
      yellow: tab10[5],
      purple: tab10[6],
      pink: tab10[7],
      brown: tab10[8],
      gray0: "#000",
      gray1: "#111",
      gray2: "#222",
      gray3: "#333",
      gray4: "#444",
      gray5: "#555",
      gray6: "#666",
      gray7: "#777",
      gray8: "#888",
      gray9: "#999",
      gray10: "#aaa",
      gray11: "#bbb",
      gray12: "#ccc",
      gray13: "#ddd",
      gray14: "#eee",
      gray15: "#fff"
    };
    MARK_STYLES = ["view", ...PRIMITIVE_MARKS];
    VL_ONLY_CONFIG_PROPERTIES = [
      "color",
      "fontSize",
      "background",
      "padding",
      "facet",
      "concat",
      "numberFormat",
      "timeFormat",
      "countTitle",
      "header",
      "axisQuantitative",
      "axisTemporal",
      "axisDiscrete",
      "axisPoint",
      "axisXBand",
      "axisXPoint",
      "axisXDiscrete",
      "axisXQuantitative",
      "axisXTemporal",
      "axisYBand",
      "axisYPoint",
      "axisYDiscrete",
      "axisYQuantitative",
      "axisYTemporal",
      "scale",
      "selection",
      "overlay"
    ];
    VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = Object.assign({ view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"] }, VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/layer.js
function isLayerSpec(spec) {
  return "layer" in spec;
}
var init_layer = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/layer.js"() {
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/repeat.js
function isRepeatSpec(spec) {
  return "repeat" in spec;
}
function isLayerRepeatSpec(spec) {
  return !isArray_default(spec.repeat) && spec.repeat["layer"];
}
var init_repeat2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/repeat.js"() {
    init_vega_util();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/index.js
var init_spec = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/index.js"() {
    init_concat();
    init_facet();
    init_layer();
    init_repeat2();
    init_unit();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/map.js
var SpecMapper;
var init_map4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/map.js"() {
    init_tslib_es6();
    init_log3();
    init_concat();
    init_facet();
    init_layer();
    init_repeat2();
    init_unit();
    SpecMapper = class {
      map(spec, params2) {
        if (isFacetSpec(spec)) {
          return this.mapFacet(spec, params2);
        } else if (isRepeatSpec(spec)) {
          return this.mapRepeat(spec, params2);
        } else if (isHConcatSpec(spec)) {
          return this.mapHConcat(spec, params2);
        } else if (isVConcatSpec(spec)) {
          return this.mapVConcat(spec, params2);
        } else if (isConcatSpec(spec)) {
          return this.mapConcat(spec, params2);
        } else {
          return this.mapLayerOrUnit(spec, params2);
        }
      }
      mapLayerOrUnit(spec, params2) {
        if (isLayerSpec(spec)) {
          return this.mapLayer(spec, params2);
        } else if (isUnitSpec(spec)) {
          return this.mapUnit(spec, params2);
        }
        throw new Error(message_exports.invalidSpec(spec));
      }
      mapLayer(spec, params2) {
        return Object.assign(Object.assign({}, spec), { layer: spec.layer.map((subspec) => this.mapLayerOrUnit(subspec, params2)) });
      }
      mapHConcat(spec, params2) {
        return Object.assign(Object.assign({}, spec), { hconcat: spec.hconcat.map((subspec) => this.map(subspec, params2)) });
      }
      mapVConcat(spec, params2) {
        return Object.assign(Object.assign({}, spec), { vconcat: spec.vconcat.map((subspec) => this.map(subspec, params2)) });
      }
      mapConcat(spec, params2) {
        const { concat } = spec, rest = __rest(spec, ["concat"]);
        return Object.assign(Object.assign({}, rest), { concat: concat.map((subspec) => this.map(subspec, params2)) });
      }
      mapFacet(spec, params2) {
        return Object.assign(Object.assign({}, spec), {
          spec: this.map(spec.spec, params2)
        });
      }
      mapRepeat(spec, params2) {
        return Object.assign(Object.assign({}, spec), {
          spec: this.map(spec.spec, params2)
        });
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/stack.js
function isStackOffset(s3) {
  return s3 in STACK_OFFSET_INDEX;
}
function potentialStackedChannel(encoding, x7) {
  var _a2, _b;
  const y7 = x7 === "x" ? "y" : "radius";
  const xDef = encoding[x7];
  const yDef = encoding[y7];
  if (isFieldDef(xDef) && isFieldDef(yDef)) {
    if (channelDefType(xDef) === "quantitative" && channelDefType(yDef) === "quantitative") {
      if (xDef.stack) {
        return x7;
      } else if (yDef.stack) {
        return y7;
      }
      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;
      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;
      if (xAggregate !== yAggregate) {
        return xAggregate ? x7 : y7;
      } else {
        const xScale = (_a2 = xDef.scale) === null || _a2 === void 0 ? void 0 : _a2.type;
        const yScale = (_b = yDef.scale) === null || _b === void 0 ? void 0 : _b.type;
        if (xScale && xScale !== "linear") {
          return y7;
        } else if (yScale && yScale !== "linear") {
          return x7;
        }
      }
    } else if (channelDefType(xDef) === "quantitative") {
      return x7;
    } else if (channelDefType(yDef) === "quantitative") {
      return y7;
    }
  } else if (channelDefType(xDef) === "quantitative") {
    return x7;
  } else if (channelDefType(yDef) === "quantitative") {
    return y7;
  }
  return void 0;
}
function getDimensionChannel(channel) {
  switch (channel) {
    case "x":
      return "y";
    case "y":
      return "x";
    case "theta":
      return "radius";
    case "radius":
      return "theta";
  }
}
function stack(m2, encoding, opt = {}) {
  const mark = isMarkDef(m2) ? m2.type : m2;
  if (!STACKABLE_MARKS.has(mark)) {
    return null;
  }
  const fieldChannel = potentialStackedChannel(encoding, "x") || potentialStackedChannel(encoding, "theta");
  if (!fieldChannel) {
    return null;
  }
  const stackedFieldDef = encoding[fieldChannel];
  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : void 0;
  let dimensionChannel = getDimensionChannel(fieldChannel);
  let dimensionDef = encoding[dimensionChannel];
  let dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : void 0;
  if (dimensionField === stackedField) {
    dimensionField = void 0;
    dimensionDef = void 0;
    dimensionChannel = void 0;
  }
  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {
    if (channel !== "tooltip" && channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      for (const cDef of array_default6(channelDef)) {
        const fieldDef = getFieldDef(cDef);
        if (fieldDef.aggregate) {
          continue;
        }
        const f = vgField(fieldDef, {});
        if (!f || f !== dimensionField) {
          sc.push({ channel, fieldDef });
        }
      }
    }
    return sc;
  }, []);
  let offset5;
  if (stackedFieldDef.stack !== void 0) {
    if (isBoolean_default(stackedFieldDef.stack)) {
      offset5 = stackedFieldDef.stack ? "zero" : null;
    } else {
      offset5 = stackedFieldDef.stack;
    }
  } else if (stackBy.length > 0 && STACK_BY_DEFAULT_MARKS.has(mark)) {
    offset5 = "zero";
  }
  if (!offset5 || !isStackOffset(offset5)) {
    return null;
  }
  if (isAggregate(encoding) && stackBy.length === 0) {
    return null;
  }
  if (stackedFieldDef.scale && stackedFieldDef.scale.type && stackedFieldDef.scale.type !== ScaleType.LINEAR) {
    if (opt.disallowNonLinearStack) {
      return null;
    } else {
      warn2(message_exports.cannotStackNonLinearScale(stackedFieldDef.scale.type));
    }
  }
  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {
    if (stackedFieldDef.stack !== void 0) {
      warn2(message_exports.cannotStackRangedMark(fieldChannel));
    }
    return null;
  }
  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !contains2(SUM_OPS, stackedFieldDef.aggregate)) {
    warn2(message_exports.stackNonSummativeAggregate(stackedFieldDef.aggregate));
  }
  return {
    groupbyChannel: dimensionDef ? dimensionChannel : void 0,
    groupbyField: dimensionField,
    fieldChannel,
    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),
    stackBy,
    offset: offset5
  };
}
var STACK_OFFSET_INDEX, STACKABLE_MARKS, STACK_BY_DEFAULT_MARKS;
var init_stack3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/stack.js"() {
    init_vega_util();
    init_aggregate();
    init_channel();
    init_channeldef();
    init_encoding();
    init_log3();
    init_mark();
    init_scale();
    init_util();
    STACK_OFFSET_INDEX = {
      zero: 1,
      center: 1,
      normalize: 1
    };
    STACKABLE_MARKS = /* @__PURE__ */ new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);
    STACK_BY_DEFAULT_MARKS = /* @__PURE__ */ new Set([BAR, AREA, ARC]);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/pathoverlay.js
function dropLineAndPoint(markDef) {
  const { point: _point, line: _line } = markDef, mark = __rest(markDef, ["point", "line"]);
  return keys4(mark).length > 1 ? mark : mark.type;
}
function dropLineAndPointFromConfig(config) {
  for (const mark of ["line", "area", "rule", "trail"]) {
    if (config[mark]) {
      config = Object.assign(Object.assign({}, config), {
        [mark]: omit(config[mark], ["point", "line"])
      });
    }
  }
  return config;
}
function getPointOverlay(markDef, markConfig = {}, encoding) {
  if (markDef.point === "transparent") {
    return { opacity: 0 };
  } else if (markDef.point) {
    return isObject_default(markDef.point) ? markDef.point : {};
  } else if (markDef.point !== void 0) {
    return null;
  } else {
    if (markConfig.point || encoding.shape) {
      return isObject_default(markConfig.point) ? markConfig.point : {};
    }
    return void 0;
  }
}
function getLineOverlay(markDef, markConfig = {}) {
  if (markDef.line) {
    return markDef.line === true ? {} : markDef.line;
  } else if (markDef.line !== void 0) {
    return null;
  } else {
    if (markConfig.line) {
      return markConfig.line === true ? {} : markConfig.line;
    }
    return void 0;
  }
}
var PathOverlayNormalizer;
var init_pathoverlay = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/pathoverlay.js"() {
    init_tslib_es6();
    init_vega_util();
    init_mark();
    init_unit();
    init_stack3();
    init_util();
    PathOverlayNormalizer = class {
      constructor() {
        this.name = "path-overlay";
      }
      hasMatchingType(spec, config) {
        if (isUnitSpec(spec)) {
          const { mark, encoding } = spec;
          const markDef = isMarkDef(mark) ? mark : { type: mark };
          switch (markDef.type) {
            case "line":
            case "rule":
            case "trail":
              return !!getPointOverlay(markDef, config[markDef.type], encoding);
            case "area":
              return !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type]);
          }
        }
        return false;
      }
      run(spec, params2, normalize4) {
        const { config } = params2;
        const { selection: selection2, projection: projection3, encoding, mark } = spec, outerSpec = __rest(spec, ["selection", "projection", "encoding", "mark"]);
        const markDef = isMarkDef(mark) ? mark : { type: mark };
        const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);
        const lineOverlay = markDef.type === "area" && getLineOverlay(markDef, config[markDef.type]);
        const layer = [
          Object.assign(Object.assign({}, selection2 ? { selection: selection2 } : {}), {
            mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef.type === "area" && markDef.opacity === void 0 && markDef.fillOpacity === void 0 ? { opacity: 0.7 } : {}), markDef)),
            encoding: omit(encoding, ["shape"])
          })
        ];
        const stackProps = stack(markDef, encoding);
        let overlayEncoding = encoding;
        if (stackProps) {
          const { fieldChannel: stackFieldChannel, offset: offset5 } = stackProps;
          overlayEncoding = Object.assign(Object.assign({}, encoding), { [stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset5 ? { stack: offset5 } : {}) });
        }
        if (lineOverlay) {
          layer.push(Object.assign(Object.assign({}, projection3 ? { projection: projection3 } : {}), { mark: Object.assign(Object.assign({ type: "line" }, pick3(markDef, ["clip", "interpolate", "tension", "tooltip"])), lineOverlay), encoding: overlayEncoding }));
        }
        if (pointOverlay) {
          layer.push(Object.assign(Object.assign({}, projection3 ? { projection: projection3 } : {}), { mark: Object.assign(Object.assign({ type: "point", opacity: 1, filled: true }, pick3(markDef, ["clip", "tooltip"])), pointOverlay), encoding: overlayEncoding }));
        }
        return normalize4(Object.assign(Object.assign({}, outerSpec), { layer }), Object.assign(Object.assign({}, params2), { config: dropLineAndPointFromConfig(config) }));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/rangestep.js
var RangeStepNormalizer;
var init_rangestep = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/rangestep.js"() {
    init_tslib_es6();
    init_channel();
    init_channeldef();
    init_log3();
    init_unit();
    init_util();
    RangeStepNormalizer = class {
      constructor() {
        this.name = "RangeStep";
      }
      hasMatchingType(spec) {
        var _a2;
        if (isUnitSpec(spec) && spec.encoding) {
          for (const channel of POSITION_SCALE_CHANNELS) {
            const def3 = spec.encoding[channel];
            if (def3 && isFieldOrDatumDef(def3)) {
              if ((_a2 = def3 === null || def3 === void 0 ? void 0 : def3.scale) === null || _a2 === void 0 ? void 0 : _a2["rangeStep"]) {
                return true;
              }
            }
          }
        }
        return false;
      }
      run(spec) {
        var _a2;
        const sizeMixins = {};
        let encoding = Object.assign({}, spec.encoding);
        for (const channel of POSITION_SCALE_CHANNELS) {
          const sizeType = getSizeChannel(channel);
          const def3 = encoding[channel];
          if (def3 && isFieldOrDatumDef(def3)) {
            if ((_a2 = def3 === null || def3 === void 0 ? void 0 : def3.scale) === null || _a2 === void 0 ? void 0 : _a2["rangeStep"]) {
              const { scale: scale8 } = def3, defWithoutScale = __rest(def3, ["scale"]);
              const _b = scale8, { rangeStep } = _b, scaleWithoutRangeStep = __rest(_b, ["rangeStep"]);
              sizeMixins[sizeType] = { step: scale8["rangeStep"] };
              warn2(message_exports.RANGE_STEP_DEPRECATED);
              encoding = Object.assign(Object.assign({}, encoding), { [channel]: Object.assign(Object.assign({}, defWithoutScale), isEmpty(scaleWithoutRangeStep) ? {} : { scale: scaleWithoutRangeStep }) });
            }
          }
        }
        return Object.assign(Object.assign(Object.assign({}, sizeMixins), spec), { encoding });
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/repeater.js
function replaceRepeaterInFacet(facet, repeater) {
  if (!repeater) {
    return facet;
  }
  if (isFacetMapping(facet)) {
    return replaceRepeaterInMapping(facet, repeater);
  }
  return replaceRepeaterInFieldDef(facet, repeater);
}
function replaceRepeaterInEncoding(encoding, repeater) {
  if (!repeater) {
    return encoding;
  }
  return replaceRepeaterInMapping(encoding, repeater);
}
function replaceRepeatInProp(prop, o, repeater) {
  const val = o[prop];
  if (isRepeatRef(val)) {
    if (val.repeat in repeater) {
      return Object.assign(Object.assign({}, o), { [prop]: repeater[val.repeat] });
    } else {
      warn2(message_exports.noSuchRepeatedValue(val.repeat));
      return void 0;
    }
  }
  return o;
}
function replaceRepeaterInFieldDef(fieldDef, repeater) {
  fieldDef = replaceRepeatInProp("field", fieldDef, repeater);
  if (fieldDef === void 0) {
    return void 0;
  } else if (fieldDef === null) {
    return null;
  }
  if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {
    const sort5 = replaceRepeatInProp("field", fieldDef.sort, repeater);
    fieldDef = Object.assign(Object.assign({}, fieldDef), sort5 ? { sort: sort5 } : {});
  }
  return fieldDef;
}
function replaceRepeaterInFieldOrDatumDef(def3, repeater) {
  if (isFieldDef(def3)) {
    return replaceRepeaterInFieldDef(def3, repeater);
  } else {
    const datumDef = replaceRepeatInProp("datum", def3, repeater);
    if (datumDef !== def3 && !datumDef.type) {
      datumDef.type = "nominal";
    }
    return datumDef;
  }
}
function replaceRepeaterInChannelDef(channelDef, repeater) {
  if (isFieldOrDatumDef(channelDef)) {
    const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);
    if (fd) {
      return fd;
    } else if (isConditionalDef(channelDef)) {
      return { condition: channelDef.condition };
    }
  } else {
    if (hasConditionalFieldOrDatumDef(channelDef)) {
      const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);
      if (fd) {
        return Object.assign(Object.assign({}, channelDef), { condition: fd });
      } else {
        const { condition } = channelDef, channelDefWithoutCondition = __rest(channelDef, ["condition"]);
        return channelDefWithoutCondition;
      }
    }
    return channelDef;
  }
  return void 0;
}
function replaceRepeaterInMapping(mapping, repeater) {
  const out = {};
  for (const channel in mapping) {
    if (hasOwnProperty_default(mapping, channel)) {
      const channelDef = mapping[channel];
      if (isArray_default(channelDef)) {
        out[channel] = channelDef.map((cd) => replaceRepeaterInChannelDef(cd, repeater)).filter((cd) => cd);
      } else {
        const cd = replaceRepeaterInChannelDef(channelDef, repeater);
        if (cd !== void 0) {
          out[channel] = cd;
        }
      }
    }
  }
  return out;
}
var init_repeater = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/repeater.js"() {
    init_tslib_es6();
    init_vega_util();
    init_channeldef();
    init_log3();
    init_sort5();
    init_facet();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/ruleforrangedline.js
var RuleForRangedLineNormalizer;
var init_ruleforrangedline = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/ruleforrangedline.js"() {
    init_bin4();
    init_channel();
    init_channeldef();
    init_log3();
    init_unit();
    RuleForRangedLineNormalizer = class {
      constructor() {
        this.name = "RuleForRangedLine";
      }
      hasMatchingType(spec) {
        if (isUnitSpec(spec)) {
          const { encoding, mark } = spec;
          if (mark === "line") {
            for (const channel of SECONDARY_RANGE_CHANNEL) {
              const mainChannel = getMainRangeChannel(channel);
              const mainChannelDef = encoding[mainChannel];
              if (encoding[channel]) {
                if (isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin) || isDatumDef(mainChannelDef)) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }
      run(spec, params2, normalize4) {
        const { encoding } = spec;
        warn2(message_exports.lineWithRange(!!encoding.x2, !!encoding.y2));
        return normalize4(Object.assign(Object.assign({}, spec), { mark: "rule" }), params2);
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/core.js
function mergeEncoding(opt) {
  const { parentEncoding, encoding } = opt;
  if (parentEncoding && encoding) {
    const overriden = keys4(parentEncoding).reduce((o, key3) => {
      if (encoding[key3]) {
        o.push(key3);
      }
      return o;
    }, []);
    if (overriden.length > 0) {
      warn2(message_exports.encodingOverridden(overriden));
    }
  }
  const merged = Object.assign(Object.assign({}, parentEncoding !== null && parentEncoding !== void 0 ? parentEncoding : {}), encoding !== null && encoding !== void 0 ? encoding : {});
  return isEmpty(merged) ? void 0 : merged;
}
function mergeProjection(opt) {
  const { parentProjection, projection: projection3 } = opt;
  if (parentProjection && projection3) {
    warn2(message_exports.projectionOverridden({ parentProjection, projection: projection3 }));
  }
  return projection3 !== null && projection3 !== void 0 ? projection3 : parentProjection;
}
var CoreNormalizer;
var init_core2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/core.js"() {
    init_tslib_es6();
    init_vega_util();
    init_channel();
    init_boxplot();
    init_errorband();
    init_errorbar();
    init_encoding();
    init_log3();
    init_facet();
    init_map4();
    init_repeat2();
    init_unit();
    init_util();
    init_pathoverlay();
    init_rangestep();
    init_repeater();
    init_ruleforrangedline();
    CoreNormalizer = class extends SpecMapper {
      constructor() {
        super(...arguments);
        this.nonFacetUnitNormalizers = [
          boxPlotNormalizer,
          errorBarNormalizer,
          errorBandNormalizer,
          new PathOverlayNormalizer(),
          new RuleForRangedLineNormalizer(),
          new RangeStepNormalizer()
        ];
      }
      map(spec, params2) {
        if (isUnitSpec(spec)) {
          const hasRow = channelHasField(spec.encoding, ROW);
          const hasColumn = channelHasField(spec.encoding, COLUMN);
          const hasFacet = channelHasField(spec.encoding, FACET);
          if (hasRow || hasColumn || hasFacet) {
            return this.mapFacetedUnit(spec, params2);
          }
        }
        return super.map(spec, params2);
      }
      mapUnit(spec, params2) {
        const { parentEncoding, parentProjection } = params2;
        const specWithReplacedEncoding = Object.assign(Object.assign({}, spec), { encoding: replaceRepeaterInEncoding(spec.encoding, params2.repeater) });
        if (parentEncoding || parentProjection) {
          return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params2);
        }
        const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);
        for (const unitNormalizer of this.nonFacetUnitNormalizers) {
          if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params2.config)) {
            return unitNormalizer.run(specWithReplacedEncoding, params2, normalizeLayerOrUnit);
          }
        }
        return specWithReplacedEncoding;
      }
      mapRepeat(spec, params2) {
        if (isLayerRepeatSpec(spec)) {
          return this.mapLayerRepeat(spec, params2);
        } else {
          return this.mapNonLayerRepeat(spec, params2);
        }
      }
      mapLayerRepeat(spec, params2) {
        const { repeat: repeat2, spec: childSpec } = spec, rest = __rest(spec, ["repeat", "spec"]);
        const { row, column, layer } = repeat2;
        const { repeater = {}, repeaterPrefix = "" } = params2;
        if (row || column) {
          return this.mapRepeat(Object.assign(Object.assign({}, spec), { repeat: Object.assign(Object.assign({}, row ? { row } : {}), column ? { column } : {}), spec: {
            repeat: { layer },
            spec: childSpec
          } }), params2);
        } else {
          return Object.assign(Object.assign({}, rest), { layer: layer.map((layerValue) => {
            const childRepeater = Object.assign(Object.assign({}, repeater), { layer: layerValue });
            const childName = (childSpec.name || "") + repeaterPrefix + `child__layer_${varName(layerValue)}`;
            const child = this.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params2), { repeater: childRepeater, repeaterPrefix: childName }));
            child.name = childName;
            return child;
          }) });
        }
      }
      mapNonLayerRepeat(spec, params2) {
        var _a2;
        const { repeat: repeat2, spec: childSpec, data: data3 } = spec, remainingProperties = __rest(spec, ["repeat", "spec", "data"]);
        if (!isArray_default(repeat2) && spec.columns) {
          spec = omit(spec, ["columns"]);
          warn2(message_exports.columnsNotSupportByRowCol("repeat"));
        }
        const concat = [];
        const { repeater = {}, repeaterPrefix = "" } = params2;
        const row = !isArray_default(repeat2) && repeat2.row || [repeater ? repeater.row : null];
        const column = !isArray_default(repeat2) && repeat2.column || [repeater ? repeater.column : null];
        const repeatValues = isArray_default(repeat2) && repeat2 || [repeater ? repeater.repeat : null];
        for (const repeatValue of repeatValues) {
          for (const rowValue of row) {
            for (const columnValue of column) {
              const childRepeater = {
                repeat: repeatValue,
                row: rowValue,
                column: columnValue,
                layer: repeater.layer
              };
              const childName = (childSpec.name || "") + repeaterPrefix + "child__" + (isArray_default(repeat2) ? `${varName(repeatValue)}` : (repeat2.row ? `row_${varName(rowValue)}` : "") + (repeat2.column ? `column_${varName(columnValue)}` : ""));
              const child = this.map(childSpec, Object.assign(Object.assign({}, params2), { repeater: childRepeater, repeaterPrefix: childName }));
              child.name = childName;
              concat.push(omit(child, ["data"]));
            }
          }
        }
        const columns = isArray_default(repeat2) ? spec.columns : repeat2.column ? repeat2.column.length : 1;
        return Object.assign(Object.assign({ data: (_a2 = childSpec.data) !== null && _a2 !== void 0 ? _a2 : data3, align: "all" }, remainingProperties), {
          columns,
          concat
        });
      }
      mapFacet(spec, params2) {
        const { facet } = spec;
        if (isFacetMapping(facet) && spec.columns) {
          spec = omit(spec, ["columns"]);
          warn2(message_exports.columnsNotSupportByRowCol("facet"));
        }
        return super.mapFacet(spec, params2);
      }
      mapUnitWithParentEncodingOrProjection(spec, params2) {
        const { encoding, projection: projection3 } = spec;
        const { parentEncoding, parentProjection, config } = params2;
        const mergedProjection = mergeProjection({ parentProjection, projection: projection3 });
        const mergedEncoding = mergeEncoding({
          parentEncoding,
          encoding: replaceRepeaterInEncoding(encoding, params2.repeater)
        });
        return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? { projection: mergedProjection } : {}), mergedEncoding ? { encoding: mergedEncoding } : {}), { config });
      }
      mapFacetedUnit(spec, params2) {
        const _a2 = spec.encoding, { row, column, facet } = _a2, encoding = __rest(_a2, ["row", "column", "facet"]);
        const { mark, width: width2, projection: projection3, height: height2, view, selection: selection2, encoding: _ } = spec, outerSpec = __rest(spec, ["mark", "width", "projection", "height", "view", "selection", "encoding"]);
        const { facetMapping, layout } = this.getFacetMappingAndLayout({ row, column, facet }, params2);
        const newEncoding = replaceRepeaterInEncoding(encoding, params2.repeater);
        return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {
          facet: facetMapping,
          spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, width2 ? { width: width2 } : {}), height2 ? { height: height2 } : {}), view ? { view } : {}), projection3 ? { projection: projection3 } : {}), { mark, encoding: newEncoding }), selection2 ? { selection: selection2 } : {})
        }), params2);
      }
      getFacetMappingAndLayout(facets, params2) {
        var _a2;
        const { row, column, facet } = facets;
        if (row || column) {
          if (facet) {
            warn2(message_exports.facetChannelDropped([...row ? [ROW] : [], ...column ? [COLUMN] : []]));
          }
          const facetMapping = {};
          const layout = {};
          for (const channel of [ROW, COLUMN]) {
            const def3 = facets[channel];
            if (def3) {
              const { align: align2, center, spacing, columns } = def3, defWithoutLayout = __rest(def3, ["align", "center", "spacing", "columns"]);
              facetMapping[channel] = defWithoutLayout;
              for (const prop of ["align", "center", "spacing"]) {
                if (def3[prop] !== void 0) {
                  layout[prop] = (_a2 = layout[prop]) !== null && _a2 !== void 0 ? _a2 : {};
                  layout[prop][channel] = def3[prop];
                }
              }
            }
          }
          return { facetMapping, layout };
        } else {
          const { align: align2, center, spacing, columns } = facet, facetMapping = __rest(facet, ["align", "center", "spacing", "columns"]);
          return {
            facetMapping: replaceRepeaterInFacet(facetMapping, params2.repeater),
            layout: Object.assign(Object.assign(Object.assign(Object.assign({}, align2 ? { align: align2 } : {}), center ? { center } : {}), spacing ? { spacing } : {}), columns ? { columns } : {})
          };
        }
      }
      mapLayer(spec, _a2) {
        var { parentEncoding, parentProjection } = _a2, otherParams = __rest(_a2, ["parentEncoding", "parentProjection"]);
        const { encoding, projection: projection3 } = spec, rest = __rest(spec, ["encoding", "projection"]);
        const params2 = Object.assign(Object.assign({}, otherParams), { parentEncoding: mergeEncoding({ parentEncoding, encoding }), parentProjection: mergeProjection({ parentProjection, projection: projection3 }) });
        return super.mapLayer(rest, params2);
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/index.js
function normalize3(spec, config) {
  if (config === void 0) {
    config = initConfig(spec.config);
  }
  const normalizedSpec = normalizeGenericSpec(spec, config);
  const { width: width2, height: height2 } = spec;
  const autosize = normalizeAutoSize(normalizedSpec, { width: width2, height: height2, autosize: spec.autosize }, config);
  return Object.assign(Object.assign({}, normalizedSpec), autosize ? { autosize } : {});
}
function normalizeGenericSpec(spec, config = {}) {
  return normalizer.map(spec, { config });
}
function _normalizeAutoSize(autosize) {
  return isString_default(autosize) ? { type: autosize } : autosize !== null && autosize !== void 0 ? autosize : {};
}
function normalizeAutoSize(spec, sizeInfo, config) {
  let { width: width2, height: height2 } = sizeInfo;
  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);
  const autosizeDefault = {};
  if (!isFitCompatible) {
    if (width2 == "container") {
      warn2(message_exports.containerSizeNonSingle("width"));
      width2 = void 0;
    }
    if (height2 == "container") {
      warn2(message_exports.containerSizeNonSingle("height"));
      height2 = void 0;
    }
  } else {
    if (width2 == "container" && height2 == "container") {
      autosizeDefault.type = "fit";
      autosizeDefault.contains = "padding";
    } else if (width2 == "container") {
      autosizeDefault.type = "fit-x";
      autosizeDefault.contains = "padding";
    } else if (height2 == "container") {
      autosizeDefault.type = "fit-y";
      autosizeDefault.contains = "padding";
    }
  }
  const autosize = Object.assign(Object.assign(Object.assign({ type: "pad" }, autosizeDefault), config ? _normalizeAutoSize(config.autosize) : {}), _normalizeAutoSize(spec.autosize));
  if (autosize.type === "fit" && !isFitCompatible) {
    warn2(message_exports.FIT_NON_SINGLE);
    autosize.type = "pad";
  }
  if (width2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-x")) {
    warn2(message_exports.containerSizeNotCompatibleWithAutosize("width"));
  }
  if (height2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-y")) {
    warn2(message_exports.containerSizeNotCompatibleWithAutosize("height"));
  }
  if (deepEqual(autosize, { type: "pad" })) {
    return void 0;
  }
  return autosize;
}
var normalizer;
var init_normalize = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/normalize/index.js"() {
    init_vega_util();
    init_config();
    init_log3();
    init_spec();
    init_util();
    init_core2();
    normalizer = new CoreNormalizer();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/toplevel.js
function isFitType(autoSizeType) {
  return autoSizeType === "fit" || autoSizeType === "fit-x" || autoSizeType === "fit-y";
}
function getFitType(sizeType) {
  return sizeType ? `fit-${getPositionScaleChannel(sizeType)}` : "fit";
}
function extractTopLevelProperties(t) {
  return TOP_LEVEL_PROPERTIES.reduce((o, p) => {
    if (t && t[p] !== void 0) {
      o[p] = t[p];
    }
    return o;
  }, {});
}
var TOP_LEVEL_PROPERTIES;
var init_toplevel = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/spec/toplevel.js"() {
    init_channel();
    TOP_LEVEL_PROPERTIES = [
      "background",
      "padding"
    ];
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/split.js
function makeExplicit(value4) {
  return {
    explicit: true,
    value: value4
  };
}
function makeImplicit(value4) {
  return {
    explicit: false,
    value: value4
  };
}
function tieBreakByComparing(compare6) {
  return (v1, v2, property2, propertyOf) => {
    const diff2 = compare6(v1.value, v2.value);
    if (diff2 > 0) {
      return v1;
    } else if (diff2 < 0) {
      return v2;
    }
    return defaultTieBreaker(v1, v2, property2, propertyOf);
  };
}
function defaultTieBreaker(v1, v2, property2, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn2(message_exports.mergeConflictingProperty(property2, propertyOf, v1.value, v2.value));
  }
  return v1;
}
function mergeValuesWithExplicit(v1, v2, property2, propertyOf, tieBreaker = defaultTieBreaker) {
  if (v1 === void 0 || v1.value === void 0) {
    return v2;
  }
  if (v1.explicit && !v2.explicit) {
    return v1;
  } else if (v2.explicit && !v1.explicit) {
    return v2;
  } else if (deepEqual(v1.value, v2.value)) {
    return v1;
  } else {
    return tieBreaker(v1, v2, property2, propertyOf);
  }
}
var Split;
var init_split = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/split.js"() {
    init_log3();
    init_util();
    Split = class {
      constructor(explicit = {}, implicit3 = {}) {
        this.explicit = explicit;
        this.implicit = implicit3;
      }
      clone() {
        return new Split(duplicate(this.explicit), duplicate(this.implicit));
      }
      combine() {
        return Object.assign(Object.assign({}, this.explicit), this.implicit);
      }
      get(key3) {
        return getFirstDefined(this.explicit[key3], this.implicit[key3]);
      }
      getWithExplicit(key3) {
        if (this.explicit[key3] !== void 0) {
          return { explicit: true, value: this.explicit[key3] };
        } else if (this.implicit[key3] !== void 0) {
          return { explicit: false, value: this.implicit[key3] };
        }
        return { explicit: false, value: void 0 };
      }
      setWithExplicit(key3, value4) {
        if (value4.value !== void 0) {
          this.set(key3, value4.value, value4.explicit);
        }
      }
      set(key3, value4, explicit) {
        delete this[explicit ? "implicit" : "explicit"][key3];
        this[explicit ? "explicit" : "implicit"][key3] = value4;
        return this;
      }
      copyKeyFromSplit(key3, s3) {
        if (s3.explicit[key3] !== void 0) {
          this.set(key3, s3.explicit[key3], true);
        } else if (s3.implicit[key3] !== void 0) {
          this.set(key3, s3.implicit[key3], false);
        }
      }
      copyKeyFromObject(key3, s3) {
        if (s3[key3] !== void 0) {
          this.set(key3, s3[key3], true);
        }
      }
      copyAll(other) {
        for (const key3 of keys4(other.combine())) {
          const val = other.getWithExplicit(key3);
          this.setWithExplicit(key3, val);
        }
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/index.js
var AncestorParse;
var init_data2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/index.js"() {
    init_split();
    AncestorParse = class extends Split {
      constructor(explicit = {}, implicit3 = {}, parseNothing = false) {
        super(explicit, implicit3);
        this.explicit = explicit;
        this.implicit = implicit3;
        this.parseNothing = parseNothing;
      }
      clone() {
        const clone = super.clone();
        clone.parseNothing = this.parseNothing;
        return clone;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/data.js
function isUrlData(data3) {
  return "url" in data3;
}
function isInlineData(data3) {
  return "values" in data3;
}
function isNamedData(data3) {
  return "name" in data3 && !isUrlData(data3) && !isInlineData(data3) && !isGenerator(data3);
}
function isGenerator(data3) {
  return data3 && (isSequenceGenerator(data3) || isSphereGenerator(data3) || isGraticuleGenerator(data3));
}
function isSequenceGenerator(data3) {
  return "sequence" in data3;
}
function isSphereGenerator(data3) {
  return "sphere" in data3;
}
function isGraticuleGenerator(data3) {
  return "graticule" in data3;
}
var MAIN, RAW;
var init_data3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/data.js"() {
    MAIN = "main";
    RAW = "raw";
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/transform.js
function isFilter(t) {
  return "filter" in t;
}
function isImputeSequence(t) {
  return (t === null || t === void 0 ? void 0 : t["stop"]) !== void 0;
}
function isLookup(t) {
  return "lookup" in t;
}
function isLookupData(from) {
  return "data" in from;
}
function isLookupSelection(from) {
  return "selection" in from;
}
function isPivot(t) {
  return "pivot" in t;
}
function isDensity(t) {
  return "density" in t;
}
function isQuantile2(t) {
  return "quantile" in t;
}
function isRegression(t) {
  return "regression" in t;
}
function isLoess(t) {
  return "loess" in t;
}
function isSample(t) {
  return "sample" in t;
}
function isWindow(t) {
  return "window" in t;
}
function isJoinAggregate(t) {
  return "joinaggregate" in t;
}
function isFlatten(t) {
  return "flatten" in t;
}
function isCalculate(t) {
  return "calculate" in t;
}
function isBin(t) {
  return "bin" in t;
}
function isImpute(t) {
  return "impute" in t;
}
function isTimeUnit(t) {
  return "timeUnit" in t;
}
function isAggregate2(t) {
  return "aggregate" in t;
}
function isStack(t) {
  return "stack" in t;
}
function isFold(t) {
  return "fold" in t;
}
function normalizeTransform(transform4) {
  return transform4.map((t) => {
    if (isFilter(t)) {
      return {
        filter: normalizeLogicalComposition(t.filter, normalizePredicate)
      };
    }
    return t;
  });
}
var init_transform6 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/transform.js"() {
    init_logical();
    init_predicate();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/conditional.js
function wrapCondition(model, channelDef, vgChannel, refFn) {
  const condition = isConditionalDef(channelDef) && channelDef.condition;
  const valueRef = refFn(channelDef);
  if (condition) {
    const conditions = array_default6(condition);
    const vgConditions = conditions.map((c2) => {
      const conditionValueRef = refFn(c2);
      const test2 = isConditionalSelection(c2) ? parseSelectionPredicate(model, c2.selection) : expression2(model, c2.test);
      return Object.assign({ test: test2 }, conditionValueRef);
    });
    return {
      [vgChannel]: [...vgConditions, ...valueRef !== void 0 ? [valueRef] : []]
    };
  } else {
    return valueRef !== void 0 ? { [vgChannel]: valueRef } : {};
  }
}
var init_conditional = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/conditional.js"() {
    init_vega_util();
    init_channeldef();
    init_predicate2();
    init_parse3();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/text.js
function text3(model, channel = "text") {
  const channelDef = model.encoding[channel];
  return wrapCondition(model, channelDef, channel, (cDef) => textRef(cDef, model.config));
}
function textRef(channelDef, config, expr2 = "datum") {
  if (channelDef) {
    if (isValueDef(channelDef)) {
      return signalOrValueRef(channelDef.value);
    }
    if (isFieldOrDatumDef(channelDef)) {
      const { format: format9, formatType } = getFormatMixins(channelDef);
      return formatSignalRef({ fieldOrDatumDef: channelDef, format: format9, formatType, expr: expr2, config });
    }
  }
  return void 0;
}
var init_text = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/text.js"() {
    init_channeldef();
    init_common();
    init_format();
    init_conditional();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/tooltip.js
function tooltip(model, opt = {}) {
  const { encoding, markDef, config, stack: stack3 } = model;
  const channelDef = encoding.tooltip;
  if (isArray_default(channelDef)) {
    return { tooltip: tooltipRefForEncoding({ tooltip: channelDef }, stack3, config, opt) };
  } else {
    const datum2 = opt.reactiveGeom ? "datum.datum" : "datum";
    return wrapCondition(model, channelDef, "tooltip", (cDef) => {
      const tooltipRefFromChannelDef = textRef(cDef, config, datum2);
      if (tooltipRefFromChannelDef) {
        return tooltipRefFromChannelDef;
      }
      if (cDef === null) {
        return void 0;
      }
      let markTooltip = getMarkPropOrConfig("tooltip", markDef, config);
      if (markTooltip === true) {
        markTooltip = { content: "encoding" };
      }
      if (isString_default(markTooltip)) {
        return { value: markTooltip };
      } else if (isObject_default(markTooltip)) {
        if (markTooltip.content === "encoding") {
          return tooltipRefForEncoding(encoding, stack3, config, opt);
        } else {
          return { signal: datum2 };
        }
      }
      return void 0;
    });
  }
}
function tooltipData(encoding, stack3, config, { reactiveGeom } = {}) {
  const toSkip = {};
  const expr2 = reactiveGeom ? "datum.datum" : "datum";
  const tuples = [];
  function add7(fDef, channel) {
    const mainChannel = getMainRangeChannel(channel);
    const fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {
      type: encoding[mainChannel].type
    });
    const key3 = array_default6(title(fieldDef, config, { allowDisabling: false })).join(", ");
    let value4;
    if (isXorY(channel)) {
      const channel2 = channel === "x" ? "x2" : "y2";
      const fieldDef2 = getFieldDef(encoding[channel2]);
      if (isBinned(fieldDef.bin) && fieldDef2) {
        const startField = vgField(fieldDef, { expr: expr2 });
        const endField = vgField(fieldDef2, { expr: expr2 });
        const { format: format9, formatType } = getFormatMixins(fieldDef);
        value4 = binFormatExpression(startField, endField, format9, formatType, config);
        toSkip[channel2] = true;
      } else if (stack3 && stack3.fieldChannel === channel && stack3.offset === "normalize") {
        const { format: format9, formatType } = getFormatMixins(fieldDef);
        value4 = formatSignalRef({ fieldOrDatumDef: fieldDef, format: format9, formatType, expr: expr2, config, normalizeStack: true }).signal;
      }
    }
    value4 = value4 !== null && value4 !== void 0 ? value4 : textRef(fieldDef, config, expr2).signal;
    tuples.push({ channel, key: key3, value: value4 });
  }
  forEach(encoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      add7(channelDef, channel);
    } else if (hasConditionalFieldDef(channelDef)) {
      add7(channelDef.condition, channel);
    }
  });
  const out = {};
  for (const { channel, key: key3, value: value4 } of tuples) {
    if (!toSkip[channel] && !out[key3]) {
      out[$3(key3)] = value4;
    }
  }
  return out;
}
function tooltipRefForEncoding(encoding, stack3, config, { reactiveGeom } = {}) {
  const data3 = tooltipData(encoding, stack3, config, { reactiveGeom });
  const keyValues = entries(data3).map(({ key: key3, value: value4 }) => `${key3}: ${value4}`);
  return keyValues.length > 0 ? { signal: `{${keyValues.join(", ")}}` } : void 0;
}
var init_tooltip = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/tooltip.js"() {
    init_vega_util();
    init_bin4();
    init_channel();
    init_channeldef();
    init_encoding();
    init_util();
    init_common();
    init_format();
    init_conditional();
    init_text();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/aria.js
function aria(model) {
  const { markDef, config } = model;
  const enableAria = getMarkPropOrConfig("aria", markDef, config);
  if (enableAria === false) {
    return {};
  }
  return Object.assign(Object.assign(Object.assign({}, enableAria ? { aria: enableAria } : {}), ariaRoleDescription(model)), description2(model));
}
function ariaRoleDescription(model) {
  const { mark, markDef, config } = model;
  if (config.aria === false) {
    return {};
  }
  const ariaRoleDesc = getMarkPropOrConfig("ariaRoleDescription", markDef, config);
  if (ariaRoleDesc != null) {
    return { ariaRoleDescription: { value: ariaRoleDesc } };
  }
  return mark in VG_MARK_INDEX ? {} : { ariaRoleDescription: { value: mark } };
}
function description2(model) {
  const { encoding, markDef, config, stack: stack3 } = model;
  const channelDef = encoding.description;
  if (channelDef) {
    return wrapCondition(model, channelDef, "description", (cDef) => textRef(cDef, model.config));
  }
  const descriptionValue = getMarkPropOrConfig("description", markDef, config);
  if (descriptionValue != null) {
    return {
      description: signalOrValueRef(descriptionValue)
    };
  }
  if (config.aria === false) {
    return {};
  }
  const data3 = tooltipData(encoding, stack3, config);
  if (isEmpty(data3)) {
    return void 0;
  }
  return {
    description: {
      signal: entries(data3).map(({ key: key3, value: value4 }) => `${key3} + ": " + (${value4})`).join(' + "; " + ')
    }
  };
}
var init_aria = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/aria.js"() {
    init_util();
    init_common();
    init_vega_schema();
    init_conditional();
    init_text();
    init_tooltip();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/nonposition.js
function nonPosition(channel, model, opt = {}) {
  const { markDef, encoding, config } = model;
  const { vgChannel } = opt;
  let { defaultRef, defaultValue } = opt;
  if (defaultRef === void 0) {
    defaultValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : getMarkPropOrConfig(channel, markDef, config, { vgChannel, ignoreVgConfig: true });
    if (defaultValue !== void 0) {
      defaultRef = signalOrValueRef(defaultValue);
    }
  }
  const channelDef = encoding[channel];
  return wrapCondition(model, channelDef, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, (cDef) => {
    return midPoint({
      channel,
      channelDef: cDef,
      markDef,
      config,
      scaleName: model.scaleName(channel),
      scale: model.getScaleComponent(channel),
      stack: null,
      defaultRef
    });
  });
}
var init_nonposition = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/nonposition.js"() {
    init_common();
    init_conditional();
    init_valueref();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/color.js
function color6(model, opt = { filled: void 0 }) {
  var _a2, _b, _c2, _d2;
  const { markDef, encoding, config } = model;
  const { type: markType2 } = markDef;
  const filled2 = (_a2 = opt.filled) !== null && _a2 !== void 0 ? _a2 : getMarkPropOrConfig("filled", markDef, config);
  const transparentIfNeeded = contains2(["bar", "point", "circle", "square", "geoshape"], markType2) ? "transparent" : void 0;
  const defaultFill = (_c2 = (_b = getMarkPropOrConfig(filled2 === true ? "color" : void 0, markDef, config, { vgChannel: "fill" })) !== null && _b !== void 0 ? _b : config.mark[filled2 === true && "color"]) !== null && _c2 !== void 0 ? _c2 : transparentIfNeeded;
  const defaultStroke = (_d2 = getMarkPropOrConfig(filled2 === false ? "color" : void 0, markDef, config, { vgChannel: "stroke" })) !== null && _d2 !== void 0 ? _d2 : config.mark[filled2 === false && "color"];
  const colorVgChannel = filled2 ? "fill" : "stroke";
  const fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, defaultFill ? { fill: signalOrValueRef(defaultFill) } : {}), defaultStroke ? { stroke: signalOrValueRef(defaultStroke) } : {});
  if (markDef.color && (filled2 ? markDef.fill : markDef.stroke)) {
    warn2(message_exports.droppingColor("property", { fill: "fill" in markDef, stroke: "stroke" in markDef }));
  }
  return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition("color", model, {
    vgChannel: colorVgChannel,
    defaultValue: filled2 ? defaultFill : defaultStroke
  })), nonPosition("fill", model, {
    defaultValue: encoding.fill ? defaultFill : void 0
  })), nonPosition("stroke", model, {
    defaultValue: encoding.stroke ? defaultStroke : void 0
  }));
}
var init_color5 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/color.js"() {
    init_log3();
    init_util();
    init_common();
    init_nonposition();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/offset.js
function getOffset(channel, markDef) {
  const offsetChannel = getOffsetChannel(channel);
  const markDefOffsetValue = markDef[offsetChannel];
  if (markDefOffsetValue) {
    return markDefOffsetValue;
  }
  return void 0;
}
var init_offset = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/offset.js"() {
    init_channel();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/position-point.js
function pointPosition(channel, model, { defaultPos, vgChannel, isMidPoint }) {
  const { encoding, markDef, config, stack: stack3 } = model;
  const channelDef = encoding[channel];
  const channel2Def = encoding[getSecondaryRangeChannel(channel)];
  const scaleName = model.scaleName(channel);
  const scale8 = model.getScaleComponent(channel);
  const offset5 = getOffset(channel, markDef);
  const defaultRef = pointPositionDefaultRef({
    model,
    defaultPos,
    channel,
    scaleName,
    scale: scale8
  });
  const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ? { field: model.getName(channel) } : positionRef({
    channel,
    channelDef,
    channel2Def,
    markDef,
    config,
    isMidPoint,
    scaleName,
    scale: scale8,
    stack: stack3,
    offset: offset5,
    defaultRef
  });
  return valueRef ? { [vgChannel || channel]: valueRef } : void 0;
}
function positionRef(params2) {
  const { channel, channelDef, isMidPoint, scaleName, stack: stack3, offset: offset5, markDef, config } = params2;
  if (isFieldOrDatumDef(channelDef) && stack3 && channel === stack3.fieldChannel) {
    if (isFieldDef(channelDef)) {
      const band5 = getBand({
        channel,
        fieldDef: channelDef,
        isMidPoint,
        markDef,
        stack: stack3,
        config
      });
      if (band5 !== void 0) {
        return interpolatedSignalRef({
          scaleName,
          fieldOrDatumDef: channelDef,
          startSuffix: "start",
          band: band5,
          offset: offset5
        });
      }
    }
    return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "end" }, { offset: offset5 });
  }
  return midPointRefWithPositionInvalidTest(params2);
}
function pointPositionDefaultRef({ model, defaultPos, channel, scaleName, scale: scale8 }) {
  const { markDef, config } = model;
  return () => {
    const mainChannel = getMainRangeChannel(channel);
    const vgChannel = getVgPositionChannel(channel);
    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, { vgChannel });
    if (definedValueOrConfig !== void 0) {
      return widthHeightValueOrSignalRef(channel, definedValueOrConfig);
    }
    switch (defaultPos) {
      case "zeroOrMin":
      case "zeroOrMax":
        if (scaleName) {
          const scaleType2 = scale8.get("type");
          if (contains2([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType2)) {
          } else {
            if (scale8.domainDefinitelyIncludesZero()) {
              return {
                scale: scaleName,
                value: 0
              };
            }
          }
        }
        if (defaultPos === "zeroOrMin") {
          return mainChannel === "y" ? { field: { group: "height" } } : { value: 0 };
        } else {
          switch (mainChannel) {
            case "radius":
              return {
                signal: `min(${model.width.signal},${model.height.signal})/2`
              };
            case "theta":
              return { signal: "2*PI" };
            case "x":
              return { field: { group: "width" } };
            case "y":
              return { value: 0 };
          }
        }
        break;
      case "mid": {
        const sizeRef = model[getSizeChannel(channel)];
        return Object.assign(Object.assign({}, sizeRef), { mult: 0.5 });
      }
    }
    return void 0;
  };
}
var init_position_point = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/position-point.js"() {
    init_channel();
    init_channeldef();
    init_scale();
    init_util();
    init_common();
    init_offset();
    init_valueref();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/position-align.js
function vgAlignedPositionChannel(channel, markDef, config, defaultAlign = "middle") {
  if (channel === "radius" || channel === "theta") {
    return getVgPositionChannel(channel);
  }
  const alignChannel = channel === "x" ? "align" : "baseline";
  const align2 = getMarkPropOrConfig(alignChannel, markDef, config);
  if (channel === "x") {
    return ALIGNED_X_CHANNEL[align2 || (defaultAlign === "top" ? "left" : "center")];
  } else {
    return BASELINED_Y_CHANNEL[align2 || defaultAlign];
  }
}
var ALIGNED_X_CHANNEL, BASELINED_Y_CHANNEL;
var init_position_align = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/position-align.js"() {
    init_channel();
    init_common();
    ALIGNED_X_CHANNEL = {
      left: "x",
      center: "xc",
      right: "x2"
    };
    BASELINED_Y_CHANNEL = {
      top: "y",
      middle: "yc",
      bottom: "y2"
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/position-range.js
function pointOrRangePosition(channel, model, { defaultPos, defaultPos2, range: range7 }) {
  if (range7) {
    return rangePosition(channel, model, { defaultPos, defaultPos2 });
  }
  return pointPosition(channel, model, { defaultPos });
}
function rangePosition(channel, model, { defaultPos, defaultPos2 }) {
  const { markDef, config } = model;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);
  const vgChannel = pos2Mixins[sizeChannel] ? vgAlignedPositionChannel(channel, markDef, config) : getVgPositionChannel(channel);
  return Object.assign(Object.assign({}, pointPosition(channel, model, { defaultPos, vgChannel })), pos2Mixins);
}
function pointPosition2OrSize(model, defaultPos, channel) {
  const { encoding, mark, markDef, stack: stack3, config } = model;
  const baseChannel = getMainRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const channelDef = encoding[baseChannel];
  const scaleName = model.scaleName(baseChannel);
  const scale8 = model.getScaleComponent(baseChannel);
  const offset5 = channel in encoding || channel in markDef ? getOffset(channel, model.markDef) : getOffset(baseChannel, model.markDef);
  if (!channelDef && (channel === "x2" || channel === "y2") && (encoding.latitude || encoding.longitude)) {
    return { [vgChannel]: { field: model.getName(channel) } };
  }
  const valueRef = position2Ref({
    channel,
    channelDef,
    channel2Def: encoding[channel],
    markDef,
    config,
    scaleName,
    scale: scale8,
    stack: stack3,
    offset: offset5,
    defaultRef: void 0
  });
  if (valueRef !== void 0) {
    return { [vgChannel]: valueRef };
  }
  return position2orSize(channel, markDef) || position2orSize(channel, {
    [channel]: getMarkStyleConfig(channel, markDef, config.style),
    [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)
  }) || position2orSize(channel, config[mark]) || position2orSize(channel, config.mark) || {
    [vgChannel]: pointPositionDefaultRef({
      model,
      defaultPos,
      channel,
      scaleName,
      scale: scale8
    })()
  };
}
function position2Ref({ channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale8, stack: stack3, offset: offset5, defaultRef }) {
  if (isFieldOrDatumDef(channelDef) && stack3 && channel.charAt(0) === stack3.fieldChannel.charAt(0)) {
    return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "start" }, { offset: offset5 });
  }
  return midPointRefWithPositionInvalidTest({
    channel,
    channelDef: channel2Def,
    scaleName,
    scale: scale8,
    stack: stack3,
    markDef,
    config,
    offset: offset5,
    defaultRef
  });
}
function position2orSize(channel, markDef) {
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  if (markDef[vgChannel] !== void 0) {
    return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[vgChannel]) };
  } else if (markDef[channel] !== void 0) {
    return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[channel]) };
  } else if (markDef[sizeChannel]) {
    return { [sizeChannel]: widthHeightValueOrSignalRef(channel, markDef[sizeChannel]) };
  }
  return void 0;
}
var init_position_range = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/position-range.js"() {
    init_channel();
    init_channeldef();
    init_common();
    init_offset();
    init_position_align();
    init_position_point();
    init_valueref();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/position-rect.js
function rectPosition(model, channel, mark) {
  var _a2, _b, _c2, _d2;
  const { config, encoding, markDef, stack: stack3 } = model;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const channelDef = encoding[channel];
  const channelDef2 = encoding[channel2];
  const scale8 = model.getScaleComponent(channel);
  const scaleType2 = scale8 ? scale8.get("type") : void 0;
  const scaleName = model.scaleName(channel);
  const orient3 = markDef.orient;
  const hasSizeDef = (_b = (_a2 = encoding[sizeChannel]) !== null && _a2 !== void 0 ? _a2 : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig("size", markDef, config, { vgChannel: sizeChannel });
  const isBarBand = mark === "bar" && (channel === "x" ? orient3 === "vertical" : orient3 === "horizontal");
  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !hasSizeDef && !hasDiscreteDomain(scaleType2)) {
    const band5 = getBand({ channel, fieldDef: channelDef, stack: stack3, markDef, config });
    const axis = (_c2 = model.component.axes[channel]) === null || _c2 === void 0 ? void 0 : _c2[0];
    const axisTranslate = (_d2 = axis === null || axis === void 0 ? void 0 : axis.get("translate")) !== null && _d2 !== void 0 ? _d2 : 0.5;
    return rectBinPosition({
      fieldDef: channelDef,
      fieldDef2: channelDef2,
      channel,
      markDef,
      scaleName,
      band: band5,
      axisTranslate,
      spacing: isXorY(channel) ? getMarkPropOrConfig("binSpacing", markDef, config) : void 0,
      reverse: scale8.get("reverse"),
      config
    });
  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType2) || isBarBand) && !channelDef2) {
    return positionAndSize(mark, channelDef, channel, model);
  } else {
    return rangePosition(channel, model, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
  }
}
function defaultSizeRef(mark, sizeChannel, scaleName, scale8, config, band5) {
  if (scale8) {
    const scaleType2 = scale8.get("type");
    if (scaleType2 === "point" || scaleType2 === "band") {
      if (config[mark].discreteBandSize !== void 0) {
        return { value: config[mark].discreteBandSize };
      }
      if (scaleType2 === ScaleType.POINT) {
        const scaleRange = scale8.get("range");
        if (isVgRangeStep(scaleRange) && isNumber_default(scaleRange.step)) {
          return { value: scaleRange.step - 2 };
        }
        return { value: DEFAULT_STEP - 2 };
      } else {
        return { scale: scaleName, band: band5 };
      }
    } else {
      return { value: config[mark].continuousBandSize };
    }
  }
  const step = getViewConfigDiscreteStep(config.view, sizeChannel);
  const value4 = getFirstDefined(
    config[mark].discreteBandSize,
    step - 2
  );
  return value4 !== void 0 ? { value: value4 } : void 0;
}
function positionAndSize(mark, fieldDef, channel, model) {
  var _a2;
  const { markDef, encoding, config, stack: stack3 } = model;
  const orient3 = markDef.orient;
  const scaleName = model.scaleName(channel);
  const scale8 = model.getScaleComponent(channel);
  const vgSizeChannel = getSizeChannel(channel);
  const channel2 = getSecondaryRangeChannel(channel);
  const useVlSizeChannel = orient3 === "horizontal" && channel === "y" || orient3 === "vertical" && channel === "x";
  const sizeFromMarkOrConfig = getMarkPropOrConfig(useVlSizeChannel ? "size" : vgSizeChannel, markDef, config, {
    vgChannel: vgSizeChannel
  });
  let sizeMixins;
  if (encoding.size || sizeFromMarkOrConfig !== void 0) {
    if (useVlSizeChannel) {
      sizeMixins = nonPosition("size", model, { vgChannel: vgSizeChannel, defaultValue: sizeFromMarkOrConfig });
    } else {
      warn2(message_exports.cannotApplySizeToNonOrientedMark(markDef.type));
    }
  }
  const band5 = (_a2 = isFieldOrDatumDef(fieldDef) ? getBand({ channel, fieldDef, markDef, stack: stack3, config }) : void 0) !== null && _a2 !== void 0 ? _a2 : 1;
  sizeMixins = sizeMixins || { [vgSizeChannel]: defaultSizeRef(mark, vgSizeChannel, scaleName, scale8, config, band5) };
  const center = (scale8 === null || scale8 === void 0 ? void 0 : scale8.get("type")) !== "band" || !("band" in sizeMixins[vgSizeChannel]);
  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, center ? "middle" : "top");
  const offset5 = getOffset(channel, markDef);
  const posRef = midPointRefWithPositionInvalidTest({
    channel,
    channelDef: fieldDef,
    markDef,
    config,
    scaleName,
    scale: scale8,
    stack: stack3,
    offset: offset5,
    defaultRef: pointPositionDefaultRef({ model, defaultPos: "mid", channel, scaleName, scale: scale8 }),
    band: center ? 0.5 : (1 - band5) / 2
  });
  if (vgSizeChannel) {
    return Object.assign({ [vgChannel]: posRef }, sizeMixins);
  } else {
    const vgChannel2 = getVgPositionChannel(channel2);
    const sizeRef = sizeMixins[vgSizeChannel];
    const sizeOffset = offset5 ? Object.assign(Object.assign({}, sizeRef), { offset: offset5 }) : sizeRef;
    return {
      [vgChannel]: posRef,
      [vgChannel2]: isArray_default(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), { offset: sizeOffset })] : Object.assign(Object.assign({}, posRef), { offset: sizeOffset })
    };
  }
}
function getBinSpacing(channel, spacing, reverse6, translate5, offset5) {
  if (isPolarPositionChannel(channel)) {
    return 0;
  }
  const spacingOffset = channel === "x" || channel === "y2" ? -spacing / 2 : spacing / 2;
  if (isSignalRef(reverse6)) {
    const offsetExpr = signalOrStringValue(offset5);
    return {
      signal: `${reverse6.signal} ? ${translate5 - spacingOffset}${offsetExpr ? "-" + offsetExpr : ""} : ${translate5 + spacingOffset}${offsetExpr ? "+" + offsetExpr : ""}`
    };
  } else {
    if (isSignalRef(offset5)) {
      const translateAndSpacingOffset = translate5 + (reverse6 ? -spacingOffset : spacingOffset);
      return {
        signal: `${translateAndSpacingOffset || ""}${reverse6 ? " - " : translateAndSpacingOffset ? " + " : ""}${offset5.signal}`
      };
    }
    offset5 = offset5 || 0;
    return translate5 + (reverse6 ? -offset5 - spacingOffset : +offset5 + spacingOffset);
  }
}
function rectBinPosition({ fieldDef, fieldDef2, channel, band: band5, scaleName, markDef, spacing = 0, axisTranslate, reverse: reverse6, config }) {
  const channel2 = getSecondaryRangeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const vgChannel2 = getVgPositionChannel(channel2);
  const offset5 = getOffset(channel, markDef);
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {
    return {
      [vgChannel2]: rectBinRef({
        channel,
        fieldDef,
        scaleName,
        markDef,
        band: (1 - band5) / 2,
        offset: getBinSpacing(channel2, spacing, reverse6, axisTranslate, offset5),
        config
      }),
      [vgChannel]: rectBinRef({
        channel,
        fieldDef,
        scaleName,
        markDef,
        band: 1 - (1 - band5) / 2,
        offset: getBinSpacing(channel, spacing, reverse6, axisTranslate, offset5),
        config
      })
    };
  } else if (isBinned(fieldDef.bin)) {
    const startRef = valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: getBinSpacing(channel2, spacing, reverse6, axisTranslate, offset5) });
    if (isFieldDef(fieldDef2)) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: getBinSpacing(channel, spacing, reverse6, axisTranslate, offset5) })
      };
    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: {
          signal: `scale("${scaleName}", ${vgField(fieldDef, { expr: "datum" })} + ${fieldDef.bin.step})`,
          offset: getBinSpacing(channel, spacing, reverse6, axisTranslate, offset5)
        }
      };
    }
  }
  warn2(message_exports.channelRequiredForBinned(channel2));
  return void 0;
}
function rectBinRef({ channel, fieldDef, scaleName, markDef, band: band5, offset: offset5, config }) {
  const r2 = interpolatedSignalRef({
    scaleName,
    fieldOrDatumDef: fieldDef,
    band: band5,
    offset: offset5
  });
  return wrapPositionInvalidTest({
    fieldDef,
    channel,
    markDef,
    ref: r2,
    config
  });
}
var init_position_rect = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/position-rect.js"() {
    init_vega_util();
    init_bin4();
    init_channel();
    init_channeldef();
    init_config();
    init_log3();
    init_scale();
    init_util();
    init_vega_schema();
    init_common();
    init_nonposition();
    init_offset();
    init_position_align();
    init_position_point();
    init_position_range();
    init_valueref();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/base.js
function baseEncodeEntry(model, ignore) {
  const { fill: fill3 = void 0, stroke: stroke3 = void 0 } = ignore.color === "include" ? color6(model) : {};
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, "fill", fill3)), wrapAllFieldsInvalid(model, "stroke", stroke3)), nonPosition("opacity", model)), nonPosition("fillOpacity", model)), nonPosition("strokeOpacity", model)), nonPosition("strokeWidth", model)), nonPosition("strokeDash", model)), tooltip(model)), text3(model, "href")), aria(model));
}
function wrapAllFieldsInvalid(model, channel, valueRef) {
  const { config, mark, markDef } = model;
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid === "hide" && valueRef && !isPathMark(mark)) {
    const test2 = allFieldsInvalidPredicate(model, { invalid: true, channels: SCALE_CHANNELS });
    if (test2) {
      return {
        [channel]: [
          { test: test2, value: null },
          ...array_default6(valueRef)
        ]
      };
    }
  }
  return valueRef ? { [channel]: valueRef } : {};
}
function markDefProperties(mark, ignore) {
  return VG_MARK_CONFIGS.reduce((m2, prop) => {
    if (!ALWAYS_IGNORE.has(prop) && mark[prop] !== void 0 && ignore[prop] !== "ignore") {
      m2[prop] = signalOrValueRef(mark[prop]);
    }
    return m2;
  }, {});
}
function allFieldsInvalidPredicate(model, { invalid = false, channels }) {
  const filterIndex = channels.reduce((aggregator, channel) => {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const scaleType2 = scaleComponent.get("type");
      const field4 = model.vgField(channel, { expr: "datum" });
      if (field4 && hasContinuousDomain(scaleType2)) {
        aggregator[field4] = true;
      }
    }
    return aggregator;
  }, {});
  const fields = keys4(filterIndex);
  if (fields.length > 0) {
    const op = invalid ? "||" : "&&";
    return fields.map((field4) => fieldInvalidPredicate(field4, invalid)).join(` ${op} `);
  }
  return void 0;
}
var ALWAYS_IGNORE;
var init_base3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/base.js"() {
    init_vega_util();
    init_channel();
    init_mark();
    init_scale();
    init_util();
    init_vega_schema();
    init_common();
    init_aria();
    init_color5();
    init_nonposition();
    init_text();
    init_tooltip();
    init_valueref();
    init_color5();
    init_conditional();
    init_nonposition();
    init_position_point();
    init_position_range();
    init_position_rect();
    init_text();
    init_tooltip();
    ALWAYS_IGNORE = /* @__PURE__ */ new Set(["aria"]);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/defined.js
function defined(model) {
  const { config, markDef } = model;
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid) {
    const signal = allFieldsInvalidPredicate2(model, { channels: POSITION_SCALE_CHANNELS });
    if (signal) {
      return { defined: { signal } };
    }
  }
  return {};
}
function allFieldsInvalidPredicate2(model, { invalid = false, channels }) {
  const filterIndex = channels.reduce((aggregator, channel) => {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const scaleType2 = scaleComponent.get("type");
      const field4 = model.vgField(channel, { expr: "datum" });
      if (field4 && hasContinuousDomain(scaleType2)) {
        aggregator[field4] = true;
      }
    }
    return aggregator;
  }, {});
  const fields = keys4(filterIndex);
  if (fields.length > 0) {
    const op = invalid ? "||" : "&&";
    return fields.map((field4) => fieldInvalidPredicate(field4, invalid)).join(` ${op} `);
  }
  return void 0;
}
function valueIfDefined(prop, value4) {
  if (value4 !== void 0) {
    return { [prop]: signalOrValueRef(value4) };
  }
  return void 0;
}
var init_defined = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/defined.js"() {
    init_channel();
    init_scale();
    init_util();
    init_common();
    init_valueref();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/index.js
var init_encode = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/encode/index.js"() {
    init_base3();
    init_color5();
    init_conditional();
    init_defined();
    init_nonposition();
    init_position_point();
    init_position_range();
    init_position_rect();
    init_text();
    init_tooltip();
    init_aria();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/nearest.js
var VORONOI, nearest, nearest_default;
var init_nearest = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/nearest.js"() {
    init_log3();
    init_mark();
    init_encode();
    VORONOI = "voronoi";
    nearest = {
      has: (selCmpt) => {
        return selCmpt.type !== "interval" && selCmpt.nearest;
      },
      parse: (model, selCmpt) => {
        if (selCmpt.events) {
          for (const s3 of selCmpt.events) {
            s3.markname = model.getName(VORONOI);
          }
        }
      },
      marks: (model, selCmpt, marks) => {
        const { x: x7, y: y7 } = selCmpt.project.hasChannel;
        const markType2 = model.mark;
        if (isPathMark(markType2)) {
          warn2(message_exports.nearestNotSupportForContinuous(markType2));
          return marks;
        }
        const cellDef = {
          name: model.getName(VORONOI),
          type: "path",
          interactive: true,
          from: { data: model.getName("marks") },
          encode: {
            update: Object.assign({ fill: { value: "transparent" }, strokeWidth: { value: 0.35 }, stroke: { value: "transparent" }, isVoronoi: { value: true } }, tooltip(model, { reactiveGeom: true }))
          },
          transform: [
            {
              type: "voronoi",
              x: { expr: x7 || !y7 ? "datum.datum.x || 0" : "0" },
              y: { expr: y7 || !x7 ? "datum.datum.y || 0" : "0" },
              size: [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")]
            }
          ]
        };
        let index8 = 0;
        let exists = false;
        marks.forEach((mark, i) => {
          var _a2;
          const name4 = (_a2 = mark.name) !== null && _a2 !== void 0 ? _a2 : "";
          if (name4 === model.component.mark[0].name) {
            index8 = i;
          } else if (name4.indexOf(VORONOI) >= 0) {
            exists = true;
          }
        });
        if (!exists) {
          marks.splice(index8 + 1, 0, cellDef);
        }
        return marks;
      }
    };
    nearest_default = nearest;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/dataflow.js
var DataFlowNode, OutputNode;
var init_dataflow = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/dataflow.js"() {
    init_util();
    DataFlowNode = class {
      constructor(parent, debugName) {
        this.debugName = debugName;
        this._children = [];
        this._parent = null;
        if (parent) {
          this.parent = parent;
        }
      }
      clone() {
        throw new Error("Cannot clone node");
      }
      get parent() {
        return this._parent;
      }
      set parent(parent) {
        this._parent = parent;
        if (parent) {
          parent.addChild(this);
        }
      }
      get children() {
        return this._children;
      }
      numChildren() {
        return this._children.length;
      }
      addChild(child, loc) {
        if (this._children.indexOf(child) > -1) {
          console.warn("Attempt to add the same child twice.");
          return;
        }
        if (loc !== void 0) {
          this._children.splice(loc, 0, child);
        } else {
          this._children.push(child);
        }
      }
      removeChild(oldChild) {
        const loc = this._children.indexOf(oldChild);
        this._children.splice(loc, 1);
        return loc;
      }
      remove() {
        let loc = this._parent.removeChild(this);
        for (const child of this._children) {
          child._parent = this._parent;
          this._parent.addChild(child, loc++);
        }
      }
      insertAsParentOf(other) {
        const parent = other.parent;
        parent.removeChild(this);
        this.parent = parent;
        other.parent = this;
      }
      swapWithParent() {
        const parent = this._parent;
        const newParent = parent.parent;
        for (const child of this._children) {
          child.parent = parent;
        }
        this._children = [];
        parent.removeChild(this);
        parent.parent.removeChild(parent);
        this.parent = newParent;
        parent.parent = this;
      }
    };
    OutputNode = class extends DataFlowNode {
      constructor(parent, source5, type4, refCounts) {
        super(parent, source5);
        this.type = type4;
        this.refCounts = refCounts;
        this._source = this._name = source5;
        if (this.refCounts && !(this._name in this.refCounts)) {
          this.refCounts[this._name] = 0;
        }
      }
      clone() {
        const cloneObj = new this.constructor();
        cloneObj.debugName = "clone_" + this.debugName;
        cloneObj._source = this._source;
        cloneObj._name = "clone_" + this._name;
        cloneObj.type = this.type;
        cloneObj.refCounts = this.refCounts;
        cloneObj.refCounts[cloneObj._name] = 0;
        return cloneObj;
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      hash() {
        if (this._hash === void 0) {
          this._hash = `Output ${uniqueId()}`;
        }
        return this._hash;
      }
      getSource() {
        this.refCounts[this._name]++;
        return this._source;
      }
      isRequired() {
        return !!this.refCounts[this._name];
      }
      setSource(source5) {
        this._source = source5;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/timeunit.js
var TimeUnitNode;
var init_timeunit2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/timeunit.js"() {
    init_tslib_es6();
    init_channel();
    init_channeldef();
    init_timeunit();
    init_util();
    init_model();
    init_dataflow();
    TimeUnitNode = class extends DataFlowNode {
      constructor(parent, formula) {
        super(parent);
        this.formula = formula;
      }
      clone() {
        return new TimeUnitNode(null, duplicate(this.formula));
      }
      static makeFromEncoding(parent, model) {
        const formula = model.reduceFieldDef((timeUnitComponent, fieldDef, channel) => {
          const { field: field4, timeUnit } = fieldDef;
          const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0;
          const band5 = isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.stack, model.markDef, model.config);
          if (timeUnit) {
            const as = vgField(fieldDef, { forAs: true });
            timeUnitComponent[hash({
              as,
              field: field4,
              timeUnit
            })] = Object.assign({
              as,
              field: field4,
              timeUnit
            }, band5 ? { band: true } : {});
          }
          return timeUnitComponent;
        }, {});
        if (isEmpty(formula)) {
          return null;
        }
        return new TimeUnitNode(parent, formula);
      }
      static makeFromTransform(parent, t) {
        const _a2 = Object.assign({}, t), { timeUnit } = _a2, other = __rest(_a2, ["timeUnit"]);
        const normalizedTimeUnit = normalizeTimeUnit(timeUnit);
        const component = Object.assign(Object.assign({}, other), { timeUnit: normalizedTimeUnit });
        return new TimeUnitNode(parent, {
          [hash(component)]: component
        });
      }
      merge(other) {
        this.formula = Object.assign({}, this.formula);
        for (const key3 in other.formula) {
          if (!this.formula[key3] || other.formula[key3].band) {
            this.formula[key3] = other.formula[key3];
          }
        }
        for (const child of other.children) {
          other.removeChild(child);
          child.parent = this;
        }
        other.remove();
      }
      producedFields() {
        return new Set(vals(this.formula).map((f) => f.as));
      }
      dependentFields() {
        return new Set(vals(this.formula).map((f) => f.field));
      }
      hash() {
        return `TimeUnit ${hash(this.formula)}`;
      }
      assemble() {
        const transforms2 = [];
        for (const f of vals(this.formula)) {
          const { field: field4, as, timeUnit } = f;
          const _a2 = normalizeTimeUnit(timeUnit), { unit: unit3, utc } = _a2, params2 = __rest(_a2, ["unit", "utc"]);
          transforms2.push(Object.assign(Object.assign(Object.assign(Object.assign({ field: replacePathInField(field4), type: "timeunit" }, unit3 ? { units: getTimeUnitParts(unit3) } : {}), utc ? { timezone: "utc" } : {}), params2), { as: [as, `${as}_end`] }));
        }
        return transforms2;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/project.js
var TUPLE_FIELDS, SelectionProjectionComponent, project2, project_default2;
var init_project2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/project.js"() {
    init_tslib_es6();
    init_vega_util();
    init_channel();
    init_log3();
    init_scale();
    init_util();
    init_timeunit2();
    TUPLE_FIELDS = "_tuple_fields";
    SelectionProjectionComponent = class {
      constructor(...items2) {
        this.items = items2;
        this.hasChannel = {};
        this.hasField = {};
      }
    };
    project2 = {
      has: () => {
        return true;
      },
      parse: (model, selCmpt, selDef) => {
        var _a2, _b, _c2;
        const name4 = selCmpt.name;
        const proj = (_a2 = selCmpt.project) !== null && _a2 !== void 0 ? _a2 : selCmpt.project = new SelectionProjectionComponent();
        const parsed = {};
        const timeUnits2 = {};
        const signals = /* @__PURE__ */ new Set();
        const signalName = (p, range7) => {
          const suffix = range7 === "visual" ? p.channel : p.field;
          let sg = varName(`${name4}_${suffix}`);
          for (let counter = 1; signals.has(sg); counter++) {
            sg = varName(`${name4}_${suffix}_${counter}`);
          }
          signals.add(sg);
          return { [range7]: sg };
        };
        if (!selDef.fields && !selDef.encodings) {
          const cfg = model.config.selection[selDef.type];
          if (selDef.init) {
            for (const init2 of array_default6(selDef.init)) {
              for (const key3 of keys4(init2)) {
                if (isSingleDefUnitChannel(key3)) {
                  (selDef.encodings || (selDef.encodings = [])).push(key3);
                } else {
                  if (selDef.type === "interval") {
                    warn2('Interval selections should be initialized using "x" and/or "y" keys.');
                    selDef.encodings = cfg.encodings;
                  } else {
                    (selDef.fields || (selDef.fields = [])).push(key3);
                  }
                }
              }
            }
          } else {
            selDef.encodings = cfg.encodings;
            selDef.fields = cfg.fields;
          }
        }
        for (const field4 of (_b = selDef.fields) !== null && _b !== void 0 ? _b : []) {
          const p = { type: "E", field: field4 };
          p.signals = Object.assign({}, signalName(p, "data"));
          proj.items.push(p);
          proj.hasField[field4] = p;
        }
        for (const channel of (_c2 = selDef.encodings) !== null && _c2 !== void 0 ? _c2 : []) {
          const fieldDef = model.fieldDef(channel);
          if (fieldDef) {
            let field4 = fieldDef.field;
            if (fieldDef.aggregate) {
              warn2(message_exports.cannotProjectAggregate(channel, fieldDef.aggregate));
              continue;
            } else if (!field4) {
              warn2(message_exports.cannotProjectOnChannelWithoutField(channel));
              continue;
            }
            if (fieldDef.timeUnit) {
              field4 = model.vgField(channel);
              const component = {
                timeUnit: fieldDef.timeUnit,
                as: field4,
                field: fieldDef.field
              };
              timeUnits2[hash(component)] = component;
            }
            if (!parsed[field4]) {
              let type4 = "E";
              if (selCmpt.type === "interval") {
                const scaleType2 = model.getScaleComponent(channel).get("type");
                if (hasContinuousDomain(scaleType2)) {
                  type4 = "R";
                }
              } else if (fieldDef.bin) {
                type4 = "R-RE";
              }
              const p = { field: field4, channel, type: type4 };
              p.signals = Object.assign(Object.assign({}, signalName(p, "data")), signalName(p, "visual"));
              proj.items.push(parsed[field4] = p);
              proj.hasField[field4] = proj.hasChannel[channel] = parsed[field4];
            }
          } else {
            warn2(message_exports.cannotProjectOnChannelWithoutField(channel));
          }
        }
        if (selDef.init) {
          const parseInit = (i) => {
            return proj.items.map((p) => i[p.channel] !== void 0 ? i[p.channel] : i[p.field]);
          };
          if (selDef.type === "interval") {
            selCmpt.init = parseInit(selDef.init);
          } else {
            const init2 = array_default6(selDef.init);
            selCmpt.init = init2.map(parseInit);
          }
        }
        if (!isEmpty(timeUnits2)) {
          proj.timeUnit = new TimeUnitNode(null, timeUnits2);
        }
      },
      signals: (model, selCmpt, allSignals) => {
        const name4 = selCmpt.name + TUPLE_FIELDS;
        const hasSignal2 = allSignals.filter((s3) => s3.name === name4);
        return hasSignal2.length > 0 ? allSignals : allSignals.concat({
          name: name4,
          value: selCmpt.project.items.map((proj) => {
            const { signals, hasLegend } = proj, rest = __rest(proj, ["signals", "hasLegend"]);
            rest.field = replacePathInField(rest.field);
            return rest;
          })
        });
      }
    };
    project_default2 = project2;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/inputs.js
var inputBindings, inputs_default;
var init_inputs = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/inputs.js"() {
    init_vega_util();
    init_selection2();
    init_util();
    init_assemble();
    init_nearest();
    init_project2();
    init_selection();
    inputBindings = {
      has: (selCmpt) => {
        return selCmpt.type === "single" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind !== "scales" && !isLegendBinding(selCmpt.bind);
      },
      parse: (model, selCmpt, selDef, origDef) => {
        if (!origDef.on)
          delete selCmpt.events;
        if (!origDef.clear)
          delete selCmpt.clear;
      },
      topLevelSignals: (model, selCmpt, signals) => {
        const name4 = selCmpt.name;
        const proj = selCmpt.project;
        const bind4 = selCmpt.bind;
        const init2 = selCmpt.init && selCmpt.init[0];
        const datum2 = nearest_default.has(selCmpt) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
        proj.items.forEach((p, i) => {
          var _a2, _b;
          const sgname = varName(`${name4}_${p.field}`);
          const hasSignal2 = signals.filter((s3) => s3.name === sgname);
          if (!hasSignal2.length) {
            signals.unshift(Object.assign(Object.assign({ name: sgname }, init2 ? { init: assembleInit(init2[i]) } : { value: null }), { on: selCmpt.events ? [
              {
                events: selCmpt.events,
                update: `datum && item().mark.marktype !== 'group' ? ${datum2}[${$3(p.field)}] : null`
              }
            ] : [], bind: (_b = (_a2 = bind4[p.field]) !== null && _a2 !== void 0 ? _a2 : bind4[p.channel]) !== null && _b !== void 0 ? _b : bind4 }));
          }
        });
        return signals;
      },
      signals: (model, selCmpt, signals) => {
        const name4 = selCmpt.name;
        const proj = selCmpt.project;
        const signal = signals.filter((s3) => s3.name === name4 + TUPLE)[0];
        const fields = name4 + TUPLE_FIELDS;
        const values5 = proj.items.map((p) => varName(`${name4}_${p.field}`));
        const valid = values5.map((v) => `${v} !== null`).join(" && ");
        if (values5.length) {
          signal.update = `${valid} ? {fields: ${fields}, values: [${values5.join(", ")}]} : null`;
        }
        delete signal.value;
        delete signal.on;
        return signals;
      }
    };
    inputs_default = inputBindings;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/toggle.js
var TOGGLE, toggle, toggle_default;
var init_toggle = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/toggle.js"() {
    init_selection2();
    TOGGLE = "_toggle";
    toggle = {
      has: (selCmpt) => {
        return selCmpt.type === "multi" && !!selCmpt.toggle;
      },
      signals: (model, selCmpt, signals) => {
        return signals.concat({
          name: selCmpt.name + TOGGLE,
          value: false,
          on: [{ events: selCmpt.events, update: selCmpt.toggle }]
        });
      },
      modifyExpr: (model, selCmpt) => {
        const tpl = selCmpt.name + TUPLE;
        const signal = selCmpt.name + TOGGLE;
        return `${signal} ? null : ${tpl}, ` + (selCmpt.resolve === "global" ? `${signal} ? null : true, ` : `${signal} ? null : {unit: ${unitName(model)}}, `) + `${signal} ? ${tpl} : null`;
      }
    };
    toggle_default = toggle;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/clear.js
var clear, clear_default;
var init_clear = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/clear.js"() {
    init_vega_event_selector_module2();
    init_vega_util();
    init_selection2();
    init_util();
    init_inputs();
    init_toggle();
    clear = {
      has: (selCmpt) => {
        return selCmpt.clear !== void 0 && selCmpt.clear !== false;
      },
      parse: (model, selCmpt, selDef) => {
        if (selDef.clear) {
          selCmpt.clear = isString_default(selDef.clear) ? eventSelector2(selDef.clear, "scope") : selDef.clear;
        }
      },
      topLevelSignals: (model, selCmpt, signals) => {
        if (inputs_default.has(selCmpt)) {
          for (const proj of selCmpt.project.items) {
            const idx = signals.findIndex((n) => n.name === varName(`${selCmpt.name}_${proj.field}`));
            if (idx !== -1) {
              signals[idx].on.push({ events: selCmpt.clear, update: "null" });
            }
          }
        }
        return signals;
      },
      signals: (model, selCmpt, signals) => {
        function addClear(idx, update3) {
          if (idx !== -1 && signals[idx].on) {
            signals[idx].on.push({ events: selCmpt.clear, update: update3 });
          }
        }
        if (selCmpt.type === "interval") {
          for (const proj of selCmpt.project.items) {
            const vIdx = signals.findIndex((n) => n.name === proj.signals.visual);
            addClear(vIdx, "[0, 0]");
            if (vIdx === -1) {
              const dIdx = signals.findIndex((n) => n.name === proj.signals.data);
              addClear(dIdx, "null");
            }
          }
        } else {
          let tIdx = signals.findIndex((n) => n.name === selCmpt.name + TUPLE);
          addClear(tIdx, "null");
          if (toggle_default.has(selCmpt)) {
            tIdx = signals.findIndex((n) => n.name === selCmpt.name + TOGGLE);
            addClear(tIdx, "false");
          }
        }
        return signals;
      }
    };
    clear_default = clear;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/scales.js
function domain3(model, channel) {
  const scale8 = $3(model.scaleName(channel));
  return `domain(${scale8})`;
}
function isTopLevelLayer(model) {
  var _a2;
  return model.parent && isLayerModel(model.parent) && ((_a2 = !model.parent.parent) !== null && _a2 !== void 0 ? _a2 : isTopLevelLayer(model.parent.parent));
}
var scaleBindings, scales_default;
var init_scales = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/scales.js"() {
    init_vega_util();
    init_selection2();
    init_channel();
    init_log3();
    init_scale();
    init_model();
    scaleBindings = {
      has: (selCmpt) => {
        return selCmpt.type === "interval" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind === "scales";
      },
      parse: (model, selCmpt) => {
        const bound3 = selCmpt.scales = [];
        for (const proj of selCmpt.project.items) {
          const channel = proj.channel;
          if (!isScaleChannel(channel)) {
            continue;
          }
          const scale8 = model.getScaleComponent(channel);
          const scaleType2 = scale8 ? scale8.get("type") : void 0;
          if (!scale8 || !hasContinuousDomain(scaleType2)) {
            warn2(message_exports.SCALE_BINDINGS_CONTINUOUS);
            continue;
          }
          const extent5 = { selection: selCmpt.name, field: proj.field };
          scale8.set("selectionExtent", extent5, true);
          bound3.push(proj);
        }
      },
      topLevelSignals: (model, selCmpt, signals) => {
        const bound3 = selCmpt.scales.filter((proj) => signals.filter((s3) => s3.name === proj.signals.data).length === 0);
        if (!model.parent || isTopLevelLayer(model) || bound3.length === 0) {
          return signals;
        }
        const namedSg = signals.filter((s3) => s3.name === selCmpt.name)[0];
        let update3 = namedSg.update;
        if (update3.indexOf(VL_SELECTION_RESOLVE) >= 0) {
          namedSg.update = `{${bound3.map((proj) => `${$3(proj.field)}: ${proj.signals.data}`).join(", ")}}`;
        } else {
          for (const proj of bound3) {
            const mapping = `${$3(proj.field)}: ${proj.signals.data}`;
            if (update3.indexOf(mapping) < 0) {
              update3 = `${update3.substring(0, update3.length - 1)}, ${mapping}}`;
            }
          }
          namedSg.update = update3;
        }
        return signals.concat(bound3.map((proj) => ({ name: proj.signals.data })));
      },
      signals: (model, selCmpt, signals) => {
        if (model.parent && !isTopLevelLayer(model)) {
          for (const proj of selCmpt.scales) {
            const signal = signals.filter((s3) => s3.name === proj.signals.data)[0];
            signal.push = "outer";
            delete signal.value;
            delete signal.update;
          }
        }
        return signals;
      }
    };
    scales_default = scaleBindings;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/legends.js
function parseInteractiveLegend(model, channel, legendCmpt) {
  var _a2;
  const field4 = (_a2 = model.fieldDef(channel)) === null || _a2 === void 0 ? void 0 : _a2.field;
  forEachSelection(model, (selCmpt) => {
    var _a3, _b;
    const proj = (_a3 = selCmpt.project.hasField[field4]) !== null && _a3 !== void 0 ? _a3 : selCmpt.project.hasChannel[channel];
    if (proj && legendBindings.has(selCmpt)) {
      const legendSelections = (_b = legendCmpt.get("selections")) !== null && _b !== void 0 ? _b : [];
      legendSelections.push(selCmpt.name);
      legendCmpt.set("selections", legendSelections, false);
      proj.hasLegend = true;
    }
  });
}
var legendBindings, legends_default;
var init_legends = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/legends.js"() {
    init_vega_event_selector_module2();
    init_vega_util();
    init_selection2();
    init_log3();
    init_selection();
    init_util();
    init_project2();
    init_toggle();
    legendBindings = {
      has: (selCmpt) => {
        const spec = selCmpt.resolve === "global" && selCmpt.bind && isLegendBinding(selCmpt.bind);
        const projLen = selCmpt.project.items.length === 1 && selCmpt.project.items[0].field !== SELECTION_ID;
        if (spec && !projLen) {
          warn2(message_exports.LEGEND_BINDINGS_PROJECT_LENGTH);
        }
        return spec && projLen;
      },
      parse: (model, selCmpt, selDef, origDef) => {
        var _a2;
        if (!origDef.on)
          delete selCmpt.events;
        if (!origDef.clear)
          delete selCmpt.clear;
        if (origDef.on || origDef.clear) {
          const legendFilter = 'event.item && indexof(event.item.mark.role, "legend") < 0';
          for (const evt2 of selCmpt.events) {
            evt2.filter = array_default6((_a2 = evt2.filter) !== null && _a2 !== void 0 ? _a2 : []);
            if (evt2.filter.indexOf(legendFilter) < 0) {
              evt2.filter.push(legendFilter);
            }
          }
        }
        const evt = isLegendStreamBinding(selCmpt.bind) ? selCmpt.bind.legend : "click";
        const stream2 = isString_default(evt) ? eventSelector2(evt, "view") : array_default6(evt);
        selCmpt.bind = { legend: { merge: stream2 } };
      },
      topLevelSignals: (model, selCmpt, signals) => {
        const selName = selCmpt.name;
        const stream2 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
        const markName = (name4) => (s3) => {
          const ds = duplicate(s3);
          ds.markname = name4;
          return ds;
        };
        for (const proj of selCmpt.project.items) {
          if (!proj.hasLegend)
            continue;
          const prefix = `${varName(proj.field)}_legend`;
          const sgName = `${selName}_${prefix}`;
          const hasSignal2 = signals.filter((s3) => s3.name === sgName);
          if (hasSignal2.length === 0) {
            const events4 = stream2.merge.map(markName(`${prefix}_symbols`)).concat(stream2.merge.map(markName(`${prefix}_labels`))).concat(stream2.merge.map(markName(`${prefix}_entries`)));
            signals.unshift(Object.assign(Object.assign({ name: sgName }, !selCmpt.init ? { value: null } : {}), { on: [
              { events: events4, update: "datum.value || item().items[0].items[0].datum.value", force: true },
              { events: stream2.merge, update: `!event.item || !datum ? null : ${sgName}`, force: true }
            ] }));
          }
        }
        return signals;
      },
      signals: (model, selCmpt, signals) => {
        const name4 = selCmpt.name;
        const proj = selCmpt.project;
        const tuple = signals.find((s3) => s3.name === name4 + TUPLE);
        const fields = name4 + TUPLE_FIELDS;
        const values5 = proj.items.filter((p) => p.hasLegend).map((p) => varName(`${name4}_${varName(p.field)}_legend`));
        const valid = values5.map((v) => `${v} !== null`).join(" && ");
        const update3 = `${valid} ? {fields: ${fields}, values: [${values5.join(", ")}]} : null`;
        if (selCmpt.events && values5.length > 0) {
          tuple.on.push({
            events: values5.map((signal) => ({ signal })),
            update: update3
          });
        } else if (values5.length > 0) {
          tuple.update = update3;
          delete tuple.value;
          delete tuple.on;
        }
        const toggle2 = signals.find((s3) => s3.name === name4 + TOGGLE);
        const events4 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
        if (toggle2) {
          if (!selCmpt.events)
            toggle2.on[0].events = events4;
          else
            toggle2.on.push(Object.assign(Object.assign({}, toggle2.on[0]), { events: events4 }));
        }
        return signals;
      }
    };
    legends_default = legendBindings;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/translate.js
function onDelta(model, selCmpt, proj, size, signals) {
  var _a2;
  const name4 = selCmpt.name;
  const anchor = name4 + ANCHOR;
  const delta = name4 + DELTA;
  const channel = proj.channel;
  const hasScales = scales_default.has(selCmpt);
  const signal = signals.filter((s3) => s3.name === proj.signals[hasScales ? "data" : "visual"])[0];
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt.get("type");
  const sign5 = hasScales && channel === X3 ? "-" : "";
  const extent5 = `${anchor}.extent_${channel}`;
  const offset5 = `${sign5}${delta}.${channel} / ` + (hasScales ? `${sizeSg}` : `span(${extent5})`);
  const panFn = !hasScales ? "panLinear" : scaleType2 === "log" ? "panLog" : scaleType2 === "pow" ? "panPow" : "panLinear";
  const update3 = `${panFn}(${extent5}, ${offset5}` + (hasScales && scaleType2 === "pow" ? `, ${(_a2 = scaleCmpt.get("exponent")) !== null && _a2 !== void 0 ? _a2 : 1}` : "") + ")";
  signal.on.push({
    events: { signal: delta },
    update: hasScales ? update3 : `clampRange(${update3}, 0, ${sizeSg})`
  });
}
var ANCHOR, DELTA, translate4, translate_default;
var init_translate = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/translate.js"() {
    init_vega_event_selector_module2();
    init_channel();
    init_interval4();
    init_scales();
    ANCHOR = "_translate_anchor";
    DELTA = "_translate_delta";
    translate4 = {
      has: (selCmpt) => {
        return selCmpt.type === "interval" && selCmpt.translate;
      },
      signals: (model, selCmpt, signals) => {
        const name4 = selCmpt.name;
        const hasScales = scales_default.has(selCmpt);
        const anchor = name4 + ANCHOR;
        const { x: x7, y: y7 } = selCmpt.project.hasChannel;
        let events4 = eventSelector2(selCmpt.translate, "scope");
        if (!hasScales) {
          events4 = events4.map((e3) => (e3.between[0].markname = name4 + BRUSH, e3));
        }
        signals.push({
          name: anchor,
          value: {},
          on: [
            {
              events: events4.map((e3) => e3.between[0]),
              update: "{x: x(unit), y: y(unit)" + (x7 !== void 0 ? ", extent_x: " + (hasScales ? domain3(model, X3) : `slice(${x7.signals.visual})`) : "") + (y7 !== void 0 ? ", extent_y: " + (hasScales ? domain3(model, Y3) : `slice(${y7.signals.visual})`) : "") + "}"
            }
          ]
        }, {
          name: name4 + DELTA,
          value: {},
          on: [
            {
              events: events4,
              update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`
            }
          ]
        });
        if (x7 !== void 0) {
          onDelta(model, selCmpt, x7, "width", signals);
        }
        if (y7 !== void 0) {
          onDelta(model, selCmpt, y7, "height", signals);
        }
        return signals;
      }
    };
    translate_default = translate4;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/zoom.js
function onDelta2(model, selCmpt, proj, size, signals) {
  var _a2;
  const name4 = selCmpt.name;
  const channel = proj.channel;
  const hasScales = scales_default.has(selCmpt);
  const signal = signals.filter((s3) => s3.name === proj.signals[hasScales ? "data" : "visual"])[0];
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt.get("type");
  const base3 = hasScales ? domain3(model, channel) : signal.name;
  const delta = name4 + DELTA2;
  const anchor = `${name4}${ANCHOR2}.${channel}`;
  const zoomFn = !hasScales ? "zoomLinear" : scaleType2 === "log" ? "zoomLog" : scaleType2 === "pow" ? "zoomPow" : "zoomLinear";
  const update3 = `${zoomFn}(${base3}, ${anchor}, ${delta}` + (hasScales && scaleType2 === "pow" ? `, ${(_a2 = scaleCmpt.get("exponent")) !== null && _a2 !== void 0 ? _a2 : 1}` : "") + ")";
  signal.on.push({
    events: { signal: delta },
    update: hasScales ? update3 : `clampRange(${update3}, 0, ${sizeSg})`
  });
}
var ANCHOR2, DELTA2, zoom2, zoom_default3;
var init_zoom3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/zoom.js"() {
    init_vega_event_selector_module2();
    init_vega_util();
    init_channel();
    init_interval4();
    init_scales();
    ANCHOR2 = "_zoom_anchor";
    DELTA2 = "_zoom_delta";
    zoom2 = {
      has: (selCmpt) => {
        return selCmpt.type === "interval" && selCmpt.zoom;
      },
      signals: (model, selCmpt, signals) => {
        const name4 = selCmpt.name;
        const hasScales = scales_default.has(selCmpt);
        const delta = name4 + DELTA2;
        const { x: x7, y: y7 } = selCmpt.project.hasChannel;
        const sx = $3(model.scaleName(X3));
        const sy = $3(model.scaleName(Y3));
        let events4 = eventSelector2(selCmpt.zoom, "scope");
        if (!hasScales) {
          events4 = events4.map((e3) => (e3.markname = name4 + BRUSH, e3));
        }
        signals.push({
          name: name4 + ANCHOR2,
          on: [
            {
              events: events4,
              update: !hasScales ? `{x: x(unit), y: y(unit)}` : "{" + [sx ? `x: invert(${sx}, x(unit))` : "", sy ? `y: invert(${sy}, y(unit))` : ""].filter((expr2) => !!expr2).join(", ") + "}"
            }
          ]
        }, {
          name: delta,
          on: [
            {
              events: events4,
              force: true,
              update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
            }
          ]
        });
        if (x7 !== void 0) {
          onDelta2(model, selCmpt, x7, "width", signals);
        }
        if (y7 !== void 0) {
          onDelta2(model, selCmpt, y7, "height", signals);
        }
        return signals;
      }
    };
    zoom_default3 = zoom2;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/transforms.js
function forEachTransform(selCmpt, cb) {
  for (const t of compilers) {
    if (t.has(selCmpt)) {
      cb(t);
    }
  }
}
var compilers;
var init_transforms = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/transforms/transforms.js"() {
    init_clear();
    init_inputs();
    init_nearest();
    init_project2();
    init_scales();
    init_legends();
    init_toggle();
    init_translate();
    init_zoom3();
    compilers = [project_default2, toggle_default, scales_default, legends_default, translate_default, zoom_default3, inputs_default, nearest_default, clear_default];
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/assemble.js
function assembleInit(init2, isExpr2 = true, wrap2 = identity11) {
  if (isArray_default(init2)) {
    const assembled = init2.map((v) => assembleInit(v, isExpr2, wrap2));
    return isExpr2 ? `[${assembled.join(", ")}]` : assembled;
  } else if (isDateTime(init2)) {
    if (isExpr2) {
      return wrap2(dateTimeToExpr(init2));
    } else {
      return wrap2(dateTimeToTimestamp(init2));
    }
  }
  return isExpr2 ? wrap2(JSON.stringify(init2)) : init2;
}
function assembleUnitSelectionSignals(model, signals) {
  forEachSelection(model, (selCmpt, selCompiler) => {
    const name4 = selCmpt.name;
    let modifyExpr = selCompiler.modifyExpr(model, selCmpt);
    signals.push(...selCompiler.signals(model, selCmpt));
    forEachTransform(selCmpt, (txCompiler) => {
      if (txCompiler.signals) {
        signals = txCompiler.signals(model, selCmpt, signals);
      }
      if (txCompiler.modifyExpr) {
        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);
      }
    });
    signals.push({
      name: name4 + MODIFY,
      on: [
        {
          events: { signal: selCmpt.name + TUPLE },
          update: `modify(${$3(selCmpt.name + STORE)}, ${modifyExpr})`
        }
      ]
    });
  });
  return cleanupEmptyOnArray(signals);
}
function assembleFacetSignals(model, signals) {
  if (model.component.selection && keys4(model.component.selection).length) {
    const name4 = $3(model.getName("cell"));
    signals.unshift({
      name: "facet",
      value: {},
      on: [
        {
          events: eventSelector2("mousemove", "scope"),
          update: `isTuple(facet) ? facet : group(${name4}).datum`
        }
      ]
    });
  }
  return cleanupEmptyOnArray(signals);
}
function assembleTopLevelSignals(model, signals) {
  let hasSelections = false;
  forEachSelection(model, (selCmpt, selCompiler) => {
    const name4 = selCmpt.name;
    const store = $3(name4 + STORE);
    const hasSg = signals.filter((s3) => s3.name === name4);
    if (hasSg.length === 0) {
      const resolve2 = selCmpt.resolve === "global" ? "union" : selCmpt.resolve;
      const isMulti = selCmpt.type === "multi" ? ", true)" : ")";
      signals.push({
        name: selCmpt.name,
        update: `${VL_SELECTION_RESOLVE}(${store}, ${$3(resolve2)}${isMulti}`
      });
    }
    hasSelections = true;
    if (selCompiler.topLevelSignals) {
      signals = selCompiler.topLevelSignals(model, selCmpt, signals);
    }
    forEachTransform(selCmpt, (txCompiler) => {
      if (txCompiler.topLevelSignals) {
        signals = txCompiler.topLevelSignals(model, selCmpt, signals);
      }
    });
  });
  if (hasSelections) {
    const hasUnit = signals.filter((s3) => s3.name === "unit");
    if (hasUnit.length === 0) {
      signals.unshift({
        name: "unit",
        value: {},
        on: [{ events: "mousemove", update: "isTuple(group()) ? group() : unit" }]
      });
    }
  }
  return cleanupEmptyOnArray(signals);
}
function assembleUnitSelectionData(model, data3) {
  const dataCopy = [...data3];
  forEachSelection(model, (selCmpt) => {
    const init2 = { name: selCmpt.name + STORE };
    if (selCmpt.init) {
      const fields = selCmpt.project.items.map((proj) => {
        const { signals } = proj, rest = __rest(proj, ["signals"]);
        return rest;
      });
      const insert2 = selCmpt.init.map((i) => assembleInit(i, false));
      init2.values = selCmpt.type === "interval" ? [{ unit: unitName(model, { escape: false }), fields, values: insert2 }] : insert2.map((i) => ({ unit: unitName(model, { escape: false }), fields, values: i }));
    }
    const contains3 = dataCopy.filter((d) => d.name === selCmpt.name + STORE);
    if (!contains3.length) {
      dataCopy.push(init2);
    }
  });
  return dataCopy;
}
function assembleUnitSelectionMarks(model, marks) {
  forEachSelection(model, (selCmpt, selCompiler) => {
    marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;
    forEachTransform(selCmpt, (txCompiler) => {
      if (txCompiler.marks) {
        marks = txCompiler.marks(model, selCmpt, marks);
      }
    });
  });
  return marks;
}
function assembleLayerSelectionMarks(model, marks) {
  for (const child of model.children) {
    if (isUnitModel(child)) {
      marks = assembleUnitSelectionMarks(child, marks);
    }
  }
  return marks;
}
function assembleSelectionScaleDomain(model, extent5) {
  const name4 = extent5.selection;
  const selCmpt = model.getSelectionComponent(name4, varName(name4));
  return { signal: parseSelectionBinExtent(selCmpt, extent5) };
}
function cleanupEmptyOnArray(signals) {
  return signals.map((s3) => {
    if (s3.on && !s3.on.length)
      delete s3.on;
    return s3;
  });
}
var init_assemble = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/assemble.js"() {
    init_tslib_es6();
    init_vega_event_selector_module2();
    init_vega_util();
    init_selection2();
    init_datetime();
    init_util();
    init_model();
    init_transforms();
    init_parse3();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/interval.js
function channelSignals(model, selCmpt, proj, init2) {
  const channel = proj.channel;
  const vname = proj.signals.visual;
  const dname = proj.signals.data;
  const hasScales = scales_default.has(selCmpt);
  const scaleName = $3(model.scaleName(channel));
  const scale8 = model.getScaleComponent(channel);
  const scaleType2 = scale8 ? scale8.get("type") : void 0;
  const scaled = (str) => `scale(${scaleName}, ${str})`;
  const size = model.getSizeSignalRef(channel === X3 ? "width" : "height").signal;
  const coord = `${channel}(unit)`;
  const on2 = events3(selCmpt, (def3, evt) => {
    return [
      ...def3,
      { events: evt.between[0], update: `[${coord}, ${coord}]` },
      { events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]` }
    ];
  });
  on2.push({
    events: { signal: selCmpt.name + SCALE_TRIGGER },
    update: hasContinuousDomain(scaleType2) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`
  });
  return hasScales ? [{ name: dname, on: [] }] : [
    Object.assign(Object.assign({ name: vname }, init2 ? { init: assembleInit(init2, true, scaled) } : { value: [] }), { on: on2 }),
    Object.assign(Object.assign({ name: dname }, init2 ? { init: assembleInit(init2) } : {}), { on: [
      {
        events: { signal: vname },
        update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`
      }
    ] })
  ];
}
function events3(selCmpt, cb) {
  return selCmpt.events.reduce((on2, evt) => {
    if (!evt.between) {
      warn2(`${evt} is not an ordered event stream for interval selections.`);
      return on2;
    }
    return cb(on2, evt);
  }, []);
}
var BRUSH, SCALE_TRIGGER, interval2, interval_default2;
var init_interval4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/interval.js"() {
    init_tslib_es6();
    init_vega_util();
    init_selection2();
    init_channel();
    init_log3();
    init_scale();
    init_util();
    init_assemble();
    init_project2();
    init_scales();
    BRUSH = "_brush";
    SCALE_TRIGGER = "_scale_trigger";
    interval2 = {
      signals: (model, selCmpt) => {
        const name4 = selCmpt.name;
        const fieldsSg = name4 + TUPLE_FIELDS;
        const hasScales = scales_default.has(selCmpt);
        const signals = [];
        const dataSignals = [];
        const scaleTriggers = [];
        if (selCmpt.translate && !hasScales) {
          const filterExpr = `!event.item || event.item.mark.name !== ${$3(name4 + BRUSH)}`;
          events3(selCmpt, (on2, evt) => {
            var _a2;
            const filters3 = array_default6((_a2 = evt.between[0].filter) !== null && _a2 !== void 0 ? _a2 : evt.between[0].filter = []);
            if (filters3.indexOf(filterExpr) < 0) {
              filters3.push(filterExpr);
            }
            return on2;
          });
        }
        selCmpt.project.items.forEach((proj, i) => {
          const channel = proj.channel;
          if (channel !== X3 && channel !== Y3) {
            warn2("Interval selections only support x and y encoding channels.");
            return;
          }
          const init3 = selCmpt.init ? selCmpt.init[i] : null;
          const cs = channelSignals(model, selCmpt, proj, init3);
          const dname = proj.signals.data;
          const vname = proj.signals.visual;
          const scaleName = $3(model.scaleName(channel));
          const scaleType2 = model.getScaleComponent(channel).get("type");
          const toNum = hasContinuousDomain(scaleType2) ? "+" : "";
          signals.push(...cs);
          dataSignals.push(dname);
          scaleTriggers.push({
            scaleName: model.scaleName(channel),
            expr: `(!isArray(${dname}) || (${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`
          });
        });
        if (!hasScales) {
          signals.push({
            name: name4 + SCALE_TRIGGER,
            value: {},
            on: [
              {
                events: scaleTriggers.map((t) => ({ scale: t.scaleName })),
                update: scaleTriggers.map((t) => t.expr).join(" && ") + ` ? ${name4 + SCALE_TRIGGER} : {}`
              }
            ]
          });
        }
        const init2 = selCmpt.init;
        const update3 = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;
        return signals.concat(Object.assign(Object.assign({ name: name4 + TUPLE }, init2 ? { init: `{${update3}: ${assembleInit(init2)}}` } : {}), { on: [
          {
            events: [{ signal: dataSignals.join(" || ") }],
            update: dataSignals.join(" && ") + ` ? {${update3}: [${dataSignals}]} : null`
          }
        ] }));
      },
      modifyExpr: (model, selCmpt) => {
        const tpl = selCmpt.name + TUPLE;
        return tpl + ", " + (selCmpt.resolve === "global" ? "true" : `{unit: ${unitName(model)}}`);
      },
      marks: (model, selCmpt, marks) => {
        const name4 = selCmpt.name;
        const { x: x7, y: y7 } = selCmpt.project.hasChannel;
        const xvname = x7 && x7.signals.visual;
        const yvname = y7 && y7.signals.visual;
        const store = `data(${$3(selCmpt.name + STORE)})`;
        if (scales_default.has(selCmpt)) {
          return marks;
        }
        const update3 = {
          x: x7 !== void 0 ? { signal: `${xvname}[0]` } : { value: 0 },
          y: y7 !== void 0 ? { signal: `${yvname}[0]` } : { value: 0 },
          x2: x7 !== void 0 ? { signal: `${xvname}[1]` } : { field: { group: "width" } },
          y2: y7 !== void 0 ? { signal: `${yvname}[1]` } : { field: { group: "height" } }
        };
        if (selCmpt.resolve === "global") {
          for (const key3 of keys4(update3)) {
            update3[key3] = [
              Object.assign({ test: `${store}.length && ${store}[0].unit === ${unitName(model)}` }, update3[key3]),
              { value: 0 }
            ];
          }
        }
        const _a2 = selCmpt.mark, { fill: fill3, fillOpacity, cursor: cursor3 } = _a2, stroke3 = __rest(_a2, ["fill", "fillOpacity", "cursor"]);
        const vgStroke = keys4(stroke3).reduce((def3, k4) => {
          def3[k4] = [
            {
              test: [x7 !== void 0 && `${xvname}[0] !== ${xvname}[1]`, y7 !== void 0 && `${yvname}[0] !== ${yvname}[1]`].filter((t) => t).join(" && "),
              value: stroke3[k4]
            },
            { value: null }
          ];
          return def3;
        }, {});
        return [
          {
            name: name4 + BRUSH + "_bg",
            type: "rect",
            clip: true,
            encode: {
              enter: {
                fill: { value: fill3 },
                fillOpacity: { value: fillOpacity }
              },
              update: update3
            }
          },
          ...marks,
          {
            name: name4 + BRUSH,
            type: "rect",
            clip: true,
            encode: {
              enter: Object.assign(Object.assign({}, cursor3 ? { cursor: { value: cursor3 } } : {}), { fill: { value: "transparent" } }),
              update: Object.assign(Object.assign({}, update3), vgStroke)
            }
          }
        ];
      }
    };
    interval_default2 = interval2;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/multi.js
function singleOrMultiSignals(model, selCmpt) {
  const name4 = selCmpt.name;
  const fieldsSg = name4 + TUPLE_FIELDS;
  const project3 = selCmpt.project;
  const datum2 = "(item().isVoronoi ? datum.datum : datum)";
  const values5 = project3.items.map((p) => {
    const fieldDef = model.fieldDef(p.channel);
    return fieldDef && fieldDef.bin ? `[${datum2}[${$3(model.vgField(p.channel, {}))}], ${datum2}[${$3(model.vgField(p.channel, { binSuffix: "end" }))}]]` : `${datum2}[${$3(p.field)}]`;
  }).join(", ");
  const update3 = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;
  const events4 = selCmpt.events;
  return [
    {
      name: name4 + TUPLE,
      on: events4 ? [
        {
          events: events4,
          update: `datum && item().mark.marktype !== 'group' ? {${update3}: [${values5}]} : null`,
          force: true
        }
      ] : []
    }
  ];
}
var multi, multi_default;
var init_multi = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/multi.js"() {
    init_vega_util();
    init_selection2();
    init_project2();
    multi = {
      signals: singleOrMultiSignals,
      modifyExpr: (model, selCmpt) => {
        const tpl = selCmpt.name + TUPLE;
        return tpl + ", " + (selCmpt.resolve === "global" ? "null" : `{unit: ${unitName(model)}}`);
      }
    };
    multi_default = multi;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/single.js
var single, single_default;
var init_single = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/single.js"() {
    init_selection2();
    init_multi();
    single = {
      signals: singleOrMultiSignals,
      modifyExpr: (model, selCmpt) => {
        const tpl = selCmpt.name + TUPLE;
        return tpl + ", " + (selCmpt.resolve === "global" ? "true" : `{unit: ${unitName(model)}}`);
      }
    };
    single_default = single;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/index.js
function forEachSelection(model, cb) {
  const selections = model.component.selection;
  if (selections) {
    for (const sel of vals(selections)) {
      const success = cb(sel, compilers2[sel.type]);
      if (success === true)
        break;
    }
  }
}
function getFacetModel(model) {
  let parent = model.parent;
  while (parent) {
    if (isFacetModel(parent)) {
      break;
    }
    parent = parent.parent;
  }
  return parent;
}
function unitName(model, { escape: escape2 } = { escape: true }) {
  let name4 = escape2 ? $3(model.name) : model.name;
  const facetModel = getFacetModel(model);
  if (facetModel) {
    const { facet } = facetModel;
    for (const channel of FACET_CHANNELS) {
      if (facet[channel]) {
        name4 += ` + '__facet_${channel}_' + (facet[${$3(facetModel.vgField(channel))}])`;
      }
    }
  }
  return name4;
}
function requiresSelectionId(model) {
  let identifier = false;
  forEachSelection(model, (selCmpt) => {
    identifier = identifier || selCmpt.project.items.some((proj) => proj.field === SELECTION_ID);
  });
  return identifier;
}
var STORE, TUPLE, MODIFY, VL_SELECTION_RESOLVE, compilers2;
var init_selection2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/index.js"() {
    init_vega_util();
    init_channel();
    init_selection();
    init_util();
    init_model();
    init_interval4();
    init_multi();
    init_single();
    STORE = "_store";
    TUPLE = "_tuple";
    MODIFY = "_modify";
    VL_SELECTION_RESOLVE = "vlSelectionResolve";
    compilers2 = { single: single_default, multi: multi_default, interval: interval_default2 };
  }
});

// node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/src/ast.js
function ASTNode3(type4) {
  this.type = type4;
}
function children4(node) {
  switch (node.type) {
    case ArrayExpression3:
      return node.elements;
    case BinaryExpression3:
    case LogicalExpression3:
      return [node.left, node.right];
    case CallExpression3:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression3:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression3:
      return [node.object, node.property];
    case ObjectExpression3:
      return node.properties;
    case Property3:
      return [node.key, node.value];
    case UnaryExpression3:
      return [node.argument];
    case Identifier4:
    case Literal3:
    case RawCode3:
    default:
      return [];
  }
}
var RawCode3, Literal3, Property3, Identifier4, ArrayExpression3, BinaryExpression3, CallExpression3, ConditionalExpression3, LogicalExpression3, MemberExpression3, ObjectExpression3, UnaryExpression3;
var init_ast = __esm({
  "node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/src/ast.js"() {
    RawCode3 = "RawCode";
    Literal3 = "Literal";
    Property3 = "Property";
    Identifier4 = "Identifier";
    ArrayExpression3 = "ArrayExpression";
    BinaryExpression3 = "BinaryExpression";
    CallExpression3 = "CallExpression";
    ConditionalExpression3 = "ConditionalExpression";
    LogicalExpression3 = "LogicalExpression";
    MemberExpression3 = "MemberExpression";
    ObjectExpression3 = "ObjectExpression";
    UnaryExpression3 = "UnaryExpression";
    ASTNode3.prototype.visit = function(visitor) {
      let c2, i, n;
      if (visitor(this))
        return 1;
      for (c2 = children4(this), i = 0, n = c2.length; i < n; ++i) {
        if (c2[i].visit(visitor))
          return 1;
      }
    };
  }
});

// node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/src/parser.js
function assert3(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit3(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit3(ch2) {
  return "0123456789abcdefABCDEF".indexOf(ch2) >= 0;
}
function isOctalDigit3(ch2) {
  return "01234567".indexOf(ch2) >= 0;
}
function isWhiteSpace3(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch2) >= 0;
}
function isLineTerminator3(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart3(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierStart3.test(String.fromCharCode(ch2));
}
function isIdentifierPart3(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 >= 48 && ch2 <= 57 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierPart3.test(String.fromCharCode(ch2));
}
function skipComment3() {
  var ch2;
  while (index7 < length3) {
    ch2 = source4.charCodeAt(index7);
    if (isWhiteSpace3(ch2) || isLineTerminator3(ch2)) {
      ++index7;
    } else {
      break;
    }
  }
}
function scanHexEscape3(prefix) {
  var i, len, ch2, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index7 < length3 && isHexDigit3(source4[index7])) {
      ch2 = source4[index7++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape3() {
  var ch2, code, cu1, cu2;
  ch2 = source4[index7];
  code = 0;
  if (ch2 === "}") {
    throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
  }
  while (index7 < length3) {
    ch2 = source4[index7++];
    if (!isHexDigit3(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier3() {
  var ch2, id4;
  ch2 = source4.charCodeAt(index7++);
  id4 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source4.charCodeAt(index7) !== 117) {
      throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
    }
    ++index7;
    ch2 = scanHexEscape3("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart3(ch2.charCodeAt(0))) {
      throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
    }
    id4 = ch2;
  }
  while (index7 < length3) {
    ch2 = source4.charCodeAt(index7);
    if (!isIdentifierPart3(ch2)) {
      break;
    }
    ++index7;
    id4 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id4 = id4.substr(0, id4.length - 1);
      if (source4.charCodeAt(index7) !== 117) {
        throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
      }
      ++index7;
      ch2 = scanHexEscape3("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart3(ch2.charCodeAt(0))) {
        throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
      }
      id4 += ch2;
    }
  }
  return id4;
}
function getIdentifier3() {
  var start, ch2;
  start = index7++;
  while (index7 < length3) {
    ch2 = source4.charCodeAt(index7);
    if (ch2 === 92) {
      index7 = start;
      return getEscapedIdentifier3();
    }
    if (isIdentifierPart3(ch2)) {
      ++index7;
    } else {
      break;
    }
  }
  return source4.slice(start, index7);
}
function scanIdentifier3() {
  var start, id4, type4;
  start = index7;
  id4 = source4.charCodeAt(index7) === 92 ? getEscapedIdentifier3() : getIdentifier3();
  if (id4.length === 1) {
    type4 = TokenIdentifier3;
  } else if (keywords4.hasOwnProperty(id4)) {
    type4 = TokenKeyword3;
  } else if (id4 === "null") {
    type4 = TokenNullLiteral3;
  } else if (id4 === "true" || id4 === "false") {
    type4 = TokenBooleanLiteral3;
  } else {
    type4 = TokenIdentifier3;
  }
  return {
    type: type4,
    value: id4,
    start,
    end: index7
  };
}
function scanPunctuator3() {
  var start = index7, code = source4.charCodeAt(index7), code2, ch1 = source4[index7], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index7;
      return {
        type: TokenPunctuator3,
        value: String.fromCharCode(code),
        start,
        end: index7
      };
    default:
      code2 = source4.charCodeAt(index7 + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index7 += 2;
            return {
              type: TokenPunctuator3,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index7
            };
          case 33:
          case 61:
            index7 += 2;
            if (source4.charCodeAt(index7) === 61) {
              ++index7;
            }
            return {
              type: TokenPunctuator3,
              value: source4.slice(start, index7),
              start,
              end: index7
            };
        }
      }
  }
  ch4 = source4.substr(index7, 4);
  if (ch4 === ">>>=") {
    index7 += 4;
    return {
      type: TokenPunctuator3,
      value: ch4,
      start,
      end: index7
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index7 += 3;
    return {
      type: TokenPunctuator3,
      value: ch3,
      start,
      end: index7
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index7 += 2;
    return {
      type: TokenPunctuator3,
      value: ch2,
      start,
      end: index7
    };
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index7;
    return {
      type: TokenPunctuator3,
      value: ch1,
      start,
      end: index7
    };
  }
  throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
}
function scanHexLiteral3(start) {
  var number12 = "";
  while (index7 < length3) {
    if (!isHexDigit3(source4[index7])) {
      break;
    }
    number12 += source4[index7++];
  }
  if (number12.length === 0) {
    throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
  }
  if (isIdentifierStart3(source4.charCodeAt(index7))) {
    throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
  }
  return {
    type: TokenNumericLiteral3,
    value: parseInt("0x" + number12, 16),
    start,
    end: index7
  };
}
function scanOctalLiteral3(start) {
  var number12 = "0" + source4[index7++];
  while (index7 < length3) {
    if (!isOctalDigit3(source4[index7])) {
      break;
    }
    number12 += source4[index7++];
  }
  if (isIdentifierStart3(source4.charCodeAt(index7)) || isDecimalDigit3(source4.charCodeAt(index7))) {
    throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
  }
  return {
    type: TokenNumericLiteral3,
    value: parseInt(number12, 8),
    octal: true,
    start,
    end: index7
  };
}
function scanNumericLiteral3() {
  var number12, start, ch2;
  ch2 = source4[index7];
  assert3(
    isDecimalDigit3(ch2.charCodeAt(0)) || ch2 === ".",
    "Numeric literal must start with a decimal digit or a decimal point"
  );
  start = index7;
  number12 = "";
  if (ch2 !== ".") {
    number12 = source4[index7++];
    ch2 = source4[index7];
    if (number12 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index7;
        return scanHexLiteral3(start);
      }
      if (isOctalDigit3(ch2)) {
        return scanOctalLiteral3(start);
      }
      if (ch2 && isDecimalDigit3(ch2.charCodeAt(0))) {
        throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
      }
    }
    while (isDecimalDigit3(source4.charCodeAt(index7))) {
      number12 += source4[index7++];
    }
    ch2 = source4[index7];
  }
  if (ch2 === ".") {
    number12 += source4[index7++];
    while (isDecimalDigit3(source4.charCodeAt(index7))) {
      number12 += source4[index7++];
    }
    ch2 = source4[index7];
  }
  if (ch2 === "e" || ch2 === "E") {
    number12 += source4[index7++];
    ch2 = source4[index7];
    if (ch2 === "+" || ch2 === "-") {
      number12 += source4[index7++];
    }
    if (isDecimalDigit3(source4.charCodeAt(index7))) {
      while (isDecimalDigit3(source4.charCodeAt(index7))) {
        number12 += source4[index7++];
      }
    } else {
      throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
    }
  }
  if (isIdentifierStart3(source4.charCodeAt(index7))) {
    throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
  }
  return {
    type: TokenNumericLiteral3,
    value: parseFloat(number12),
    start,
    end: index7
  };
}
function scanStringLiteral3() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source4[index7];
  assert3(
    quote === "'" || quote === '"',
    "String literal must starts with a quote"
  );
  start = index7;
  ++index7;
  while (index7 < length3) {
    ch2 = source4[index7++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source4[index7++];
      if (!ch2 || !isLineTerminator3(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source4[index7] === "{") {
              ++index7;
              str += scanUnicodeCodePointEscape3();
            } else {
              str += scanHexEscape3(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit3(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index7 < length3 && isOctalDigit3(source4[index7])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source4[index7++]);
                if ("0123".indexOf(ch2) >= 0 && index7 < length3 && isOctalDigit3(source4[index7])) {
                  code = code * 8 + "01234567".indexOf(source4[index7++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source4[index7] === "\n") {
          ++index7;
        }
      }
    } else if (isLineTerminator3(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
  }
  return {
    type: TokenStringLiteral3,
    value: str,
    octal,
    start,
    end: index7
  };
}
function testRegExp3(pattern, flags) {
  var tmp = pattern;
  if (flags.indexOf("u") >= 0) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function($0, $1) {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError3({}, MessageInvalidRegExp3);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e3) {
    throwError3({}, MessageInvalidRegExp3);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody3() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source4[index7];
  assert3(ch2 === "/", "Regular expression literal must start with a slash");
  str = source4[index7++];
  classMarker = false;
  terminated = false;
  while (index7 < length3) {
    ch2 = source4[index7++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source4[index7++];
      if (isLineTerminator3(ch2.charCodeAt(0))) {
        throwError3({}, MessageUnterminatedRegExp3);
      }
      str += ch2;
    } else if (isLineTerminator3(ch2.charCodeAt(0))) {
      throwError3({}, MessageUnterminatedRegExp3);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError3({}, MessageUnterminatedRegExp3);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags3() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index7 < length3) {
    ch2 = source4[index7];
    if (!isIdentifierPart3(ch2.charCodeAt(0))) {
      break;
    }
    ++index7;
    if (ch2 === "\\" && index7 < length3) {
      throwError3({}, MessageUnexpectedToken3, ILLEGAL5);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError3({}, MessageInvalidRegExp3, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp3() {
  var start, body, flags, value4;
  lookahead3 = null;
  skipComment3();
  start = index7;
  body = scanRegExpBody3();
  flags = scanRegExpFlags3();
  value4 = testRegExp3(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value4,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index7
  };
}
function isIdentifierName3(token) {
  return token.type === TokenIdentifier3 || token.type === TokenKeyword3 || token.type === TokenBooleanLiteral3 || token.type === TokenNullLiteral3;
}
function advance3() {
  var ch2;
  skipComment3();
  if (index7 >= length3) {
    return {
      type: TokenEOF3,
      start: index7,
      end: index7
    };
  }
  ch2 = source4.charCodeAt(index7);
  if (isIdentifierStart3(ch2)) {
    return scanIdentifier3();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator3();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral3();
  }
  if (ch2 === 46) {
    if (isDecimalDigit3(source4.charCodeAt(index7 + 1))) {
      return scanNumericLiteral3();
    }
    return scanPunctuator3();
  }
  if (isDecimalDigit3(ch2)) {
    return scanNumericLiteral3();
  }
  return scanPunctuator3();
}
function lex3() {
  var token;
  token = lookahead3;
  index7 = token.end;
  lookahead3 = advance3();
  index7 = token.end;
  return token;
}
function peek5() {
  var pos;
  pos = index7;
  lookahead3 = advance3();
  index7 = pos;
}
function finishArrayExpression3(elements) {
  var node = new ASTNode3(SyntaxArrayExpression3);
  node.elements = elements;
  return node;
}
function finishBinaryExpression3(operator2, left, right) {
  var node = new ASTNode3(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression3 : SyntaxBinaryExpression3);
  node.operator = operator2;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression3(callee, args) {
  var node = new ASTNode3(SyntaxCallExpression3);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression3(test2, consequent, alternate) {
  var node = new ASTNode3(SyntaxConditionalExpression3);
  node.test = test2;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier3(name4) {
  var node = new ASTNode3(SyntaxIdentifier3);
  node.name = name4;
  return node;
}
function finishLiteral3(token) {
  var node = new ASTNode3(SyntaxLiteral3);
  node.value = token.value;
  node.raw = source4.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression3(accessor3, object2, property2) {
  var node = new ASTNode3(SyntaxMemberExpression3);
  node.computed = accessor3 === "[";
  node.object = object2;
  node.property = property2;
  if (!node.computed)
    property2.member = true;
  return node;
}
function finishObjectExpression3(properties) {
  var node = new ASTNode3(SyntaxObjectExpression3);
  node.properties = properties;
  return node;
}
function finishProperty3(kind, key3, value4) {
  var node = new ASTNode3(SyntaxProperty3);
  node.key = key3;
  node.value = value4;
  node.kind = kind;
  return node;
}
function finishUnaryExpression3(operator2, argument) {
  var node = new ASTNode3(SyntaxUnaryExpression3);
  node.operator = operator2;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError3(token, messageFormat) {
  var error3, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(
    /%(\d)/g,
    function(whole, index8) {
      assert3(index8 < args.length, "Message reference must be in range");
      return args[index8];
    }
  );
  error3 = new Error(msg);
  error3.index = index7;
  error3.description = msg;
  throw error3;
}
function throwUnexpected3(token) {
  if (token.type === TokenEOF3) {
    throwError3(token, MessageUnexpectedEOS3);
  }
  if (token.type === TokenNumericLiteral3) {
    throwError3(token, MessageUnexpectedNumber3);
  }
  if (token.type === TokenStringLiteral3) {
    throwError3(token, MessageUnexpectedString3);
  }
  if (token.type === TokenIdentifier3) {
    throwError3(token, MessageUnexpectedIdentifier3);
  }
  if (token.type === TokenKeyword3) {
    throwError3(token, MessageUnexpectedReserved3);
  }
  throwError3(token, MessageUnexpectedToken3, token.value);
}
function expect3(value4) {
  var token = lex3();
  if (token.type !== TokenPunctuator3 || token.value !== value4) {
    throwUnexpected3(token);
  }
}
function match3(value4) {
  return lookahead3.type === TokenPunctuator3 && lookahead3.value === value4;
}
function matchKeyword3(keyword) {
  return lookahead3.type === TokenKeyword3 && lookahead3.value === keyword;
}
function parseArrayInitialiser3() {
  var elements = [];
  index7 = lookahead3.start;
  expect3("[");
  while (!match3("]")) {
    if (match3(",")) {
      lex3();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression3());
      if (!match3("]")) {
        expect3(",");
      }
    }
  }
  lex3();
  return finishArrayExpression3(elements);
}
function parseObjectPropertyKey3() {
  var token;
  index7 = lookahead3.start;
  token = lex3();
  if (token.type === TokenStringLiteral3 || token.type === TokenNumericLiteral3) {
    if (token.octal) {
      throwError3(token, MessageStrictOctalLiteral3);
    }
    return finishLiteral3(token);
  }
  return finishIdentifier3(token.value);
}
function parseObjectProperty3() {
  var token, key3, id4, value4;
  index7 = lookahead3.start;
  token = lookahead3;
  if (token.type === TokenIdentifier3) {
    id4 = parseObjectPropertyKey3();
    expect3(":");
    value4 = parseConditionalExpression3();
    return finishProperty3("init", id4, value4);
  }
  if (token.type === TokenEOF3 || token.type === TokenPunctuator3) {
    throwUnexpected3(token);
  } else {
    key3 = parseObjectPropertyKey3();
    expect3(":");
    value4 = parseConditionalExpression3();
    return finishProperty3("init", key3, value4);
  }
}
function parseObjectInitialiser3() {
  var properties = [], property2, name4, key3, map11 = {}, toString3 = String;
  index7 = lookahead3.start;
  expect3("{");
  while (!match3("}")) {
    property2 = parseObjectProperty3();
    if (property2.key.type === SyntaxIdentifier3) {
      name4 = property2.key.name;
    } else {
      name4 = toString3(property2.key.value);
    }
    key3 = "$" + name4;
    if (Object.prototype.hasOwnProperty.call(map11, key3)) {
      throwError3({}, MessageStrictDuplicateProperty3);
    } else {
      map11[key3] = true;
    }
    properties.push(property2);
    if (!match3("}")) {
      expect3(",");
    }
  }
  expect3("}");
  return finishObjectExpression3(properties);
}
function parseGroupExpression3() {
  var expr2;
  expect3("(");
  expr2 = parseExpression3();
  expect3(")");
  return expr2;
}
function parsePrimaryExpression3() {
  var type4, token, expr2;
  if (match3("(")) {
    return parseGroupExpression3();
  }
  if (match3("[")) {
    return parseArrayInitialiser3();
  }
  if (match3("{")) {
    return parseObjectInitialiser3();
  }
  type4 = lookahead3.type;
  index7 = lookahead3.start;
  if (type4 === TokenIdentifier3 || legalKeywords3[lookahead3.value]) {
    expr2 = finishIdentifier3(lex3().value);
  } else if (type4 === TokenStringLiteral3 || type4 === TokenNumericLiteral3) {
    if (lookahead3.octal) {
      throwError3(lookahead3, MessageStrictOctalLiteral3);
    }
    expr2 = finishLiteral3(lex3());
  } else if (type4 === TokenKeyword3) {
    throw new Error(DISABLED3);
  } else if (type4 === TokenBooleanLiteral3) {
    token = lex3();
    token.value = token.value === "true";
    expr2 = finishLiteral3(token);
  } else if (type4 === TokenNullLiteral3) {
    token = lex3();
    token.value = null;
    expr2 = finishLiteral3(token);
  } else if (match3("/") || match3("/=")) {
    expr2 = finishLiteral3(scanRegExp3());
    peek5();
  } else {
    throwUnexpected3(lex3());
  }
  return expr2;
}
function parseArguments3() {
  var args = [];
  expect3("(");
  if (!match3(")")) {
    while (index7 < length3) {
      args.push(parseConditionalExpression3());
      if (match3(")")) {
        break;
      }
      expect3(",");
    }
  }
  expect3(")");
  return args;
}
function parseNonComputedProperty3() {
  var token;
  index7 = lookahead3.start;
  token = lex3();
  if (!isIdentifierName3(token)) {
    throwUnexpected3(token);
  }
  return finishIdentifier3(token.value);
}
function parseNonComputedMember3() {
  expect3(".");
  return parseNonComputedProperty3();
}
function parseComputedMember3() {
  var expr2;
  expect3("[");
  expr2 = parseExpression3();
  expect3("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall3() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression3();
  for (; ; ) {
    if (match3(".")) {
      property2 = parseNonComputedMember3();
      expr2 = finishMemberExpression3(".", expr2, property2);
    } else if (match3("(")) {
      args = parseArguments3();
      expr2 = finishCallExpression3(expr2, args);
    } else if (match3("[")) {
      property2 = parseComputedMember3();
      expr2 = finishMemberExpression3("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression3() {
  var expr2 = parseLeftHandSideExpressionAllowCall3();
  if (lookahead3.type === TokenPunctuator3) {
    if (match3("++") || match3("--")) {
      throw new Error(DISABLED3);
    }
  }
  return expr2;
}
function parseUnaryExpression3() {
  var token, expr2;
  if (lookahead3.type !== TokenPunctuator3 && lookahead3.type !== TokenKeyword3) {
    expr2 = parsePostfixExpression3();
  } else if (match3("++") || match3("--")) {
    throw new Error(DISABLED3);
  } else if (match3("+") || match3("-") || match3("~") || match3("!")) {
    token = lex3();
    expr2 = parseUnaryExpression3();
    expr2 = finishUnaryExpression3(token.value, expr2);
  } else if (matchKeyword3("delete") || matchKeyword3("void") || matchKeyword3("typeof")) {
    throw new Error(DISABLED3);
  } else {
    expr2 = parsePostfixExpression3();
  }
  return expr2;
}
function binaryPrecedence3(token) {
  var prec = 0;
  if (token.type !== TokenPunctuator3 && token.type !== TokenKeyword3) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
    default:
      break;
  }
  return prec;
}
function parseBinaryExpression3() {
  var marker, markers, expr2, token, prec, stack3, right, operator2, left, i;
  marker = lookahead3;
  left = parseUnaryExpression3();
  token = lookahead3;
  prec = binaryPrecedence3(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex3();
  markers = [marker, lookahead3];
  right = parseUnaryExpression3();
  stack3 = [left, token, right];
  while ((prec = binaryPrecedence3(lookahead3)) > 0) {
    while (stack3.length > 2 && prec <= stack3[stack3.length - 2].prec) {
      right = stack3.pop();
      operator2 = stack3.pop().value;
      left = stack3.pop();
      markers.pop();
      expr2 = finishBinaryExpression3(operator2, left, right);
      stack3.push(expr2);
    }
    token = lex3();
    token.prec = prec;
    stack3.push(token);
    markers.push(lookahead3);
    expr2 = parseUnaryExpression3();
    stack3.push(expr2);
  }
  i = stack3.length - 1;
  expr2 = stack3[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression3(stack3[i - 1].value, stack3[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression3() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression3();
  if (match3("?")) {
    lex3();
    consequent = parseConditionalExpression3();
    expect3(":");
    alternate = parseConditionalExpression3();
    expr2 = finishConditionalExpression3(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression3() {
  var expr2 = parseConditionalExpression3();
  if (match3(",")) {
    throw new Error(DISABLED3);
  }
  return expr2;
}
function parser_default(code) {
  source4 = code;
  index7 = 0;
  length3 = source4.length;
  lookahead3 = null;
  peek5();
  var expr2 = parseExpression3();
  if (lookahead3.type !== TokenEOF3) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}
var TokenName3, source4, index7, length3, lookahead3, TokenBooleanLiteral3, TokenEOF3, TokenIdentifier3, TokenKeyword3, TokenNullLiteral3, TokenNumericLiteral3, TokenPunctuator3, TokenStringLiteral3, TokenRegularExpression3, SyntaxArrayExpression3, SyntaxBinaryExpression3, SyntaxCallExpression3, SyntaxConditionalExpression3, SyntaxIdentifier3, SyntaxLiteral3, SyntaxLogicalExpression3, SyntaxMemberExpression3, SyntaxObjectExpression3, SyntaxProperty3, SyntaxUnaryExpression3, MessageUnexpectedToken3, MessageUnexpectedNumber3, MessageUnexpectedString3, MessageUnexpectedIdentifier3, MessageUnexpectedReserved3, MessageUnexpectedEOS3, MessageInvalidRegExp3, MessageUnterminatedRegExp3, MessageStrictOctalLiteral3, MessageStrictDuplicateProperty3, ILLEGAL5, DISABLED3, RegexNonAsciiIdentifierStart3, RegexNonAsciiIdentifierPart3, keywords4, legalKeywords3;
var init_parser = __esm({
  "node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/src/parser.js"() {
    init_ast();
    TokenBooleanLiteral3 = 1;
    TokenEOF3 = 2;
    TokenIdentifier3 = 3;
    TokenKeyword3 = 4;
    TokenNullLiteral3 = 5;
    TokenNumericLiteral3 = 6;
    TokenPunctuator3 = 7;
    TokenStringLiteral3 = 8;
    TokenRegularExpression3 = 9;
    TokenName3 = {};
    TokenName3[TokenBooleanLiteral3] = "Boolean";
    TokenName3[TokenEOF3] = "<end>";
    TokenName3[TokenIdentifier3] = "Identifier";
    TokenName3[TokenKeyword3] = "Keyword";
    TokenName3[TokenNullLiteral3] = "Null";
    TokenName3[TokenNumericLiteral3] = "Numeric";
    TokenName3[TokenPunctuator3] = "Punctuator";
    TokenName3[TokenStringLiteral3] = "String";
    TokenName3[TokenRegularExpression3] = "RegularExpression";
    SyntaxArrayExpression3 = "ArrayExpression";
    SyntaxBinaryExpression3 = "BinaryExpression";
    SyntaxCallExpression3 = "CallExpression";
    SyntaxConditionalExpression3 = "ConditionalExpression";
    SyntaxIdentifier3 = "Identifier";
    SyntaxLiteral3 = "Literal";
    SyntaxLogicalExpression3 = "LogicalExpression";
    SyntaxMemberExpression3 = "MemberExpression";
    SyntaxObjectExpression3 = "ObjectExpression";
    SyntaxProperty3 = "Property";
    SyntaxUnaryExpression3 = "UnaryExpression";
    MessageUnexpectedToken3 = "Unexpected token %0";
    MessageUnexpectedNumber3 = "Unexpected number";
    MessageUnexpectedString3 = "Unexpected string";
    MessageUnexpectedIdentifier3 = "Unexpected identifier";
    MessageUnexpectedReserved3 = "Unexpected reserved word";
    MessageUnexpectedEOS3 = "Unexpected end of input";
    MessageInvalidRegExp3 = "Invalid regular expression";
    MessageUnterminatedRegExp3 = "Invalid regular expression: missing /";
    MessageStrictOctalLiteral3 = "Octal literals are not allowed in strict mode.";
    MessageStrictDuplicateProperty3 = "Duplicate data property in object literal not allowed in strict mode";
    ILLEGAL5 = "ILLEGAL";
    DISABLED3 = "Disabled.";
    RegexNonAsciiIdentifierStart3 = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
    RegexNonAsciiIdentifierPart3 = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
    keywords4 = {
      "if": 1,
      "in": 1,
      "do": 1,
      "var": 1,
      "for": 1,
      "new": 1,
      "try": 1,
      "let": 1,
      "this": 1,
      "else": 1,
      "case": 1,
      "void": 1,
      "with": 1,
      "enum": 1,
      "while": 1,
      "break": 1,
      "catch": 1,
      "throw": 1,
      "const": 1,
      "yield": 1,
      "class": 1,
      "super": 1,
      "return": 1,
      "typeof": 1,
      "delete": 1,
      "switch": 1,
      "export": 1,
      "import": 1,
      "public": 1,
      "static": 1,
      "default": 1,
      "finally": 1,
      "extends": 1,
      "package": 1,
      "private": 1,
      "function": 1,
      "continue": 1,
      "debugger": 1,
      "interface": 1,
      "protected": 1,
      "instanceof": 1,
      "implements": 1
    };
    legalKeywords3 = {
      "if": 1
    };
  }
});

// node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/src/constants.js
var init_constants = __esm({
  "node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/src/constants.js"() {
  }
});

// node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/src/functions.js
var init_functions = __esm({
  "node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/src/functions.js"() {
    init_vega_util_module2();
  }
});

// node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/src/codegen.js
var init_codegen = __esm({
  "node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/src/codegen.js"() {
    init_constants();
    init_functions();
    init_vega_util_module2();
  }
});

// node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/index.js
var init_vega_expression = __esm({
  "node_modules/.pnpm/vega-expression@2.6.6/node_modules/vega-expression/index.js"() {
    init_ast();
    init_parser();
    init_codegen();
    init_functions();
    init_constants();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/expressions.js
function getName(node) {
  const name4 = [];
  if (node.type === "Identifier") {
    return [node.name];
  }
  if (node.type === "Literal") {
    return [node.value];
  }
  if (node.type === "MemberExpression") {
    name4.push(...getName(node.object));
    name4.push(...getName(node.property));
  }
  return name4;
}
function startsWithDatum(node) {
  if (node.object.type === "MemberExpression") {
    return startsWithDatum(node.object);
  }
  return node.object.name === "datum";
}
function getDependentFields(expression3) {
  const ast = parser_default(expression3);
  const dependents = /* @__PURE__ */ new Set();
  ast.visit((node) => {
    if (node.type === "MemberExpression" && startsWithDatum(node)) {
      dependents.add(getName(node).slice(1).join("."));
    }
  });
  return dependents;
}
var init_expressions = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/expressions.js"() {
    init_vega_expression();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/filter.js
var FilterNode;
var init_filter4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/filter.js"() {
    init_util();
    init_predicate2();
    init_dataflow();
    init_expressions();
    FilterNode = class extends DataFlowNode {
      constructor(parent, model, filter6) {
        super(parent);
        this.model = model;
        this.filter = filter6;
        this.expr = expression2(this.model, this.filter, this);
        this._dependentFields = getDependentFields(this.expr);
      }
      clone() {
        return new FilterNode(null, this.model, duplicate(this.filter));
      }
      dependentFields() {
        return this._dependentFields;
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      assemble() {
        return {
          type: "filter",
          expr: this.expr
        };
      }
      hash() {
        return `Filter ${this.expr}`;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/parse.js
function parseUnitSelection(model, selDefs) {
  var _a2;
  const selCmpts = {};
  const selectionConfig = model.config.selection;
  for (const name4 of keys4(selDefs !== null && selDefs !== void 0 ? selDefs : {})) {
    const selDef = duplicate(selDefs[name4]);
    const _b = selectionConfig[selDef.type], { fields, encodings } = _b, cfg = __rest(_b, ["fields", "encodings"]);
    for (const key3 in cfg) {
      if (key3 === "encodings" && selDef.fields || key3 === "fields" && selDef.encodings) {
        continue;
      }
      if (key3 === "mark") {
        selDef[key3] = Object.assign(Object.assign({}, cfg[key3]), selDef[key3]);
      }
      if (selDef[key3] === void 0 || selDef[key3] === true) {
        selDef[key3] = (_a2 = cfg[key3]) !== null && _a2 !== void 0 ? _a2 : selDef[key3];
      }
    }
    const safeName = varName(name4);
    const selCmpt = selCmpts[safeName] = Object.assign(Object.assign({}, selDef), { name: safeName, events: isString_default(selDef.on) ? eventSelector2(selDef.on, "scope") : duplicate(selDef.on) });
    forEachTransform(selCmpt, (txCompiler) => {
      if (txCompiler.has(selCmpt) && txCompiler.parse) {
        txCompiler.parse(model, selCmpt, selDef, selDefs[name4]);
      }
    });
  }
  return selCmpts;
}
function parseSelectionPredicate(model, selections, dfnode, datum2 = "datum") {
  const stores = [];
  function expr2(name4) {
    const vname = varName(name4);
    const selCmpt = model.getSelectionComponent(vname, name4);
    const store = $3(vname + STORE);
    if (selCmpt.project.timeUnit) {
      const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;
      const tunode = selCmpt.project.timeUnit.clone();
      if (child.parent) {
        tunode.insertAsParentOf(child);
      } else {
        child.parent = tunode;
      }
    }
    if (selCmpt.empty !== "none") {
      stores.push(store);
    }
    return `vlSelectionTest(${store}, ${datum2}` + (selCmpt.resolve === "global" ? ")" : `, ${$3(selCmpt.resolve)})`);
  }
  const predicateStr = logicalExpr(selections, expr2);
  return (stores.length ? "!(" + stores.map((s3) => `length(data(${s3}))`).join(" || ") + ") || " : "") + `(${predicateStr})`;
}
function parseSelectionBinExtent(selCmpt, extent5) {
  const encoding = extent5["encoding"];
  let field4 = extent5["field"];
  if (!encoding && !field4) {
    field4 = selCmpt.project.items[0].field;
    if (selCmpt.project.items.length > 1) {
      warn2(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${$3(field4)}.`);
    }
  } else if (encoding && !field4) {
    const encodings = selCmpt.project.items.filter((p) => p.channel === encoding);
    if (!encodings.length || encodings.length > 1) {
      field4 = selCmpt.project.items[0].field;
      warn2((!encodings.length ? "No " : "Multiple ") + `matching ${$3(encoding)} encoding found for selection ${$3(extent5.selection)}. Using "field": ${$3(field4)}.`);
    } else {
      field4 = encodings[0].field;
    }
  }
  return `${selCmpt.name}[${$3(field4)}]`;
}
function materializeSelections(model, main5) {
  forEachSelection(model, (selCmpt) => {
    const selection2 = selCmpt.name;
    const lookupName = model.getName(`lookup_${selection2}`);
    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main5, model, { selection: selection2 }), lookupName, "lookup", model.component.data.outputNodeRefCounts);
  });
}
var init_parse3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/selection/parse.js"() {
    init_tslib_es6();
    init_vega_event_selector_module2();
    init_vega_util();
    init_selection2();
    init_log3();
    init_util();
    init_dataflow();
    init_filter4();
    init_transforms();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/predicate.js
function expression2(model, filterOp, node) {
  return logicalExpr(filterOp, (predicate) => {
    if (isString_default(predicate)) {
      return predicate;
    } else if (isSelectionPredicate(predicate)) {
      return parseSelectionPredicate(model, predicate.selection, node);
    } else {
      return fieldFilterExpression(predicate);
    }
  });
}
var init_predicate2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/predicate.js"() {
    init_vega_util();
    init_predicate();
    init_util();
    init_parse3();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/assemble.js
function assembleTitle(title2, config) {
  if (!title2) {
    return void 0;
  }
  if (isArray_default(title2) && !isText(title2)) {
    return title2.map((fieldDef) => defaultTitle(fieldDef, config)).join(", ");
  }
  return title2;
}
function setAxisEncode(axis, part, vgProp, vgRef) {
  var _a2, _b, _c2;
  axis.encode = (_a2 = axis.encode) !== null && _a2 !== void 0 ? _a2 : {};
  axis.encode[part] = (_b = axis.encode[part]) !== null && _b !== void 0 ? _b : {};
  axis.encode[part].update = (_c2 = axis.encode[part].update) !== null && _c2 !== void 0 ? _c2 : {};
  axis.encode[part].update[vgProp] = vgRef;
}
function assembleAxis(axisCmpt, kind, config, opt = { header: false }) {
  var _a2, _b;
  const _c2 = axisCmpt.combine(), { disable, orient: orient3, scale: scale8, labelExpr, title: title2, zindex } = _c2, axis = __rest(_c2, ["disable", "orient", "scale", "labelExpr", "title", "zindex"]);
  if (disable) {
    return void 0;
  }
  for (const prop in axis) {
    const propType = AXIS_PROPERTY_TYPE[prop];
    const propValue = axis[prop];
    if (propType && propType !== kind && propType !== "both") {
      delete axis[prop];
    } else if (isConditionalAxisValue(propValue)) {
      const { condition } = propValue, valueOrSignalRef = __rest(propValue, ["condition"]);
      const conditions = array_default6(condition);
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        const vgRef = [
          ...conditions.map((c2) => {
            const { test: test2 } = c2, valueOrSignalCRef = __rest(c2, ["test"]);
            return Object.assign({ test: expression2(null, test2) }, valueOrSignalCRef);
          }),
          valueOrSignalRef
        ];
        setAxisEncode(axis, part, vgProp, vgRef);
        delete axis[prop];
      } else if (propIndex === null) {
        const signalRef = {
          signal: conditions.map((c2) => {
            const { test: test2 } = c2, valueOrSignalCRef = __rest(c2, ["test"]);
            return `${expression2(null, test2)} ? ${exprFromValueOrSignalRef(valueOrSignalCRef)} : `;
          }).join("") + exprFromValueOrSignalRef(valueOrSignalRef)
        };
        axis[prop] = signalRef;
      }
    } else if (isSignalRef(propValue)) {
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        setAxisEncode(axis, part, vgProp, propValue);
        delete axis[prop];
      }
    }
  }
  if (kind === "grid") {
    if (!axis.grid) {
      return void 0;
    }
    if (axis.encode) {
      const { grid } = axis.encode;
      axis.encode = Object.assign({}, grid ? { grid } : {});
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    return Object.assign(Object.assign({
      scale: scale8,
      orient: orient3
    }, axis), {
      domain: false,
      labels: false,
      aria: false,
      maxExtent: 0,
      minExtent: 0,
      ticks: false,
      zindex: getFirstDefined(zindex, 0)
    });
  } else {
    if (!opt.header && axisCmpt.mainExtracted) {
      return void 0;
    }
    if (labelExpr !== void 0) {
      let expr2 = labelExpr;
      if (((_b = (_a2 = axis.encode) === null || _a2 === void 0 ? void 0 : _a2.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {
        expr2 = replaceAll(labelExpr, "datum.label", axis.encode.labels.update.text.signal);
      }
      setAxisEncode(axis, "labels", "text", { signal: expr2 });
    }
    if (axis.labelAlign === null) {
      delete axis.labelAlign;
    }
    if (axis.encode) {
      for (const part of AXIS_PARTS) {
        if (!axisCmpt.hasAxisPart(part)) {
          delete axis.encode[part];
        }
      }
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    const titleString = assembleTitle(title2, config);
    return Object.assign(Object.assign(Object.assign(Object.assign({
      scale: scale8,
      orient: orient3,
      grid: false
    }, titleString ? { title: titleString } : {}), axis), config.aria === false ? { aria: false } : {}), {
      zindex: getFirstDefined(zindex, 0)
    });
  }
}
function assembleAxisSignals(model) {
  const { axes } = model.component;
  const signals = [];
  for (const channel of POSITION_SCALE_CHANNELS) {
    if (axes[channel]) {
      for (const axis of axes[channel]) {
        if (!axis.get("disable") && !axis.get("gridScale")) {
          const sizeType = channel === "x" ? "height" : "width";
          const update3 = model.getSizeSignalRef(sizeType).signal;
          if (sizeType !== update3) {
            signals.push({
              name: sizeType,
              update: update3
            });
          }
        }
      }
    }
  }
  return signals;
}
function assembleAxes(axisComponents, config) {
  const { x: x7 = [], y: y7 = [] } = axisComponents;
  return [
    ...x7.map((a4) => assembleAxis(a4, "grid", config)),
    ...y7.map((a4) => assembleAxis(a4, "grid", config)),
    ...x7.map((a4) => assembleAxis(a4, "main", config)),
    ...y7.map((a4) => assembleAxis(a4, "main", config))
  ].filter((a4) => a4);
}
var init_assemble2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/assemble.js"() {
    init_tslib_es6();
    init_vega_util();
    init_axis();
    init_channel();
    init_channeldef();
    init_title();
    init_util();
    init_vega_schema();
    init_common();
    init_predicate2();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/header.js
var HEADER_TITLE_PROPERTIES_MAP, HEADER_LABEL_PROPERTIES_MAP, HEADER_TITLE_PROPERTIES, HEADER_LABEL_PROPERTIES;
var init_header = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/header.js"() {
    init_util();
    HEADER_TITLE_PROPERTIES_MAP = {
      titleAlign: "align",
      titleAnchor: "anchor",
      titleAngle: "angle",
      titleBaseline: "baseline",
      titleColor: "color",
      titleFont: "font",
      titleFontSize: "fontSize",
      titleFontStyle: "fontStyle",
      titleFontWeight: "fontWeight",
      titleLimit: "limit",
      titleLineHeight: "lineHeight",
      titleOrient: "orient",
      titlePadding: "offset"
    };
    HEADER_LABEL_PROPERTIES_MAP = {
      labelAlign: "align",
      labelAnchor: "anchor",
      labelAngle: "angle",
      labelBaseline: "baseline",
      labelColor: "color",
      labelFont: "font",
      labelFontSize: "fontSize",
      labelFontStyle: "fontStyle",
      labelFontWeight: "fontWeight",
      labelLimit: "limit",
      labelLineHeight: "lineHeight",
      labelOrient: "orient",
      labelPadding: "offset"
    };
    HEADER_TITLE_PROPERTIES = keys4(HEADER_TITLE_PROPERTIES_MAP);
    HEADER_LABEL_PROPERTIES = keys4(HEADER_LABEL_PROPERTIES_MAP);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/config.js
function getAxisConfigFromConfigTypes(configTypes, config, channel, orient3) {
  return Object.assign.apply(null, [
    {},
    ...configTypes.map((configType) => {
      if (configType === "axisOrient") {
        const orient1 = channel === "x" ? "bottom" : "left";
        const orientConfig1 = config[channel === "x" ? "axisBottom" : "axisLeft"] || {};
        const orientConfig2 = config[channel === "x" ? "axisTop" : "axisRight"] || {};
        const props = /* @__PURE__ */ new Set([...keys4(orientConfig1), ...keys4(orientConfig2)]);
        const conditionalOrientAxisConfig = {};
        for (const prop of props.values()) {
          conditionalOrientAxisConfig[prop] = {
            signal: `${orient3["signal"]} === "${orient1}" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`
          };
        }
        return conditionalOrientAxisConfig;
      }
      return config[configType];
    })
  ]);
}
function getAxisConfigs(channel, scaleType2, orient3, config) {
  const typeBasedConfigTypes = scaleType2 === "band" ? ["axisDiscrete", "axisBand"] : scaleType2 === "point" ? ["axisDiscrete", "axisPoint"] : isQuantitative(scaleType2) ? ["axisQuantitative"] : scaleType2 === "time" || scaleType2 === "utc" ? ["axisTemporal"] : [];
  const axisChannel = channel === "x" ? "axisX" : "axisY";
  const axisOrient = isSignalRef(orient3) ? "axisOrient" : "axis" + titleCase(orient3);
  const vlOnlyConfigTypes = [
    ...typeBasedConfigTypes,
    ...typeBasedConfigTypes.map((c2) => axisChannel + c2.substr(4))
  ];
  const vgConfigTypes = ["axis", axisOrient, axisChannel];
  return {
    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient3),
    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient3),
    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)
  };
}
function getAxisConfigStyle(axisConfigTypes, config) {
  var _a2;
  const toMerge = [{}];
  for (const configType of axisConfigTypes) {
    let style3 = (_a2 = config[configType]) === null || _a2 === void 0 ? void 0 : _a2.style;
    if (style3) {
      style3 = array_default6(style3);
      for (const s3 of style3) {
        toMerge.push(config.style[s3]);
      }
    }
  }
  return Object.assign.apply(null, toMerge);
}
function getAxisConfig(property2, config, style3, axisConfigs = {}) {
  var _a2;
  const styleConfig = getStyleConfig(property2, style3, config.style);
  if (styleConfig !== void 0) {
    return {
      configFrom: "style",
      configValue: styleConfig
    };
  }
  for (const configFrom of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"]) {
    if (((_a2 = axisConfigs[configFrom]) === null || _a2 === void 0 ? void 0 : _a2[property2]) !== void 0) {
      return { configFrom, configValue: axisConfigs[configFrom][property2] };
    }
  }
  return {};
}
var init_config2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/config.js"() {
    init_vega_util();
    init_scale();
    init_util();
    init_vega_schema();
    init_common();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/properties.js
function defaultGrid(scaleType2, fieldDef) {
  return !hasDiscreteDomain(scaleType2) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);
}
function gridScale(model, channel) {
  const gridChannel = channel === "x" ? "y" : "x";
  if (model.getScaleComponent(gridChannel)) {
    return model.scaleName(gridChannel);
  }
  return void 0;
}
function getLabelAngle(model, axis, channel, fieldOrDatumDef, axisConfigs) {
  const labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle;
  if (labelAngle !== void 0) {
    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);
  } else {
    const { configValue: angle2 } = getAxisConfig("labelAngle", model.config, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs);
    if (angle2 !== void 0) {
      return normalizeAngle(angle2);
    } else {
      if (channel === X3 && contains2([NOMINAL, ORDINAL], fieldOrDatumDef.type)) {
        return 270;
      }
      return void 0;
    }
  }
}
function normalizeAngleExpr(angle2) {
  return `(((${angle2.signal} % 360) + 360) % 360)`;
}
function defaultLabelBaseline(angle2, orient3, channel, alwaysIncludeMiddle) {
  if (angle2 !== void 0) {
    if (channel === "x") {
      if (isSignalRef(angle2)) {
        const a4 = normalizeAngleExpr(angle2);
        const orientIsTop = isSignalRef(orient3) ? `(${orient3.signal} === "top")` : orient3 === "top";
        return {
          signal: `(45 < ${a4} && ${a4} < 135) || (225 < ${a4} && ${a4} < 315) ? "middle" :(${a4} <= 45 || 315 <= ${a4}) === ${orientIsTop} ? "bottom" : "top"`
        };
      }
      if (45 < angle2 && angle2 < 135 || 225 < angle2 && angle2 < 315) {
        return "middle";
      }
      if (isSignalRef(orient3)) {
        const op = angle2 <= 45 || 315 <= angle2 ? "===" : "!==";
        return { signal: `${orient3.signal} ${op} "top" ? "bottom" : "top"` };
      }
      return (angle2 <= 45 || 315 <= angle2) === (orient3 === "top") ? "bottom" : "top";
    } else {
      if (isSignalRef(angle2)) {
        const a4 = normalizeAngleExpr(angle2);
        const orientIsLeft = isSignalRef(orient3) ? `(${orient3.signal} === "left")` : orient3 === "left";
        const middle = alwaysIncludeMiddle ? '"middle"' : "null";
        return {
          signal: `${a4} <= 45 || 315 <= ${a4} || (135 <= ${a4} && ${a4} <= 225) ? ${middle} : (45 <= ${a4} && ${a4} <= 135) === ${orientIsLeft} ? "top" : "bottom"`
        };
      }
      if (angle2 <= 45 || 315 <= angle2 || 135 <= angle2 && angle2 <= 225) {
        return alwaysIncludeMiddle ? "middle" : null;
      }
      if (isSignalRef(orient3)) {
        const op = 45 <= angle2 && angle2 <= 135 ? "===" : "!==";
        return { signal: `${orient3.signal} ${op} "left" ? "top" : "bottom"` };
      }
      return (45 <= angle2 && angle2 <= 135) === (orient3 === "left") ? "top" : "bottom";
    }
  }
  return void 0;
}
function defaultLabelAlign(angle2, orient3, channel) {
  if (angle2 === void 0) {
    return void 0;
  }
  const isX2 = channel === "x";
  const startAngle = isX2 ? 0 : 90;
  const mainOrient = isX2 ? "bottom" : "left";
  if (isSignalRef(angle2)) {
    const a4 = normalizeAngleExpr(angle2);
    const orientIsMain = isSignalRef(orient3) ? `(${orient3.signal} === "${mainOrient}")` : orient3 === mainOrient;
    return {
      signal: `(${startAngle ? "(" + a4 + " + 90)" : a4} % 180 === 0) ? ${isX2 ? null : '"center"'} :(${startAngle} < ${a4} && ${a4} < ${180 + startAngle}) === ${orientIsMain} ? "left" : "right"`
    };
  }
  if ((angle2 + startAngle) % 180 === 0) {
    return isX2 ? null : "center";
  }
  if (isSignalRef(orient3)) {
    const op = startAngle < angle2 && angle2 < 180 + startAngle ? "===" : "!==";
    const orientIsMain = `${orient3.signal} ${op} "${mainOrient}"`;
    return {
      signal: `${orientIsMain} ? "left" : "right"`
    };
  }
  if ((startAngle < angle2 && angle2 < 180 + startAngle) === (orient3 === mainOrient)) {
    return "left";
  }
  return "right";
}
function defaultLabelFlush(type4, channel) {
  if (channel === "x" && contains2(["quantitative", "temporal"], type4)) {
    return true;
  }
  return void 0;
}
function defaultLabelOverlap(type4, scaleType2) {
  if (type4 !== "nominal") {
    if (scaleType2 === "log") {
      return "greedy";
    }
    return true;
  }
  return void 0;
}
function defaultOrient(channel) {
  return channel === "x" ? "bottom" : "left";
}
function defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size, values: vals2 }) {
  var _a2;
  if (!vals2 && !hasDiscreteDomain(scaleType2) && scaleType2 !== "log") {
    if (isFieldDef(fieldOrDatumDef)) {
      if (isBinning(fieldOrDatumDef.bin)) {
        return { signal: `ceil(${size.signal}/10)` };
      }
      if (fieldOrDatumDef.timeUnit && contains2(["month", "hours", "day", "quarter"], (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit)) {
        return void 0;
      }
    }
    return { signal: `ceil(${size.signal}/40)` };
  }
  return void 0;
}
function getFieldDefTitle(model, channel) {
  const channel2 = channel === "x" ? "x2" : "y2";
  const fieldDef = model.fieldDef(channel);
  const fieldDef2 = model.fieldDef(channel2);
  const title1 = fieldDef ? fieldDef.title : void 0;
  const title2 = fieldDef2 ? fieldDef2.title : void 0;
  if (title1 && title2) {
    return mergeTitle(title1, title2);
  } else if (title1) {
    return title1;
  } else if (title2) {
    return title2;
  } else if (title1 !== void 0) {
    return title1;
  } else if (title2 !== void 0) {
    return title2;
  }
  return void 0;
}
function values3(axis, fieldOrDatumDef) {
  const vals2 = axis.values;
  if (isArray_default(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultZindex(mark, fieldDef) {
  if (mark === "rect" && isDiscrete3(fieldDef)) {
    return 1;
  }
  return 0;
}
var axisRules;
var init_properties = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/properties.js"() {
    init_vega_util();
    init_bin4();
    init_channel();
    init_channeldef();
    init_scale();
    init_timeunit();
    init_type();
    init_util();
    init_vega_schema();
    init_common();
    init_format();
    init_config2();
    axisRules = {
      scale: ({ model, channel }) => model.scaleName(channel),
      format: ({ fieldOrDatumDef, config, axis }) => {
        const { format: format9, formatType } = axis;
        return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format9, formatType, config, true);
      },
      formatType: ({ axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
        const { formatType } = axis;
        return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
      },
      grid: ({ fieldOrDatumDef, axis, scaleType: scaleType2 }) => {
        var _a2;
        if (isFieldDef(fieldOrDatumDef) && isBinned(fieldOrDatumDef.bin)) {
          return false;
        } else {
          return (_a2 = axis.grid) !== null && _a2 !== void 0 ? _a2 : defaultGrid(scaleType2, fieldOrDatumDef);
        }
      },
      gridScale: ({ model, channel }) => gridScale(model, channel),
      labelAlign: ({ axis, labelAngle, orient: orient3, channel }) => axis.labelAlign || defaultLabelAlign(labelAngle, orient3, channel),
      labelAngle: ({ labelAngle }) => labelAngle,
      labelBaseline: ({ axis, labelAngle, orient: orient3, channel }) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient3, channel),
      labelFlush: ({ axis, fieldOrDatumDef, channel }) => {
        var _a2;
        return (_a2 = axis.labelFlush) !== null && _a2 !== void 0 ? _a2 : defaultLabelFlush(fieldOrDatumDef.type, channel);
      },
      labelOverlap: ({ axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
        var _a2;
        return (_a2 = axis.labelOverlap) !== null && _a2 !== void 0 ? _a2 : defaultLabelOverlap(fieldOrDatumDef.type, scaleType2);
      },
      orient: ({ orient: orient3 }) => orient3,
      tickCount: ({ channel, model, axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
        var _a2;
        const sizeType = channel === "x" ? "width" : channel === "y" ? "height" : void 0;
        const size = sizeType ? model.getSizeSignalRef(sizeType) : void 0;
        return (_a2 = axis.tickCount) !== null && _a2 !== void 0 ? _a2 : defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size, values: axis.values });
      },
      title: ({ axis, model, channel }) => {
        if (axis.title !== void 0) {
          return axis.title;
        }
        const fieldDefTitle = getFieldDefTitle(model, channel);
        if (fieldDefTitle !== void 0) {
          return fieldDefTitle;
        }
        const fieldDef = model.typedFieldDef(channel);
        const channel2 = channel === "x" ? "x2" : "y2";
        const fieldDef2 = model.fieldDef(channel2);
        return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);
      },
      values: ({ axis, fieldOrDatumDef }) => values3(axis, fieldOrDatumDef),
      zindex: ({ axis, fieldOrDatumDef, mark }) => {
        var _a2;
        return (_a2 = axis.zindex) !== null && _a2 !== void 0 ? _a2 : defaultZindex(mark, fieldOrDatumDef);
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/calculate.js
function sortArrayIndexField(fieldDef, channel, opt) {
  return vgField(fieldDef, Object.assign({ prefix: channel, suffix: "sort_index" }, opt !== null && opt !== void 0 ? opt : {}));
}
var CalculateNode;
var init_calculate = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/calculate.js"() {
    init_channeldef();
    init_predicate();
    init_sort5();
    init_util();
    init_dataflow();
    init_expressions();
    CalculateNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        super(parent);
        this.transform = transform4;
        this._dependentFields = getDependentFields(this.transform.calculate);
      }
      clone() {
        return new CalculateNode(null, duplicate(this.transform));
      }
      static parseAllForSortIndex(parent, model) {
        model.forEachFieldDef((fieldDef, channel) => {
          if (!isScaleFieldDef(fieldDef)) {
            return;
          }
          if (isSortArray(fieldDef.sort)) {
            const { field: field4, timeUnit } = fieldDef;
            const sort5 = fieldDef.sort;
            const calculate = sort5.map((sortValue, i) => {
              return `${fieldFilterExpression({ field: field4, timeUnit, equal: sortValue })} ? ${i} : `;
            }).join("") + sort5.length;
            parent = new CalculateNode(parent, {
              calculate,
              as: sortArrayIndexField(fieldDef, channel, { forAs: true })
            });
          }
        });
        return parent;
      }
      producedFields() {
        return /* @__PURE__ */ new Set([this.transform.as]);
      }
      dependentFields() {
        return this._dependentFields;
      }
      assemble() {
        return {
          type: "formula",
          expr: this.transform.calculate,
          as: this.transform.as
        };
      }
      hash() {
        return `Calculate ${hash(this.transform)}`;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/header/common.js
function getHeaderChannel(channel, orient3) {
  if (contains2(["top", "bottom"], orient3)) {
    return "column";
  } else if (contains2(["left", "right"], orient3)) {
    return "row";
  }
  return channel === "row" ? "row" : "column";
}
function getHeaderProperty(prop, facetFieldDef, config, channel) {
  const headerSpecificConfig = channel === "row" ? config.headerRow : channel === "column" ? config.headerColumn : config.headerFacet;
  return getFirstDefined(((facetFieldDef === null || facetFieldDef === void 0 ? void 0 : facetFieldDef.header) || {})[prop], headerSpecificConfig[prop], config.header[prop]);
}
function getHeaderProperties(properties, facetFieldDef, config, channel) {
  const props = {};
  for (const prop of properties) {
    const value4 = getHeaderProperty(prop, facetFieldDef, config, channel);
    if (value4 !== void 0) {
      props[prop] = value4;
    }
  }
  return props;
}
var init_common3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/header/common.js"() {
    init_util();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/header/component.js
var HEADER_CHANNELS, HEADER_TYPES;
var init_component = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/header/component.js"() {
    HEADER_CHANNELS = ["row", "column"];
    HEADER_TYPES = ["header", "footer"];
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/header/assemble.js
function assembleTitleGroup(model, channel) {
  const title2 = model.component.layoutHeaders[channel].title;
  const config = model.config ? model.config : void 0;
  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : void 0;
  const { titleAnchor, titleAngle: ta, titleOrient } = getHeaderProperties(["titleAnchor", "titleAngle", "titleOrient"], facetFieldDef, config, channel);
  const headerChannel = getHeaderChannel(channel, titleOrient);
  const titleAngle = normalizeAngle(ta);
  return {
    name: `${channel}-title`,
    type: "group",
    role: `${headerChannel}-title`,
    title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: title2 }, channel === "row" ? { orient: "left" } : {}), { style: "guide-title" }), defaultHeaderGuideBaseline(titleAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP))
  };
}
function defaultHeaderGuideAlign(headerChannel, angle2, anchor = "middle") {
  switch (anchor) {
    case "start":
      return { align: "left" };
    case "end":
      return { align: "right" };
  }
  const align2 = defaultLabelAlign(angle2, headerChannel === "row" ? "left" : "top", headerChannel === "row" ? "y" : "x");
  return align2 ? { align: align2 } : {};
}
function defaultHeaderGuideBaseline(angle2, channel) {
  const baseline3 = defaultLabelBaseline(angle2, channel === "row" ? "left" : "top", channel === "row" ? "y" : "x", true);
  return baseline3 ? { baseline: baseline3 } : {};
}
function assembleHeaderGroups(model, channel) {
  const layoutHeader = model.component.layoutHeaders[channel];
  const groups4 = [];
  for (const headerType of HEADER_TYPES) {
    if (layoutHeader[headerType]) {
      for (const headerComponent of layoutHeader[headerType]) {
        const group6 = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);
        if (group6 != null) {
          groups4.push(group6);
        }
      }
    }
  }
  return groups4;
}
function getSort(facetFieldDef, channel) {
  var _a2;
  const { sort: sort5 } = facetFieldDef;
  if (isSortField(sort5)) {
    return {
      field: vgField(sort5, { expr: "datum" }),
      order: (_a2 = sort5.order) !== null && _a2 !== void 0 ? _a2 : "ascending"
    };
  } else if (isArray_default(sort5)) {
    return {
      field: sortArrayIndexField(facetFieldDef, channel, { expr: "datum" }),
      order: "ascending"
    };
  } else {
    return {
      field: vgField(facetFieldDef, { expr: "datum" }),
      order: sort5 !== null && sort5 !== void 0 ? sort5 : "ascending"
    };
  }
}
function assembleLabelTitle(facetFieldDef, channel, config) {
  const { format: format9, formatType, labelAngle, labelAnchor, labelOrient, labelExpr } = getHeaderProperties(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], facetFieldDef, config, channel);
  const titleTextExpr = formatSignalRef({ fieldOrDatumDef: facetFieldDef, format: format9, formatType, expr: "parent", config }).signal;
  const headerChannel = getHeaderChannel(channel, labelOrient);
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ text: {
    signal: labelExpr ? replaceAll(replaceAll(labelExpr, "datum.label", titleTextExpr), "datum.value", vgField(facetFieldDef, { expr: "parent" })) : titleTextExpr
  } }, channel === "row" ? { orient: "left" } : {}), { style: "guide-label", frame: "group" }), defaultHeaderGuideBaseline(labelAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP));
}
function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {
  if (headerComponent) {
    let title2 = null;
    const { facetFieldDef } = layoutHeader;
    const config = model.config ? model.config : void 0;
    if (facetFieldDef && headerComponent.labels) {
      const { labelOrient } = getHeaderProperties(["labelOrient"], facetFieldDef, config, channel);
      if (channel === "row" && !contains2(["top", "bottom"], labelOrient) || channel === "column" && !contains2(["left", "right"], labelOrient)) {
        title2 = assembleLabelTitle(facetFieldDef, channel, config);
      }
    }
    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);
    const axes = headerComponent.axes;
    const hasAxes = (axes === null || axes === void 0 ? void 0 : axes.length) > 0;
    if (title2 || hasAxes) {
      const sizeChannel = channel === "row" ? "height" : "width";
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName(`${channel}_${headerType}`), type: "group", role: `${channel}-${headerType}` }, layoutHeader.facetFieldDef ? {
        from: { data: model.getName(channel + "_domain") },
        sort: getSort(facetFieldDef, channel)
      } : {}), hasAxes && isFacetWithoutRowCol ? {
        from: { data: model.getName(`facet_domain_${channel}`) }
      } : {}), title2 ? { title: title2 } : {}), headerComponent.sizeSignal ? {
        encode: {
          update: {
            [sizeChannel]: headerComponent.sizeSignal
          }
        }
      } : {}), hasAxes ? { axes } : {});
    }
  }
  return null;
}
function getLayoutTitleBand(titleAnchor, headerChannel) {
  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];
}
function assembleLayoutTitleBand(headerComponentIndex, config) {
  const titleBand = {};
  for (const channel of FACET_CHANNELS) {
    const headerComponent = headerComponentIndex[channel];
    if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent.facetFieldDef) {
      const { titleAnchor, titleOrient } = getHeaderProperties(["titleAnchor", "titleOrient"], headerComponent.facetFieldDef, config, channel);
      const headerChannel = getHeaderChannel(channel, titleOrient);
      const band5 = getLayoutTitleBand(titleAnchor, headerChannel);
      if (band5 !== void 0) {
        titleBand[headerChannel] = band5;
      }
    }
  }
  return isEmpty(titleBand) ? void 0 : titleBand;
}
function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {
  const props = {};
  for (const prop of properties) {
    if (!propertiesMap[prop]) {
      continue;
    }
    const value4 = getHeaderProperty(prop, facetFieldDef, config, channel);
    if (value4 !== void 0) {
      props[propertiesMap[prop]] = value4;
    }
  }
  return props;
}
var LAYOUT_TITLE_BAND;
var init_assemble3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/header/assemble.js"() {
    init_vega_util();
    init_channel();
    init_channeldef();
    init_header();
    init_sort5();
    init_facet();
    init_util();
    init_properties();
    init_calculate();
    init_format();
    init_model();
    init_common3();
    init_component();
    LAYOUT_TITLE_BAND = {
      column: {
        start: 0,
        end: 1
      },
      row: {
        start: 1,
        end: 0
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/layoutsize/assemble.js
function assembleLayoutSignals(model) {
  return [
    ...sizeSignals(model, "width"),
    ...sizeSignals(model, "height"),
    ...sizeSignals(model, "childWidth"),
    ...sizeSignals(model, "childHeight")
  ];
}
function sizeSignals(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const size = model.component.layoutSize.get(sizeType);
  if (!size || size === "merged") {
    return [];
  }
  const name4 = model.getSizeSignalRef(sizeType).signal;
  if (size === "step") {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const type4 = scaleComponent.get("type");
      const range7 = scaleComponent.get("range");
      if (hasDiscreteDomain(type4) && isVgRangeStep(range7)) {
        const scaleName = model.scaleName(channel);
        if (isFacetModel(model.parent)) {
          const parentResolve = model.parent.component.resolve;
          if (parentResolve.scale[channel] === "independent") {
            return [stepSignal(scaleName, range7)];
          }
        }
        return [
          stepSignal(scaleName, range7),
          {
            name: name4,
            update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)
          }
        ];
      }
    }
    throw new Error("layout size is step although width/height is not step.");
  } else if (size == "container") {
    const isWidth = name4.endsWith("width");
    const expr2 = isWidth ? "containerSize()[0]" : "containerSize()[1]";
    const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? "width" : "height");
    const safeExpr = `isFinite(${expr2}) ? ${expr2} : ${defaultValue}`;
    return [{ name: name4, init: safeExpr, on: [{ update: safeExpr, events: "window:resize" }] }];
  } else {
    return [
      {
        name: name4,
        value: size
      }
    ];
  }
}
function stepSignal(scaleName, range7) {
  return {
    name: scaleName + "_step",
    value: range7.step
  };
}
function sizeExpr(scaleName, scaleComponent, cardinality) {
  const type4 = scaleComponent.get("type");
  const padding3 = scaleComponent.get("padding");
  const paddingOuter2 = getFirstDefined(scaleComponent.get("paddingOuter"), padding3);
  let paddingInner2 = scaleComponent.get("paddingInner");
  paddingInner2 = type4 === "band" ? paddingInner2 !== void 0 ? paddingInner2 : padding3 : 1;
  return `bandspace(${cardinality}, ${paddingInner2}, ${paddingOuter2}) * ${scaleName}_step`;
}
var init_assemble4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/layoutsize/assemble.js"() {
    init_config();
    init_scale();
    init_util();
    init_vega_schema();
    init_model();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/layoutsize/component.js
function getSizeTypeFromLayoutSizeType(layoutSizeType) {
  return layoutSizeType === "childWidth" ? "width" : layoutSizeType === "childHeight" ? "height" : layoutSizeType;
}
var init_component2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/layoutsize/component.js"() {
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/guide.js
function guideEncodeEntry(encoding, model) {
  return keys4(encoding).reduce((encode2, channel) => {
    const valueDef = encoding[channel];
    return Object.assign(Object.assign({}, encode2), wrapCondition(model, valueDef, channel, (x7) => isSignalRef(x7) ? x7 : { value: x7.value }));
  }, {});
}
var init_guide2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/guide.js"() {
    init_util();
    init_vega_schema();
    init_encode();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/resolve.js
function defaultScaleResolve(channel, model) {
  if (isLayerModel(model) || isFacetModel(model)) {
    return "shared";
  } else if (isConcatModel(model)) {
    return isXorY(channel) ? "independent" : "shared";
  }
  throw new Error("invalid model type for resolve");
}
function parseGuideResolve(resolve2, channel) {
  const channelScaleResolve = resolve2.scale[channel];
  const guide = isXorY(channel) ? "axis" : "legend";
  if (channelScaleResolve === "independent") {
    if (resolve2[guide][channel] === "shared") {
      warn2(message_exports.independentScaleMeansIndependentGuide(channel));
    }
    return "independent";
  }
  return resolve2[guide][channel] || "shared";
}
var init_resolve = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/resolve.js"() {
    init_channel();
    init_log3();
    init_model();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/legend/component.js
var LEGEND_COMPONENT_PROPERTY_INDEX, LEGEND_COMPONENT_PROPERTIES, LegendComponent;
var init_component3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/legend/component.js"() {
    init_legend();
    init_util();
    init_split();
    LEGEND_COMPONENT_PROPERTY_INDEX = Object.assign(Object.assign({}, COMMON_LEGEND_PROPERTY_INDEX), {
      disable: 1,
      labelExpr: 1,
      selections: 1,
      opacity: 1,
      shape: 1,
      stroke: 1,
      fill: 1,
      size: 1,
      strokeWidth: 1,
      strokeDash: 1,
      encode: 1
    });
    LEGEND_COMPONENT_PROPERTIES = keys4(LEGEND_COMPONENT_PROPERTY_INDEX);
    LegendComponent = class extends Split {
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/legend/encode.js
function symbols6(symbolsSpec, { fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2 }) {
  var _a2, _b, _c2, _d2, _e;
  if (legendType2 !== "symbol") {
    return void 0;
  }
  const { markDef, encoding, config, mark } = model;
  const filled2 = markDef.filled && mark !== "trail";
  let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), color6(model, { filled: filled2 }));
  const opacity2 = (_a2 = getMaxValue(encoding.opacity)) !== null && _a2 !== void 0 ? _a2 : markDef.opacity;
  if (out.fill) {
    if (channel === "fill" || filled2 && channel === COLOR) {
      delete out.fill;
    } else {
      if (out.fill["field"]) {
        if (legendCmpt.get("symbolFillColor")) {
          delete out.fill;
        } else {
          out.fill = signalOrValueRef((_b = config.legend.symbolBaseFillColor) !== null && _b !== void 0 ? _b : "black");
          out.fillOpacity = signalOrValueRef(opacity2 !== null && opacity2 !== void 0 ? opacity2 : 1);
        }
      } else if (isArray_default(out.fill)) {
        const fill3 = (_e = (_d2 = getFirstConditionValue((_c2 = encoding.fill) !== null && _c2 !== void 0 ? _c2 : encoding.color)) !== null && _d2 !== void 0 ? _d2 : markDef.fill) !== null && _e !== void 0 ? _e : filled2 && markDef.color;
        if (fill3) {
          out.fill = signalOrValueRef(fill3);
        }
      }
    }
  }
  if (out.stroke) {
    if (channel === "stroke" || !filled2 && channel === COLOR) {
      delete out.stroke;
    } else {
      if (out.stroke["field"]) {
        delete out.stroke;
      } else if (isArray_default(out.stroke)) {
        const stroke3 = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled2 ? markDef.color : void 0);
        if (stroke3) {
          out.stroke = { value: stroke3 };
        }
      }
    }
  }
  if (channel !== OPACITY) {
    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);
    if (condition) {
      out.opacity = [
        Object.assign({ test: condition }, signalOrValueRef(opacity2 !== null && opacity2 !== void 0 ? opacity2 : 1)),
        signalOrValueRef(config.legend.unselectedOpacity)
      ];
    } else if (opacity2) {
      out.opacity = signalOrValueRef(opacity2);
    }
  }
  out = Object.assign(Object.assign({}, out), symbolsSpec);
  return isEmpty(out) ? void 0 : out;
}
function gradient4(gradientSpec, { model, legendType: legendType2 }) {
  if (legendType2 !== "gradient") {
    return void 0;
  }
  let out = {};
  const opacity2 = getMaxValue(model.encoding.opacity) || model.markDef.opacity;
  if (opacity2) {
    out.opacity = signalOrValueRef(opacity2);
  }
  out = Object.assign(Object.assign({}, out), gradientSpec);
  return isEmpty(out) ? void 0 : out;
}
function labels(specifiedlabelsSpec, { fieldOrDatumDef, model, channel, legendCmpt }) {
  const legend = model.legend(channel) || {};
  const config = model.config;
  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : void 0;
  const opacity2 = condition ? [{ test: condition, value: 1 }, { value: config.legend.unselectedOpacity }] : void 0;
  const { format: format9, formatType } = legend;
  const text5 = isCustomFormatType(formatType) ? formatCustomType({
    fieldOrDatumDef,
    field: "datum.value",
    format: format9,
    formatType,
    config
  }) : void 0;
  const labelsSpec = Object.assign(Object.assign(Object.assign({}, opacity2 ? { opacity: opacity2 } : {}), text5 ? { text: text5 } : {}), specifiedlabelsSpec);
  return isEmpty(labelsSpec) ? void 0 : labelsSpec;
}
function entries2(entriesSpec, { legendCmpt }) {
  const selections = legendCmpt.get("selections");
  return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), { fill: { value: "transparent" } }) : entriesSpec;
}
function getMaxValue(channelDef) {
  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));
}
function getFirstConditionValue(channelDef) {
  return getConditionValue(channelDef, (v, conditionalDef) => {
    return getFirstDefined(v, conditionalDef.value);
  });
}
function getConditionValue(channelDef, reducer) {
  if (hasConditionalValueDef(channelDef)) {
    return array_default6(channelDef.condition).reduce(reducer, channelDef.value);
  } else if (isValueDef(channelDef)) {
    return channelDef.value;
  }
  return void 0;
}
function selectedCondition(model, legendCmpt, fieldDef) {
  const selections = legendCmpt.get("selections");
  if (!(selections === null || selections === void 0 ? void 0 : selections.length))
    return void 0;
  const field4 = $3(fieldDef.field);
  return selections.map((name4) => {
    const store = $3(varName(name4) + STORE);
    return `(!length(data(${store})) || (${name4}[${field4}] && indexof(${name4}[${field4}], datum.value) >= 0))`;
  }).join(" || ");
}
var legendEncodeRules;
var init_encode2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/legend/encode.js"() {
    init_vega_util();
    init_channel();
    init_channeldef();
    init_mark();
    init_util();
    init_common();
    init_format();
    init_encode();
    init_selection2();
    legendEncodeRules = {
      symbols: symbols6,
      gradient: gradient4,
      labels,
      entries: entries2
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/legend/properties.js
function values4(legend, fieldOrDatumDef) {
  const vals2 = legend.values;
  if (isArray_default(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {
  var _a2;
  if (channel !== "shape") {
    const shape3 = (_a2 = getFirstConditionValue(shapeChannelDef)) !== null && _a2 !== void 0 ? _a2 : markShape;
    if (shape3) {
      return shape3;
    }
  }
  switch (mark) {
    case "bar":
    case "rect":
    case "image":
    case "square":
      return "square";
    case "line":
    case "trail":
    case "rule":
      return "stroke";
    case "arc":
    case "point":
    case "circle":
    case "tick":
    case "geoshape":
    case "area":
    case "text":
      return "circle";
  }
}
function getLegendType(params2) {
  const { legend } = params2;
  return getFirstDefined(legend.type, defaultType2(params2));
}
function defaultType2({ channel, timeUnit, scaleType: scaleType2 }) {
  if (isColorChannel(channel)) {
    if (contains2(["quarter", "month", "day"], timeUnit)) {
      return "symbol";
    }
    if (isContinuousToContinuous(scaleType2)) {
      return "gradient";
    }
  }
  return "symbol";
}
function getDirection({ legendConfig, legendType: legendType2, orient: orient3, legend }) {
  var _a2, _b;
  return (_b = (_a2 = legend.direction) !== null && _a2 !== void 0 ? _a2 : legendConfig[legendType2 ? "gradientDirection" : "symbolDirection"]) !== null && _b !== void 0 ? _b : defaultDirection(orient3, legendType2);
}
function defaultDirection(orient3, legendType2) {
  switch (orient3) {
    case "top":
    case "bottom":
      return "horizontal";
    case "left":
    case "right":
    case "none":
    case void 0:
      return void 0;
    default:
      return legendType2 === "gradient" ? "horizontal" : void 0;
  }
}
function defaultGradientLength({ legendConfig, model, direction, orient: orient3, scaleType: scaleType2 }) {
  const { gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength } = legendConfig;
  if (isContinuousToContinuous(scaleType2)) {
    if (direction === "horizontal") {
      if (orient3 === "top" || orient3 === "bottom") {
        return gradientLengthSignal(model, "width", gradientHorizontalMinLength, gradientHorizontalMaxLength);
      } else {
        return gradientHorizontalMinLength;
      }
    } else {
      return gradientLengthSignal(model, "height", gradientVerticalMinLength, gradientVerticalMaxLength);
    }
  }
  return void 0;
}
function gradientLengthSignal(model, sizeType, min8, max8) {
  const sizeSignal = model.getSizeSignalRef(sizeType).signal;
  return { signal: `clamp(${sizeSignal}, ${min8}, ${max8})` };
}
function defaultLabelOverlap2(scaleType2) {
  if (contains2(["quantile", "threshold", "log"], scaleType2)) {
    return "greedy";
  }
  return void 0;
}
var legendRules;
var init_properties2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/legend/properties.js"() {
    init_vega_util();
    init_channel();
    init_channeldef();
    init_scale();
    init_util();
    init_vega_schema();
    init_format();
    init_encode2();
    legendRules = {
      direction: ({ direction }) => direction,
      format: ({ fieldOrDatumDef, legend, config }) => {
        const { format: format9, formatType } = legend;
        return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format9, formatType, config, false);
      },
      formatType: ({ legend, fieldOrDatumDef, scaleType: scaleType2 }) => {
        const { formatType } = legend;
        return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
      },
      gradientLength: (params2) => {
        var _a2, _b;
        const { legend, legendConfig } = params2;
        return (_b = (_a2 = legend.gradientLength) !== null && _a2 !== void 0 ? _a2 : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params2);
      },
      labelOverlap: ({ legend, legendConfig, scaleType: scaleType2 }) => {
        var _a2, _b;
        return (_b = (_a2 = legend.labelOverlap) !== null && _a2 !== void 0 ? _a2 : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap2(scaleType2);
      },
      symbolType: ({ legend, markDef, channel, encoding }) => {
        var _a2;
        return (_a2 = legend.symbolType) !== null && _a2 !== void 0 ? _a2 : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape);
      },
      title: ({ fieldOrDatumDef, config }) => title(fieldOrDatumDef, config, { allowDisabling: true }),
      type: ({ legendType: legendType2, scaleType: scaleType2, channel }) => {
        if (isColorChannel(channel) && isContinuousToContinuous(scaleType2)) {
          if (legendType2 === "gradient") {
            return void 0;
          }
        } else if (legendType2 === "symbol") {
          return void 0;
        }
        return legendType2;
      },
      values: ({ fieldOrDatumDef, legend }) => values4(legend, fieldOrDatumDef)
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/legend/parse.js
function parseLegend2(model) {
  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);
  model.component.legends = legendComponent;
  return legendComponent;
}
function parseUnitLegend(model) {
  const { encoding } = model;
  const legendComponent = {};
  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {
    const def3 = getFieldOrDatumDef(encoding[channel]);
    if (!def3 || !model.getScaleComponent(channel)) {
      continue;
    }
    if (channel === SHAPE && isFieldDef(def3) && def3.type === GEOJSON) {
      continue;
    }
    legendComponent[channel] = parseLegendForChannel(model, channel);
  }
  return legendComponent;
}
function getLegendDefWithScale(model, channel) {
  const scale8 = model.scaleName(channel);
  if (model.mark === "trail") {
    if (channel === "color") {
      return { stroke: scale8 };
    } else if (channel === "size") {
      return { strokeWidth: scale8 };
    }
  }
  if (channel === "color") {
    return model.markDef.filled ? { fill: scale8 } : { stroke: scale8 };
  }
  return { [channel]: scale8 };
}
function isExplicit(value4, property2, legend, fieldDef) {
  switch (property2) {
    case "disable":
      return legend !== void 0;
    case "values":
      return !!(legend === null || legend === void 0 ? void 0 : legend.values);
    case "title":
      if (property2 === "title" && value4 === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {
        return true;
      }
  }
  return value4 === (legend || {})[property2];
}
function parseLegendForChannel(model, channel) {
  var _a2, _b, _c2;
  let legend = model.legend(channel);
  const { markDef, encoding, config } = model;
  const legendConfig = config.legend;
  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));
  parseInteractiveLegend(model, channel, legendCmpt);
  const disable = legend !== void 0 ? !legend : legendConfig.disable;
  legendCmpt.set("disable", disable, legend !== void 0);
  if (disable) {
    return legendCmpt;
  }
  legend = legend || {};
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit : void 0;
  const orient3 = legend.orient || config.legend.orient || "right";
  const legendType2 = getLegendType({ legend, channel, timeUnit, scaleType: scaleType2 });
  const direction = getDirection({ legend, legendType: legendType2, orient: orient3, legendConfig });
  const ruleParams = {
    legend,
    channel,
    model,
    markDef,
    encoding,
    fieldOrDatumDef,
    legendConfig,
    config,
    scaleType: scaleType2,
    orient: orient3,
    legendType: legendType2,
    direction
  };
  for (const property2 of LEGEND_COMPONENT_PROPERTIES) {
    const value4 = property2 in legendRules ? legendRules[property2](ruleParams) : legend[property2];
    if (value4 !== void 0) {
      const explicit = isExplicit(value4, property2, legend, model.fieldDef(channel));
      if (explicit || config.legend[property2] === void 0) {
        legendCmpt.set(property2, value4, explicit);
      }
    }
  }
  const legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};
  const selections = legendCmpt.get("selections");
  const legendEncode = {};
  const legendEncodeParams = { fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2 };
  for (const part of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
    const legendEncodingPart = guideEncodeEntry((_c2 = legendEncoding[part]) !== null && _c2 !== void 0 ? _c2 : {}, model);
    const value4 = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) : legendEncodingPart;
    if (value4 !== void 0 && !isEmpty(value4)) {
      legendEncode[part] = Object.assign(Object.assign(Object.assign({}, (selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? { name: `${varName(fieldOrDatumDef.field)}_legend_${part}` } : {}), (selections === null || selections === void 0 ? void 0 : selections.length) ? { interactive: !!selections } : {}), { update: value4 });
    }
  }
  if (!isEmpty(legendEncode)) {
    legendCmpt.set("encode", legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));
  }
  return legendCmpt;
}
function parseNonUnitLegend(model) {
  const { legends, resolve: resolve2 } = model.component;
  for (const child of model.children) {
    parseLegend2(child);
    for (const channel of keys4(child.component.legends)) {
      resolve2.legend[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve2.legend[channel] === "shared") {
        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);
        if (!legends[channel]) {
          resolve2.legend[channel] = "independent";
          delete legends[channel];
        }
      }
    }
  }
  for (const channel of keys4(legends)) {
    for (const child of model.children) {
      if (!child.component.legends[channel]) {
        continue;
      }
      if (resolve2.legend[channel] === "shared") {
        delete child.component.legends[channel];
      }
    }
  }
  return legends;
}
function mergeLegendComponent(mergedLegend, childLegend) {
  var _a2, _b, _c2, _d2;
  if (!mergedLegend) {
    return childLegend.clone();
  }
  const mergedOrient = mergedLegend.getWithExplicit("orient");
  const childOrient = childLegend.getWithExplicit("orient");
  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
    return void 0;
  }
  let typeMerged = false;
  for (const prop of LEGEND_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(
      mergedLegend.getWithExplicit(prop),
      childLegend.getWithExplicit(prop),
      prop,
      "legend",
      (v1, v2) => {
        switch (prop) {
          case "symbolType":
            return mergeSymbolType(v1, v2);
          case "title":
            return mergeTitleComponent(v1, v2);
          case "type":
            typeMerged = true;
            return makeImplicit("symbol");
        }
        return defaultTieBreaker(v1, v2, prop, "legend");
      }
    );
    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);
  }
  if (typeMerged) {
    if ((_b = (_a2 = mergedLegend.implicit) === null || _a2 === void 0 ? void 0 : _a2.encode) === null || _b === void 0 ? void 0 : _b.gradient) {
      deleteNestedProperty(mergedLegend.implicit, ["encode", "gradient"]);
    }
    if ((_d2 = (_c2 = mergedLegend.explicit) === null || _c2 === void 0 ? void 0 : _c2.encode) === null || _d2 === void 0 ? void 0 : _d2.gradient) {
      deleteNestedProperty(mergedLegend.explicit, ["encode", "gradient"]);
    }
  }
  return mergedLegend;
}
function mergeSymbolType(st1, st2) {
  if (st2.value === "circle") {
    return st2;
  }
  return st1;
}
var init_parse4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/legend/parse.js"() {
    init_channel();
    init_channeldef();
    init_legend();
    init_timeunit();
    init_type();
    init_util();
    init_common();
    init_guide2();
    init_model();
    init_resolve();
    init_legends();
    init_split();
    init_component3();
    init_encode2();
    init_properties2();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/legend/assemble.js
function setLegendEncode(legend, part, vgProp, vgRef) {
  var _a2, _b, _c2;
  legend.encode = (_a2 = legend.encode) !== null && _a2 !== void 0 ? _a2 : {};
  legend.encode[part] = (_b = legend.encode[part]) !== null && _b !== void 0 ? _b : {};
  legend.encode[part].update = (_c2 = legend.encode[part].update) !== null && _c2 !== void 0 ? _c2 : {};
  legend.encode[part].update[vgProp] = vgRef;
}
function assembleLegends(model) {
  const legendComponentIndex = model.component.legends;
  const legendByDomain = {};
  for (const channel of keys4(legendComponentIndex)) {
    const scaleComponent = model.getScaleComponent(channel);
    const domainHash = stringify(scaleComponent.get("domains"));
    if (legendByDomain[domainHash]) {
      for (const mergedLegendComponent of legendByDomain[domainHash]) {
        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);
        if (!merged) {
          legendByDomain[domainHash].push(legendComponentIndex[channel]);
        }
      }
    } else {
      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];
    }
  }
  const legends = vals(legendByDomain).flat().map((l) => assembleLegend(l, model.config)).filter((l) => l !== void 0);
  return legends;
}
function assembleLegend(legendCmpt, config) {
  var _a2, _b, _c2;
  const _d2 = legendCmpt.combine(), { disable, labelExpr, selections } = _d2, legend = __rest(_d2, ["disable", "labelExpr", "selections"]);
  if (disable) {
    return void 0;
  }
  if (config.aria === false && legend.aria == void 0) {
    legend.aria = false;
  }
  if ((_a2 = legend.encode) === null || _a2 === void 0 ? void 0 : _a2.symbols) {
    const out = legend.encode.symbols.update;
    if (out.fill && out.fill["value"] !== "transparent" && !out.stroke && !legend.stroke) {
      out.stroke = { value: "transparent" };
    }
    for (const property2 of LEGEND_SCALE_CHANNELS) {
      if (legend[property2]) {
        delete out[property2];
      }
    }
  }
  if (!legend.title) {
    delete legend.title;
  }
  if (labelExpr !== void 0) {
    let expr2 = labelExpr;
    if (((_c2 = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c2 === void 0 ? void 0 : _c2.update) && isSignalRef(legend.encode.labels.update.text)) {
      expr2 = replaceAll(labelExpr, "datum.label", legend.encode.labels.update.text.signal);
    }
    setLegendEncode(legend, "labels", "text", { signal: expr2 });
  }
  for (const prop in legend) {
    const propValue = legend[prop];
    if (isSignalRef(propValue)) {
      const propIndex = SIGNAL_LEGEND_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        setLegendEncode(legend, part, vgProp, propValue);
        delete legend[prop];
      }
    }
  }
  return legend;
}
var init_assemble5 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/legend/assemble.js"() {
    init_tslib_es6();
    init_legend();
    init_util();
    init_vega_schema();
    init_parse4();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/projection/assemble.js
function assembleProjections(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return assembleProjectionsForModelAndChildren(model);
  } else {
    return assembleProjectionForModel(model);
  }
}
function assembleProjectionsForModelAndChildren(model) {
  return model.children.reduce((projections2, child) => {
    return projections2.concat(child.assembleProjections());
  }, assembleProjectionForModel(model));
}
function assembleProjectionForModel(model) {
  const component = model.component.projection;
  if (!component || component.merged) {
    return [];
  }
  const projection3 = component.combine();
  const { name: name4 } = projection3;
  if (!component.data) {
    return [
      Object.assign(Object.assign({ name: name4 }, { translate: { signal: "[width / 2, height / 2]" } }), projection3)
    ];
  } else {
    const size = {
      signal: `[${component.size.map((ref2) => ref2.signal).join(", ")}]`
    };
    const fits = component.data.reduce((sources, data3) => {
      const source5 = isSignalRef(data3) ? data3.signal : `data('${model.lookupDataSource(data3)}')`;
      if (!contains2(sources, source5)) {
        sources.push(source5);
      }
      return sources;
    }, []);
    if (fits.length <= 0) {
      throw new Error("Projection's fit didn't find any data sources");
    }
    return [
      Object.assign({
        name: name4,
        size,
        fit: {
          signal: fits.length > 1 ? `[${fits.join(", ")}]` : fits[0]
        }
      }, projection3)
    ];
  }
}
var init_assemble6 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/projection/assemble.js"() {
    init_util();
    init_vega_schema();
    init_model();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/projection.js
var PROJECTION_PROPERTIES;
var init_projection2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/projection.js"() {
    PROJECTION_PROPERTIES = [
      "type",
      "clipAngle",
      "clipExtent",
      "center",
      "rotate",
      "precision",
      "reflectX",
      "reflectY",
      "coefficient",
      "distance",
      "fraction",
      "lobes",
      "parallel",
      "radius",
      "ratio",
      "spacing",
      "tilt"
    ];
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/projection/component.js
var ProjectionComponent;
var init_component4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/projection/component.js"() {
    init_split();
    ProjectionComponent = class extends Split {
      constructor(name4, specifiedProjection, size, data3) {
        super(
          Object.assign({}, specifiedProjection),
          { name: name4 }
        );
        this.specifiedProjection = specifiedProjection;
        this.size = size;
        this.data = data3;
        this.merged = false;
      }
      get isFit() {
        return !!this.data;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/projection/parse.js
function parseProjection2(model) {
  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);
}
function parseUnitProjection(model) {
  var _a2;
  if (model.hasProjection) {
    const proj = model.specifiedProjection;
    const fit3 = !(proj && (proj.scale != null || proj.translate != null));
    const size = fit3 ? [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")] : void 0;
    const data3 = fit3 ? gatherFitData(model) : void 0;
    return new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, (_a2 = model.config.projection) !== null && _a2 !== void 0 ? _a2 : {}), proj !== null && proj !== void 0 ? proj : {}), size, data3);
  }
  return void 0;
}
function gatherFitData(model) {
  const data3 = [];
  const { encoding } = model;
  for (const posssiblePair of [
    [LONGITUDE, LATITUDE],
    [LONGITUDE2, LATITUDE2]
  ]) {
    if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {
      data3.push({
        signal: model.getName(`geojson_${data3.length}`)
      });
    }
  }
  if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {
    data3.push({
      signal: model.getName(`geojson_${data3.length}`)
    });
  }
  if (data3.length === 0) {
    data3.push(model.requestDataName(MAIN));
  }
  return data3;
}
function mergeIfNoConflict(first, second3) {
  const allPropertiesShared = every4(PROJECTION_PROPERTIES, (prop) => {
    if (!hasOwnProperty_default(first.explicit, prop) && !hasOwnProperty_default(second3.explicit, prop)) {
      return true;
    }
    if (hasOwnProperty_default(first.explicit, prop) && hasOwnProperty_default(second3.explicit, prop) && stringify(first.get(prop)) === stringify(second3.get(prop))) {
      return true;
    }
    return false;
  });
  const size = stringify(first.size) === stringify(second3.size);
  if (size) {
    if (allPropertiesShared) {
      return first;
    } else if (stringify(first.explicit) === stringify({})) {
      return second3;
    } else if (stringify(second3.explicit) === stringify({})) {
      return first;
    }
  }
  return null;
}
function parseNonUnitProjections(model) {
  if (model.children.length === 0) {
    return void 0;
  }
  let nonUnitProjection;
  for (const child of model.children) {
    parseProjection2(child);
  }
  const mergable = every4(model.children, (child) => {
    const projection3 = child.component.projection;
    if (!projection3) {
      return true;
    } else if (!nonUnitProjection) {
      nonUnitProjection = projection3;
      return true;
    } else {
      const merge7 = mergeIfNoConflict(nonUnitProjection, projection3);
      if (merge7) {
        nonUnitProjection = merge7;
      }
      return !!merge7;
    }
  });
  if (nonUnitProjection && mergable) {
    const name4 = model.projectionName(true);
    const modelProjection = new ProjectionComponent(name4, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));
    for (const child of model.children) {
      const projection3 = child.component.projection;
      if (projection3) {
        if (projection3.isFit) {
          modelProjection.data.push(...child.component.projection.data);
        }
        child.renameProjection(projection3.get("name"), name4);
        projection3.merged = true;
      }
    }
    return modelProjection;
  }
  return void 0;
}
var init_parse5 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/projection/parse.js"() {
    init_vega_util();
    init_channel();
    init_channeldef();
    init_data3();
    init_projection2();
    init_type();
    init_util();
    init_model();
    init_component4();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/bin.js
function rangeFormula(model, fieldDef, channel, config) {
  var _a2, _b;
  if (binRequiresRange(fieldDef, channel)) {
    const guide = isUnitModel(model) ? (_b = (_a2 = model.axis(channel)) !== null && _a2 !== void 0 ? _a2 : model.legend(channel)) !== null && _b !== void 0 ? _b : {} : {};
    const startField = vgField(fieldDef, { expr: "datum" });
    const endField = vgField(fieldDef, { expr: "datum", binSuffix: "end" });
    return {
      formulaAs: vgField(fieldDef, { binSuffix: "range", forAs: true }),
      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)
    };
  }
  return {};
}
function binKey(bin5, field4) {
  return `${binToString(bin5)}_${field4}`;
}
function getSignalsFromModel(model, key3) {
  return {
    signal: model.getName(`${key3}_bins`),
    extentSignal: model.getName(`${key3}_extent`)
  };
}
function getBinSignalName(model, field4, bin5) {
  var _a2;
  const normalizedBin = (_a2 = normalizeBin(bin5, void 0)) !== null && _a2 !== void 0 ? _a2 : {};
  const key3 = binKey(normalizedBin, field4);
  return model.getName(`${key3}_bins`);
}
function isBinTransform(t) {
  return "as" in t;
}
function createBinComponent(t, bin5, model) {
  let as;
  let span3;
  if (isBinTransform(t)) {
    as = isString_default(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];
  } else {
    as = [vgField(t, { forAs: true }), vgField(t, { binSuffix: "end", forAs: true })];
  }
  const normalizedBin = Object.assign({}, normalizeBin(bin5, void 0));
  const key3 = binKey(normalizedBin, t.field);
  const { signal, extentSignal } = getSignalsFromModel(model, key3);
  if (isSelectionExtent(normalizedBin.extent)) {
    const ext = normalizedBin.extent;
    const selName = ext.selection;
    span3 = parseSelectionBinExtent(model.getSelectionComponent(varName(selName), selName), ext);
    delete normalizedBin.extent;
  }
  const binComponent = Object.assign(Object.assign(Object.assign({ bin: normalizedBin, field: t.field, as: [as] }, signal ? { signal } : {}), extentSignal ? { extentSignal } : {}), span3 ? { span: span3 } : {});
  return { key: key3, binComponent };
}
var BinNode;
var init_bin5 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/bin.js"() {
    init_tslib_es6();
    init_vega_util();
    init_bin4();
    init_channeldef();
    init_util();
    init_format();
    init_model();
    init_parse3();
    init_dataflow();
    BinNode = class extends DataFlowNode {
      constructor(parent, bins2) {
        super(parent);
        this.bins = bins2;
      }
      clone() {
        return new BinNode(null, duplicate(this.bins));
      }
      static makeFromEncoding(parent, model) {
        const bins2 = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {
          if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
            const { key: key3, binComponent } = createBinComponent(fieldDef, fieldDef.bin, model);
            binComponentIndex[key3] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key3]), rangeFormula(model, fieldDef, channel, model.config));
          }
          return binComponentIndex;
        }, {});
        if (isEmpty(bins2)) {
          return null;
        }
        return new BinNode(parent, bins2);
      }
      static makeFromTransform(parent, t, model) {
        const { key: key3, binComponent } = createBinComponent(t, t.bin, model);
        return new BinNode(parent, {
          [key3]: binComponent
        });
      }
      merge(other, renameSignal) {
        for (const key3 of keys4(other.bins)) {
          if (key3 in this.bins) {
            renameSignal(other.bins[key3].signal, this.bins[key3].signal);
            this.bins[key3].as = unique([...this.bins[key3].as, ...other.bins[key3].as], hash);
          } else {
            this.bins[key3] = other.bins[key3];
          }
        }
        for (const child of other.children) {
          other.removeChild(child);
          child.parent = this;
        }
        other.remove();
      }
      producedFields() {
        return new Set(vals(this.bins).map((c2) => c2.as).flat(2));
      }
      dependentFields() {
        return new Set(vals(this.bins).map((c2) => c2.field));
      }
      hash() {
        return `Bin ${hash(this.bins)}`;
      }
      assemble() {
        return vals(this.bins).flatMap((bin5) => {
          const transform4 = [];
          const [binAs, ...remainingAs] = bin5.as;
          const _a2 = bin5.bin, { extent: extent5 } = _a2, params2 = __rest(_a2, ["extent"]);
          const binTrans = Object.assign(Object.assign(Object.assign({ type: "bin", field: replacePathInField(bin5.field), as: binAs, signal: bin5.signal }, !isSelectionExtent(extent5) ? { extent: extent5 } : { extent: null }), bin5.span ? { span: { signal: `span(${bin5.span})` } } : {}), params2);
          if (!extent5 && bin5.extentSignal) {
            transform4.push({
              type: "extent",
              field: replacePathInField(bin5.field),
              signal: bin5.extentSignal
            });
            binTrans.extent = { signal: bin5.extentSignal };
          }
          transform4.push(binTrans);
          for (const as of remainingAs) {
            for (let i = 0; i < 2; i++) {
              transform4.push({
                type: "formula",
                expr: vgField({ field: binAs[i] }, { expr: "datum" }),
                as: as[i]
              });
            }
          }
          if (bin5.formula) {
            transform4.push({
              type: "formula",
              expr: bin5.formula,
              as: bin5.formulaAs
            });
          }
          return transform4;
        });
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/source.js
var SourceNode;
var init_source = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/source.js"() {
    init_data3();
    init_util();
    init_dataflow();
    SourceNode = class extends DataFlowNode {
      constructor(data3) {
        super(null);
        data3 = data3 !== null && data3 !== void 0 ? data3 : { name: "source" };
        let format9;
        if (!isGenerator(data3)) {
          format9 = data3.format ? Object.assign({}, omit(data3.format, ["parse"])) : {};
        }
        if (isInlineData(data3)) {
          this._data = { values: data3.values };
        } else if (isUrlData(data3)) {
          this._data = { url: data3.url };
          if (!format9.type) {
            let defaultExtension = /(?:\.([^.]+))?$/.exec(data3.url)[1];
            if (!contains2(["json", "csv", "tsv", "dsv", "topojson"], defaultExtension)) {
              defaultExtension = "json";
            }
            format9.type = defaultExtension;
          }
        } else if (isSphereGenerator(data3)) {
          this._data = { values: [{ type: "Sphere" }] };
        } else if (isNamedData(data3) || isGenerator(data3)) {
          this._data = {};
        }
        this._generator = isGenerator(data3);
        if (data3.name) {
          this._name = data3.name;
        }
        if (format9 && !isEmpty(format9)) {
          this._data.format = format9;
        }
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return void 0;
      }
      get data() {
        return this._data;
      }
      hasName() {
        return !!this._name;
      }
      get isGenerator() {
        return this._generator;
      }
      get dataName() {
        return this._name;
      }
      set dataName(name4) {
        this._name = name4;
      }
      set parent(parent) {
        throw new Error("Source nodes have to be roots.");
      }
      remove() {
        throw new Error("Source nodes are roots and cannot be removed.");
      }
      hash() {
        throw new Error("Cannot hash sources");
      }
      assemble() {
        return Object.assign(Object.assign({ name: this._name }, this._data), { transform: [] });
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/debug.js
function checkLinks(nodes) {
  for (const node of nodes) {
    for (const child of node.children) {
      if (child.parent !== node) {
        console.error("Dataflow graph is inconsistent.", node, child);
        return false;
      }
    }
    if (!checkLinks(node.children)) {
      return false;
    }
  }
  return true;
}
var init_debug = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/debug.js"() {
    init_util();
    init_dataflow();
    init_source();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/graticule.js
var GraticuleNode;
var init_graticule2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/graticule.js"() {
    init_util();
    init_dataflow();
    GraticuleNode = class extends DataFlowNode {
      constructor(parent, params2) {
        super(parent);
        this.params = params2;
      }
      clone() {
        return new GraticuleNode(null, this.params);
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return void 0;
      }
      hash() {
        return `Graticule ${hash(this.params)}`;
      }
      assemble() {
        return Object.assign({ type: "graticule" }, this.params === true ? {} : this.params);
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/sequence.js
var SequenceNode;
var init_sequence = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/sequence.js"() {
    init_util();
    init_dataflow();
    SequenceNode = class extends DataFlowNode {
      constructor(parent, params2) {
        super(parent);
        this.params = params2;
      }
      clone() {
        return new SequenceNode(null, this.params);
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        var _a2;
        return /* @__PURE__ */ new Set([(_a2 = this.params.as) !== null && _a2 !== void 0 ? _a2 : "data"]);
      }
      hash() {
        return `Hash ${hash(this.params)}`;
      }
      assemble() {
        return Object.assign({ type: "sequence" }, this.params);
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/optimizer.js
function isDataSourceNode(node) {
  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;
}
var OptimizerBase, BottomUpOptimizer, TopDownOptimizer;
var init_optimizer = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/optimizer.js"() {
    init_source();
    init_graticule2();
    init_sequence();
    OptimizerBase = class {
      constructor() {
        this._mutated = false;
      }
      setMutated() {
        this._mutated = true;
      }
      get mutatedFlag() {
        return this._mutated;
      }
    };
    BottomUpOptimizer = class extends OptimizerBase {
      constructor() {
        super();
        this._continue = false;
      }
      setContinue() {
        this._continue = true;
      }
      get continueFlag() {
        return this._continue;
      }
      get flags() {
        return { continueFlag: this.continueFlag, mutatedFlag: this.mutatedFlag };
      }
      set flags({ continueFlag, mutatedFlag }) {
        if (continueFlag) {
          this.setContinue();
        }
        if (mutatedFlag) {
          this.setMutated();
        }
      }
      reset() {
      }
      optimizeNextFromLeaves(node) {
        if (isDataSourceNode(node)) {
          return false;
        }
        const next = node.parent;
        const { continueFlag } = this.run(node);
        if (continueFlag) {
          this.optimizeNextFromLeaves(next);
        }
        return this.mutatedFlag;
      }
    };
    TopDownOptimizer = class extends OptimizerBase {
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/aggregate.js
function addDimension(dims, channel, fieldDef, model) {
  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0;
  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.stack, model.markDef, model.config)) {
    dims.add(vgField(fieldDef, {}));
    dims.add(vgField(fieldDef, { suffix: "end" }));
    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {
      dims.add(vgField(fieldDef, { binSuffix: "range" }));
    }
  } else if (isGeoPositionChannel(channel)) {
    const posChannel = getPositionChannelFromLatLong(channel);
    dims.add(model.getName(posChannel));
  } else {
    dims.add(vgField(fieldDef));
  }
  return dims;
}
function mergeMeasures(parentMeasures, childMeasures) {
  var _a2;
  for (const field4 of keys4(childMeasures)) {
    const ops2 = childMeasures[field4];
    for (const op of keys4(ops2)) {
      if (field4 in parentMeasures) {
        parentMeasures[field4][op] = /* @__PURE__ */ new Set([...(_a2 = parentMeasures[field4][op]) !== null && _a2 !== void 0 ? _a2 : [], ...ops2[op]]);
      } else {
        parentMeasures[field4] = { [op]: ops2[op] };
      }
    }
  }
}
var AggregateNode;
var init_aggregate2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/aggregate.js"() {
    init_aggregate();
    init_channel();
    init_channeldef();
    init_log3();
    init_util();
    init_model();
    init_dataflow();
    AggregateNode = class extends DataFlowNode {
      constructor(parent, dimensions, measures) {
        super(parent);
        this.dimensions = dimensions;
        this.measures = measures;
      }
      clone() {
        return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));
      }
      get groupBy() {
        return this.dimensions;
      }
      static makeFromEncoding(parent, model) {
        let isAggregate3 = false;
        model.forEachFieldDef((fd) => {
          if (fd.aggregate) {
            isAggregate3 = true;
          }
        });
        const meas = {};
        const dims = /* @__PURE__ */ new Set();
        if (!isAggregate3) {
          return null;
        }
        model.forEachFieldDef((fieldDef, channel) => {
          var _a2, _b, _c2, _d2;
          const { aggregate, field: field4 } = fieldDef;
          if (aggregate) {
            if (aggregate === "count") {
              meas["*"] = (_a2 = meas["*"]) !== null && _a2 !== void 0 ? _a2 : {};
              meas["*"]["count"] = /* @__PURE__ */ new Set([vgField(fieldDef, { forAs: true })]);
            } else {
              if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
                const op = isArgminDef(aggregate) ? "argmin" : "argmax";
                const argField = aggregate[op];
                meas[argField] = (_b = meas[argField]) !== null && _b !== void 0 ? _b : {};
                meas[argField][op] = /* @__PURE__ */ new Set([vgField({ op, field: argField }, { forAs: true })]);
              } else {
                meas[field4] = (_c2 = meas[field4]) !== null && _c2 !== void 0 ? _c2 : {};
                meas[field4][aggregate] = /* @__PURE__ */ new Set([vgField(fieldDef, { forAs: true })]);
              }
              if (isScaleChannel(channel) && model.scaleDomain(channel) === "unaggregated") {
                meas[field4] = (_d2 = meas[field4]) !== null && _d2 !== void 0 ? _d2 : {};
                meas[field4]["min"] = /* @__PURE__ */ new Set([vgField({ field: field4, aggregate: "min" }, { forAs: true })]);
                meas[field4]["max"] = /* @__PURE__ */ new Set([vgField({ field: field4, aggregate: "max" }, { forAs: true })]);
              }
            }
          } else {
            addDimension(dims, channel, fieldDef, model);
          }
        });
        if (dims.size + keys4(meas).length === 0) {
          return null;
        }
        return new AggregateNode(parent, dims, meas);
      }
      static makeFromTransform(parent, t) {
        var _a2, _b, _c2;
        const dims = /* @__PURE__ */ new Set();
        const meas = {};
        for (const s3 of t.aggregate) {
          const { op, field: field4, as } = s3;
          if (op) {
            if (op === "count") {
              meas["*"] = (_a2 = meas["*"]) !== null && _a2 !== void 0 ? _a2 : {};
              meas["*"]["count"] = /* @__PURE__ */ new Set([as ? as : vgField(s3, { forAs: true })]);
            } else {
              meas[field4] = (_b = meas[field4]) !== null && _b !== void 0 ? _b : {};
              meas[field4][op] = /* @__PURE__ */ new Set([as ? as : vgField(s3, { forAs: true })]);
            }
          }
        }
        for (const s3 of (_c2 = t.groupby) !== null && _c2 !== void 0 ? _c2 : []) {
          dims.add(s3);
        }
        if (dims.size + keys4(meas).length === 0) {
          return null;
        }
        return new AggregateNode(parent, dims, meas);
      }
      merge(other) {
        if (setEqual(this.dimensions, other.dimensions)) {
          mergeMeasures(this.measures, other.measures);
          return true;
        } else {
          debug2("different dimensions, cannot merge");
          return false;
        }
      }
      addDimensions(fields) {
        fields.forEach(this.dimensions.add, this.dimensions);
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([...this.dimensions, ...keys4(this.measures)]);
      }
      producedFields() {
        const out = /* @__PURE__ */ new Set();
        for (const field4 of keys4(this.measures)) {
          for (const op of keys4(this.measures[field4])) {
            const m2 = this.measures[field4][op];
            if (m2.size === 0) {
              out.add(`${op}_${field4}`);
            } else {
              m2.forEach(out.add, out);
            }
          }
        }
        return out;
      }
      hash() {
        return `Aggregate ${hash({ dimensions: this.dimensions, measures: this.measures })}`;
      }
      assemble() {
        const ops2 = [];
        const fields = [];
        const as = [];
        for (const field4 of keys4(this.measures)) {
          for (const op of keys4(this.measures[field4])) {
            for (const alias of this.measures[field4][op]) {
              as.push(alias);
              ops2.push(op);
              fields.push(field4 === "*" ? null : replacePathInField(field4));
            }
          }
        }
        const result = {
          type: "aggregate",
          groupby: [...this.dimensions].map(replacePathInField),
          ops: ops2,
          fields,
          as
        };
        return result;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/facet.js
var FacetNode;
var init_facet2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/facet.js"() {
    init_vega_util();
    init_bin4();
    init_channel();
    init_channeldef();
    init_log3();
    init_scale();
    init_sort5();
    init_util();
    init_vega_schema();
    init_component();
    init_domain();
    init_calculate();
    init_dataflow();
    FacetNode = class extends DataFlowNode {
      constructor(parent, model, name4, data3) {
        super(parent);
        this.model = model;
        this.name = name4;
        this.data = data3;
        for (const channel of FACET_CHANNELS) {
          const fieldDef = model.facet[channel];
          if (fieldDef) {
            const { bin: bin5, sort: sort5 } = fieldDef;
            this[channel] = Object.assign({ name: model.getName(`${channel}_domain`), fields: [vgField(fieldDef), ...isBinning(bin5) ? [vgField(fieldDef, { binSuffix: "end" })] : []] }, isSortField(sort5) ? { sortField: sort5 } : isArray_default(sort5) ? { sortIndexField: sortArrayIndexField(fieldDef, channel) } : {});
          }
        }
        this.childModel = model.child;
      }
      hash() {
        let out = `Facet`;
        for (const channel of FACET_CHANNELS) {
          if (this[channel]) {
            out += ` ${channel.charAt(0)}:${hash(this[channel])}`;
          }
        }
        return out;
      }
      get fields() {
        var _a2;
        const f = [];
        for (const channel of FACET_CHANNELS) {
          if ((_a2 = this[channel]) === null || _a2 === void 0 ? void 0 : _a2.fields) {
            f.push(...this[channel].fields);
          }
        }
        return f;
      }
      dependentFields() {
        const depFields = new Set(this.fields);
        for (const channel of FACET_CHANNELS) {
          if (this[channel]) {
            if (this[channel].sortField) {
              depFields.add(this[channel].sortField.field);
            }
            if (this[channel].sortIndexField) {
              depFields.add(this[channel].sortIndexField);
            }
          }
        }
        return depFields;
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      getSource() {
        return this.name;
      }
      getChildIndependentFieldsWithStep() {
        const childIndependentFieldsWithStep = {};
        for (const channel of POSITION_SCALE_CHANNELS) {
          const childScaleComponent = this.childModel.component.scales[channel];
          if (childScaleComponent && !childScaleComponent.merged) {
            const type4 = childScaleComponent.get("type");
            const range7 = childScaleComponent.get("range");
            if (hasDiscreteDomain(type4) && isVgRangeStep(range7)) {
              const domain4 = assembleDomain(this.childModel, channel);
              const field4 = getFieldFromDomain(domain4);
              if (field4) {
                childIndependentFieldsWithStep[channel] = field4;
              } else {
                warn2(`Unknown field for ${channel}. Cannot calculate view size.`);
              }
            }
          }
        }
        return childIndependentFieldsWithStep;
      }
      assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {
        const childChannel = { row: "y", column: "x" }[channel];
        const fields = [];
        const ops2 = [];
        const as = [];
        if (childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {
          if (crossedDataName) {
            fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
            ops2.push("max");
          } else {
            fields.push(childIndependentFieldsWithStep[childChannel]);
            ops2.push("distinct");
          }
          as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
        }
        const { sortField, sortIndexField } = this[channel];
        if (sortField) {
          const { op = DEFAULT_SORT_OP, field: field4 } = sortField;
          fields.push(field4);
          ops2.push(op);
          as.push(vgField(sortField, { forAs: true }));
        } else if (sortIndexField) {
          fields.push(sortIndexField);
          ops2.push("max");
          as.push(sortIndexField);
        }
        return {
          name: this[channel].name,
          source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,
          transform: [
            Object.assign({ type: "aggregate", groupby: this[channel].fields }, fields.length ? {
              fields,
              ops: ops2,
              as
            } : {})
          ]
        };
      }
      assembleFacetHeaderData(childIndependentFieldsWithStep) {
        var _a2, _b;
        const { columns } = this.model.layout;
        const { layoutHeaders: layoutHeaders2 } = this.model.component;
        const data3 = [];
        const hasSharedAxis = {};
        for (const headerChannel of HEADER_CHANNELS) {
          for (const headerType of HEADER_TYPES) {
            const headers = (_a2 = layoutHeaders2[headerChannel] && layoutHeaders2[headerChannel][headerType]) !== null && _a2 !== void 0 ? _a2 : [];
            for (const header of headers) {
              if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                hasSharedAxis[headerChannel] = true;
                break;
              }
            }
          }
          if (hasSharedAxis[headerChannel]) {
            const cardinality = `length(data("${this.facet.name}"))`;
            const stop2 = headerChannel === "row" ? columns ? { signal: `ceil(${cardinality} / ${columns})` } : 1 : columns ? { signal: `min(${cardinality}, ${columns})` } : { signal: cardinality };
            data3.push({
              name: `${this.facet.name}_${headerChannel}`,
              transform: [
                {
                  type: "sequence",
                  start: 0,
                  stop: stop2
                }
              ]
            });
          }
        }
        const { row, column } = hasSharedAxis;
        if (row || column) {
          data3.unshift(this.assembleRowColumnHeaderData("facet", null, childIndependentFieldsWithStep));
        }
        return data3;
      }
      assemble() {
        var _a2, _b;
        const data3 = [];
        let crossedDataName = null;
        const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();
        const { column, row, facet } = this;
        if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {
          crossedDataName = `cross_${this.column.name}_${this.row.name}`;
          const fields = [].concat((_a2 = childIndependentFieldsWithStep.x) !== null && _a2 !== void 0 ? _a2 : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);
          const ops2 = fields.map(() => "distinct");
          data3.push({
            name: crossedDataName,
            source: this.data,
            transform: [
              {
                type: "aggregate",
                groupby: this.fields,
                fields,
                ops: ops2
              }
            ]
          });
        }
        for (const channel of [COLUMN, ROW]) {
          if (this[channel]) {
            data3.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));
          }
        }
        if (facet) {
          const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);
          if (facetData) {
            data3.push(...facetData);
          }
        }
        return data3;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/formatparse.js
function unquote(pattern) {
  if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
    return pattern.slice(1, -1);
  }
  return pattern;
}
function parseExpression4(field4, parse8) {
  const f = accessPathWithDatum(field4);
  if (parse8 === "number") {
    return `toNumber(${f})`;
  } else if (parse8 === "boolean") {
    return `toBoolean(${f})`;
  } else if (parse8 === "string") {
    return `toString(${f})`;
  } else if (parse8 === "date") {
    return `toDate(${f})`;
  } else if (parse8 === "flatten") {
    return f;
  } else if (parse8.indexOf("date:") === 0) {
    const specifier = unquote(parse8.slice(5, parse8.length));
    return `timeParse(${f},'${specifier}')`;
  } else if (parse8.indexOf("utc:") === 0) {
    const specifier = unquote(parse8.slice(4, parse8.length));
    return `utcParse(${f},'${specifier}')`;
  } else {
    warn2(message_exports.unrecognizedParse(parse8));
    return null;
  }
}
function getImplicitFromFilterTransform(transform4) {
  const implicit3 = {};
  forEachLeaf(transform4.filter, (filter6) => {
    var _a2;
    if (isFieldPredicate(filter6)) {
      let val = null;
      if (isFieldEqualPredicate(filter6)) {
        val = filter6.equal;
      } else if (isFieldRangePredicate(filter6)) {
        val = filter6.range[0];
      } else if (isFieldOneOfPredicate(filter6)) {
        val = ((_a2 = filter6.oneOf) !== null && _a2 !== void 0 ? _a2 : filter6["in"])[0];
      }
      if (val) {
        if (isDateTime(val)) {
          implicit3[filter6.field] = "date";
        } else if (isNumber_default(val)) {
          implicit3[filter6.field] = "number";
        } else if (isString_default(val)) {
          implicit3[filter6.field] = "string";
        }
      }
      if (filter6.timeUnit) {
        implicit3[filter6.field] = "date";
      }
    }
  });
  return implicit3;
}
function getImplicitFromEncoding(model) {
  const implicit3 = {};
  function add7(fieldDef) {
    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {
      implicit3[fieldDef.field] = "date";
    } else if (fieldDef.type === "quantitative" && isMinMaxOp(fieldDef.aggregate)) {
      implicit3[fieldDef.field] = "number";
    } else if (accessPathDepth(fieldDef.field) > 1) {
      if (!(fieldDef.field in implicit3)) {
        implicit3[fieldDef.field] = "flatten";
      }
    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {
      if (!(fieldDef.sort.field in implicit3)) {
        implicit3[fieldDef.sort.field] = "flatten";
      }
    }
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef)) {
        add7(fieldDef);
      } else {
        const mainChannel = getMainRangeChannel(channel);
        const mainFieldDef = model.fieldDef(mainChannel);
        add7(Object.assign(Object.assign({}, fieldDef), { type: mainFieldDef.type }));
      }
    });
  }
  if (isUnitModel(model)) {
    const { mark, markDef, encoding } = model;
    if (isPathMark(mark) && !model.encoding.order) {
      const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
      const dimensionChannelDef = encoding[dimensionChannel];
      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === "quantitative" && !(dimensionChannelDef.field in implicit3)) {
        implicit3[dimensionChannelDef.field] = "number";
      }
    }
  }
  return implicit3;
}
function getImplicitFromSelection(model) {
  const implicit3 = {};
  if (isUnitModel(model) && model.component.selection) {
    for (const name4 of keys4(model.component.selection)) {
      const selCmpt = model.component.selection[name4];
      for (const proj of selCmpt.project.items) {
        if (!proj.channel && accessPathDepth(proj.field) > 1) {
          implicit3[proj.field] = "flatten";
        }
      }
    }
  }
  return implicit3;
}
var ParseNode;
var init_formatparse = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/formatparse.js"() {
    init_vega_util();
    init_aggregate();
    init_channel();
    init_channeldef();
    init_data3();
    init_datetime();
    init_log3();
    init_logical();
    init_mark();
    init_predicate();
    init_sort5();
    init_util();
    init_model();
    init_split();
    init_dataflow();
    ParseNode = class extends DataFlowNode {
      constructor(parent, parse8) {
        super(parent);
        this._parse = parse8;
      }
      clone() {
        return new ParseNode(null, duplicate(this._parse));
      }
      hash() {
        return `Parse ${hash(this._parse)}`;
      }
      static makeExplicit(parent, model, ancestorParse) {
        let explicit = {};
        const data3 = model.data;
        if (!isGenerator(data3) && data3 && data3.format && data3.format.parse) {
          explicit = data3.format.parse;
        }
        return this.makeWithAncestors(parent, explicit, {}, ancestorParse);
      }
      static makeWithAncestors(parent, explicit, implicit3, ancestorParse) {
        for (const field4 of keys4(implicit3)) {
          const parsedAs = ancestorParse.getWithExplicit(field4);
          if (parsedAs.value !== void 0) {
            if (parsedAs.explicit || parsedAs.value === implicit3[field4] || parsedAs.value === "derived" || implicit3[field4] === "flatten") {
              delete implicit3[field4];
            } else {
              warn2(message_exports.differentParse(field4, implicit3[field4], parsedAs.value));
            }
          }
        }
        for (const field4 of keys4(explicit)) {
          const parsedAs = ancestorParse.get(field4);
          if (parsedAs !== void 0) {
            if (parsedAs === explicit[field4]) {
              delete explicit[field4];
            } else {
              warn2(message_exports.differentParse(field4, explicit[field4], parsedAs));
            }
          }
        }
        const parse8 = new Split(explicit, implicit3);
        ancestorParse.copyAll(parse8);
        const p = {};
        for (const key3 of keys4(parse8.combine())) {
          const val = parse8.get(key3);
          if (val !== null) {
            p[key3] = val;
          }
        }
        if (keys4(p).length === 0 || ancestorParse.parseNothing) {
          return null;
        }
        return new ParseNode(parent, p);
      }
      get parse() {
        return this._parse;
      }
      merge(other) {
        this._parse = Object.assign(Object.assign({}, this._parse), other.parse);
        other.remove();
      }
      assembleFormatParse() {
        const formatParse = {};
        for (const field4 of keys4(this._parse)) {
          const p = this._parse[field4];
          if (accessPathDepth(field4) === 1) {
            formatParse[field4] = p;
          }
        }
        return formatParse;
      }
      producedFields() {
        return new Set(keys4(this._parse));
      }
      dependentFields() {
        return new Set(keys4(this._parse));
      }
      assembleTransforms(onlyNested = false) {
        return keys4(this._parse).filter((field4) => onlyNested ? accessPathDepth(field4) > 1 : true).map((field4) => {
          const expr2 = parseExpression4(field4, this._parse[field4]);
          if (!expr2) {
            return null;
          }
          const formula = {
            type: "formula",
            expr: expr2,
            as: removePathFromField(field4)
          };
          return formula;
        }).filter((t) => t !== null);
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/identifier.js
var IdentifierNode;
var init_identifier = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/identifier.js"() {
    init_selection();
    init_dataflow();
    IdentifierNode = class extends DataFlowNode {
      clone() {
        return new IdentifierNode(null);
      }
      constructor(parent) {
        super(parent);
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return /* @__PURE__ */ new Set([SELECTION_ID]);
      }
      hash() {
        return "Identifier";
      }
      assemble() {
        return { type: "identifier", as: SELECTION_ID };
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/joinaggregate.js
var JoinAggregateTransformNode;
var init_joinaggregate = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/joinaggregate.js"() {
    init_channeldef();
    init_util();
    init_util();
    init_dataflow();
    JoinAggregateTransformNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        super(parent);
        this.transform = transform4;
      }
      clone() {
        return new JoinAggregateTransformNode(null, duplicate(this.transform));
      }
      addDimensions(fields) {
        this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
      }
      dependentFields() {
        const out = /* @__PURE__ */ new Set();
        if (this.transform.groupby) {
          this.transform.groupby.forEach(out.add, out);
        }
        this.transform.joinaggregate.map((w5) => w5.field).filter((f) => f !== void 0).forEach(out.add, out);
        return out;
      }
      producedFields() {
        return new Set(this.transform.joinaggregate.map(this.getDefaultName));
      }
      getDefaultName(joinAggregateFieldDef) {
        var _a2;
        return (_a2 = joinAggregateFieldDef.as) !== null && _a2 !== void 0 ? _a2 : vgField(joinAggregateFieldDef);
      }
      hash() {
        return `JoinAggregateTransform ${hash(this.transform)}`;
      }
      assemble() {
        const fields = [];
        const ops2 = [];
        const as = [];
        for (const joinaggregate of this.transform.joinaggregate) {
          ops2.push(joinaggregate.op);
          as.push(this.getDefaultName(joinaggregate));
          fields.push(joinaggregate.field === void 0 ? null : joinaggregate.field);
        }
        const groupby = this.transform.groupby;
        return Object.assign({
          type: "joinaggregate",
          as,
          ops: ops2,
          fields
        }, groupby !== void 0 ? { groupby } : {});
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/stack.js
function getStackByFields(model) {
  return model.stack.stackBy.reduce((fields, by) => {
    const fieldDef = by.fieldDef;
    const _field = vgField(fieldDef);
    if (_field) {
      fields.push(_field);
    }
    return fields;
  }, []);
}
function isValidAsArray(as) {
  return isArray_default(as) && as.every((s3) => isString_default(s3)) && as.length > 1;
}
var StackNode;
var init_stack4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/stack.js"() {
    init_vega_util();
    init_channeldef();
    init_util();
    init_common();
    init_dataflow();
    StackNode = class extends DataFlowNode {
      constructor(parent, stack3) {
        super(parent);
        this._stack = stack3;
      }
      clone() {
        return new StackNode(null, duplicate(this._stack));
      }
      static makeFromTransform(parent, stackTransform) {
        const { stack: stack3, groupby, as, offset: offset5 = "zero" } = stackTransform;
        const sortFields = [];
        const sortOrder = [];
        if (stackTransform.sort !== void 0) {
          for (const sortField of stackTransform.sort) {
            sortFields.push(sortField.field);
            sortOrder.push(getFirstDefined(sortField.order, "ascending"));
          }
        }
        const sort5 = {
          field: sortFields,
          order: sortOrder
        };
        let normalizedAs;
        if (isValidAsArray(as)) {
          normalizedAs = as;
        } else if (isString_default(as)) {
          normalizedAs = [as, as + "_end"];
        } else {
          normalizedAs = [stackTransform.stack + "_start", stackTransform.stack + "_end"];
        }
        return new StackNode(parent, {
          stackField: stack3,
          groupby,
          offset: offset5,
          sort: sort5,
          facetby: [],
          as: normalizedAs
        });
      }
      static makeFromEncoding(parent, model) {
        const stackProperties = model.stack;
        const { encoding } = model;
        if (!stackProperties) {
          return null;
        }
        const { groupbyChannel, fieldChannel, offset: offset5, impute } = stackProperties;
        let dimensionFieldDef;
        if (groupbyChannel) {
          const cDef = encoding[groupbyChannel];
          dimensionFieldDef = getFieldDef(cDef);
        }
        const stackby = getStackByFields(model);
        const orderDef = model.encoding.order;
        let sort5;
        if (isArray_default(orderDef) || isFieldDef(orderDef)) {
          sort5 = sortParams(orderDef);
        } else {
          sort5 = stackby.reduce((s3, field4) => {
            s3.field.push(field4);
            s3.order.push(fieldChannel === "y" ? "descending" : "ascending");
            return s3;
          }, { field: [], order: [] });
        }
        return new StackNode(parent, {
          dimensionFieldDef,
          stackField: model.vgField(fieldChannel),
          facetby: [],
          stackby,
          sort: sort5,
          offset: offset5,
          impute,
          as: [
            model.vgField(fieldChannel, { suffix: "start", forAs: true }),
            model.vgField(fieldChannel, { suffix: "end", forAs: true })
          ]
        });
      }
      get stack() {
        return this._stack;
      }
      addDimensions(fields) {
        this._stack.facetby.push(...fields);
      }
      dependentFields() {
        const out = /* @__PURE__ */ new Set();
        out.add(this._stack.stackField);
        this.getGroupbyFields().forEach(out.add, out);
        this._stack.facetby.forEach(out.add, out);
        this._stack.sort.field.forEach(out.add, out);
        return out;
      }
      producedFields() {
        return new Set(this._stack.as);
      }
      hash() {
        return `Stack ${hash(this._stack)}`;
      }
      getGroupbyFields() {
        const { dimensionFieldDef, impute, groupby } = this._stack;
        if (dimensionFieldDef) {
          if (dimensionFieldDef.bin) {
            if (impute) {
              return [vgField(dimensionFieldDef, { binSuffix: "mid" })];
            }
            return [
              vgField(dimensionFieldDef, {}),
              vgField(dimensionFieldDef, { binSuffix: "end" })
            ];
          }
          return [vgField(dimensionFieldDef)];
        }
        return groupby !== null && groupby !== void 0 ? groupby : [];
      }
      assemble() {
        const transform4 = [];
        const { facetby, dimensionFieldDef, stackField: field4, stackby, sort: sort5, offset: offset5, impute, as } = this._stack;
        if (impute && dimensionFieldDef) {
          const { band: band5 = 0.5, bin: bin5 } = dimensionFieldDef;
          if (bin5) {
            transform4.push({
              type: "formula",
              expr: `${band5}*` + vgField(dimensionFieldDef, { expr: "datum" }) + `+${1 - band5}*` + vgField(dimensionFieldDef, { expr: "datum", binSuffix: "end" }),
              as: vgField(dimensionFieldDef, { binSuffix: "mid", forAs: true })
            });
          }
          transform4.push({
            type: "impute",
            field: field4,
            groupby: [...stackby, ...facetby],
            key: vgField(dimensionFieldDef, { binSuffix: "mid" }),
            method: "value",
            value: 0
          });
        }
        transform4.push({
          type: "stack",
          groupby: [...this.getGroupbyFields(), ...facetby],
          field: field4,
          sort: sort5,
          as,
          offset: offset5
        });
        return transform4;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/window.js
var WindowTransformNode;
var init_window = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/window.js"() {
    init_aggregate();
    init_channeldef();
    init_util();
    init_util();
    init_dataflow();
    WindowTransformNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        super(parent);
        this.transform = transform4;
      }
      clone() {
        return new WindowTransformNode(null, duplicate(this.transform));
      }
      addDimensions(fields) {
        this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
      }
      dependentFields() {
        var _a2, _b;
        const out = /* @__PURE__ */ new Set();
        ((_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []).forEach(out.add, out);
        ((_b = this.transform.sort) !== null && _b !== void 0 ? _b : []).forEach((m2) => out.add(m2.field));
        this.transform.window.map((w5) => w5.field).filter((f) => f !== void 0).forEach(out.add, out);
        return out;
      }
      producedFields() {
        return new Set(this.transform.window.map(this.getDefaultName));
      }
      getDefaultName(windowFieldDef) {
        var _a2;
        return (_a2 = windowFieldDef.as) !== null && _a2 !== void 0 ? _a2 : vgField(windowFieldDef);
      }
      hash() {
        return `WindowTransform ${hash(this.transform)}`;
      }
      assemble() {
        var _a2;
        const fields = [];
        const ops2 = [];
        const as = [];
        const params2 = [];
        for (const window2 of this.transform.window) {
          ops2.push(window2.op);
          as.push(this.getDefaultName(window2));
          params2.push(window2.param === void 0 ? null : window2.param);
          fields.push(window2.field === void 0 ? null : window2.field);
        }
        const frame2 = this.transform.frame;
        const groupby = this.transform.groupby;
        if (frame2 && frame2[0] === null && frame2[1] === null && ops2.every((o) => isAggregateOp(o))) {
          return Object.assign({ type: "joinaggregate", as, ops: ops2, fields }, groupby !== void 0 ? { groupby } : {});
        }
        const sortFields = [];
        const sortOrder = [];
        if (this.transform.sort !== void 0) {
          for (const sortField of this.transform.sort) {
            sortFields.push(sortField.field);
            sortOrder.push((_a2 = sortField.order) !== null && _a2 !== void 0 ? _a2 : "ascending");
          }
        }
        const sort5 = {
          field: sortFields,
          order: sortOrder
        };
        const ignorePeers = this.transform.ignorePeers;
        return Object.assign(Object.assign(Object.assign({
          type: "window",
          params: params2,
          as,
          ops: ops2,
          fields,
          sort: sort5
        }, ignorePeers !== void 0 ? { ignorePeers } : {}), groupby !== void 0 ? { groupby } : {}), frame2 !== void 0 ? { frame: frame2 } : {});
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/optimizers.js
function cloneSubtree(facet) {
  function clone(node) {
    if (!(node instanceof FacetNode)) {
      const copy6 = node.clone();
      if (copy6 instanceof OutputNode) {
        const newName = FACET_SCALE_PREFIX + copy6.getSource();
        copy6.setSource(newName);
        facet.model.component.data.outputNodes[newName] = copy6;
      } else if (copy6 instanceof AggregateNode || copy6 instanceof StackNode || copy6 instanceof WindowTransformNode || copy6 instanceof JoinAggregateTransformNode) {
        copy6.addDimensions(facet.fields);
      }
      for (const n of node.children.flatMap(clone)) {
        n.parent = copy6;
      }
      return [copy6];
    }
    return node.children.flatMap(clone);
  }
  return clone;
}
function moveFacetDown(node) {
  if (node instanceof FacetNode) {
    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {
      const child = node.children[0];
      if (child instanceof AggregateNode || child instanceof StackNode || child instanceof WindowTransformNode || child instanceof JoinAggregateTransformNode) {
        child.addDimensions(node.fields);
      }
      child.swapWithParent();
      moveFacetDown(node);
    } else {
      const facetMain = node.model.component.data.main;
      moveMainDownToFacet(facetMain);
      const cloner = cloneSubtree(node);
      const copy6 = node.children.map(cloner).flat();
      for (const c2 of copy6) {
        c2.parent = facetMain;
      }
    }
  } else {
    node.children.map(moveFacetDown);
  }
}
function moveMainDownToFacet(node) {
  if (node instanceof OutputNode && node.type === MAIN) {
    if (node.numChildren() === 1) {
      const child = node.children[0];
      if (!(child instanceof FacetNode)) {
        child.swapWithParent();
        moveMainDownToFacet(node);
      }
    }
  }
}
var MoveParseUp, MergeIdenticalNodes, RemoveUnusedSubtrees, RemoveDuplicateTimeUnits, MergeTimeUnits, RemoveUnnecessaryOutputNodes, RemoveUnnecessaryIdentifierNodes, MergeParse, MergeAggregates, MergeBins, MergeOutputs;
var init_optimizers = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/optimizers.js"() {
    init_data3();
    init_util();
    init_selection2();
    init_aggregate2();
    init_bin5();
    init_dataflow();
    init_facet2();
    init_filter4();
    init_formatparse();
    init_identifier();
    init_joinaggregate();
    init_optimize();
    init_optimizer();
    init_stack4();
    init_timeunit2();
    init_window();
    MoveParseUp = class extends BottomUpOptimizer {
      run(node) {
        const parent = node.parent;
        if (node instanceof ParseNode) {
          if (isDataSourceNode(parent)) {
            return this.flags;
          }
          if (parent.numChildren() > 1) {
            this.setContinue();
            return this.flags;
          }
          if (parent instanceof ParseNode) {
            this.setMutated();
            parent.merge(node);
          } else {
            if (fieldIntersection(parent.producedFields(), node.dependentFields())) {
              this.setContinue();
              return this.flags;
            }
            this.setMutated();
            node.swapWithParent();
          }
        }
        this.setContinue();
        return this.flags;
      }
    };
    MergeIdenticalNodes = class extends TopDownOptimizer {
      mergeNodes(parent, nodes) {
        const mergedNode = nodes.shift();
        for (const node of nodes) {
          parent.removeChild(node);
          node.parent = mergedNode;
          node.remove();
        }
      }
      run(node) {
        const hashes = node.children.map((x7) => x7.hash());
        const buckets = {};
        for (let i = 0; i < hashes.length; i++) {
          if (buckets[hashes[i]] === void 0) {
            buckets[hashes[i]] = [node.children[i]];
          } else {
            buckets[hashes[i]].push(node.children[i]);
          }
        }
        for (const k4 of keys4(buckets)) {
          if (buckets[k4].length > 1) {
            this.setMutated();
            this.mergeNodes(node, buckets[k4]);
          }
        }
        for (const child of node.children) {
          this.run(child);
        }
        return this.mutatedFlag;
      }
    };
    RemoveUnusedSubtrees = class extends BottomUpOptimizer {
      run(node) {
        if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {
          return this.flags;
        } else {
          this.setMutated();
          node.remove();
        }
        return this.flags;
      }
    };
    RemoveDuplicateTimeUnits = class extends BottomUpOptimizer {
      constructor() {
        super(...arguments);
        this.fields = /* @__PURE__ */ new Set();
        this.prev = null;
      }
      run(node) {
        this.setContinue();
        if (node instanceof TimeUnitNode) {
          const pfields = node.producedFields();
          if (hasIntersection(pfields, this.fields)) {
            this.setMutated();
            this.prev.remove();
          } else {
            this.fields = /* @__PURE__ */ new Set([...this.fields, ...pfields]);
          }
          this.prev = node;
        }
        return this.flags;
      }
      reset() {
        this.fields.clear();
      }
    };
    MergeTimeUnits = class extends BottomUpOptimizer {
      run(node) {
        this.setContinue();
        const parent = node.parent;
        const timeUnitChildren = parent.children.filter((x7) => x7 instanceof TimeUnitNode);
        const combination = timeUnitChildren.pop();
        for (const timeUnit of timeUnitChildren) {
          this.setMutated();
          combination.merge(timeUnit);
        }
        return this.flags;
      }
    };
    RemoveUnnecessaryOutputNodes = class extends TopDownOptimizer {
      constructor() {
        super();
      }
      run(node) {
        if (node instanceof OutputNode && !node.isRequired()) {
          this.setMutated();
          node.remove();
        }
        for (const child of node.children) {
          this.run(child);
        }
        return this.mutatedFlag;
      }
    };
    RemoveUnnecessaryIdentifierNodes = class extends TopDownOptimizer {
      constructor(model) {
        super();
        this.requiresSelectionId = model && requiresSelectionId(model);
      }
      run(node) {
        if (node instanceof IdentifierNode) {
          if (!(this.requiresSelectionId && (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode))) {
            this.setMutated();
            node.remove();
          }
        }
        for (const child of node.children) {
          this.run(child);
        }
        return this.mutatedFlag;
      }
    };
    MergeParse = class extends BottomUpOptimizer {
      run(node) {
        const parent = node.parent;
        const originalChildren = [...parent.children];
        const parseChildren = parent.children.filter((child) => child instanceof ParseNode);
        if (parent.numChildren() > 1 && parseChildren.length >= 1) {
          const commonParse = {};
          const conflictingParse = /* @__PURE__ */ new Set();
          for (const parseNode of parseChildren) {
            const parse8 = parseNode.parse;
            for (const k4 of keys4(parse8)) {
              if (!(k4 in commonParse)) {
                commonParse[k4] = parse8[k4];
              } else if (commonParse[k4] !== parse8[k4]) {
                conflictingParse.add(k4);
              }
            }
          }
          for (const field4 of conflictingParse) {
            delete commonParse[field4];
          }
          if (!isEmpty(commonParse)) {
            this.setMutated();
            const mergedParseNode = new ParseNode(parent, commonParse);
            for (const childNode of originalChildren) {
              if (childNode instanceof ParseNode) {
                for (const key3 of keys4(commonParse)) {
                  delete childNode.parse[key3];
                }
              }
              parent.removeChild(childNode);
              childNode.parent = mergedParseNode;
              if (childNode instanceof ParseNode && keys4(childNode.parse).length === 0) {
                childNode.remove();
              }
            }
          }
        }
        this.setContinue();
        return this.flags;
      }
    };
    MergeAggregates = class extends BottomUpOptimizer {
      run(node) {
        const parent = node.parent;
        const aggChildren = parent.children.filter((child) => child instanceof AggregateNode);
        const groupedAggregates = {};
        for (const agg of aggChildren) {
          const groupBys = hash(agg.groupBy);
          if (!(groupBys in groupedAggregates)) {
            groupedAggregates[groupBys] = [];
          }
          groupedAggregates[groupBys].push(agg);
        }
        for (const group6 of keys4(groupedAggregates)) {
          const mergeableAggs = groupedAggregates[group6];
          if (mergeableAggs.length > 1) {
            const mergedAggs = mergeableAggs.pop();
            for (const agg of mergeableAggs) {
              if (mergedAggs.merge(agg)) {
                parent.removeChild(agg);
                agg.parent = mergedAggs;
                agg.remove();
                this.setMutated();
              }
            }
          }
        }
        this.setContinue();
        return this.flags;
      }
    };
    MergeBins = class extends BottomUpOptimizer {
      constructor(model) {
        super();
        this.model = model;
      }
      run(node) {
        const parent = node.parent;
        const moveBinsUp = !(isDataSourceNode(parent) || parent instanceof FilterNode || parent instanceof ParseNode || parent instanceof IdentifierNode);
        const promotableBins = [];
        const remainingBins = [];
        for (const child of parent.children) {
          if (child instanceof BinNode) {
            if (moveBinsUp && !fieldIntersection(parent.producedFields(), child.dependentFields())) {
              promotableBins.push(child);
            } else {
              remainingBins.push(child);
            }
          }
        }
        if (promotableBins.length > 0) {
          const promotedBin = promotableBins.pop();
          for (const bin5 of promotableBins) {
            promotedBin.merge(bin5, this.model.renameSignal.bind(this.model));
          }
          this.setMutated();
          if (parent instanceof BinNode) {
            parent.merge(promotedBin, this.model.renameSignal.bind(this.model));
          } else {
            promotedBin.swapWithParent();
          }
        }
        if (remainingBins.length > 1) {
          const remainingBin = remainingBins.pop();
          for (const bin5 of remainingBins) {
            remainingBin.merge(bin5, this.model.renameSignal.bind(this.model));
          }
          this.setMutated();
        }
        this.setContinue();
        return this.flags;
      }
    };
    MergeOutputs = class extends BottomUpOptimizer {
      run(node) {
        const parent = node.parent;
        const children5 = [...parent.children];
        const hasOutputChild = some4(children5, (child) => child instanceof OutputNode);
        if (!hasOutputChild || parent.numChildren() <= 1) {
          this.setContinue();
          return this.flags;
        }
        const otherChildren = [];
        let mainOutput;
        for (const child of children5) {
          if (child instanceof OutputNode) {
            let lastOutput = child;
            while (lastOutput.numChildren() === 1) {
              const theChild = lastOutput.children[0];
              if (theChild instanceof OutputNode) {
                lastOutput = theChild;
              } else {
                break;
              }
            }
            otherChildren.push(...lastOutput.children);
            if (mainOutput) {
              parent.removeChild(child);
              child.parent = mainOutput.parent;
              mainOutput.parent.removeChild(mainOutput);
              mainOutput.parent = lastOutput;
              this.setMutated();
            } else {
              mainOutput = lastOutput;
            }
          } else {
            otherChildren.push(child);
          }
        }
        if (otherChildren.length) {
          this.setMutated();
          for (const child of otherChildren) {
            child.parent.removeChild(child);
            child.parent = mainOutput;
          }
        }
        this.setContinue();
        return this.flags;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/optimize.js
function getLeaves(roots) {
  const leaves = [];
  function append2(node) {
    if (node.numChildren() === 0) {
      leaves.push(node);
    } else {
      for (const child of node.children) {
        append2(child);
      }
    }
  }
  for (const child of roots) {
    append2(child);
  }
  return leaves;
}
function isTrue(x7) {
  return x7;
}
function runOptimizer(optimizer, nodes) {
  const flags = nodes.map((node) => {
    if (optimizer instanceof BottomUpOptimizer) {
      const runFlags = optimizer.optimizeNextFromLeaves(node);
      optimizer.reset();
      return runFlags;
    } else {
      return optimizer.run(node);
    }
  });
  return flags.some(isTrue);
}
function optimizationDataflowHelper(dataComponent, model) {
  let roots = dataComponent.sources;
  const mutatedFlags = /* @__PURE__ */ new Set();
  mutatedFlags.add(runOptimizer(new RemoveUnnecessaryOutputNodes(), roots));
  mutatedFlags.add(runOptimizer(new RemoveUnnecessaryIdentifierNodes(model), roots));
  roots = roots.filter((r2) => r2.numChildren() > 0);
  mutatedFlags.add(runOptimizer(new RemoveUnusedSubtrees(), getLeaves(roots)));
  roots = roots.filter((r2) => r2.numChildren() > 0);
  mutatedFlags.add(runOptimizer(new MoveParseUp(), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new MergeBins(model), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new RemoveDuplicateTimeUnits(), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new MergeParse(), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new MergeAggregates(), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new MergeTimeUnits(), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new MergeIdenticalNodes(), roots));
  mutatedFlags.add(runOptimizer(new MergeOutputs(), getLeaves(roots)));
  dataComponent.sources = roots;
  return mutatedFlags.has(true);
}
function optimizeDataflow(data3, model) {
  checkLinks(data3.sources);
  let firstPassCounter = 0;
  let secondPassCounter = 0;
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data3, model)) {
      break;
    }
    firstPassCounter++;
  }
  data3.sources.map(moveFacetDown);
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data3, model)) {
      break;
    }
    secondPassCounter++;
  }
  checkLinks(data3.sources);
  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {
    warn2(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);
  }
}
var FACET_SCALE_PREFIX, MAX_OPTIMIZATION_RUNS;
var init_optimize = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/optimize.js"() {
    init_log3();
    init_debug();
    init_optimizer();
    init_optimizers();
    FACET_SCALE_PREFIX = "scale_";
    MAX_OPTIMIZATION_RUNS = 5;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/signal.js
var SignalRefWrapper;
var init_signal = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/signal.js"() {
    SignalRefWrapper = class {
      constructor(exprGenerator) {
        Object.defineProperty(this, "signal", {
          enumerable: true,
          get: exprGenerator
        });
      }
      static fromName(rename, signalName) {
        return new SignalRefWrapper(() => rename(signalName));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/domain.js
function parseScaleDomain2(model) {
  if (isUnitModel(model)) {
    parseUnitScaleDomain(model);
  } else {
    parseNonUnitScaleDomain(model);
  }
}
function parseUnitScaleDomain(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of keys4(localScaleComponents)) {
    const domains = parseDomainForChannel(model, channel);
    const localScaleCmpt = localScaleComponents[channel];
    localScaleCmpt.setWithExplicit("domains", domains);
    parseSelectionDomain(model, channel);
    if (model.component.data.isFaceted) {
      let facetParent = model;
      while (!isFacetModel(facetParent) && facetParent.parent) {
        facetParent = facetParent.parent;
      }
      const resolve2 = facetParent.component.resolve.scale[channel];
      if (resolve2 === "shared") {
        for (const domain4 of domains.value) {
          if (isDataRefDomain(domain4)) {
            domain4.data = FACET_SCALE_PREFIX + domain4.data.replace(FACET_SCALE_PREFIX, "");
          }
        }
      }
    }
  }
}
function parseNonUnitScaleDomain(model) {
  for (const child of model.children) {
    parseScaleDomain2(child);
  }
  const localScaleComponents = model.component.scales;
  for (const channel of keys4(localScaleComponents)) {
    let domains;
    let selectionExtent = null;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        if (domains === void 0) {
          domains = childComponent.getWithExplicit("domains");
        } else {
          domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit("domains"), "domains", "scale", domainsTieBreaker);
        }
        const se = childComponent.get("selectionExtent");
        if (selectionExtent && se && selectionExtent.selection !== se.selection) {
          warn2("The same selection must be used to override scale domains in a layered view.");
        }
        selectionExtent = se;
      }
    }
    localScaleComponents[channel].setWithExplicit("domains", domains);
    if (selectionExtent) {
      localScaleComponents[channel].set("selectionExtent", selectionExtent, true);
    }
  }
}
function normalizeUnaggregatedDomain(domain4, fieldDef, scaleType2, scaleConfig) {
  if (domain4 === "unaggregated") {
    const { valid, reason } = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (!valid) {
      warn2(reason);
      return void 0;
    }
  } else if (domain4 === void 0 && scaleConfig.useUnaggregatedDomain) {
    const { valid } = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (valid) {
      return "unaggregated";
    }
  }
  return domain4;
}
function parseDomainForChannel(model, channel) {
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const { encoding } = model;
  const domain4 = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType2, model.config.scale);
  if (domain4 !== model.scaleDomain(channel)) {
    model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), { domain: domain4 });
  }
  if (channel === "x" && getFieldOrDatumDef(encoding.x2)) {
    if (getFieldOrDatumDef(encoding.x)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain4, model, "x"), parseSingleChannelDomain(scaleType2, domain4, model, "x2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain4, model, "x2");
    }
  } else if (channel === "y" && getFieldOrDatumDef(encoding.y2)) {
    if (getFieldOrDatumDef(encoding.y)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain4, model, "y"), parseSingleChannelDomain(scaleType2, domain4, model, "y2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain4, model, "y2");
    }
  }
  return parseSingleChannelDomain(scaleType2, domain4, model, channel);
}
function mapDomainToDataSignal(domain4, type4, timeUnit) {
  return domain4.map((v) => {
    const data3 = valueExpr(v, { timeUnit, type: type4 });
    return { signal: `{data: ${data3}}` };
  });
}
function convertDomainIfItIsDateTime(domain4, type4, timeUnit) {
  var _a2;
  const normalizedTimeUnit = (_a2 = normalizeTimeUnit(timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit;
  if (type4 === "temporal" || normalizedTimeUnit) {
    return mapDomainToDataSignal(domain4, type4, normalizedTimeUnit);
  }
  return [domain4];
}
function parseSingleChannelDomain(scaleType2, domain4, model, channel) {
  const { encoding } = model;
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const { type: type4 } = fieldOrDatumDef;
  const timeUnit = fieldOrDatumDef["timeUnit"];
  if (isDomainUnionWith(domain4)) {
    const defaultDomain = parseSingleChannelDomain(scaleType2, void 0, model, channel);
    const unionWith = convertDomainIfItIsDateTime(domain4.unionWith, type4, timeUnit);
    return makeExplicit([...defaultDomain.value, ...unionWith]);
  } else if (isSignalRef(domain4)) {
    return makeExplicit([domain4]);
  } else if (domain4 && domain4 !== "unaggregated" && !isSelectionDomain(domain4)) {
    return makeExplicit(convertDomainIfItIsDateTime(domain4, type4, timeUnit));
  }
  const stack3 = model.stack;
  if (stack3 && channel === stack3.fieldChannel) {
    if (stack3.offset === "normalize") {
      return makeImplicit([[0, 1]]);
    }
    const data3 = model.requestDataName(MAIN);
    return makeImplicit([
      {
        data: data3,
        field: model.vgField(channel, { suffix: "start" })
      },
      {
        data: data3,
        field: model.vgField(channel, { suffix: "end" })
      }
    ]);
  }
  const sort5 = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType2) : void 0;
  if (isDatumDef(fieldOrDatumDef)) {
    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type4, timeUnit);
    return makeImplicit(d);
  }
  const fieldDef = fieldOrDatumDef;
  if (domain4 === "unaggregated") {
    const data3 = model.requestDataName(MAIN);
    const { field: field4 } = fieldOrDatumDef;
    return makeImplicit([
      {
        data: data3,
        field: vgField({ field: field4, aggregate: "min" })
      },
      {
        data: data3,
        field: vgField({ field: field4, aggregate: "max" })
      }
    ]);
  } else if (isBinning(fieldDef.bin)) {
    if (hasDiscreteDomain(scaleType2)) {
      if (scaleType2 === "bin-ordinal") {
        return makeImplicit([]);
      }
      return makeImplicit([
        {
          data: isBoolean4(sort5) ? model.requestDataName(MAIN) : model.requestDataName(RAW),
          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? { binSuffix: "range" } : {}),
          sort: sort5 === true || !isObject_default(sort5) ? {
            field: model.vgField(channel, {}),
            op: "min"
          } : sort5
        }
      ]);
    } else {
      const { bin: bin5 } = fieldDef;
      if (isBinning(bin5)) {
        const binSignal = getBinSignalName(model, fieldDef.field, bin5);
        return makeImplicit([
          new SignalRefWrapper(() => {
            const signal = model.getSignalName(binSignal);
            return `[${signal}.start, ${signal}.stop]`;
          })
        ]);
      } else {
        return makeImplicit([
          {
            data: model.requestDataName(MAIN),
            field: model.vgField(channel, {})
          }
        ]);
      }
    }
  } else if (fieldDef.timeUnit && contains2(["time", "utc"], scaleType2) && hasBand(channel, fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0, model.stack, model.markDef, model.config)) {
    const data3 = model.requestDataName(MAIN);
    return makeImplicit([
      {
        data: data3,
        field: model.vgField(channel)
      },
      {
        data: data3,
        field: model.vgField(channel, { suffix: "end" })
      }
    ]);
  } else if (sort5) {
    return makeImplicit([
      {
        data: isBoolean4(sort5) ? model.requestDataName(MAIN) : model.requestDataName(RAW),
        field: model.vgField(channel),
        sort: sort5
      }
    ]);
  } else {
    return makeImplicit([
      {
        data: model.requestDataName(MAIN),
        field: model.vgField(channel)
      }
    ]);
  }
}
function normalizeSortField(sort5, isStackedMeasure) {
  const { op, field: field4, order } = sort5;
  return Object.assign(Object.assign({
    op: op !== null && op !== void 0 ? op : isStackedMeasure ? "sum" : DEFAULT_SORT_OP
  }, field4 ? { field: replacePathInField(field4) } : {}), order ? { order } : {});
}
function parseSelectionDomain(model, channel) {
  var _a2;
  const scale8 = model.component.scales[channel];
  const spec = model.specifiedScales[channel].domain;
  const bin5 = (_a2 = model.fieldDef(channel)) === null || _a2 === void 0 ? void 0 : _a2.bin;
  const domain4 = isSelectionDomain(spec) && spec;
  const extent5 = isBinParams(bin5) && isSelectionExtent(bin5.extent) && bin5.extent;
  if (domain4 || extent5) {
    scale8.set("selectionExtent", domain4 !== null && domain4 !== void 0 ? domain4 : extent5, true);
  }
}
function domainSort(model, channel, scaleType2) {
  if (!hasDiscreteDomain(scaleType2)) {
    return void 0;
  }
  const fieldDef = model.fieldDef(channel);
  const sort5 = fieldDef.sort;
  if (isSortArray(sort5)) {
    return {
      op: "min",
      field: sortArrayIndexField(fieldDef, channel),
      order: "ascending"
    };
  }
  const { stack: stack3 } = model;
  const stackDimensions = stack3 ? [...stack3.groupbyField ? [stack3.groupbyField] : [], ...stack3.stackBy.map((s3) => s3.fieldDef.field)] : void 0;
  if (isSortField(sort5)) {
    const isStackedMeasure = stack3 && !contains2(stackDimensions, sort5.field);
    return normalizeSortField(sort5, isStackedMeasure);
  } else if (isSortByEncoding(sort5)) {
    const { encoding, order } = sort5;
    const fieldDefToSortBy = model.fieldDef(encoding);
    const { aggregate, field: field4 } = fieldDefToSortBy;
    const isStackedMeasure = stack3 && !contains2(stackDimensions, field4);
    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
      return normalizeSortField({
        field: vgField(fieldDefToSortBy),
        order
      }, isStackedMeasure);
    } else if (isAggregateOp(aggregate) || !aggregate) {
      return normalizeSortField({
        op: aggregate,
        field: field4,
        order
      }, isStackedMeasure);
    }
  } else if (sort5 === "descending") {
    return {
      op: "min",
      field: model.vgField(channel),
      order: "descending"
    };
  } else if (contains2(["ascending", void 0], sort5)) {
    return true;
  }
  return void 0;
}
function canUseUnaggregatedDomain(fieldDef, scaleType2) {
  const { aggregate, type: type4 } = fieldDef;
  if (!aggregate) {
    return {
      valid: false,
      reason: message_exports.unaggregateDomainHasNoEffectForRawField(fieldDef)
    };
  }
  if (isString_default(aggregate) && !SHARED_DOMAIN_OP_INDEX[aggregate]) {
    return {
      valid: false,
      reason: message_exports.unaggregateDomainWithNonSharedDomainOp(aggregate)
    };
  }
  if (type4 === "quantitative") {
    if (scaleType2 === "log") {
      return {
        valid: false,
        reason: message_exports.unaggregatedDomainWithLogScale(fieldDef)
      };
    }
  }
  return { valid: true };
}
function domainsTieBreaker(v1, v2, property2, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn2(message_exports.mergeConflictingDomainProperty(property2, propertyOf, v1.value, v2.value));
  }
  return { explicit: v1.explicit, value: [...v1.value, ...v2.value] };
}
function mergeDomains(domains) {
  const uniqueDomains = unique(domains.map((domain4) => {
    if (isDataRefDomain(domain4)) {
      const { sort: _s } = domain4, domainWithoutSort = __rest(domain4, ["sort"]);
      return domainWithoutSort;
    }
    return domain4;
  }), hash);
  const sorts = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      const s3 = d.sort;
      if (s3 !== void 0 && !isBoolean4(s3)) {
        if ("op" in s3 && s3.op === "count") {
          delete s3.field;
        }
        if (s3.order === "ascending") {
          delete s3.order;
        }
      }
      return s3;
    }
    return void 0;
  }).filter((s3) => s3 !== void 0), hash);
  if (uniqueDomains.length === 0) {
    return void 0;
  } else if (uniqueDomains.length === 1) {
    const domain4 = domains[0];
    if (isDataRefDomain(domain4) && sorts.length > 0) {
      let sort6 = sorts[0];
      if (sorts.length > 1) {
        warn2(message_exports.MORE_THAN_ONE_SORT);
        sort6 = true;
      } else {
        if (isObject_default(sort6) && "field" in sort6) {
          const sortField = sort6.field;
          if (domain4.field === sortField) {
            sort6 = sort6.order ? { order: sort6.order } : true;
          }
        }
      }
      return Object.assign(Object.assign({}, domain4), { sort: sort6 });
    }
    return domain4;
  }
  const unionDomainSorts = unique(sorts.map((s3) => {
    if (isBoolean4(s3) || !("op" in s3) || s3.op in MULTIDOMAIN_SORT_OP_INDEX) {
      return s3;
    }
    warn2(message_exports.domainSortDropped(s3));
    return true;
  }), hash);
  let sort5;
  if (unionDomainSorts.length === 1) {
    sort5 = unionDomainSorts[0];
  } else if (unionDomainSorts.length > 1) {
    warn2(message_exports.MORE_THAN_ONE_SORT);
    sort5 = true;
  }
  const allData = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      return d.data;
    }
    return null;
  }), (x7) => x7);
  if (allData.length === 1 && allData[0] !== null) {
    const domain4 = Object.assign({ data: allData[0], fields: uniqueDomains.map((d) => d.field) }, sort5 ? { sort: sort5 } : {});
    return domain4;
  }
  return Object.assign({ fields: uniqueDomains }, sort5 ? { sort: sort5 } : {});
}
function getFieldFromDomain(domain4) {
  if (isDataRefDomain(domain4) && isString_default(domain4.field)) {
    return domain4.field;
  } else if (isDataRefUnionedDomain(domain4)) {
    let field4;
    for (const nonUnionDomain of domain4.fields) {
      if (isDataRefDomain(nonUnionDomain) && isString_default(nonUnionDomain.field)) {
        if (!field4) {
          field4 = nonUnionDomain.field;
        } else if (field4 !== nonUnionDomain.field) {
          warn2(message_exports.FACETED_INDEPENDENT_DIFFERENT_SOURCES);
          return field4;
        }
      }
    }
    warn2(message_exports.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);
    return field4;
  } else if (isFieldRefUnionDomain(domain4)) {
    warn2(message_exports.FACETED_INDEPENDENT_SAME_SOURCE);
    const field4 = domain4.fields[0];
    return isString_default(field4) ? field4 : void 0;
  }
  return void 0;
}
function assembleDomain(model, channel) {
  const scaleComponent = model.component.scales[channel];
  const domains = scaleComponent.get("domains").map((domain4) => {
    if (isDataRefDomain(domain4)) {
      domain4.data = model.lookupDataSource(domain4.data);
    }
    return domain4;
  });
  return mergeDomains(domains);
}
var init_domain = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/domain.js"() {
    init_tslib_es6();
    init_vega_util();
    init_aggregate();
    init_bin4();
    init_channel();
    init_channeldef();
    init_data3();
    init_log3();
    init_scale();
    init_sort5();
    init_timeunit();
    init_util();
    init_vega_schema();
    init_bin5();
    init_calculate();
    init_optimize();
    init_model();
    init_signal();
    init_split();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/assemble.js
function assembleScales(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return model.children.reduce((scales3, child) => {
      return scales3.concat(assembleScales(child));
    }, assembleScalesForModel(model));
  } else {
    return assembleScalesForModel(model);
  }
}
function assembleScalesForModel(model) {
  return keys4(model.component.scales).reduce((scales3, channel) => {
    const scaleComponent = model.component.scales[channel];
    if (scaleComponent.merged) {
      return scales3;
    }
    const scale8 = scaleComponent.combine();
    const { name: name4, type: type4, selectionExtent, domains: _d2, range: _r2, reverse: reverse6 } = scale8, otherScaleProps = __rest(scale8, ["name", "type", "selectionExtent", "domains", "range", "reverse"]);
    const range7 = assembleScaleRange(scale8.range, name4, channel);
    let domainRaw;
    if (selectionExtent) {
      domainRaw = assembleSelectionScaleDomain(model, selectionExtent);
    }
    const domain4 = assembleDomain(model, channel);
    scales3.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      name: name4,
      type: type4
    }, domain4 ? { domain: domain4 } : {}), domainRaw ? { domainRaw } : {}), { range: range7 }), reverse6 !== void 0 ? { reverse: reverse6 } : {}), otherScaleProps));
    return scales3;
  }, []);
}
function assembleScaleRange(scaleRange, scaleName, channel) {
  if (isXorY(channel)) {
    if (isVgRangeStep(scaleRange)) {
      return {
        step: { signal: scaleName + "_step" }
      };
    }
  }
  return scaleRange;
}
var init_assemble7 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/assemble.js"() {
    init_tslib_es6();
    init_channel();
    init_util();
    init_vega_schema();
    init_model();
    init_assemble();
    init_domain();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/component.js
var ScaleComponent;
var init_component5 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/component.js"() {
    init_vega_util();
    init_util();
    init_split();
    ScaleComponent = class extends Split {
      constructor(name4, typeWithExplicit) {
        super(
          {},
          { name: name4 }
        );
        this.merged = false;
        this.setWithExplicit("type", typeWithExplicit);
      }
      domainDefinitelyIncludesZero() {
        if (this.get("zero") !== false) {
          return true;
        }
        return some4(this.get("domains"), (d) => isArray_default(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/range.js
function getSizeChannel2(channel) {
  return channel === "x" ? "width" : channel === "y" ? "height" : void 0;
}
function parseUnitScaleRange(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of SCALE_CHANNELS) {
    const localScaleCmpt = localScaleComponents[channel];
    if (!localScaleCmpt) {
      continue;
    }
    const rangeWithExplicit = parseRangeForChannel(channel, model);
    localScaleCmpt.setWithExplicit("range", rangeWithExplicit);
  }
}
function getBinStepSignal(model, channel) {
  const fieldDef = model.fieldDef(channel);
  if (fieldDef && fieldDef.bin && isBinning(fieldDef.bin)) {
    const binSignal = getBinSignalName(model, fieldDef.field, fieldDef.bin);
    const sizeType = getSizeChannel2(channel);
    const sizeSignal = model.getName(sizeType);
    return new SignalRefWrapper(() => {
      const updatedName = model.getSignalName(binSignal);
      const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;
      return `${model.getSignalName(sizeSignal)} / (${binCount})`;
    });
  }
  return void 0;
}
function parseRangeForChannel(channel, model) {
  const specifiedScale = model.specifiedScales[channel];
  const { size } = model;
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  for (const property2 of RANGE_PROPERTIES) {
    if (specifiedScale[property2] !== void 0) {
      const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
      const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
      if (!supportedByScaleType) {
        warn2(message_exports.scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
      } else if (channelIncompatability) {
        warn2(channelIncompatability);
      } else {
        switch (property2) {
          case "range":
            if (isArray_default(specifiedScale.range) && isXorY(channel)) {
              return makeExplicit(specifiedScale.range.map((v) => {
                if (v === "width" || v === "height") {
                  const sizeSignal = model.getName(v);
                  const getSignalName = model.getSignalName.bind(model);
                  return SignalRefWrapper.fromName(getSignalName, sizeSignal);
                }
                return v;
              }));
            }
            return makeExplicit(specifiedScale.range);
          case "scheme":
            return makeExplicit(parseScheme(specifiedScale[property2]));
        }
      }
    }
  }
  if (channel === X3 || channel === Y3) {
    const sizeChannel = channel === X3 ? "width" : "height";
    const sizeValue = size[sizeChannel];
    if (isStep(sizeValue)) {
      if (hasDiscreteDomain(scaleType2)) {
        return makeExplicit({ step: sizeValue.step });
      } else {
        warn2(message_exports.stepDropped(sizeChannel));
      }
    }
  }
  return makeImplicit(defaultRange(channel, model));
}
function parseScheme(scheme4) {
  if (isExtendedScheme(scheme4)) {
    return Object.assign({ scheme: scheme4.name }, omit(scheme4, ["name"]));
  }
  return { scheme: scheme4 };
}
function defaultRange(channel, model) {
  const { size, config, mark, encoding } = model;
  const getSignalName = model.getSignalName.bind(model);
  const { type: type4 } = getFieldOrDatumDef(encoding[channel]);
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  const { domain: domain4, domainMid } = model.specifiedScales[channel];
  switch (channel) {
    case X3:
    case Y3: {
      if (contains2(["point", "band"], scaleType2)) {
        if (channel === X3 && !size.width) {
          const w5 = getViewConfigDiscreteSize(config.view, "width");
          if (isStep(w5)) {
            return w5;
          }
        } else if (channel === Y3 && !size.height) {
          const h4 = getViewConfigDiscreteSize(config.view, "height");
          if (isStep(h4)) {
            return h4;
          }
        }
      }
      const sizeType = getSizeChannel2(channel);
      const sizeSignal = model.getName(sizeType);
      if (channel === Y3 && hasContinuousDomain(scaleType2)) {
        return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];
      } else {
        return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];
      }
    }
    case SIZE2: {
      const zero10 = model.component.scales[channel].get("zero");
      const rangeMin = sizeRangeMin(mark, zero10, config);
      const rangeMax = sizeRangeMax(mark, size, model, config);
      if (isContinuousToDiscrete(scaleType2)) {
        return interpolateRange2(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType2, config, domain4, channel));
      } else {
        return [rangeMin, rangeMax];
      }
    }
    case THETA:
      return [0, Math.PI * 2];
    case ANGLE:
      return [0, 360];
    case RADIUS: {
      return [
        0,
        new SignalRefWrapper(() => {
          const w5 = model.getSignalName("width");
          const h4 = model.getSignalName("height");
          return `min(${w5},${h4})/2`;
        })
      ];
    }
    case STROKEWIDTH:
      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];
    case STROKEDASH:
      return [
        [1, 0],
        [4, 2],
        [2, 1],
        [1, 1],
        [1, 2, 4, 2]
      ];
    case SHAPE:
      return "symbol";
    case COLOR:
    case FILL:
    case STROKE:
      if (scaleType2 === "ordinal") {
        return type4 === "nominal" ? "category" : "ordinal";
      } else {
        if (domainMid !== void 0) {
          return "diverging";
        } else {
          return mark === "rect" || mark === "geoshape" ? "heatmap" : "ramp";
        }
      }
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
      return [config.scale.minOpacity, config.scale.maxOpacity];
  }
  throw new Error(`Scale range undefined for channel ${channel}`);
}
function defaultContinuousToDiscreteCount(scaleType2, config, domain4, channel) {
  switch (scaleType2) {
    case "quantile":
      return config.scale.quantileCount;
    case "quantize":
      return config.scale.quantizeCount;
    case "threshold":
      if (domain4 !== void 0 && isArray_default(domain4)) {
        return domain4.length + 1;
      } else {
        warn2(message_exports.domainRequiredForThresholdScale(channel));
        return 3;
      }
  }
}
function interpolateRange2(rangeMin, rangeMax, cardinality) {
  const f = () => {
    const rMax = signalOrStringValue(rangeMax);
    const rMin = signalOrStringValue(rangeMin);
    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;
    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;
  };
  if (isSignalRef(rangeMax)) {
    return new SignalRefWrapper(f);
  } else {
    return { signal: f() };
  }
}
function sizeRangeMin(mark, zero10, config) {
  if (zero10) {
    if (isSignalRef(zero10)) {
      return { signal: `${zero10.signal} ? 0 : ${sizeRangeMin(mark, false, config)}` };
    } else {
      return 0;
    }
  }
  switch (mark) {
    case "bar":
    case "tick":
      return config.scale.minBandSize;
    case "line":
    case "trail":
    case "rule":
      return config.scale.minStrokeWidth;
    case "text":
      return config.scale.minFontSize;
    case "point":
    case "square":
    case "circle":
      return config.scale.minSize;
  }
  throw new Error(message_exports.incompatibleChannel("size", mark));
}
function sizeRangeMax(mark, size, model, config) {
  const xyStepSignals = {
    x: getBinStepSignal(model, "x"),
    y: getBinStepSignal(model, "y")
  };
  switch (mark) {
    case "bar":
    case "tick": {
      if (config.scale.maxBandSize !== void 0) {
        return config.scale.maxBandSize;
      }
      const min8 = minXYStep(size, xyStepSignals, config.view);
      if (isNumber_default(min8)) {
        return min8 - 1;
      } else {
        return new SignalRefWrapper(() => `${min8.signal} - 1`);
      }
    }
    case "line":
    case "trail":
    case "rule":
      return config.scale.maxStrokeWidth;
    case "text":
      return config.scale.maxFontSize;
    case "point":
    case "square":
    case "circle": {
      if (config.scale.maxSize) {
        return config.scale.maxSize;
      }
      const pointStep = minXYStep(size, xyStepSignals, config.view);
      if (isNumber_default(pointStep)) {
        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);
      } else {
        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);
      }
    }
  }
  throw new Error(message_exports.incompatibleChannel("size", mark));
}
function minXYStep(size, xyStepSignals, viewConfig) {
  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, "width");
  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, "height");
  if (xyStepSignals.x || xyStepSignals.y) {
    return new SignalRefWrapper(() => {
      const exprs = [
        xyStepSignals.x ? xyStepSignals.x.signal : widthStep,
        xyStepSignals.y ? xyStepSignals.y.signal : heightStep
      ];
      return `min(${exprs.join(", ")})`;
    });
  }
  return Math.min(widthStep, heightStep);
}
var RANGE_PROPERTIES, MAX_SIZE_RANGE_STEP_RATIO;
var init_range4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/range.js"() {
    init_vega_util();
    init_bin4();
    init_channel();
    init_channeldef();
    init_config();
    init_log3();
    init_scale();
    init_base2();
    init_util();
    init_vega_schema();
    init_bin5();
    init_signal();
    init_split();
    init_common();
    RANGE_PROPERTIES = ["range", "scheme"];
    MAX_SIZE_RANGE_STEP_RATIO = 0.95;
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/properties.js
function parseScaleProperty(model, property2) {
  if (isUnitModel(model)) {
    parseUnitScaleProperty(model, property2);
  } else {
    parseNonUnitScaleProperty(model, property2);
  }
}
function parseUnitScaleProperty(model, property2) {
  const localScaleComponents = model.component.scales;
  const { config, encoding, markDef, specifiedScales } = model;
  for (const channel of keys4(localScaleComponents)) {
    const specifiedScale = specifiedScales[channel];
    const localScaleCmpt = localScaleComponents[channel];
    const mergedScaleCmpt = model.getScaleComponent(channel);
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    const specifiedValue = specifiedScale[property2];
    const scaleType2 = mergedScaleCmpt.get("type");
    const scalePadding = mergedScaleCmpt.get("padding");
    const scalePaddingInner = mergedScaleCmpt.get("paddingInner");
    const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
    const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
    if (specifiedValue !== void 0) {
      if (!supportedByScaleType) {
        warn2(message_exports.scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
      } else if (channelIncompatability) {
        warn2(channelIncompatability);
      }
    }
    if (supportedByScaleType && channelIncompatability === void 0) {
      if (specifiedValue !== void 0) {
        localScaleCmpt.copyKeyFromObject(property2, specifiedScale);
      } else {
        const value4 = property2 in scaleRules ? scaleRules[property2]({
          model,
          channel,
          fieldOrDatumDef,
          scaleType: scaleType2,
          scalePadding,
          scalePaddingInner,
          domain: specifiedScale.domain,
          markDef,
          config
        }) : config.scale[property2];
        if (value4 !== void 0) {
          localScaleCmpt.set(property2, value4, false);
        }
      }
    }
  }
}
function parseScaleRange2(model) {
  if (isUnitModel(model)) {
    parseUnitScaleRange(model);
  } else {
    parseNonUnitScaleProperty(model, "range");
  }
}
function parseNonUnitScaleProperty(model, property2) {
  const localScaleComponents = model.component.scales;
  for (const child of model.children) {
    if (property2 === "range") {
      parseScaleRange2(child);
    } else {
      parseScaleProperty(child, property2);
    }
  }
  for (const channel of keys4(localScaleComponents)) {
    let valueWithExplicit;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        const childValueWithExplicit = childComponent.getWithExplicit(property2);
        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property2, "scale", tieBreakByComparing((v1, v2) => {
          switch (property2) {
            case "range":
              if (v1.step && v2.step) {
                return v1.step - v2.step;
              }
              return 0;
          }
          return 0;
        }));
      }
    }
    localScaleComponents[channel].setWithExplicit(property2, valueWithExplicit);
  }
}
function bins(model, fieldDef) {
  const bin5 = fieldDef.bin;
  if (isBinning(bin5)) {
    const binSignal = getBinSignalName(model, fieldDef.field, bin5);
    return new SignalRefWrapper(() => {
      return model.getSignalName(binSignal);
    });
  } else if (isBinned(bin5) && isBinParams(bin5) && bin5.step !== void 0) {
    return {
      step: bin5.step
    };
  }
  return void 0;
}
function interpolate3(channel, type4) {
  if (contains2([COLOR, FILL, STROKE], channel) && type4 !== "nominal") {
    return "hcl";
  }
  return void 0;
}
function nice6(scaleType2, channel, fieldOrDatumDef) {
  var _a2;
  if (((_a2 = getFieldDef(fieldOrDatumDef)) === null || _a2 === void 0 ? void 0 : _a2.bin) || contains2([ScaleType.TIME, ScaleType.UTC], scaleType2)) {
    return void 0;
  }
  return channel in POSITION_SCALE_CHANNEL_INDEX ? true : void 0;
}
function padding2(channel, scaleType2, scaleConfig, fieldOrDatumDef, markDef, barConfig) {
  if (channel in POSITION_SCALE_CHANNEL_INDEX) {
    if (isContinuousToContinuous(scaleType2)) {
      if (scaleConfig.continuousPadding !== void 0) {
        return scaleConfig.continuousPadding;
      }
      const { type: type4, orient: orient3 } = markDef;
      if (type4 === "bar" && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {
        if (orient3 === "vertical" && channel === "x" || orient3 === "horizontal" && channel === "y") {
          return barConfig.continuousBandSize;
        }
      }
    }
    if (scaleType2 === ScaleType.POINT) {
      return scaleConfig.pointPadding;
    }
  }
  return void 0;
}
function paddingInner(paddingValue, channel, mark, scaleConfig) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (channel in POSITION_SCALE_CHANNEL_INDEX) {
    const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner } = scaleConfig;
    return getFirstDefined(bandPaddingInner, mark === "bar" ? barBandPaddingInner : rectBandPaddingInner);
  }
  return void 0;
}
function paddingOuter(paddingValue, channel, scaleType2, mark, paddingInnerValue, scaleConfig) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (channel in POSITION_SCALE_CHANNEL_INDEX) {
    if (scaleType2 === ScaleType.BAND) {
      const { bandPaddingOuter } = scaleConfig;
      return getFirstDefined(
        bandPaddingOuter,
        isSignalRef(paddingInnerValue) ? { signal: `${paddingInnerValue.signal}/2` } : paddingInnerValue / 2
      );
    }
  }
  return void 0;
}
function reverse5(scaleType2, sort5, channel, scaleConfig) {
  if (channel === "x" && scaleConfig.xReverse !== void 0) {
    if (hasContinuousDomain(scaleType2) && sort5 === "descending") {
      if (isSignalRef(scaleConfig.xReverse)) {
        return { signal: `!${scaleConfig.xReverse.signal}` };
      } else {
        return !scaleConfig.xReverse;
      }
    }
    return scaleConfig.xReverse;
  }
  if (hasContinuousDomain(scaleType2) && sort5 === "descending") {
    return true;
  }
  return void 0;
}
function zero9(channel, fieldDef, specifiedDomain, markDef, scaleType2) {
  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== "unaggregated";
  if (hasCustomDomain) {
    if (hasContinuousDomain(scaleType2)) {
      if (isArray_default(specifiedDomain)) {
        const first = specifiedDomain[0];
        const last = specifiedDomain[specifiedDomain.length - 1];
        if (first <= 0 && last >= 0) {
          return true;
        }
      }
      return false;
    }
  }
  if (channel === "size" && fieldDef.type === "quantitative" && !isContinuousToDiscrete(scaleType2)) {
    return true;
  }
  if (!(isFieldDef(fieldDef) && fieldDef.bin) && contains2([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {
    const { orient: orient3, type: type4 } = markDef;
    if (contains2(["bar", "area", "line", "trail"], type4)) {
      if (orient3 === "horizontal" && channel === "y" || orient3 === "vertical" && channel === "x") {
        return false;
      }
    }
    return true;
  }
  return false;
}
var scaleRules;
var init_properties3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/properties.js"() {
    init_vega_util();
    init_bin4();
    init_channel();
    init_channeldef();
    init_log3();
    init_scale();
    init_util();
    init_util();
    init_vega_schema();
    init_bin5();
    init_model();
    init_signal();
    init_split();
    init_range4();
    scaleRules = {
      bins: ({ model, fieldOrDatumDef }) => isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : void 0,
      interpolate: ({ channel, fieldOrDatumDef }) => interpolate3(channel, fieldOrDatumDef.type),
      nice: ({ scaleType: scaleType2, channel, fieldOrDatumDef }) => nice6(scaleType2, channel, fieldOrDatumDef),
      padding: ({ channel, scaleType: scaleType2, fieldOrDatumDef, markDef, config }) => padding2(channel, scaleType2, config.scale, fieldOrDatumDef, markDef, config.bar),
      paddingInner: ({ scalePadding, channel, markDef, config }) => paddingInner(scalePadding, channel, markDef.type, config.scale),
      paddingOuter: ({ scalePadding, channel, scaleType: scaleType2, markDef, scalePaddingInner, config }) => paddingOuter(scalePadding, channel, scaleType2, markDef.type, scalePaddingInner, config.scale),
      reverse: ({ fieldOrDatumDef, scaleType: scaleType2, channel, config }) => {
        const sort5 = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0;
        return reverse5(scaleType2, sort5, channel, config.scale);
      },
      zero: ({ channel, fieldOrDatumDef, domain: domain4, markDef, scaleType: scaleType2 }) => zero9(channel, fieldOrDatumDef, domain4, markDef, scaleType2)
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/type.js
function scaleType(specifiedScale, channel, fieldDef, mark) {
  const defaultScaleType = defaultType3(channel, fieldDef, mark);
  const { type: type4 } = specifiedScale;
  if (!isScaleChannel(channel)) {
    return null;
  }
  if (type4 !== void 0) {
    if (!channelSupportScaleType(channel, type4)) {
      warn2(message_exports.scaleTypeNotWorkWithChannel(channel, type4, defaultScaleType));
      return defaultScaleType;
    }
    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type4, fieldDef.type)) {
      warn2(message_exports.scaleTypeNotWorkWithFieldDef(type4, defaultScaleType));
      return defaultScaleType;
    }
    return type4;
  }
  return defaultScaleType;
}
function defaultType3(channel, fieldDef, mark) {
  var _a2;
  switch (fieldDef.type) {
    case "nominal":
    case "ordinal":
      if (isColorChannel(channel) || rangeType(channel) === "discrete") {
        if (channel === "shape" && fieldDef.type === "ordinal") {
          warn2(message_exports.discreteChannelCannotEncode(channel, "ordinal"));
        }
        return "ordinal";
      }
      if (channel in POSITION_SCALE_CHANNEL_INDEX) {
        if (contains2(["rect", "bar", "image", "rule"], mark)) {
          return "band";
        }
      } else if (mark === "arc" && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {
        return "band";
      }
      if (fieldDef.band !== void 0 || isPositionFieldOrDatumDef(fieldDef) && ((_a2 = fieldDef.axis) === null || _a2 === void 0 ? void 0 : _a2.tickBand)) {
        return "band";
      }
      return "point";
    case "temporal":
      if (isColorChannel(channel)) {
        return "time";
      } else if (rangeType(channel) === "discrete") {
        warn2(message_exports.discreteChannelCannotEncode(channel, "temporal"));
        return "ordinal";
      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {
        return "utc";
      }
      return "time";
    case "quantitative":
      if (isColorChannel(channel)) {
        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
          return "bin-ordinal";
        }
        return "linear";
      } else if (rangeType(channel) === "discrete") {
        warn2(message_exports.discreteChannelCannotEncode(channel, "quantitative"));
        return "ordinal";
      }
      return "linear";
    case "geojson":
      return void 0;
  }
  throw new Error(message_exports.invalidFieldType(fieldDef.type));
}
var init_type2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/type.js"() {
    init_bin4();
    init_channel();
    init_channeldef();
    init_log3();
    init_scale();
    init_timeunit();
    init_util();
    init_channel();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/parse.js
function parseScales(model, { ignoreRange } = {}) {
  parseScaleCore(model);
  parseScaleDomain2(model);
  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {
    parseScaleProperty(model, prop);
  }
  if (!ignoreRange) {
    parseScaleRange2(model);
  }
}
function parseScaleCore(model) {
  if (isUnitModel(model)) {
    model.component.scales = parseUnitScaleCore(model);
  } else {
    model.component.scales = parseNonUnitScaleCore(model);
  }
}
function parseUnitScaleCore(model) {
  const { encoding, mark } = model;
  return SCALE_CHANNELS.reduce((scaleComponents, channel) => {
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {
      return scaleComponents;
    }
    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef["scale"];
    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {
      specifiedScale = specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : {};
      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, mark);
      scaleComponents[channel] = new ScaleComponent(model.scaleName(channel + "", true), {
        value: sType,
        explicit: specifiedScale.type === sType
      });
    }
    return scaleComponents;
  }, {});
}
function parseNonUnitScaleCore(model) {
  var _a2;
  const scaleComponents = model.component.scales = {};
  const scaleTypeWithExplicitIndex = {};
  const resolve2 = model.component.resolve;
  for (const child of model.children) {
    parseScaleCore(child);
    for (const channel of keys4(child.component.scales)) {
      resolve2.scale[channel] = (_a2 = resolve2.scale[channel]) !== null && _a2 !== void 0 ? _a2 : defaultScaleResolve(channel, model);
      if (resolve2.scale[channel] === "shared") {
        const explicitScaleType = scaleTypeWithExplicitIndex[channel];
        const childScaleType = child.component.scales[channel].getWithExplicit("type");
        if (explicitScaleType) {
          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {
            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, "type", "scale", scaleTypeTieBreaker);
          } else {
            resolve2.scale[channel] = "independent";
            delete scaleTypeWithExplicitIndex[channel];
          }
        } else {
          scaleTypeWithExplicitIndex[channel] = childScaleType;
        }
      }
    }
  }
  for (const channel of keys4(scaleTypeWithExplicitIndex)) {
    const name4 = model.scaleName(channel, true);
    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];
    scaleComponents[channel] = new ScaleComponent(name4, typeWithExplicit);
    for (const child of model.children) {
      const childScale = child.component.scales[channel];
      if (childScale) {
        child.renameScale(childScale.get("name"), name4);
        childScale.merged = true;
      }
    }
  }
  return scaleComponents;
}
var scaleTypeTieBreaker;
var init_parse6 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/scale/parse.js"() {
    init_channel();
    init_channeldef();
    init_mark();
    init_scale();
    init_type();
    init_util();
    init_model();
    init_resolve();
    init_split();
    init_component5();
    init_domain();
    init_properties3();
    init_type2();
    scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/model.js
function isUnitModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "unit";
}
function isFacetModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "facet";
}
function isConcatModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "concat";
}
function isLayerModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "layer";
}
var NameMap, Model, ModelWithField;
var init_model = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/model.js"() {
    init_tslib_es6();
    init_channel();
    init_channeldef();
    init_encoding();
    init_log3();
    init_scale();
    init_spec();
    init_base2();
    init_title();
    init_transform6();
    init_util();
    init_vega_schema();
    init_assemble2();
    init_common();
    init_assemble3();
    init_component();
    init_assemble4();
    init_component2();
    init_assemble5();
    init_parse4();
    init_assemble6();
    init_parse5();
    init_assemble7();
    init_domain();
    init_parse6();
    init_split();
    NameMap = class {
      constructor() {
        this.nameMap = {};
      }
      rename(oldName, newName) {
        this.nameMap[oldName] = newName;
      }
      has(name4) {
        return this.nameMap[name4] !== void 0;
      }
      get(name4) {
        while (this.nameMap[name4] && name4 !== this.nameMap[name4]) {
          name4 = this.nameMap[name4];
        }
        return name4;
      }
    };
    Model = class {
      constructor(spec, type4, parent, parentGivenName, config, resolve2, view) {
        var _a2, _b;
        this.type = type4;
        this.parent = parent;
        this.config = config;
        this.view = view;
        this.children = [];
        this.correctDataNames = (mark) => {
          if (mark.from && mark.from.data) {
            mark.from.data = this.lookupDataSource(mark.from.data);
          }
          if (mark.from && mark.from.facet && mark.from.facet.data) {
            mark.from.facet.data = this.lookupDataSource(mark.from.facet.data);
          }
          return mark;
        };
        this.parent = parent;
        this.config = config;
        this.name = (_a2 = spec.name) !== null && _a2 !== void 0 ? _a2 : parentGivenName;
        this.title = isText(spec.title) ? { text: spec.title } : spec.title;
        this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();
        this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();
        this.signalNameMap = parent ? parent.signalNameMap : new NameMap();
        this.data = spec.data;
        this.description = spec.description;
        this.transforms = normalizeTransform((_b = spec.transform) !== null && _b !== void 0 ? _b : []);
        this.layout = type4 === "layer" || type4 === "unit" ? {} : extractCompositionLayout(spec, type4, config);
        this.component = {
          data: {
            sources: parent ? parent.component.data.sources : [],
            outputNodes: parent ? parent.component.data.outputNodes : {},
            outputNodeRefCounts: parent ? parent.component.data.outputNodeRefCounts : {},
            isFaceted: isFacetSpec(spec) || parent && parent.component.data.isFaceted && spec.data === void 0
          },
          layoutSize: new Split(),
          layoutHeaders: { row: {}, column: {}, facet: {} },
          mark: null,
          resolve: Object.assign({ scale: {}, axis: {}, legend: {} }, resolve2 ? duplicate(resolve2) : {}),
          selection: null,
          scales: null,
          projection: null,
          axes: {},
          legends: {}
        };
      }
      get width() {
        return this.getSizeSignalRef("width");
      }
      get height() {
        return this.getSizeSignalRef("height");
      }
      parse() {
        this.parseScale();
        this.parseLayoutSize();
        this.renameTopLevelLayoutSizeSignal();
        this.parseSelections();
        this.parseProjection();
        this.parseData();
        this.parseAxesAndHeaders();
        this.parseLegends();
        this.parseMarkGroup();
      }
      parseScale() {
        parseScales(this);
      }
      parseProjection() {
        parseProjection2(this);
      }
      renameTopLevelLayoutSizeSignal() {
        if (this.getName("width") !== "width") {
          this.renameSignal(this.getName("width"), "width");
        }
        if (this.getName("height") !== "height") {
          this.renameSignal(this.getName("height"), "height");
        }
      }
      parseLegends() {
        parseLegend2(this);
      }
      assembleGroupStyle() {
        var _a2, _b;
        if (this.type === "unit" || this.type === "layer") {
          return (_b = (_a2 = this.view) === null || _a2 === void 0 ? void 0 : _a2.style) !== null && _b !== void 0 ? _b : "cell";
        }
        return void 0;
      }
      assembleEncodeFromView(view) {
        const { style: _ } = view, baseView = __rest(view, ["style"]);
        const e3 = {};
        for (const property2 of keys4(baseView)) {
          const value4 = baseView[property2];
          if (value4 !== void 0) {
            e3[property2] = signalOrValueRef(value4);
          }
        }
        return e3;
      }
      assembleGroupEncodeEntry(isTopLevel) {
        let encodeEntry2 = {};
        if (this.view) {
          encodeEntry2 = this.assembleEncodeFromView(this.view);
        }
        if (!isTopLevel) {
          if (this.description) {
            encodeEntry2["description"] = signalOrValueRef(this.description);
          }
          if (this.type === "unit" || this.type === "layer") {
            return Object.assign({ width: this.getSizeSignalRef("width"), height: this.getSizeSignalRef("height") }, encodeEntry2 !== null && encodeEntry2 !== void 0 ? encodeEntry2 : {});
          }
        }
        return isEmpty(encodeEntry2) ? void 0 : encodeEntry2;
      }
      assembleLayout() {
        if (!this.layout) {
          return void 0;
        }
        const _a2 = this.layout, { spacing } = _a2, layout = __rest(_a2, ["spacing"]);
        const { component, config } = this;
        const titleBand = assembleLayoutTitleBand(component.layoutHeaders, config);
        return Object.assign(Object.assign(Object.assign({ padding: spacing }, this.assembleDefaultLayout()), layout), titleBand ? { titleBand } : {});
      }
      assembleDefaultLayout() {
        return {};
      }
      assembleHeaderMarks() {
        const { layoutHeaders: layoutHeaders2 } = this.component;
        let headerMarks = [];
        for (const channel of FACET_CHANNELS) {
          if (layoutHeaders2[channel].title) {
            headerMarks.push(assembleTitleGroup(this, channel));
          }
        }
        for (const channel of HEADER_CHANNELS) {
          headerMarks = headerMarks.concat(assembleHeaderGroups(this, channel));
        }
        return headerMarks;
      }
      assembleAxes() {
        return assembleAxes(this.component.axes, this.config);
      }
      assembleLegends() {
        return assembleLegends(this);
      }
      assembleProjections() {
        return assembleProjections(this);
      }
      assembleTitle() {
        var _a2, _b, _c2;
        const _d2 = (_a2 = this.title) !== null && _a2 !== void 0 ? _a2 : {}, { encoding } = _d2, titleNoEncoding = __rest(_d2, ["encoding"]);
        const title2 = Object.assign(Object.assign(Object.assign({}, extractTitleConfig(this.config.title).nonMark), titleNoEncoding), encoding ? { encode: { update: encoding } } : {});
        if (title2.text) {
          if (contains2(["unit", "layer"], this.type)) {
            if (contains2(["middle", void 0], title2.anchor)) {
              title2.frame = (_b = title2.frame) !== null && _b !== void 0 ? _b : "group";
            }
          } else {
            title2.anchor = (_c2 = title2.anchor) !== null && _c2 !== void 0 ? _c2 : "start";
          }
          return isEmpty(title2) ? void 0 : title2;
        }
        return void 0;
      }
      assembleGroup(signals = []) {
        const group6 = {};
        signals = signals.concat(this.assembleSignals());
        if (signals.length > 0) {
          group6.signals = signals;
        }
        const layout = this.assembleLayout();
        if (layout) {
          group6.layout = layout;
        }
        group6.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
        const scales3 = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];
        if (scales3.length > 0) {
          group6.scales = scales3;
        }
        const axes = this.assembleAxes();
        if (axes.length > 0) {
          group6.axes = axes;
        }
        const legends = this.assembleLegends();
        if (legends.length > 0) {
          group6.legends = legends;
        }
        return group6;
      }
      getName(text5) {
        return varName((this.name ? this.name + "_" : "") + text5);
      }
      requestDataName(name4) {
        var _a2;
        const fullName = this.getName(name4);
        const refCounts = this.component.data.outputNodeRefCounts;
        refCounts[fullName] = ((_a2 = refCounts[fullName]) !== null && _a2 !== void 0 ? _a2 : 0) + 1;
        return fullName;
      }
      getSizeSignalRef(layoutSizeType) {
        if (isFacetModel(this.parent)) {
          const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
          const channel = getPositionScaleChannel(sizeType);
          const scaleComponent = this.component.scales[channel];
          if (scaleComponent && !scaleComponent.merged) {
            const type4 = scaleComponent.get("type");
            const range7 = scaleComponent.get("range");
            if (hasDiscreteDomain(type4) && isVgRangeStep(range7)) {
              const scaleName = scaleComponent.get("name");
              const domain4 = assembleDomain(this, channel);
              const field4 = getFieldFromDomain(domain4);
              if (field4) {
                const fieldRef2 = vgField({ aggregate: "distinct", field: field4 }, { expr: "datum" });
                return {
                  signal: sizeExpr(scaleName, scaleComponent, fieldRef2)
                };
              } else {
                warn2(`Unknown field for ${channel}. Cannot calculate view size.`);
                return null;
              }
            }
          }
        }
        return {
          signal: this.signalNameMap.get(this.getName(layoutSizeType))
        };
      }
      lookupDataSource(name4) {
        const node = this.component.data.outputNodes[name4];
        if (!node) {
          return name4;
        }
        return node.getSource();
      }
      getSignalName(oldSignalName) {
        return this.signalNameMap.get(oldSignalName);
      }
      renameSignal(oldName, newName) {
        this.signalNameMap.rename(oldName, newName);
      }
      renameScale(oldName, newName) {
        this.scaleNameMap.rename(oldName, newName);
      }
      renameProjection(oldName, newName) {
        this.projectionNameMap.rename(oldName, newName);
      }
      scaleName(originalScaleName, parse8) {
        if (parse8) {
          return this.getName(originalScaleName);
        }
        if (isChannel(originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName] || this.scaleNameMap.has(this.getName(originalScaleName))) {
          return this.scaleNameMap.get(this.getName(originalScaleName));
        }
        return void 0;
      }
      projectionName(parse8) {
        if (parse8) {
          return this.getName("projection");
        }
        if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) {
          return this.projectionNameMap.get(this.getName("projection"));
        }
        return void 0;
      }
      getScaleComponent(channel) {
        if (!this.component.scales) {
          throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
        }
        const localScaleComponent = this.component.scales[channel];
        if (localScaleComponent && !localScaleComponent.merged) {
          return localScaleComponent;
        }
        return this.parent ? this.parent.getScaleComponent(channel) : void 0;
      }
      getSelectionComponent(variableName, origName) {
        let sel = this.component.selection[variableName];
        if (!sel && this.parent) {
          sel = this.parent.getSelectionComponent(variableName, origName);
        }
        if (!sel) {
          throw new Error(message_exports.selectionNotFound(origName));
        }
        return sel;
      }
      hasAxisOrientSignalRef() {
        var _a2, _b;
        return ((_a2 = this.component.axes.x) === null || _a2 === void 0 ? void 0 : _a2.some((a4) => a4.hasOrientSignalRef())) || ((_b = this.component.axes.y) === null || _b === void 0 ? void 0 : _b.some((a4) => a4.hasOrientSignalRef()));
      }
    };
    ModelWithField = class extends Model {
      vgField(channel, opt = {}) {
        const fieldDef = this.fieldDef(channel);
        if (!fieldDef) {
          return void 0;
        }
        return vgField(fieldDef, opt);
      }
      reduceFieldDef(f, init2) {
        return reduce4(this.getMapping(), (acc, cd, c2) => {
          const fieldDef = getFieldDef(cd);
          if (fieldDef) {
            return f(acc, fieldDef, c2);
          }
          return acc;
        }, init2);
      }
      forEachFieldDef(f, t) {
        forEach(this.getMapping(), (cd, c2) => {
          const fieldDef = getFieldDef(cd);
          if (fieldDef) {
            f(fieldDef, c2);
          }
        }, t);
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/density.js
var DensityTransformNode;
var init_density = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/density.js"() {
    init_tslib_es6();
    init_util();
    init_dataflow();
    DensityTransformNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        var _a2, _b, _c2;
        super(parent);
        this.transform = transform4;
        this.transform = duplicate(transform4);
        const specifiedAs = (_a2 = this.transform.as) !== null && _a2 !== void 0 ? _a2 : [void 0, void 0];
        this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "value", (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : "density"];
      }
      clone() {
        return new DensityTransformNode(null, duplicate(this.transform));
      }
      dependentFields() {
        var _a2;
        return /* @__PURE__ */ new Set([this.transform.density, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `DensityTransform ${hash(this.transform)}`;
      }
      assemble() {
        const _a2 = this.transform, { density } = _a2, rest = __rest(_a2, ["density"]);
        const result = Object.assign({ type: "kde", field: density }, rest);
        return result;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/filterinvalid.js
var FilterInvalidNode;
var init_filterinvalid = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/filterinvalid.js"() {
    init_channel();
    init_channeldef();
    init_mark();
    init_scale();
    init_util();
    init_common();
    init_dataflow();
    FilterInvalidNode = class extends DataFlowNode {
      constructor(parent, filter6) {
        super(parent);
        this.filter = filter6;
      }
      clone() {
        return new FilterInvalidNode(null, Object.assign({}, this.filter));
      }
      static make(parent, model) {
        const { config, mark, markDef } = model;
        const invalid = getMarkPropOrConfig("invalid", markDef, config);
        if (invalid !== "filter") {
          return null;
        }
        const filter6 = model.reduceFieldDef((aggregator, fieldDef, channel) => {
          const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);
          if (scaleComponent) {
            const scaleType2 = scaleComponent.get("type");
            if (hasContinuousDomain(scaleType2) && fieldDef.aggregate !== "count" && !isPathMark(mark)) {
              aggregator[fieldDef.field] = fieldDef;
            }
          }
          return aggregator;
        }, {});
        if (!keys4(filter6).length) {
          return null;
        }
        return new FilterInvalidNode(parent, filter6);
      }
      dependentFields() {
        return new Set(keys4(this.filter));
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      hash() {
        return `FilterInvalid ${hash(this.filter)}`;
      }
      assemble() {
        const filters3 = keys4(this.filter).reduce((vegaFilters, field4) => {
          const fieldDef = this.filter[field4];
          const ref2 = vgField(fieldDef, { expr: "datum" });
          if (fieldDef !== null) {
            if (fieldDef.type === "temporal") {
              vegaFilters.push(`(isDate(${ref2}) || (isValid(${ref2}) && isFinite(+${ref2})))`);
            } else if (fieldDef.type === "quantitative") {
              vegaFilters.push(`isValid(${ref2})`);
              vegaFilters.push(`isFinite(+${ref2})`);
            } else {
            }
          }
          return vegaFilters;
        }, []);
        return filters3.length > 0 ? {
          type: "filter",
          expr: filters3.join(" && ")
        } : null;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/flatten.js
var FlattenTransformNode;
var init_flatten = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/flatten.js"() {
    init_util();
    init_dataflow();
    FlattenTransformNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        super(parent);
        this.transform = transform4;
        this.transform = duplicate(transform4);
        const { flatten: flatten2, as = [] } = this.transform;
        this.transform.as = flatten2.map((f, i) => {
          var _a2;
          return (_a2 = as[i]) !== null && _a2 !== void 0 ? _a2 : f;
        });
      }
      clone() {
        return new FlattenTransformNode(this.parent, duplicate(this.transform));
      }
      dependentFields() {
        return new Set(this.transform.flatten);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `FlattenTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { flatten: fields, as } = this.transform;
        const result = {
          type: "flatten",
          fields,
          as
        };
        return result;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/fold.js
var FoldTransformNode;
var init_fold = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/fold.js"() {
    init_util();
    init_dataflow();
    FoldTransformNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        var _a2, _b, _c2;
        super(parent);
        this.transform = transform4;
        this.transform = duplicate(transform4);
        const specifiedAs = (_a2 = this.transform.as) !== null && _a2 !== void 0 ? _a2 : [void 0, void 0];
        this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "key", (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : "value"];
      }
      clone() {
        return new FoldTransformNode(null, duplicate(this.transform));
      }
      dependentFields() {
        return new Set(this.transform.fold);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `FoldTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { fold, as } = this.transform;
        const result = {
          type: "fold",
          fields: fold,
          as
        };
        return result;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/geojson.js
var GeoJSONNode;
var init_geojson = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/geojson.js"() {
    init_vega_util();
    init_channel();
    init_channeldef();
    init_type();
    init_util();
    init_dataflow();
    GeoJSONNode = class extends DataFlowNode {
      constructor(parent, fields, geojson, signal) {
        super(parent);
        this.fields = fields;
        this.geojson = geojson;
        this.signal = signal;
      }
      clone() {
        return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);
      }
      static parseAll(parent, model) {
        if (model.component.projection && !model.component.projection.isFit) {
          return parent;
        }
        let geoJsonCounter = 0;
        for (const coordinates of [
          [LONGITUDE, LATITUDE],
          [LONGITUDE2, LATITUDE2]
        ]) {
          const pair = coordinates.map((channel) => {
            const def3 = getFieldOrDatumDef(model.encoding[channel]);
            return isFieldDef(def3) ? def3.field : isDatumDef(def3) ? { expr: `${def3.datum}` } : isValueDef(def3) ? { expr: `${def3["value"]}` } : void 0;
          });
          if (pair[0] || pair[1]) {
            parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));
          }
        }
        if (model.channelHasField(SHAPE)) {
          const fieldDef = model.typedFieldDef(SHAPE);
          if (fieldDef.type === GEOJSON) {
            parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));
          }
        }
        return parent;
      }
      dependentFields() {
        var _a2;
        const fields = ((_a2 = this.fields) !== null && _a2 !== void 0 ? _a2 : []).filter(isString_default);
        return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...fields]);
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      hash() {
        return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;
      }
      assemble() {
        return Object.assign(Object.assign(Object.assign({ type: "geojson" }, this.fields ? { fields: this.fields } : {}), this.geojson ? { geojson: this.geojson } : {}), { signal: this.signal });
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/geopoint.js
var GeoPointNode;
var init_geopoint = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/geopoint.js"() {
    init_vega_util();
    init_channel();
    init_channeldef();
    init_util();
    init_dataflow();
    GeoPointNode = class extends DataFlowNode {
      constructor(parent, projection3, fields, as) {
        super(parent);
        this.projection = projection3;
        this.fields = fields;
        this.as = as;
      }
      clone() {
        return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));
      }
      static parseAll(parent, model) {
        if (!model.projectionName()) {
          return parent;
        }
        for (const coordinates of [
          [LONGITUDE, LATITUDE],
          [LONGITUDE2, LATITUDE2]
        ]) {
          const pair = coordinates.map((channel) => {
            const def3 = getFieldOrDatumDef(model.encoding[channel]);
            return isFieldDef(def3) ? def3.field : isDatumDef(def3) ? { expr: `${def3.datum}` } : isValueDef(def3) ? { expr: `${def3["value"]}` } : void 0;
          });
          const suffix = coordinates[0] === LONGITUDE2 ? "2" : "";
          if (pair[0] || pair[1]) {
            parent = new GeoPointNode(parent, model.projectionName(), pair, [
              model.getName("x" + suffix),
              model.getName("y" + suffix)
            ]);
          }
        }
        return parent;
      }
      dependentFields() {
        return new Set(this.fields.filter(isString_default));
      }
      producedFields() {
        return new Set(this.as);
      }
      hash() {
        return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;
      }
      assemble() {
        return {
          type: "geopoint",
          projection: this.projection,
          fields: this.fields,
          as: this.as
        };
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/impute.js
var ImputeNode;
var init_impute = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/impute.js"() {
    init_channeldef();
    init_encoding();
    init_transform6();
    init_util();
    init_dataflow();
    ImputeNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        super(parent);
        this.transform = transform4;
      }
      clone() {
        return new ImputeNode(null, duplicate(this.transform));
      }
      dependentFields() {
        var _a2;
        return /* @__PURE__ */ new Set([this.transform.impute, this.transform.key, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
      }
      producedFields() {
        return /* @__PURE__ */ new Set([this.transform.impute]);
      }
      processSequence(keyvals) {
        const { start = 0, stop: stop2, step } = keyvals;
        const result = [start, stop2, ...step ? [step] : []].join(",");
        return { signal: `sequence(${result})` };
      }
      static makeFromTransform(parent, imputeTransform) {
        return new ImputeNode(parent, imputeTransform);
      }
      static makeFromEncoding(parent, model) {
        const encoding = model.encoding;
        const xDef = encoding.x;
        const yDef = encoding.y;
        if (isFieldDef(xDef) && isFieldDef(yDef)) {
          const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : void 0;
          if (imputedChannel === void 0) {
            return void 0;
          }
          const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : void 0;
          const { method: method3, value: value4, frame: frame2, keyvals } = imputedChannel.impute;
          const groupbyFields = pathGroupingFields(model.mark, encoding);
          return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ impute: imputedChannel.field, key: keyChannel.field }, method3 ? { method: method3 } : {}), value4 !== void 0 ? { value: value4 } : {}), frame2 ? { frame: frame2 } : {}), keyvals !== void 0 ? { keyvals } : {}), groupbyFields.length ? { groupby: groupbyFields } : {}));
        }
        return null;
      }
      hash() {
        return `Impute ${hash(this.transform)}`;
      }
      assemble() {
        const { impute, key: key3, keyvals, method: method3, groupby, value: value4, frame: frame2 = [null, null] } = this.transform;
        const imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({ type: "impute", field: impute, key: key3 }, keyvals ? { keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals } : {}), { method: "value" }), groupby ? { groupby } : {}), { value: !method3 || method3 === "value" ? value4 : null });
        if (method3 && method3 !== "value") {
          const deriveNewField = Object.assign({ type: "window", as: [`imputed_${impute}_value`], ops: [method3], fields: [impute], frame: frame2, ignorePeers: false }, groupby ? { groupby } : {});
          const replaceOriginal = {
            type: "formula",
            expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,
            as: impute
          };
          return [imputeTransform, deriveNewField, replaceOriginal];
        } else {
          return [imputeTransform];
        }
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/loess.js
var LoessTransformNode;
var init_loess = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/loess.js"() {
    init_tslib_es6();
    init_util();
    init_dataflow();
    LoessTransformNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        var _a2, _b, _c2;
        super(parent);
        this.transform = transform4;
        this.transform = duplicate(transform4);
        const specifiedAs = (_a2 = this.transform.as) !== null && _a2 !== void 0 ? _a2 : [void 0, void 0];
        this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : transform4.on, (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : transform4.loess];
      }
      clone() {
        return new LoessTransformNode(null, duplicate(this.transform));
      }
      dependentFields() {
        var _a2;
        return /* @__PURE__ */ new Set([this.transform.loess, this.transform.on, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `LoessTransform ${hash(this.transform)}`;
      }
      assemble() {
        const _a2 = this.transform, { loess: loess2, on: on2 } = _a2, rest = __rest(_a2, ["loess", "on"]);
        const result = Object.assign({ type: "loess", x: on2, y: loess2 }, rest);
        return result;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/lookup.js
var LookupNode;
var init_lookup = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/lookup.js"() {
    init_vega_util();
    init_log3();
    init_transform6();
    init_util();
    init_dataflow();
    init_parse9();
    init_source();
    LookupNode = class extends DataFlowNode {
      constructor(parent, transform4, secondary) {
        super(parent);
        this.transform = transform4;
        this.secondary = secondary;
      }
      clone() {
        return new LookupNode(null, duplicate(this.transform), this.secondary);
      }
      static make(parent, model, transform4, counter) {
        const sources = model.component.data.sources;
        const { from } = transform4;
        let fromOutputNode = null;
        if (isLookupData(from)) {
          let fromSource = findSource(from.data, sources);
          if (!fromSource) {
            fromSource = new SourceNode(from.data);
            sources.push(fromSource);
          }
          const fromOutputName = model.getName(`lookup_${counter}`);
          fromOutputNode = new OutputNode(fromSource, fromOutputName, "lookup", model.component.data.outputNodeRefCounts);
          model.component.data.outputNodes[fromOutputName] = fromOutputNode;
        } else if (isLookupSelection(from)) {
          const selName = from.selection;
          transform4 = Object.assign({ as: selName }, transform4);
          fromOutputNode = model.getSelectionComponent(varName(selName), selName).materialized;
          if (!fromOutputNode) {
            throw new Error(message_exports.noSameUnitLookup(selName));
          }
        }
        return new LookupNode(parent, transform4, fromOutputNode.getSource());
      }
      dependentFields() {
        return /* @__PURE__ */ new Set([this.transform.lookup]);
      }
      producedFields() {
        return new Set(this.transform.as ? array_default6(this.transform.as) : this.transform.from.fields);
      }
      hash() {
        return `Lookup ${hash({ transform: this.transform, secondary: this.secondary })}`;
      }
      assemble() {
        let foreign;
        if (this.transform.from.fields) {
          foreign = Object.assign({ values: this.transform.from.fields }, this.transform.as ? { as: array_default6(this.transform.as) } : {});
        } else {
          let asName = this.transform.as;
          if (!isString_default(asName)) {
            warn2(message_exports.NO_FIELDS_NEEDS_AS);
            asName = "_lookup";
          }
          foreign = {
            as: [asName]
          };
        }
        return Object.assign(Object.assign({ type: "lookup", from: this.secondary, key: this.transform.from.key, fields: [this.transform.lookup] }, foreign), this.transform.default ? { default: this.transform.default } : {});
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/quantile.js
var QuantileTransformNode;
var init_quantile6 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/quantile.js"() {
    init_tslib_es6();
    init_util();
    init_dataflow();
    QuantileTransformNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        var _a2, _b, _c2;
        super(parent);
        this.transform = transform4;
        this.transform = duplicate(transform4);
        const specifiedAs = (_a2 = this.transform.as) !== null && _a2 !== void 0 ? _a2 : [void 0, void 0];
        this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "prob", (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : "value"];
      }
      clone() {
        return new QuantileTransformNode(null, duplicate(this.transform));
      }
      dependentFields() {
        var _a2;
        return /* @__PURE__ */ new Set([this.transform.quantile, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `QuantileTransform ${hash(this.transform)}`;
      }
      assemble() {
        const _a2 = this.transform, { quantile: quantile6 } = _a2, rest = __rest(_a2, ["quantile"]);
        const result = Object.assign({ type: "quantile", field: quantile6 }, rest);
        return result;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/regression.js
var RegressionTransformNode;
var init_regression = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/regression.js"() {
    init_tslib_es6();
    init_util();
    init_dataflow();
    RegressionTransformNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        var _a2, _b, _c2;
        super(parent);
        this.transform = transform4;
        this.transform = duplicate(transform4);
        const specifiedAs = (_a2 = this.transform.as) !== null && _a2 !== void 0 ? _a2 : [void 0, void 0];
        this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : transform4.on, (_c2 = specifiedAs[1]) !== null && _c2 !== void 0 ? _c2 : transform4.regression];
      }
      clone() {
        return new RegressionTransformNode(null, duplicate(this.transform));
      }
      dependentFields() {
        var _a2;
        return /* @__PURE__ */ new Set([this.transform.regression, this.transform.on, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
      }
      producedFields() {
        return new Set(this.transform.as);
      }
      hash() {
        return `RegressionTransform ${hash(this.transform)}`;
      }
      assemble() {
        const _a2 = this.transform, { regression, on: on2 } = _a2, rest = __rest(_a2, ["regression", "on"]);
        const result = Object.assign({ type: "regression", x: on2, y: regression }, rest);
        return result;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/pivot.js
var PivotTransformNode;
var init_pivot = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/pivot.js"() {
    init_util();
    init_dataflow();
    PivotTransformNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        super(parent);
        this.transform = transform4;
      }
      clone() {
        return new PivotTransformNode(null, duplicate(this.transform));
      }
      addDimensions(fields) {
        var _a2;
        this.transform.groupby = unique(((_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []).concat(fields), (d) => d);
      }
      producedFields() {
        return void 0;
      }
      dependentFields() {
        var _a2;
        return /* @__PURE__ */ new Set([this.transform.pivot, this.transform.value, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
      }
      hash() {
        return `PivotTransform ${hash(this.transform)}`;
      }
      assemble() {
        const { pivot, value: value4, groupby, limit, op } = this.transform;
        return Object.assign(Object.assign(Object.assign({ type: "pivot", field: pivot, value: value4 }, limit !== void 0 ? { limit } : {}), op !== void 0 ? { op } : {}), groupby !== void 0 ? { groupby } : {});
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/sample.js
var SampleTransformNode;
var init_sample = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/sample.js"() {
    init_util();
    init_dataflow();
    SampleTransformNode = class extends DataFlowNode {
      constructor(parent, transform4) {
        super(parent);
        this.transform = transform4;
      }
      clone() {
        return new SampleTransformNode(null, duplicate(this.transform));
      }
      dependentFields() {
        return /* @__PURE__ */ new Set();
      }
      producedFields() {
        return /* @__PURE__ */ new Set();
      }
      hash() {
        return `SampleTransform ${hash(this.transform)}`;
      }
      assemble() {
        return {
          type: "sample",
          size: this.transform.sample
        };
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/assemble.js
function makeWalkTree(data3) {
  let datasetIndex = 0;
  function walkTree(node, dataSource) {
    var _a2;
    if (node instanceof SourceNode) {
      if (!node.isGenerator && !isUrlData(node.data)) {
        data3.push(dataSource);
        const newData = {
          name: null,
          source: dataSource.name,
          transform: []
        };
        dataSource = newData;
      }
    }
    if (node instanceof ParseNode) {
      if (node.parent instanceof SourceNode && !dataSource.source) {
        dataSource.format = Object.assign(Object.assign({}, (_a2 = dataSource.format) !== null && _a2 !== void 0 ? _a2 : {}), { parse: node.assembleFormatParse() });
        dataSource.transform.push(...node.assembleTransforms(true));
      } else {
        dataSource.transform.push(...node.assembleTransforms());
      }
    }
    if (node instanceof FacetNode) {
      if (!dataSource.name) {
        dataSource.name = `data_${datasetIndex++}`;
      }
      if (!dataSource.source || dataSource.transform.length > 0) {
        data3.push(dataSource);
        node.data = dataSource.name;
      } else {
        node.data = dataSource.source;
      }
      for (const d of node.assemble()) {
        data3.push(d);
      }
      return;
    }
    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof GeoJSONNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode) {
      dataSource.transform.push(node.assemble());
    }
    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode) {
      dataSource.transform.push(...node.assemble());
    }
    if (node instanceof OutputNode) {
      if (dataSource.source && dataSource.transform.length === 0) {
        node.setSource(dataSource.source);
      } else if (node.parent instanceof OutputNode) {
        node.setSource(dataSource.name);
      } else {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        node.setSource(dataSource.name);
        if (node.numChildren() === 1) {
          data3.push(dataSource);
          const newData = {
            name: null,
            source: dataSource.name,
            transform: []
          };
          dataSource = newData;
        }
      }
    }
    switch (node.numChildren()) {
      case 0:
        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {
          data3.push(dataSource);
        }
        break;
      case 1:
        walkTree(node.children[0], dataSource);
        break;
      default: {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        let source5 = dataSource.name;
        if (!dataSource.source || dataSource.transform.length > 0) {
          data3.push(dataSource);
        } else {
          source5 = dataSource.source;
        }
        for (const child of node.children) {
          const newData = {
            name: null,
            source: source5,
            transform: []
          };
          walkTree(child, newData);
        }
        break;
      }
    }
  }
  return walkTree;
}
function assembleFacetData(root2) {
  const data3 = [];
  const walkTree = makeWalkTree(data3);
  for (const child of root2.children) {
    walkTree(child, {
      source: root2.name,
      name: null,
      transform: []
    });
  }
  return data3;
}
function assembleRootData(dataComponent, datasets) {
  var _a2, _b;
  const data3 = [];
  const walkTree = makeWalkTree(data3);
  let sourceIndex = 0;
  for (const root2 of dataComponent.sources) {
    if (!root2.hasName()) {
      root2.dataName = `source_${sourceIndex++}`;
    }
    const newData = root2.assemble();
    walkTree(root2, newData);
  }
  for (const d of data3) {
    if (d.transform.length === 0) {
      delete d.transform;
    }
  }
  let whereTo = 0;
  for (const [i, d] of data3.entries()) {
    if (((_a2 = d.transform) !== null && _a2 !== void 0 ? _a2 : []).length === 0 && !d.source) {
      data3.splice(whereTo++, 0, data3.splice(i, 1)[0]);
    }
  }
  for (const d of data3) {
    for (const t of (_b = d.transform) !== null && _b !== void 0 ? _b : []) {
      if (t.type === "lookup") {
        t.from = dataComponent.outputNodes[t.from].getSource();
      }
    }
  }
  for (const d of data3) {
    if (d.name in datasets) {
      d.values = datasets[d.name];
    }
  }
  return data3;
}
var init_assemble8 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/assemble.js"() {
    init_data3();
    init_aggregate2();
    init_bin5();
    init_calculate();
    init_dataflow();
    init_density();
    init_facet2();
    init_filter4();
    init_filterinvalid();
    init_flatten();
    init_fold();
    init_formatparse();
    init_geojson();
    init_geopoint();
    init_graticule2();
    init_identifier();
    init_impute();
    init_joinaggregate();
    init_loess();
    init_lookup();
    init_quantile6();
    init_regression();
    init_pivot();
    init_sample();
    init_sequence();
    init_source();
    init_stack4();
    init_timeunit2();
    init_window();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/header/parse.js
function getHeaderType(orient3) {
  if (orient3 === "top" || orient3 === "left" || isSignalRef(orient3)) {
    return "header";
  }
  return "footer";
}
function parseFacetHeaders(model) {
  for (const channel of FACET_CHANNELS) {
    parseFacetHeader(model, channel);
  }
  mergeChildAxis(model, "x");
  mergeChildAxis(model, "y");
}
function parseFacetHeader(model, channel) {
  var _a2;
  const { facet, config, child, component } = model;
  if (model.channelHasField(channel)) {
    const fieldDef = facet[channel];
    const titleConfig = getHeaderProperty("title", null, config, channel);
    let title2 = title(fieldDef, config, {
      allowDisabling: true,
      includeDefault: titleConfig === void 0 || !!titleConfig
    });
    if (child.component.layoutHeaders[channel].title) {
      title2 = isArray_default(title2) ? title2.join(", ") : title2;
      title2 += " / " + child.component.layoutHeaders[channel].title;
      child.component.layoutHeaders[channel].title = null;
    }
    const labelOrient = getHeaderProperty("labelOrient", fieldDef, config, channel);
    const header = (_a2 = fieldDef.header) !== null && _a2 !== void 0 ? _a2 : {};
    const labels3 = getFirstDefined(header.labels, config.header.labels, true);
    const headerType = contains2(["bottom", "right"], labelOrient) ? "footer" : "header";
    component.layoutHeaders[channel] = {
      title: title2,
      facetFieldDef: fieldDef,
      [headerType]: channel === "facet" ? [] : [makeHeaderComponent(model, channel, labels3)]
    };
  }
}
function makeHeaderComponent(model, channel, labels3) {
  const sizeType = channel === "row" ? "height" : "width";
  return {
    labels: labels3,
    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : void 0,
    axes: []
  };
}
function mergeChildAxis(model, channel) {
  var _a2;
  const { child } = model;
  if (child.component.axes[channel]) {
    const { layoutHeaders: layoutHeaders2, resolve: resolve2 } = model.component;
    resolve2.axis[channel] = parseGuideResolve(resolve2, channel);
    if (resolve2.axis[channel] === "shared") {
      const headerChannel = channel === "x" ? "column" : "row";
      const layoutHeader = layoutHeaders2[headerChannel];
      for (const axisComponent of child.component.axes[channel]) {
        const headerType = getHeaderType(axisComponent.get("orient"));
        layoutHeader[headerType] = (_a2 = layoutHeader[headerType]) !== null && _a2 !== void 0 ? _a2 : [makeHeaderComponent(model, headerChannel, false)];
        const mainAxis = assembleAxis(axisComponent, "main", model.config, { header: true });
        if (mainAxis) {
          layoutHeader[headerType][0].axes.push(mainAxis);
        }
        axisComponent.mainExtracted = true;
      }
    } else {
    }
  }
}
var init_parse7 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/header/parse.js"() {
    init_vega_util();
    init_channel();
    init_channeldef();
    init_util();
    init_vega_schema();
    init_assemble2();
    init_resolve();
    init_common3();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/layoutsize/parse.js
function parseLayerLayoutSize(model) {
  parseChildrenLayoutSize(model);
  parseNonUnitLayoutSizeForChannel(model, "width");
  parseNonUnitLayoutSizeForChannel(model, "height");
}
function parseConcatLayoutSize(model) {
  parseChildrenLayoutSize(model);
  const widthType = model.layout.columns === 1 ? "width" : "childWidth";
  const heightType = model.layout.columns === void 0 ? "height" : "childHeight";
  parseNonUnitLayoutSizeForChannel(model, widthType);
  parseNonUnitLayoutSizeForChannel(model, heightType);
}
function parseChildrenLayoutSize(model) {
  for (const child of model.children) {
    child.parseLayoutSize();
  }
}
function parseNonUnitLayoutSizeForChannel(model, layoutSizeType) {
  const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
  const channel = getPositionScaleChannel(sizeType);
  const resolve2 = model.component.resolve;
  const layoutSizeCmpt = model.component.layoutSize;
  let mergedSize;
  for (const child of model.children) {
    const childSize = child.component.layoutSize.getWithExplicit(sizeType);
    const scaleResolve = resolve2.scale[channel];
    if (scaleResolve === "independent" && childSize.value === "step") {
      mergedSize = void 0;
      break;
    }
    if (mergedSize) {
      if (scaleResolve === "independent" && mergedSize.value !== childSize.value) {
        mergedSize = void 0;
        break;
      }
      mergedSize = mergeValuesWithExplicit(mergedSize, childSize, sizeType, "");
    } else {
      mergedSize = childSize;
    }
  }
  if (mergedSize) {
    for (const child of model.children) {
      model.renameSignal(child.getName(sizeType), model.getName(layoutSizeType));
      child.component.layoutSize.set(sizeType, "merged", false);
    }
    layoutSizeCmpt.setWithExplicit(layoutSizeType, mergedSize);
  } else {
    layoutSizeCmpt.setWithExplicit(layoutSizeType, {
      explicit: false,
      value: void 0
    });
  }
}
function parseUnitLayoutSize(model) {
  const { size, component } = model;
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (size[sizeType]) {
      const specifiedSize = size[sizeType];
      component.layoutSize.set(sizeType, isStep(specifiedSize) ? "step" : specifiedSize, true);
    } else {
      const defaultSize2 = defaultUnitSize(model, sizeType);
      component.layoutSize.set(sizeType, defaultSize2, false);
    }
  }
}
function defaultUnitSize(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const config = model.config;
  const scaleComponent = model.getScaleComponent(channel);
  if (scaleComponent) {
    const scaleType2 = scaleComponent.get("type");
    const range7 = scaleComponent.get("range");
    if (hasDiscreteDomain(scaleType2)) {
      const size = getViewConfigDiscreteSize(config.view, sizeType);
      if (isVgRangeStep(range7) || isStep(size)) {
        return "step";
      } else {
        return size;
      }
    } else {
      return getViewConfigContinuousSize(config.view, sizeType);
    }
  } else if (model.hasProjection || model.mark === "arc") {
    return getViewConfigContinuousSize(config.view, sizeType);
  } else {
    const size = getViewConfigDiscreteSize(config.view, sizeType);
    return isStep(size) ? size.step : size;
  }
}
var init_parse8 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/layoutsize/parse.js"() {
    init_channel();
    init_config();
    init_scale();
    init_base2();
    init_vega_schema();
    init_split();
    init_component2();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/facet.js
function facetSortFieldName(fieldDef, sort5, opt) {
  return vgField(sort5, Object.assign({ suffix: `by_${vgField(fieldDef)}` }, opt !== null && opt !== void 0 ? opt : {}));
}
var FacetModel;
var init_facet3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/facet.js"() {
    init_vega_util();
    init_bin4();
    init_channel();
    init_channeldef();
    init_encoding();
    init_log3();
    init_scale();
    init_sort5();
    init_facet();
    init_util();
    init_vega_schema();
    init_buildmodel();
    init_assemble8();
    init_calculate();
    init_parse9();
    init_assemble3();
    init_common3();
    init_component();
    init_parse7();
    init_parse8();
    init_model();
    init_domain();
    init_assemble();
    FacetModel = class extends ModelWithField {
      constructor(spec, parent, parentGivenName, config) {
        super(spec, "facet", parent, parentGivenName, config, spec.resolve);
        this.child = buildModel(spec.spec, this, this.getName("child"), void 0, config);
        this.children = [this.child];
        this.facet = this.initFacet(spec.facet, config);
      }
      initFacet(facet, config) {
        if (!isFacetMapping(facet)) {
          return { facet: initChannelDef(facet, "facet", config) };
        }
        return reduce4(facet, (normalizedFacet, fieldDef, channel) => {
          if (!contains2([ROW, COLUMN], channel)) {
            warn2(message_exports.incompatibleChannel(channel, "facet"));
            return normalizedFacet;
          }
          if (fieldDef.field === void 0) {
            warn2(message_exports.emptyFieldDef(fieldDef, channel));
            return normalizedFacet;
          }
          normalizedFacet[channel] = initChannelDef(fieldDef, channel, config);
          return normalizedFacet;
        }, {});
      }
      channelHasField(channel) {
        return !!this.facet[channel];
      }
      fieldDef(channel) {
        return this.facet[channel];
      }
      parseData() {
        this.component.data = parseData2(this);
        this.child.parseData();
      }
      parseLayoutSize() {
        parseChildrenLayoutSize(this);
      }
      parseSelections() {
        this.child.parseSelections();
        this.component.selection = this.child.component.selection;
      }
      parseMarkGroup() {
        this.child.parseMarkGroup();
      }
      parseAxesAndHeaders() {
        this.child.parseAxesAndHeaders();
        parseFacetHeaders(this);
      }
      assembleSelectionTopLevelSignals(signals) {
        return this.child.assembleSelectionTopLevelSignals(signals);
      }
      assembleSignals() {
        this.child.assembleSignals();
        return [];
      }
      assembleSelectionData(data3) {
        return this.child.assembleSelectionData(data3);
      }
      getHeaderLayoutMixins() {
        var _a2, _b, _c2;
        const layoutMixins = {};
        for (const channel of FACET_CHANNELS) {
          for (const headerType of HEADER_TYPES) {
            const layoutHeaderComponent = this.component.layoutHeaders[channel];
            const headerComponent = layoutHeaderComponent[headerType];
            const { facetFieldDef } = layoutHeaderComponent;
            if (facetFieldDef) {
              const titleOrient = getHeaderProperty("titleOrient", facetFieldDef, this.config, channel);
              if (contains2(["right", "bottom"], titleOrient)) {
                const headerChannel = getHeaderChannel(channel, titleOrient);
                layoutMixins.titleAnchor = (_a2 = layoutMixins.titleAnchor) !== null && _a2 !== void 0 ? _a2 : {};
                layoutMixins.titleAnchor[headerChannel] = "end";
              }
            }
            if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {
              const sizeType = channel === "row" ? "height" : "width";
              const bandType = headerType === "header" ? "headerBand" : "footerBand";
              if (channel !== "facet" && !this.child.component.layoutSize.get(sizeType)) {
                layoutMixins[bandType] = (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : {};
                layoutMixins[bandType][channel] = 0.5;
              }
              if (layoutHeaderComponent.title) {
                layoutMixins.offset = (_c2 = layoutMixins.offset) !== null && _c2 !== void 0 ? _c2 : {};
                layoutMixins.offset[channel === "row" ? "rowTitle" : "columnTitle"] = 10;
              }
            }
          }
        }
        return layoutMixins;
      }
      assembleDefaultLayout() {
        const { column, row } = this.facet;
        const columns = column ? this.columnDistinctSignal() : row ? 1 : void 0;
        let align2 = "all";
        if (!row && this.component.resolve.scale.x === "independent") {
          align2 = "none";
        } else if (!column && this.component.resolve.scale.y === "independent") {
          align2 = "none";
        }
        return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), columns ? { columns } : {}), { bounds: "full", align: align2 });
      }
      assembleLayoutSignals() {
        return this.child.assembleLayoutSignals();
      }
      columnDistinctSignal() {
        if (this.parent && this.parent instanceof FacetModel) {
          return void 0;
        } else {
          const facetLayoutDataName = this.getName("column_domain");
          return { signal: `length(data('${facetLayoutDataName}'))` };
        }
      }
      assembleGroup(signals) {
        if (this.parent && this.parent instanceof FacetModel) {
          return Object.assign(Object.assign({}, this.channelHasField("column") ? {
            encode: {
              update: {
                columns: { field: vgField(this.facet.column, { prefix: "distinct" }) }
              }
            }
          } : {}), super.assembleGroup(signals));
        }
        return super.assembleGroup(signals);
      }
      getCardinalityAggregateForChild() {
        const fields = [];
        const ops2 = [];
        const as = [];
        if (this.child instanceof FacetModel) {
          if (this.child.channelHasField("column")) {
            const field4 = vgField(this.child.facet.column);
            fields.push(field4);
            ops2.push("distinct");
            as.push(`distinct_${field4}`);
          }
        } else {
          for (const channel of POSITION_SCALE_CHANNELS) {
            const childScaleComponent = this.child.component.scales[channel];
            if (childScaleComponent && !childScaleComponent.merged) {
              const type4 = childScaleComponent.get("type");
              const range7 = childScaleComponent.get("range");
              if (hasDiscreteDomain(type4) && isVgRangeStep(range7)) {
                const domain4 = assembleDomain(this.child, channel);
                const field4 = getFieldFromDomain(domain4);
                if (field4) {
                  fields.push(field4);
                  ops2.push("distinct");
                  as.push(`distinct_${field4}`);
                } else {
                  warn2(`Unknown field for ${channel}. Cannot calculate view size.`);
                }
              }
            }
          }
        }
        return { fields, ops: ops2, as };
      }
      assembleFacet() {
        const { name: name4, data: data3 } = this.component.data.facetRoot;
        const { row, column } = this.facet;
        const { fields, ops: ops2, as } = this.getCardinalityAggregateForChild();
        const groupby = [];
        for (const channel of FACET_CHANNELS) {
          const fieldDef = this.facet[channel];
          if (fieldDef) {
            groupby.push(vgField(fieldDef));
            const { bin: bin5, sort: sort5 } = fieldDef;
            if (isBinning(bin5)) {
              groupby.push(vgField(fieldDef, { binSuffix: "end" }));
            }
            if (isSortField(sort5)) {
              const { field: field4, op = DEFAULT_SORT_OP } = sort5;
              const outputName = facetSortFieldName(fieldDef, sort5);
              if (row && column) {
                fields.push(outputName);
                ops2.push("max");
                as.push(outputName);
              } else {
                fields.push(field4);
                ops2.push(op);
                as.push(outputName);
              }
            } else if (isArray_default(sort5)) {
              const outputName = sortArrayIndexField(fieldDef, channel);
              fields.push(outputName);
              ops2.push("max");
              as.push(outputName);
            }
          }
        }
        const cross5 = !!row && !!column;
        return Object.assign({
          name: name4,
          data: data3,
          groupby
        }, cross5 || fields.length > 0 ? {
          aggregate: Object.assign(Object.assign({}, cross5 ? { cross: cross5 } : {}), fields.length ? { fields, ops: ops2, as } : {})
        } : {});
      }
      facetSortFields(channel) {
        const { facet } = this;
        const fieldDef = facet[channel];
        if (fieldDef) {
          if (isSortField(fieldDef.sort)) {
            return [facetSortFieldName(fieldDef, fieldDef.sort, { expr: "datum" })];
          } else if (isArray_default(fieldDef.sort)) {
            return [sortArrayIndexField(fieldDef, channel, { expr: "datum" })];
          }
          return [vgField(fieldDef, { expr: "datum" })];
        }
        return [];
      }
      facetSortOrder(channel) {
        const { facet } = this;
        const fieldDef = facet[channel];
        if (fieldDef) {
          const { sort: sort5 } = fieldDef;
          const order = (isSortField(sort5) ? sort5.order : !isArray_default(sort5) && sort5) || "ascending";
          return [order];
        }
        return [];
      }
      assembleLabelTitle() {
        const { facet, config } = this;
        if (facet.facet) {
          return assembleLabelTitle(facet.facet, "facet", config);
        }
        const ORTHOGONAL_ORIENT = {
          row: ["top", "bottom"],
          column: ["left", "right"]
        };
        for (const channel of HEADER_CHANNELS) {
          if (facet[channel]) {
            const labelOrient = getHeaderProperty("labelOrient", facet[channel], config, channel);
            if (contains2(ORTHOGONAL_ORIENT[channel], labelOrient)) {
              return assembleLabelTitle(facet[channel], channel, config);
            }
          }
        }
        return void 0;
      }
      assembleMarks() {
        const { child } = this;
        const facetRoot = this.component.data.facetRoot;
        const data3 = assembleFacetData(facetRoot);
        const encodeEntry2 = child.assembleGroupEncodeEntry(false);
        const title2 = this.assembleLabelTitle() || child.assembleTitle();
        const style3 = child.assembleGroupStyle();
        const markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: this.getName("cell"), type: "group" }, title2 ? { title: title2 } : {}), style3 ? { style: style3 } : {}), {
          from: {
            facet: this.assembleFacet()
          },
          sort: {
            field: FACET_CHANNELS.map((c2) => this.facetSortFields(c2)).flat(),
            order: FACET_CHANNELS.map((c2) => this.facetSortOrder(c2)).flat()
          }
        }), data3.length > 0 ? { data: data3 } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), child.assembleGroup(assembleFacetSignals(this, [])));
        return [markGroup];
      }
      getMapping() {
        return this.facet;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/joinaggregatefacet.js
function makeJoinAggregateFromFacet(parent, facet) {
  const { row, column } = facet;
  if (row && column) {
    let newParent = null;
    for (const fieldDef of [row, column]) {
      if (isSortField(fieldDef.sort)) {
        const { field: field4, op = DEFAULT_SORT_OP } = fieldDef.sort;
        parent = newParent = new JoinAggregateTransformNode(parent, {
          joinaggregate: [
            {
              op,
              field: field4,
              as: facetSortFieldName(fieldDef, fieldDef.sort, { forAs: true })
            }
          ],
          groupby: [vgField(fieldDef)]
        });
      }
    }
    return newParent;
  }
  return null;
}
var init_joinaggregatefacet = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/joinaggregatefacet.js"() {
    init_channeldef();
    init_sort5();
    init_facet3();
    init_joinaggregate();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/parse.js
function findSource(data3, sources) {
  var _a2, _b, _c2, _d2, _e, _f2, _g2, _h, _j, _k2;
  for (const other of sources) {
    const otherData = other.data;
    if (data3.name && other.hasName() && data3.name !== other.dataName) {
      continue;
    }
    if (((_a2 = data3["format"]) === null || _a2 === void 0 ? void 0 : _a2.mesh) && ((_b = otherData.format) === null || _b === void 0 ? void 0 : _b.feature)) {
      continue;
    }
    if ((((_c2 = data3["format"]) === null || _c2 === void 0 ? void 0 : _c2.feature) || ((_d2 = otherData.format) === null || _d2 === void 0 ? void 0 : _d2.feature)) && ((_e = data3["format"]) === null || _e === void 0 ? void 0 : _e.feature) !== ((_f2 = otherData.format) === null || _f2 === void 0 ? void 0 : _f2.feature)) {
      continue;
    }
    if ((((_g2 = data3["format"]) === null || _g2 === void 0 ? void 0 : _g2.mesh) || ((_h = otherData.format) === null || _h === void 0 ? void 0 : _h.mesh)) && ((_j = data3["format"]) === null || _j === void 0 ? void 0 : _j.mesh) !== ((_k2 = otherData.format) === null || _k2 === void 0 ? void 0 : _k2.mesh)) {
      continue;
    }
    if (isInlineData(data3) && isInlineData(otherData)) {
      if (deepEqual(data3.values, otherData.values)) {
        return other;
      }
    } else if (isUrlData(data3) && isUrlData(otherData)) {
      if (data3.url === otherData.url) {
        return other;
      }
    } else if (isNamedData(data3)) {
      if (data3.name === other.dataName) {
        return other;
      }
    }
  }
  return null;
}
function parseRoot(model, sources) {
  if (model.data || !model.parent) {
    if (model.data === null) {
      const source5 = new SourceNode({ values: [] });
      sources.push(source5);
      return source5;
    }
    const existingSource = findSource(model.data, sources);
    if (existingSource) {
      if (!isGenerator(model.data)) {
        existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);
      }
      if (!existingSource.hasName() && model.data.name) {
        existingSource.dataName = model.data.name;
      }
      return existingSource;
    } else {
      const source5 = new SourceNode(model.data);
      sources.push(source5);
      return source5;
    }
  } else {
    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
  }
}
function parseTransformArray(head, model, ancestorParse) {
  var _a2, _b;
  let lookupCounter = 0;
  for (const t of model.transforms) {
    let derivedType = void 0;
    let transformNode;
    if (isCalculate(t)) {
      transformNode = head = new CalculateNode(head, t);
      derivedType = "derived";
    } else if (isFilter(t)) {
      const implicit3 = getImplicitFromFilterTransform(t);
      transformNode = head = (_a2 = ParseNode.makeWithAncestors(head, {}, implicit3, ancestorParse)) !== null && _a2 !== void 0 ? _a2 : head;
      head = new FilterNode(head, model, t.filter);
    } else if (isBin(t)) {
      transformNode = head = BinNode.makeFromTransform(head, t, model);
      derivedType = "number";
    } else if (isTimeUnit(t)) {
      derivedType = "date";
      const parsedAs = ancestorParse.getWithExplicit(t.field);
      if (parsedAs.value === void 0) {
        head = new ParseNode(head, { [t.field]: derivedType });
        ancestorParse.set(t.field, derivedType, false);
      }
      transformNode = head = TimeUnitNode.makeFromTransform(head, t);
    } else if (isAggregate2(t)) {
      transformNode = head = AggregateNode.makeFromTransform(head, t);
      derivedType = "number";
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    } else if (isLookup(t)) {
      transformNode = head = LookupNode.make(head, model, t, lookupCounter++);
      derivedType = "derived";
    } else if (isWindow(t)) {
      transformNode = head = new WindowTransformNode(head, t);
      derivedType = "number";
    } else if (isJoinAggregate(t)) {
      transformNode = head = new JoinAggregateTransformNode(head, t);
      derivedType = "number";
    } else if (isStack(t)) {
      transformNode = head = StackNode.makeFromTransform(head, t);
      derivedType = "derived";
    } else if (isFold(t)) {
      transformNode = head = new FoldTransformNode(head, t);
      derivedType = "derived";
    } else if (isFlatten(t)) {
      transformNode = head = new FlattenTransformNode(head, t);
      derivedType = "derived";
    } else if (isPivot(t)) {
      transformNode = head = new PivotTransformNode(head, t);
      derivedType = "derived";
    } else if (isSample(t)) {
      head = new SampleTransformNode(head, t);
    } else if (isImpute(t)) {
      transformNode = head = ImputeNode.makeFromTransform(head, t);
      derivedType = "derived";
    } else if (isDensity(t)) {
      transformNode = head = new DensityTransformNode(head, t);
      derivedType = "derived";
    } else if (isQuantile2(t)) {
      transformNode = head = new QuantileTransformNode(head, t);
      derivedType = "derived";
    } else if (isRegression(t)) {
      transformNode = head = new RegressionTransformNode(head, t);
      derivedType = "derived";
    } else if (isLoess(t)) {
      transformNode = head = new LoessTransformNode(head, t);
      derivedType = "derived";
    } else {
      warn2(message_exports.invalidTransformIgnored(t));
      continue;
    }
    if (transformNode && derivedType !== void 0) {
      for (const field4 of (_b = transformNode.producedFields()) !== null && _b !== void 0 ? _b : []) {
        ancestorParse.set(field4, derivedType, false);
      }
    }
  }
  return head;
}
function parseData2(model) {
  var _a2, _b, _c2, _d2, _e, _f2, _g2, _h, _j, _k2;
  let head = parseRoot(model, model.component.data.sources);
  const { outputNodes, outputNodeRefCounts } = model.component.data;
  const ancestorParse = model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();
  const data3 = model.data;
  if (isGenerator(data3)) {
    if (isSequenceGenerator(data3)) {
      head = new SequenceNode(head, data3.sequence);
    } else if (isGraticuleGenerator(data3)) {
      head = new GraticuleNode(head, data3.graticule);
    }
    ancestorParse.parseNothing = true;
  } else if (((_a2 = data3 === null || data3 === void 0 ? void 0 : data3.format) === null || _a2 === void 0 ? void 0 : _a2.parse) === null) {
    ancestorParse.parseNothing = true;
  }
  head = (_b = ParseNode.makeExplicit(head, model, ancestorParse)) !== null && _b !== void 0 ? _b : head;
  head = new IdentifierNode(head);
  const parentIsLayer = model.parent && isLayerModel(model.parent);
  if (isUnitModel(model) || isFacetModel(model)) {
    if (parentIsLayer) {
      head = (_c2 = BinNode.makeFromEncoding(head, model)) !== null && _c2 !== void 0 ? _c2 : head;
    }
  }
  if (model.transforms.length > 0) {
    head = parseTransformArray(head, model, ancestorParse);
  }
  const implicitSelection = getImplicitFromSelection(model);
  const implicitEncoding = getImplicitFromEncoding(model);
  head = (_d2 = ParseNode.makeWithAncestors(head, {}, Object.assign(Object.assign({}, implicitSelection), implicitEncoding), ancestorParse)) !== null && _d2 !== void 0 ? _d2 : head;
  if (isUnitModel(model)) {
    head = GeoJSONNode.parseAll(head, model);
    head = GeoPointNode.parseAll(head, model);
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    if (!parentIsLayer) {
      head = (_e = BinNode.makeFromEncoding(head, model)) !== null && _e !== void 0 ? _e : head;
    }
    head = (_f2 = TimeUnitNode.makeFromEncoding(head, model)) !== null && _f2 !== void 0 ? _f2 : head;
    head = CalculateNode.parseAllForSortIndex(head, model);
  }
  const rawName = model.getName(RAW);
  const raw = new OutputNode(head, rawName, RAW, outputNodeRefCounts);
  outputNodes[rawName] = raw;
  head = raw;
  if (isUnitModel(model)) {
    const agg = AggregateNode.makeFromEncoding(head, model);
    if (agg) {
      head = agg;
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    }
    head = (_g2 = ImputeNode.makeFromEncoding(head, model)) !== null && _g2 !== void 0 ? _g2 : head;
    head = (_h = StackNode.makeFromEncoding(head, model)) !== null && _h !== void 0 ? _h : head;
  }
  if (isUnitModel(model)) {
    head = (_j = FilterInvalidNode.make(head, model)) !== null && _j !== void 0 ? _j : head;
  }
  const mainName = model.getName(MAIN);
  const main5 = new OutputNode(head, mainName, MAIN, outputNodeRefCounts);
  outputNodes[mainName] = main5;
  head = main5;
  if (isUnitModel(model)) {
    materializeSelections(model, main5);
  }
  let facetRoot = null;
  if (isFacetModel(model)) {
    const facetName = model.getName("facet");
    head = (_k2 = makeJoinAggregateFromFacet(head, model.facet)) !== null && _k2 !== void 0 ? _k2 : head;
    facetRoot = new FacetNode(head, model, facetName, main5.getSource());
    outputNodes[facetName] = facetRoot;
  }
  return Object.assign(Object.assign({}, model.component.data), {
    outputNodes,
    outputNodeRefCounts,
    raw,
    main: main5,
    facetRoot,
    ancestorParse
  });
}
var init_parse9 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/data/parse.js"() {
    init_data2();
    init_data3();
    init_log3();
    init_transform6();
    init_util();
    init_model();
    init_selection2();
    init_parse3();
    init_aggregate2();
    init_bin5();
    init_calculate();
    init_dataflow();
    init_density();
    init_facet2();
    init_filter4();
    init_filterinvalid();
    init_flatten();
    init_fold();
    init_formatparse();
    init_geojson();
    init_geopoint();
    init_graticule2();
    init_identifier();
    init_impute();
    init_joinaggregate();
    init_joinaggregatefacet();
    init_loess();
    init_lookup();
    init_pivot();
    init_quantile6();
    init_regression();
    init_sample();
    init_sequence();
    init_source();
    init_stack4();
    init_timeunit2();
    init_window();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/concat.js
var ConcatModel;
var init_concat2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/concat.js"() {
    init_log3();
    init_spec();
    init_util();
    init_buildmodel();
    init_parse9();
    init_assemble4();
    init_parse8();
    init_model();
    ConcatModel = class extends Model {
      constructor(spec, parent, parentGivenName, config) {
        var _a2, _b, _c2, _d2;
        super(spec, "concat", parent, parentGivenName, config, spec.resolve);
        if (((_b = (_a2 = spec.resolve) === null || _a2 === void 0 ? void 0 : _a2.axis) === null || _b === void 0 ? void 0 : _b.x) === "shared" || ((_d2 = (_c2 = spec.resolve) === null || _c2 === void 0 ? void 0 : _c2.axis) === null || _d2 === void 0 ? void 0 : _d2.y) === "shared") {
          warn2(message_exports.CONCAT_CANNOT_SHARE_AXIS);
        }
        this.children = this.getChildren(spec).map((child, i) => {
          return buildModel(child, this, this.getName("concat_" + i), void 0, config);
        });
      }
      parseData() {
        this.component.data = parseData2(this);
        for (const child of this.children) {
          child.parseData();
        }
      }
      parseSelections() {
        this.component.selection = {};
        for (const child of this.children) {
          child.parseSelections();
          for (const key3 of keys4(child.component.selection)) {
            this.component.selection[key3] = child.component.selection[key3];
          }
        }
      }
      parseMarkGroup() {
        for (const child of this.children) {
          child.parseMarkGroup();
        }
      }
      parseAxesAndHeaders() {
        for (const child of this.children) {
          child.parseAxesAndHeaders();
        }
      }
      getChildren(spec) {
        if (isVConcatSpec(spec)) {
          return spec.vconcat;
        } else if (isHConcatSpec(spec)) {
          return spec.hconcat;
        }
        return spec.concat;
      }
      parseLayoutSize() {
        parseConcatLayoutSize(this);
      }
      parseAxisGroup() {
        return null;
      }
      assembleSelectionTopLevelSignals(signals) {
        return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
      }
      assembleSignals() {
        this.children.forEach((child) => child.assembleSignals());
        return [];
      }
      assembleLayoutSignals() {
        const layoutSignals = assembleLayoutSignals(this);
        for (const child of this.children) {
          layoutSignals.push(...child.assembleLayoutSignals());
        }
        return layoutSignals;
      }
      assembleSelectionData(data3) {
        return this.children.reduce((db, child) => child.assembleSelectionData(db), data3);
      }
      assembleMarks() {
        return this.children.map((child) => {
          const title2 = child.assembleTitle();
          const style3 = child.assembleGroupStyle();
          const encodeEntry2 = child.assembleGroupEncodeEntry(false);
          return Object.assign(Object.assign(Object.assign(Object.assign({ type: "group", name: child.getName("group") }, title2 ? { title: title2 } : {}), style3 ? { style: style3 } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), child.assembleGroup());
        });
      }
      assembleDefaultLayout() {
        const columns = this.layout.columns;
        return Object.assign(Object.assign({}, columns != null ? { columns } : {}), {
          bounds: "full",
          align: "each"
        });
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/component.js
function isFalseOrNull(v) {
  return v === false || v === null;
}
var AXIS_COMPONENT_PROPERTIES_INDEX, AXIS_COMPONENT_PROPERTIES, AxisComponent;
var init_component6 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/component.js"() {
    init_axis();
    init_util();
    init_split();
    init_vega_schema();
    AXIS_COMPONENT_PROPERTIES_INDEX = Object.assign(Object.assign({ disable: 1, gridScale: 1, scale: 1 }, COMMON_AXIS_PROPERTIES_INDEX), { labelExpr: 1, encode: 1 });
    AXIS_COMPONENT_PROPERTIES = keys4(AXIS_COMPONENT_PROPERTIES_INDEX);
    AxisComponent = class extends Split {
      constructor(explicit = {}, implicit3 = {}, mainExtracted = false) {
        super();
        this.explicit = explicit;
        this.implicit = implicit3;
        this.mainExtracted = mainExtracted;
      }
      clone() {
        return new AxisComponent(duplicate(this.explicit), duplicate(this.implicit), this.mainExtracted);
      }
      hasAxisPart(part) {
        if (part === "axis") {
          return true;
        }
        if (part === "grid" || part === "title") {
          return !!this.get(part);
        }
        return !isFalseOrNull(this.get(part));
      }
      hasOrientSignalRef() {
        return isSignalRef(this.explicit.orient);
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/encode.js
function labels2(model, channel, specifiedLabelsSpec) {
  var _a2;
  const { encoding, config } = model;
  const fieldOrDatumDef = (_a2 = getFieldOrDatumDef(encoding[channel])) !== null && _a2 !== void 0 ? _a2 : getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);
  const axis = model.axis(channel) || {};
  const { format: format9, formatType } = axis;
  if (isCustomFormatType(formatType)) {
    return Object.assign({ text: formatCustomType({
      fieldOrDatumDef,
      field: "datum.value",
      format: format9,
      formatType,
      config
    }) }, specifiedLabelsSpec);
  }
  return specifiedLabelsSpec;
}
var init_encode3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/encode.js"() {
    init_channel();
    init_channeldef();
    init_format();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/parse.js
function parseUnitAxes(model) {
  return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {
    if (model.component.scales[channel]) {
      axis[channel] = [parseAxis2(channel, model)];
    }
    return axis;
  }, {});
}
function parseLayerAxes(model) {
  var _a2;
  const { axes, resolve: resolve2 } = model.component;
  const axisCount = { top: 0, bottom: 0, right: 0, left: 0 };
  for (const child of model.children) {
    child.parseAxesAndHeaders();
    for (const channel of keys4(child.component.axes)) {
      resolve2.axis[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve2.axis[channel] === "shared") {
        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);
        if (!axes[channel]) {
          resolve2.axis[channel] = "independent";
          delete axes[channel];
        }
      }
    }
  }
  for (const channel of POSITION_SCALE_CHANNELS) {
    for (const child of model.children) {
      if (!child.component.axes[channel]) {
        continue;
      }
      if (resolve2.axis[channel] === "independent") {
        axes[channel] = ((_a2 = axes[channel]) !== null && _a2 !== void 0 ? _a2 : []).concat(child.component.axes[channel]);
        for (const axisComponent of child.component.axes[channel]) {
          const { value: orient3, explicit } = axisComponent.getWithExplicit("orient");
          if (isSignalRef(orient3)) {
            continue;
          }
          if (axisCount[orient3] > 0 && !explicit) {
            const oppositeOrient = OPPOSITE_ORIENT[orient3];
            if (axisCount[orient3] > axisCount[oppositeOrient]) {
              axisComponent.set("orient", oppositeOrient, false);
            }
          }
          axisCount[orient3]++;
        }
      }
      delete child.component.axes[channel];
    }
    if (resolve2.axis[channel] === "independent" && axes[channel] && axes[channel].length > 1) {
      for (const axisCmpt of axes[channel]) {
        if (!!axisCmpt.get("grid") && !axisCmpt.explicit.grid) {
          axisCmpt.implicit.grid = false;
        }
      }
    }
  }
}
function mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {
  if (mergedAxisCmpts) {
    if (mergedAxisCmpts.length !== childAxisCmpts.length) {
      return void 0;
    }
    const length4 = mergedAxisCmpts.length;
    for (let i = 0; i < length4; i++) {
      const merged = mergedAxisCmpts[i];
      const child = childAxisCmpts[i];
      if (!!merged !== !!child) {
        return void 0;
      } else if (merged && child) {
        const mergedOrient = merged.getWithExplicit("orient");
        const childOrient = child.getWithExplicit("orient");
        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
          return void 0;
        } else {
          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);
        }
      }
    }
  } else {
    return childAxisCmpts.map((axisComponent) => axisComponent.clone());
  }
  return mergedAxisCmpts;
}
function mergeAxisComponent(merged, child) {
  for (const prop of AXIS_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(
      merged.getWithExplicit(prop),
      child.getWithExplicit(prop),
      prop,
      "axis",
      (v1, v2) => {
        switch (prop) {
          case "title":
            return mergeTitleComponent(v1, v2);
          case "gridScale":
            return {
              explicit: v1.explicit,
              value: getFirstDefined(v1.value, v2.value)
            };
        }
        return defaultTieBreaker(v1, v2, prop, "axis");
      }
    );
    merged.setWithExplicit(prop, mergedValueWithExplicit);
  }
  return merged;
}
function isExplicit2(value4, property2, axis, model, channel) {
  if (property2 === "disable") {
    return axis !== void 0;
  }
  axis = axis || {};
  switch (property2) {
    case "titleAngle":
    case "labelAngle":
      return value4 === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));
    case "values":
      return !!axis.values;
    case "encode":
      return !!axis.encoding || !!axis.labelAngle;
    case "title":
      if (value4 === getFieldDefTitle(model, channel)) {
        return true;
      }
  }
  return value4 === axis[property2];
}
function parseAxis2(channel, model) {
  var _a2, _b, _c2;
  let axis = model.axis(channel);
  const axisComponent = new AxisComponent();
  const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);
  const { mark, config } = model;
  const orient3 = (axis === null || axis === void 0 ? void 0 : axis.orient) || ((_a2 = config[channel === "x" ? "axisX" : "axisY"]) === null || _a2 === void 0 ? void 0 : _a2.orient) || ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) || defaultOrient(channel);
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const axisConfigs = getAxisConfigs(channel, scaleType2, orient3, model.config);
  const disable = axis !== void 0 ? !axis : getAxisConfig("disable", config, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;
  axisComponent.set("disable", disable, axis !== void 0);
  if (disable) {
    return axisComponent;
  }
  axis = axis || {};
  const labelAngle = getLabelAngle(model, axis, channel, fieldOrDatumDef, axisConfigs);
  const ruleParams = {
    fieldOrDatumDef,
    axis,
    channel,
    model,
    scaleType: scaleType2,
    orient: orient3,
    labelAngle,
    mark,
    config
  };
  for (const property2 of AXIS_COMPONENT_PROPERTIES) {
    const value4 = property2 in axisRules ? axisRules[property2](ruleParams) : isAxisProperty(property2) ? axis[property2] : void 0;
    const hasValue = value4 !== void 0;
    const explicit = isExplicit2(value4, property2, axis, model, channel);
    if (hasValue && explicit) {
      axisComponent.set(property2, value4, explicit);
    } else {
      const { configValue = void 0, configFrom = void 0 } = isAxisProperty(property2) && property2 !== "values" ? getAxisConfig(property2, model.config, axis.style, axisConfigs) : {};
      const hasConfigValue = configValue !== void 0;
      if (hasValue && !hasConfigValue) {
        axisComponent.set(property2, value4, explicit);
      } else if (!(configFrom === "vgAxisConfig") || propsToAlwaysIncludeConfig.has(property2) && hasConfigValue || isConditionalAxisValue(configValue) || isSignalRef(configValue)) {
        axisComponent.set(property2, configValue, false);
      }
    }
  }
  const axisEncoding = (_c2 = axis.encoding) !== null && _c2 !== void 0 ? _c2 : {};
  const axisEncode = AXIS_PARTS.reduce((e3, part) => {
    var _a3;
    if (!axisComponent.hasAxisPart(part)) {
      return e3;
    }
    const axisEncodingPart = guideEncodeEntry((_a3 = axisEncoding[part]) !== null && _a3 !== void 0 ? _a3 : {}, model);
    const value4 = part === "labels" ? labels2(model, channel, axisEncodingPart) : axisEncodingPart;
    if (value4 !== void 0 && !isEmpty(value4)) {
      e3[part] = { update: value4 };
    }
    return e3;
  }, {});
  if (!isEmpty(axisEncode)) {
    axisComponent.set("encode", axisEncode, !!axis.encoding || axis.labelAngle !== void 0);
  }
  return axisComponent;
}
var OPPOSITE_ORIENT, propsToAlwaysIncludeConfig;
var init_parse10 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/axis/parse.js"() {
    init_axis();
    init_channel();
    init_channeldef();
    init_util();
    init_vega_schema();
    init_common();
    init_guide2();
    init_resolve();
    init_split();
    init_component6();
    init_config2();
    init_encode3();
    init_properties();
    OPPOSITE_ORIENT = {
      bottom: "top",
      top: "bottom",
      left: "right",
      right: "left"
    };
    propsToAlwaysIncludeConfig = /* @__PURE__ */ new Set([
      "grid",
      "translate",
      "format",
      "formatType",
      "orient",
      "labelExpr",
      "tickCount",
      "position",
      "tickMinStep"
    ]);
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/layoutsize/init.js
function initLayoutSize({ encoding, size }) {
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (isStep(size[sizeType])) {
      if (isContinuousFieldOrDatumDef(encoding[channel])) {
        delete size[sizeType];
        warn2(message_exports.stepDropped(sizeType));
      }
    }
  }
  return size;
}
var init_init3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/layoutsize/init.js"() {
    init_channel();
    init_channeldef();
    init_log3();
    init_base2();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/init.js
function initMarkdef(mark, encoding, config, { graticule: graticule2 }) {
  const markDef = isMarkDef(mark) ? Object.assign({}, mark) : { type: mark };
  const specifiedOrient = getMarkPropOrConfig("orient", markDef, config);
  markDef.orient = orient2(markDef.type, encoding, specifiedOrient);
  if (specifiedOrient !== void 0 && specifiedOrient !== markDef.orient) {
    warn2(message_exports.orientOverridden(markDef.orient, specifiedOrient));
  }
  if (markDef.type === "bar" && markDef.orient) {
    const cornerRadiusEnd = getMarkPropOrConfig("cornerRadiusEnd", markDef, config);
    if (cornerRadiusEnd !== void 0) {
      const newProps = markDef.orient === "horizontal" && encoding.x2 || markDef.orient === "vertical" && encoding.y2 ? ["cornerRadius"] : BAR_CORNER_RADIUS_INDEX[markDef.orient];
      for (const newProp of newProps) {
        markDef[newProp] = cornerRadiusEnd;
      }
      if (markDef.cornerRadiusEnd !== void 0) {
        delete markDef.cornerRadiusEnd;
      }
    }
  }
  const specifiedOpacity = getMarkPropOrConfig("opacity", markDef, config);
  if (specifiedOpacity === void 0) {
    markDef.opacity = opacity(markDef.type, encoding);
  }
  const specifiedFilled = markDef.filled;
  if (specifiedFilled === void 0) {
    markDef.filled = graticule2 ? false : filled(markDef, config);
  }
  const specifiedCursor = getMarkPropOrConfig("cursor", markDef, config);
  if (specifiedCursor === void 0) {
    markDef.cursor = cursor2(markDef, encoding, config);
  }
  return markDef;
}
function cursor2(markDef, encoding, config) {
  if (encoding.href || markDef.href || getMarkPropOrConfig("href", markDef, config)) {
    return "pointer";
  }
  return markDef.cursor;
}
function opacity(mark, encoding) {
  if (contains2([POINT, TICK, CIRCLE, SQUARE], mark)) {
    if (!isAggregate(encoding)) {
      return 0.7;
    }
  }
  return void 0;
}
function filled(markDef, config) {
  const filledConfig = getMarkConfig("filled", markDef, config);
  const mark = markDef.type;
  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);
}
function orient2(mark, encoding, specifiedOrient) {
  switch (mark) {
    case POINT:
    case CIRCLE:
    case SQUARE:
    case TEXT:
    case RECT:
    case IMAGE:
      return void 0;
  }
  const { x: x7, y: y7, x2: x22, y2: y22 } = encoding;
  switch (mark) {
    case BAR:
      if (isFieldDef(x7) && (isBinned(x7.bin) || isFieldDef(y7) && y7.aggregate && !x7.aggregate)) {
        return "vertical";
      }
      if (isFieldDef(y7) && (isBinned(y7.bin) || isFieldDef(x7) && x7.aggregate && !y7.aggregate)) {
        return "horizontal";
      }
      if (y22 || x22) {
        if (specifiedOrient) {
          return specifiedOrient;
        }
        if (!x22) {
          if (isFieldDef(x7) && x7.type === QUANTITATIVE && !isBinning(x7.bin) || isNumericDataDef(x7)) {
            return "horizontal";
          }
        }
        if (!y22) {
          if (isFieldDef(y7) && y7.type === QUANTITATIVE && !isBinning(y7.bin) || isNumericDataDef(y7)) {
            return "vertical";
          }
        }
      }
    case RULE:
      if (x22 && !(isFieldDef(x7) && isBinned(x7.bin)) && y22 && !(isFieldDef(y7) && isBinned(y7.bin))) {
        return void 0;
      }
    case AREA:
      if (y22) {
        if (isFieldDef(y7) && isBinned(y7.bin)) {
          return "horizontal";
        } else {
          return "vertical";
        }
      } else if (x22) {
        if (isFieldDef(x7) && isBinned(x7.bin)) {
          return "vertical";
        } else {
          return "horizontal";
        }
      } else if (mark === RULE) {
        if (x7 && !y7) {
          return "vertical";
        } else if (y7 && !x7) {
          return "horizontal";
        }
      }
    case LINE:
    case TICK: {
      const xIsContinuous = isContinuousFieldOrDatumDef(x7);
      const yIsContinuous = isContinuousFieldOrDatumDef(y7);
      if (xIsContinuous && !yIsContinuous) {
        return mark !== "tick" ? "horizontal" : "vertical";
      } else if (!xIsContinuous && yIsContinuous) {
        return mark !== "tick" ? "vertical" : "horizontal";
      } else if (xIsContinuous && yIsContinuous) {
        const xDef = x7;
        const yDef = y7;
        const xIsTemporal = xDef.type === TEMPORAL;
        const yIsTemporal = yDef.type === TEMPORAL;
        if (xIsTemporal && !yIsTemporal) {
          return mark !== "tick" ? "vertical" : "horizontal";
        } else if (!xIsTemporal && yIsTemporal) {
          return mark !== "tick" ? "horizontal" : "vertical";
        }
        if (!xDef.aggregate && yDef.aggregate) {
          return mark !== "tick" ? "vertical" : "horizontal";
        } else if (xDef.aggregate && !yDef.aggregate) {
          return mark !== "tick" ? "horizontal" : "vertical";
        }
        if (specifiedOrient) {
          return specifiedOrient;
        }
        return "vertical";
      } else {
        if (specifiedOrient) {
          return specifiedOrient;
        }
        return void 0;
      }
    }
  }
  return "vertical";
}
var init_init4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/init.js"() {
    init_bin4();
    init_channeldef();
    init_encoding();
    init_log3();
    init_mark();
    init_type();
    init_util();
    init_common();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/arc.js
var arc4;
var init_arc3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/arc.js"() {
    init_encode();
    arc4 = {
      vgMark: "arc",
      encodeEntry: (model) => {
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          size: "ignore",
          orient: "ignore",
          theta: "ignore"
        })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), rectPosition(model, "radius", "arc")), rectPosition(model, "theta", "arc"));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/area.js
var area4;
var init_area5 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/area.js"() {
    init_encode();
    area4 = {
      vgMark: "area",
      encodeEntry: (model) => {
        return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          orient: "include",
          size: "ignore",
          theta: "ignore"
        })), pointOrRangePosition("x", model, {
          defaultPos: "zeroOrMin",
          defaultPos2: "zeroOrMin",
          range: model.markDef.orient === "horizontal"
        })), pointOrRangePosition("y", model, {
          defaultPos: "zeroOrMin",
          defaultPos2: "zeroOrMin",
          range: model.markDef.orient === "vertical"
        })), defined(model));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/bar.js
var bar;
var init_bar = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/bar.js"() {
    init_encode();
    bar = {
      vgMark: "rect",
      encodeEntry: (model) => {
        return Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          orient: "ignore",
          size: "ignore",
          theta: "ignore"
        })), rectPosition(model, "x", "bar")), rectPosition(model, "y", "bar"));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/geoshape.js
var geoshape;
var init_geoshape = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/geoshape.js"() {
    init_channeldef();
    init_type();
    init_encode();
    geoshape = {
      vgMark: "shape",
      encodeEntry: (model) => {
        return Object.assign({}, baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          size: "ignore",
          orient: "ignore",
          theta: "ignore"
        }));
      },
      postEncodingTransform: (model) => {
        const { encoding } = model;
        const shapeDef = encoding.shape;
        const transform4 = Object.assign({ type: "geoshape", projection: model.projectionName() }, shapeDef && isFieldDef(shapeDef) && shapeDef.type === GEOJSON ? { field: vgField(shapeDef, { expr: "datum" }) } : {});
        return [transform4];
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/image.js
var image3;
var init_image = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/image.js"() {
    init_encode();
    image3 = {
      vgMark: "image",
      encodeEntry: (model) => {
        return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "ignore",
          orient: "ignore",
          size: "ignore",
          theta: "ignore"
        })), rectPosition(model, "x", "image")), rectPosition(model, "y", "image")), text3(model, "url"));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/line.js
var line4, trail3;
var init_line4 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/line.js"() {
    init_encode();
    line4 = {
      vgMark: "line",
      encodeEntry: (model) => {
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          size: "ignore",
          orient: "ignore",
          theta: "ignore"
        })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model, {
          vgChannel: "strokeWidth"
        })), defined(model));
      }
    };
    trail3 = {
      vgMark: "trail",
      encodeEntry: (model) => {
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          size: "include",
          orient: "ignore",
          theta: "ignore"
        })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model)), defined(model));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/point.js
function encodeEntry(model, fixedShape) {
  const { config } = model;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
    align: "ignore",
    baseline: "ignore",
    color: "include",
    size: "include",
    orient: "ignore",
    theta: "ignore"
  })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), nonPosition("size", model)), nonPosition("angle", model)), shapeMixins(model, config, fixedShape));
}
function shapeMixins(model, config, fixedShape) {
  if (fixedShape) {
    return { shape: { value: fixedShape } };
  }
  return nonPosition("shape", model);
}
var point15, circle2, square;
var init_point3 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/point.js"() {
    init_encode();
    point15 = {
      vgMark: "symbol",
      encodeEntry: (model) => {
        return encodeEntry(model);
      }
    };
    circle2 = {
      vgMark: "symbol",
      encodeEntry: (model) => {
        return encodeEntry(model, "circle");
      }
    };
    square = {
      vgMark: "symbol",
      encodeEntry: (model) => {
        return encodeEntry(model, "square");
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/rect.js
var rect3;
var init_rect = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/rect.js"() {
    init_encode();
    rect3 = {
      vgMark: "rect",
      encodeEntry: (model) => {
        return Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          orient: "ignore",
          size: "ignore",
          theta: "ignore"
        })), rectPosition(model, "x", "rect")), rectPosition(model, "y", "rect"));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/rule.js
var rule4;
var init_rule = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/rule.js"() {
    init_encode();
    rule4 = {
      vgMark: "rule",
      encodeEntry: (model) => {
        const { markDef } = model;
        const orient3 = markDef.orient;
        if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {
          return {};
        }
        return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          orient: "ignore",
          size: "ignore",
          theta: "ignore"
        })), pointOrRangePosition("x", model, {
          defaultPos: orient3 === "horizontal" ? "zeroOrMax" : "mid",
          defaultPos2: "zeroOrMin",
          range: orient3 !== "vertical"
        })), pointOrRangePosition("y", model, {
          defaultPos: orient3 === "vertical" ? "zeroOrMax" : "mid",
          defaultPos2: "zeroOrMin",
          range: orient3 !== "horizontal"
        })), nonPosition("size", model, {
          vgChannel: "strokeWidth"
        }));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/text.js
function align(markDef, encoding, config) {
  const a4 = getMarkPropOrConfig("align", markDef, config);
  if (a4 === void 0) {
    return "center";
  }
  return void 0;
}
function baseline2(markDef, encoding, config) {
  const b3 = getMarkPropOrConfig("baseline", markDef, config);
  if (b3 === void 0) {
    return "middle";
  }
  return void 0;
}
var text4;
var init_text2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/text.js"() {
    init_common();
    init_encode();
    text4 = {
      vgMark: "text",
      encodeEntry: (model) => {
        const { config, encoding } = model;
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
          align: "include",
          baseline: "include",
          color: "include",
          size: "ignore",
          orient: "ignore",
          theta: "include"
        })), pointPosition("x", model, { defaultPos: "mid" })), pointPosition("y", model, { defaultPos: "mid" })), text3(model)), nonPosition("size", model, {
          vgChannel: "fontSize"
        })), nonPosition("angle", model)), valueIfDefined("align", align(model.markDef, encoding, config))), valueIfDefined("baseline", baseline2(model.markDef, encoding, config))), pointPosition("radius", model, { defaultPos: null, isMidPoint: true })), pointPosition("theta", model, { defaultPos: null, isMidPoint: true }));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/tick.js
function defaultSize(model) {
  var _a2;
  const { config, markDef } = model;
  const { orient: orient3 } = markDef;
  const vgSizeChannel = orient3 === "horizontal" ? "width" : "height";
  const scale8 = model.getScaleComponent(orient3 === "horizontal" ? "x" : "y");
  const markPropOrConfig = (_a2 = getMarkPropOrConfig("size", markDef, config, { vgChannel: vgSizeChannel })) !== null && _a2 !== void 0 ? _a2 : config.tick.bandSize;
  if (markPropOrConfig !== void 0) {
    return markPropOrConfig;
  } else {
    const scaleRange = scale8 ? scale8.get("range") : void 0;
    if (scaleRange && isVgRangeStep(scaleRange) && isNumber_default(scaleRange.step)) {
      return scaleRange.step * 3 / 4;
    }
    const defaultViewStep = getViewConfigDiscreteStep(config.view, vgSizeChannel);
    return defaultViewStep * 3 / 4;
  }
}
var tick;
var init_tick = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/tick.js"() {
    init_vega_util();
    init_config();
    init_vega_schema();
    init_common();
    init_encode();
    tick = {
      vgMark: "rect",
      encodeEntry: (model) => {
        const { config, markDef } = model;
        const orient3 = markDef.orient;
        const vgSizeChannel = orient3 === "horizontal" ? "width" : "height";
        const vgThicknessChannel = orient3 === "horizontal" ? "height" : "width";
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
          align: "ignore",
          baseline: "ignore",
          color: "include",
          orient: "ignore",
          size: "ignore",
          theta: "ignore"
        })), pointPosition("x", model, { defaultPos: "mid", vgChannel: "xc" })), pointPosition("y", model, { defaultPos: "mid", vgChannel: "yc" })), nonPosition("size", model, {
          defaultValue: defaultSize(model),
          vgChannel: vgSizeChannel
        })), { [vgThicknessChannel]: signalOrValueRef(getMarkPropOrConfig("thickness", markDef, config)) });
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/mark.js
function parseMarkGroups(model) {
  if (contains2([LINE, AREA, TRAIL], model.mark)) {
    return parsePathMark(model);
  } else if (contains2([BAR], model.mark)) {
    return getStackGroups(model);
  } else {
    return getMarkGroups(model);
  }
}
function parsePathMark(model) {
  const details = pathGroupingFields(model.mark, model.encoding);
  const pathMarks = getMarkGroups(model, {
    fromPrefix: details.length > 0 ? FACETED_PATH_PREFIX : ""
  });
  if (details.length > 0) {
    return [
      {
        name: model.getName("pathgroup"),
        type: "group",
        from: {
          facet: {
            name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),
            data: model.requestDataName(MAIN),
            groupby: details
          }
        },
        encode: {
          update: {
            width: { field: { group: "width" } },
            height: { field: { group: "height" } }
          }
        },
        marks: pathMarks
      }
    ];
  } else {
    return pathMarks;
  }
}
function getStackGroups(model) {
  const hasCornerRadius3 = VG_CORNERRADIUS_CHANNELS.some((prop) => getMarkPropOrConfig(prop, model.markDef, model.config));
  if (model.stack && !model.fieldDef("size") && hasCornerRadius3) {
    const [mark] = getMarkGroups(model, { fromPrefix: STACK_GROUP_PREFIX });
    const fieldScale = model.scaleName(model.stack.fieldChannel);
    const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt);
    const stackFieldGroup = (func, expr2) => {
      const vgFieldMinMax = [
        stackField({ prefix: "min", suffix: "start", expr: expr2 }),
        stackField({ prefix: "max", suffix: "start", expr: expr2 }),
        stackField({ prefix: "min", suffix: "end", expr: expr2 }),
        stackField({ prefix: "max", suffix: "end", expr: expr2 })
      ];
      return `${func}(${vgFieldMinMax.map((field4) => `scale('${fieldScale}',${field4})`).join(",")})`;
    };
    let groupUpdate;
    let innerGroupUpdate;
    if (model.stack.fieldChannel === "x") {
      groupUpdate = Object.assign(Object.assign({}, pick3(mark.encode.update, ["y", "yc", "y2", "height", ...VG_CORNERRADIUS_CHANNELS])), { x: { signal: stackFieldGroup("min", "datum") }, x2: { signal: stackFieldGroup("max", "datum") }, clip: { value: true } });
      innerGroupUpdate = {
        x: { field: { group: "x" }, mult: -1 },
        height: { field: { group: "height" } }
      };
      mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ["y", "yc", "y2"])), { height: { field: { group: "height" } } });
    } else {
      groupUpdate = Object.assign(Object.assign({}, pick3(mark.encode.update, ["x", "xc", "x2", "width"])), { y: { signal: stackFieldGroup("min", "datum") }, y2: { signal: stackFieldGroup("max", "datum") }, clip: { value: true } });
      innerGroupUpdate = {
        y: { field: { group: "y" }, mult: -1 },
        width: { field: { group: "width" } }
      };
      mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ["x", "xc", "x2"])), { width: { field: { group: "width" } } });
    }
    for (const key3 of VG_CORNERRADIUS_CHANNELS) {
      const configValue = getMarkConfig(key3, model.markDef, model.config);
      if (mark.encode.update[key3]) {
        groupUpdate[key3] = mark.encode.update[key3];
        delete mark.encode.update[key3];
      } else if (configValue) {
        groupUpdate[key3] = signalOrValueRef(configValue);
      }
      if (configValue) {
        mark.encode.update[key3] = { value: 0 };
      }
    }
    const groupByField = model.fieldDef(model.stack.groupbyChannel);
    const groupby = vgField(groupByField) ? [vgField(groupByField)] : [];
    if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.bin) || (groupByField === null || groupByField === void 0 ? void 0 : groupByField.timeUnit)) {
      groupby.push(vgField(groupByField, { binSuffix: "end" }));
    }
    const strokeProperties = [
      "stroke",
      "strokeWidth",
      "strokeJoin",
      "strokeCap",
      "strokeDash",
      "strokeDashOffset",
      "strokeMiterLimit",
      "strokeOpacity"
    ];
    groupUpdate = strokeProperties.reduce((encode2, prop) => {
      if (mark.encode.update[prop]) {
        return Object.assign(Object.assign({}, encode2), { [prop]: mark.encode.update[prop] });
      } else {
        const configValue = getMarkConfig(prop, model.markDef, model.config);
        if (configValue !== void 0) {
          return Object.assign(Object.assign({}, encode2), { [prop]: signalOrValueRef(configValue) });
        } else {
          return encode2;
        }
      }
    }, groupUpdate);
    if (groupUpdate.stroke) {
      groupUpdate.strokeForeground = { value: true };
      groupUpdate.strokeOffset = { value: 0 };
    }
    return [
      {
        type: "group",
        from: {
          facet: {
            data: model.requestDataName(MAIN),
            name: STACK_GROUP_PREFIX + model.requestDataName(MAIN),
            groupby,
            aggregate: {
              fields: [
                stackField({ suffix: "start" }),
                stackField({ suffix: "start" }),
                stackField({ suffix: "end" }),
                stackField({ suffix: "end" })
              ],
              ops: ["min", "max", "min", "max"]
            }
          }
        },
        encode: {
          update: groupUpdate
        },
        marks: [
          {
            type: "group",
            encode: { update: innerGroupUpdate },
            marks: [mark]
          }
        ]
      }
    ];
  } else {
    return getMarkGroups(model);
  }
}
function getSort2(model) {
  const { encoding, stack: stack3, mark, markDef, config } = model;
  const order = encoding.order;
  if (!isArray_default(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig("order", markDef, config))) {
    return void 0;
  } else if ((isArray_default(order) || isFieldDef(order)) && !stack3) {
    return sortParams(order, { expr: "datum" });
  } else if (isPathMark(mark)) {
    const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
    const dimensionChannelDef = encoding[dimensionChannel];
    if (isFieldDef(dimensionChannelDef)) {
      const s3 = dimensionChannelDef.sort;
      if (isArray_default(s3)) {
        return {
          field: vgField(dimensionChannelDef, { prefix: dimensionChannel, suffix: "sort_index", expr: "datum" })
        };
      } else if (isSortField(s3)) {
        return {
          field: vgField({
            aggregate: isAggregate(model.encoding) ? s3.op : void 0,
            field: s3.field
          }, { expr: "datum" })
        };
      } else if (isSortByEncoding(s3)) {
        const fieldDefToSort = model.fieldDef(s3.encoding);
        return {
          field: vgField(fieldDefToSort, { expr: "datum" }),
          order: s3.order
        };
      } else if (s3 === null) {
        return void 0;
      } else {
        return {
          field: vgField(dimensionChannelDef, {
            binSuffix: model.stack && model.stack.impute ? "mid" : void 0,
            expr: "datum"
          })
        };
      }
    }
    return void 0;
  }
  return void 0;
}
function getMarkGroups(model, opt = { fromPrefix: "" }) {
  const { mark, markDef, config } = model;
  const clip4 = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));
  const style3 = getStyles(markDef);
  const key3 = model.encoding.key;
  const sort5 = getSort2(model);
  const interactive2 = interactiveFlag(model);
  const aria2 = getMarkPropOrConfig("aria", markDef, config);
  const postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;
  return [
    Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ name: model.getName("marks"), type: markCompiler[mark].vgMark }, clip4 ? { clip: true } : {}), style3 ? { style: style3 } : {}), key3 ? { key: key3.field } : {}), sort5 ? { sort: sort5 } : {}), interactive2 ? interactive2 : {}), aria2 === false ? { aria: aria2 } : {}), { from: { data: opt.fromPrefix + model.requestDataName(MAIN) }, encode: {
      update: markCompiler[mark].encodeEntry(model)
    } }), postEncodingTransform ? {
      transform: postEncodingTransform
    } : {})
  ];
}
function scaleClip(model) {
  const xScale = model.getScaleComponent("x");
  const yScale = model.getScaleComponent("y");
  return xScale && xScale.get("selectionExtent") || yScale && yScale.get("selectionExtent") ? true : void 0;
}
function projectionClip(model) {
  const projection3 = model.component.projection;
  return projection3 && !projection3.isFit ? true : void 0;
}
function interactiveFlag(model) {
  if (!model.component.selection)
    return null;
  const unitCount = keys4(model.component.selection).length;
  let parentCount = unitCount;
  let parent = model.parent;
  while (parent && parentCount === 0) {
    parentCount = keys4(parent.component.selection).length;
    parent = parent.parent;
  }
  return parentCount ? { interactive: unitCount > 0 } : null;
}
var markCompiler, FACETED_PATH_PREFIX, STACK_GROUP_PREFIX;
var init_mark2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/mark/mark.js"() {
    init_vega_util();
    init_channeldef();
    init_data3();
    init_encoding();
    init_mark();
    init_sort5();
    init_util();
    init_vega_schema();
    init_common();
    init_arc3();
    init_area5();
    init_bar();
    init_geoshape();
    init_image();
    init_line4();
    init_point3();
    init_rect();
    init_rule();
    init_text2();
    init_tick();
    markCompiler = {
      arc: arc4,
      area: area4,
      bar,
      circle: circle2,
      geoshape,
      image: image3,
      line: line4,
      point: point15,
      rect: rect3,
      rule: rule4,
      square,
      text: text4,
      tick,
      trail: trail3
    };
    FACETED_PATH_PREFIX = "faceted_path_";
    STACK_GROUP_PREFIX = "stack_group_";
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/unit.js
var UnitModel;
var init_unit2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/unit.js"() {
    init_channel();
    init_channeldef();
    init_data3();
    init_encoding();
    init_encoding();
    init_mark();
    init_base2();
    init_stack3();
    init_assemble2();
    init_parse10();
    init_parse9();
    init_assemble4();
    init_init3();
    init_parse8();
    init_init4();
    init_mark2();
    init_model();
    init_assemble();
    init_parse3();
    UnitModel = class extends ModelWithField {
      constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {
        var _a2, _b;
        super(spec, "unit", parent, parentGivenName, config, void 0, isFrameMixins(spec) ? spec.view : void 0);
        this.specifiedScales = {};
        this.specifiedAxes = {};
        this.specifiedLegends = {};
        this.specifiedProjection = {};
        this.selection = {};
        this.children = [];
        const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;
        this.markDef = initMarkdef(spec.mark, (_a2 = spec.encoding) !== null && _a2 !== void 0 ? _a2 : {}, config, {
          graticule: spec.data && isGraticuleGenerator(spec.data)
        });
        const encoding = this.encoding = initEncoding((_b = spec.encoding) !== null && _b !== void 0 ? _b : {}, this.markDef, config);
        this.size = initLayoutSize({
          encoding,
          size: isFrameMixins(spec) ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? { width: spec.width } : {}), spec.height ? { height: spec.height } : {}) : parentGivenSize
        });
        this.stack = stack(mark, encoding);
        this.specifiedScales = this.initScales(mark, encoding);
        this.specifiedAxes = this.initAxes(encoding);
        this.specifiedLegends = this.initLegend(encoding);
        this.specifiedProjection = spec.projection;
        this.selection = spec.selection;
      }
      get hasProjection() {
        const { encoding } = this;
        const isGeoShapeMark = this.mark === GEOSHAPE;
        const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some((channel) => isFieldOrDatumDef(encoding[channel]));
        return isGeoShapeMark || hasGeoPosition;
      }
      scaleDomain(channel) {
        const scale8 = this.specifiedScales[channel];
        return scale8 ? scale8.domain : void 0;
      }
      axis(channel) {
        return this.specifiedAxes[channel];
      }
      legend(channel) {
        return this.specifiedLegends[channel];
      }
      initScales(mark, encoding) {
        return SCALE_CHANNELS.reduce((scales3, channel) => {
          var _a2;
          const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
          if (fieldOrDatumDef) {
            scales3[channel] = (_a2 = fieldOrDatumDef.scale) !== null && _a2 !== void 0 ? _a2 : {};
          }
          return scales3;
        }, {});
      }
      initAxes(encoding) {
        return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {
          const channelDef = encoding[channel];
          if (isFieldOrDatumDef(channelDef) || channel === X3 && isFieldOrDatumDef(encoding.x2) || channel === Y3 && isFieldOrDatumDef(encoding.y2)) {
            const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : void 0;
            _axis[channel] = axisSpec ? Object.assign({}, axisSpec) : axisSpec;
          }
          return _axis;
        }, {});
      }
      initLegend(encoding) {
        return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {
          const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
          if (fieldOrDatumDef && supportLegend(channel)) {
            const legend = fieldOrDatumDef.legend;
            _legend[channel] = legend ? Object.assign({}, legend) : legend;
          }
          return _legend;
        }, {});
      }
      parseData() {
        this.component.data = parseData2(this);
      }
      parseLayoutSize() {
        parseUnitLayoutSize(this);
      }
      parseSelections() {
        this.component.selection = parseUnitSelection(this, this.selection);
      }
      parseMarkGroup() {
        this.component.mark = parseMarkGroups(this);
      }
      parseAxesAndHeaders() {
        this.component.axes = parseUnitAxes(this);
      }
      assembleSelectionTopLevelSignals(signals) {
        return assembleTopLevelSignals(this, signals);
      }
      assembleSignals() {
        return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];
      }
      assembleSelectionData(data3) {
        return assembleUnitSelectionData(this, data3);
      }
      assembleLayout() {
        return null;
      }
      assembleLayoutSignals() {
        return assembleLayoutSignals(this);
      }
      assembleMarks() {
        var _a2;
        let marks = (_a2 = this.component.mark) !== null && _a2 !== void 0 ? _a2 : [];
        if (!this.parent || !isLayerModel(this.parent)) {
          marks = assembleUnitSelectionMarks(this, marks);
        }
        return marks.map(this.correctDataNames);
      }
      getMapping() {
        return this.encoding;
      }
      get mark() {
        return this.markDef.type;
      }
      channelHasField(channel) {
        return channelHasField(this.encoding, channel);
      }
      fieldDef(channel) {
        const channelDef = this.encoding[channel];
        return getFieldDef(channelDef);
      }
      typedFieldDef(channel) {
        const fieldDef = this.fieldDef(channel);
        if (isTypedFieldDef(fieldDef)) {
          return fieldDef;
        }
        return null;
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/layer.js
var LayerModel;
var init_layer2 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/layer.js"() {
    init_log3();
    init_spec();
    init_util();
    init_assemble2();
    init_parse10();
    init_parse9();
    init_assemble4();
    init_parse8();
    init_assemble5();
    init_model();
    init_assemble();
    init_unit2();
    LayerModel = class extends Model {
      constructor(spec, parent, parentGivenName, parentGivenSize, config) {
        super(spec, "layer", parent, parentGivenName, config, spec.resolve, spec.view);
        const layoutSize = Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? { width: spec.width } : {}), spec.height ? { height: spec.height } : {});
        this.children = spec.layer.map((layer, i) => {
          if (isLayerSpec(layer)) {
            return new LayerModel(layer, this, this.getName("layer_" + i), layoutSize, config);
          } else if (isUnitSpec(layer)) {
            return new UnitModel(layer, this, this.getName("layer_" + i), layoutSize, config);
          }
          throw new Error(message_exports.invalidSpec(layer));
        });
      }
      parseData() {
        this.component.data = parseData2(this);
        for (const child of this.children) {
          child.parseData();
        }
      }
      parseLayoutSize() {
        parseLayerLayoutSize(this);
      }
      parseSelections() {
        this.component.selection = {};
        for (const child of this.children) {
          child.parseSelections();
          for (const key3 of keys4(child.component.selection)) {
            this.component.selection[key3] = child.component.selection[key3];
          }
        }
      }
      parseMarkGroup() {
        for (const child of this.children) {
          child.parseMarkGroup();
        }
      }
      parseAxesAndHeaders() {
        parseLayerAxes(this);
      }
      assembleSelectionTopLevelSignals(signals) {
        return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
      }
      assembleSignals() {
        return this.children.reduce((signals, child) => {
          return signals.concat(child.assembleSignals());
        }, assembleAxisSignals(this));
      }
      assembleLayoutSignals() {
        return this.children.reduce((signals, child) => {
          return signals.concat(child.assembleLayoutSignals());
        }, assembleLayoutSignals(this));
      }
      assembleSelectionData(data3) {
        return this.children.reduce((db, child) => child.assembleSelectionData(db), data3);
      }
      assembleTitle() {
        let title2 = super.assembleTitle();
        if (title2) {
          return title2;
        }
        for (const child of this.children) {
          title2 = child.assembleTitle();
          if (title2) {
            return title2;
          }
        }
        return void 0;
      }
      assembleLayout() {
        return null;
      }
      assembleMarks() {
        return assembleLayerSelectionMarks(this, this.children.flatMap((child) => {
          return child.assembleMarks();
        }));
      }
      assembleLegends() {
        return this.children.reduce((legends, child) => {
          return legends.concat(child.assembleLegends());
        }, assembleLegends(this));
      }
    };
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/buildmodel.js
function buildModel(spec, parent, parentGivenName, unitSize, config) {
  if (isFacetSpec(spec)) {
    return new FacetModel(spec, parent, parentGivenName, config);
  } else if (isLayerSpec(spec)) {
    return new LayerModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isUnitSpec(spec)) {
    return new UnitModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isAnyConcatSpec(spec)) {
    return new ConcatModel(spec, parent, parentGivenName, config);
  }
  throw new Error(message_exports.invalidSpec(spec));
}
var init_buildmodel = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/buildmodel.js"() {
    init_log3();
    init_spec();
    init_concat2();
    init_facet3();
    init_layer2();
    init_unit2();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/compile.js
function compile(inputSpec, opt = {}) {
  if (opt.logger) {
    set7(opt.logger);
  }
  if (opt.fieldTitle) {
    setTitleFormatter(opt.fieldTitle);
  }
  try {
    const config = initConfig(mergeConfig2(opt.config, inputSpec.config));
    const spec = normalize3(inputSpec, config);
    const model = buildModel(spec, null, "", void 0, config);
    model.parse();
    optimizeDataflow(model.component.data, model);
    const vgSpec = assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);
    return {
      spec: vgSpec,
      normalized: spec
    };
  } finally {
    if (opt.logger) {
      reset2();
    }
    if (opt.fieldTitle) {
      resetTitleFormatter();
    }
  }
}
function getTopLevelProperties(inputSpec, autosize, config, model) {
  const width2 = model.component.layoutSize.get("width");
  const height2 = model.component.layoutSize.get("height");
  if (autosize === void 0) {
    autosize = { type: "pad" };
    if (model.hasAxisOrientSignalRef()) {
      autosize.resize = true;
    }
  } else if (isString_default(autosize)) {
    autosize = { type: autosize };
  }
  if (width2 && height2 && isFitType(autosize.type)) {
    if (width2 === "step" && height2 === "step") {
      warn2(message_exports.droppingFit());
      autosize.type = "pad";
    } else if (width2 === "step" || height2 === "step") {
      const sizeType = width2 === "step" ? "width" : "height";
      warn2(message_exports.droppingFit(getPositionScaleChannel(sizeType)));
      const inverseSizeType = sizeType === "width" ? "height" : "width";
      autosize.type = getFitType(inverseSizeType);
    }
  }
  return Object.assign(Object.assign(Object.assign({}, keys4(autosize).length === 1 && autosize.type ? autosize.type === "pad" ? {} : { autosize: autosize.type } : { autosize }), extractTopLevelProperties(config)), extractTopLevelProperties(inputSpec));
}
function assembleTopLevelModel(model, topLevelProperties, datasets = {}, usermeta) {
  const vgConfig = model.config ? stripAndRedirectConfig(model.config) : void 0;
  const data3 = [].concat(
    model.assembleSelectionData([]),
    assembleRootData(model.component.data, datasets)
  );
  const projections2 = model.assembleProjections();
  const title2 = model.assembleTitle();
  const style3 = model.assembleGroupStyle();
  const encodeEntry2 = model.assembleGroupEncodeEntry(true);
  let layoutSignals = model.assembleLayoutSignals();
  layoutSignals = layoutSignals.filter((signal) => {
    if ((signal.name === "width" || signal.name === "height") && signal.value !== void 0) {
      topLevelProperties[signal.name] = +signal.value;
      return false;
    }
    return true;
  });
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ $schema: "https://vega.github.io/schema/vega/v5.json" }, model.description ? { description: model.description } : {}), topLevelProperties), title2 ? { title: title2 } : {}), style3 ? { style: style3 } : {}), encodeEntry2 ? { encode: { update: encodeEntry2 } } : {}), { data: data3 }), projections2.length > 0 ? { projections: projections2 } : {}), model.assembleGroup([...layoutSignals, ...model.assembleSelectionTopLevelSignals([])])), vgConfig ? { config: vgConfig } : {}), usermeta ? { usermeta } : {});
}
var init_compile = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/compile/compile.js"() {
    init_vega_util();
    init_channel();
    init_channeldef();
    init_config();
    init_log3();
    init_normalize();
    init_toplevel();
    init_util();
    init_buildmodel();
    init_assemble8();
    init_optimize();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/transformextract.js
function extractTransforms(spec, config) {
  return extractor.map(spec, { config });
}
var TransformExtractMapper, extractor;
var init_transformextract = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/transformextract.js"() {
    init_encoding();
    init_map4();
    TransformExtractMapper = class extends SpecMapper {
      mapUnit(spec, { config }) {
        if (spec.encoding) {
          const { encoding: oldEncoding, transform: oldTransforms } = spec;
          const { bins: bins2, timeUnits: timeUnits2, aggregate, groupby, encoding } = extractTransformsFromEncoding(oldEncoding, config);
          const transform4 = [
            ...oldTransforms ? oldTransforms : [],
            ...bins2,
            ...timeUnits2,
            ...aggregate.length === 0 ? [] : [{ aggregate, groupby }]
          ];
          return Object.assign(Object.assign(Object.assign({}, spec), transform4.length > 0 ? { transform: transform4 } : {}), { encoding });
        } else {
          return spec;
        }
      }
    };
    extractor = new TransformExtractMapper();
  }
});

// node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/index.js
var src_exports5 = {};
__export(src_exports5, {
  compile: () => compile,
  extractTransforms: () => extractTransforms,
  normalize: () => normalize3,
  version: () => version2
});
var version2;
var init_src34 = __esm({
  "node_modules/.pnpm/vega-lite@4.13.1_vega@5.20.0/node_modules/vega-lite/build/src/index.js"() {
    init_package();
    init_normalize();
    init_compile();
    init_transformextract();
    version2 = package_default.version;
  }
});

// node_modules/.pnpm/vega-schema-url-parser@2.2.0/node_modules/vega-schema-url-parser/dist/parser.module.js
function e(e3) {
  const [n, r2] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e3).slice(1, 3);
  return { library: n, version: r2 };
}
var parser_module_default;
var init_parser_module = __esm({
  "node_modules/.pnpm/vega-schema-url-parser@2.2.0/node_modules/vega-schema-url-parser/dist/parser.module.js"() {
    parser_module_default = e;
  }
});

// node_modules/.pnpm/vega-themes@2.14.0_vega-lite@4.13.1_vega@5.20.0/node_modules/vega-themes/build/vega-themes.module.js
var vega_themes_module_exports = {};
__export(vega_themes_module_exports, {
  carbong10: () => carbong10,
  carbong100: () => carbong100,
  carbong90: () => carbong90,
  carbonwhite: () => carbonwhite,
  dark: () => darkTheme,
  excel: () => excelTheme,
  fivethirtyeight: () => fiveThirtyEightTheme,
  ggplot2: () => ggplot2Theme,
  googlecharts: () => googlechartsTheme,
  latimes: () => latimesTheme,
  powerbi: () => powerbiTheme,
  quartz: () => quartzTheme,
  urbaninstitute: () => urbanInstituteTheme,
  version: () => version3,
  vox: () => voxTheme
});
function genCarbonConfig({
  type: type4,
  background: background4
}) {
  const viewbg = type4 === "dark" ? "#161616" : "#ffffff";
  const textColor = type4 === "dark" ? "#f4f4f4" : "#161616";
  const category = type4 === "dark" ? darkCategories : lightCategories;
  const markColor2 = type4 === "dark" ? "#d4bbff" : "#6929c4";
  return {
    background: background4,
    arc: {
      fill: markColor2
    },
    area: {
      fill: markColor2
    },
    path: {
      stroke: markColor2
    },
    rect: {
      fill: markColor2
    },
    shape: {
      stroke: markColor2
    },
    symbol: {
      stroke: markColor2
    },
    circle: {
      fill: markColor2
    },
    view: {
      fill: viewbg,
      stroke: viewbg
    },
    group: {
      fill: viewbg
    },
    title: {
      color: textColor,
      anchor: "start",
      dy: -15,
      fontSize: 16,
      font: defaultFont,
      fontWeight: 600
    },
    axis: {
      labelColor: textColor,
      labelFontSize: 12,
      grid: true,
      gridColor: "#525252",
      titleColor: textColor,
      labelAngle: 0
    },
    style: {
      "guide-label": {
        font: defaultFont,
        fill: textColor,
        fontWeight
      },
      "guide-title": {
        font: defaultFont,
        fill: textColor,
        fontWeight
      }
    },
    range: {
      category,
      diverging: ["#750e13", "#a2191f", "#da1e28", "#fa4d56", "#ff8389", "#ffb3b8", "#ffd7d9", "#fff1f1", "#e5f6ff", "#bae6ff", "#82cfff", "#33b1ff", "#1192e8", "#0072c3", "#00539a", "#003a6d"],
      heatmap: ["#f6f2ff", "#e8daff", "#d4bbff", "#be95ff", "#a56eff", "#8a3ffc", "#6929c4", "#491d8b", "#31135e", "#1c0f30"]
    }
  };
}
var name2, version$12, description3, keywords5, license2, author2, contributors, main3, module2, unpkg2, jsdelivr2, types2, repository2, files, scripts2, devDependencies2, peerDependencies, dependencies2, pkg2, lightColor, medColor, darkTheme, markColor$7, excelTheme, markColor$6, axisColor$2, guideLabelColor, guideTitleColor, backgroundColor$2, blackTitle, fiveThirtyEightTheme, markColor$5, ggplot2Theme, headlineFontSize, headlineFontWeight, labelFont$1, labelFontSize, labelFontWeight, markColor$4, titleFont, titleFontWeight, titleFontSize$1, colorSchemes$1, latimesTheme, markColor$3, axisColor$1, quartzTheme, markColor$2, voxTheme, markColor$1, axisColor, backgroundColor$1, font3, labelFont, sourceFont, gridColor$1, titleFontSize, colorSchemes, urbanInstituteTheme, markColor, gridColor, defaultFont$1, googlechartsTheme, ptToPx, fontSmallPx, legendFontPx, fontLargePx, fontStandard, fontTitle, firstLevelElementColor, secondLevelElementColor, backgroundColor, backgroundSecondaryColor, paletteColor1, paletteColor2, paletteColor3, paletteColor4, paletteColor5, paletteColor6, paletteColor7, paletteColor8, divergentColorMax, divergentColorMin, divergentPalette, ordinalPalette, powerbiTheme, defaultFont, fontWeight, darkCategories, lightCategories, carbonwhite, carbong10, carbong90, carbong100, version3;
var init_vega_themes_module = __esm({
  "node_modules/.pnpm/vega-themes@2.14.0_vega-lite@4.13.1_vega@5.20.0/node_modules/vega-themes/build/vega-themes.module.js"() {
    name2 = "vega-themes";
    version$12 = "2.14.0";
    description3 = "Themes for stylized Vega and Vega-Lite visualizations.";
    keywords5 = ["vega", "vega-lite", "themes", "style"];
    license2 = "BSD-3-Clause";
    author2 = {
      name: "UW Interactive Data Lab",
      url: "https://idl.cs.washington.edu"
    };
    contributors = [{
      name: "Emily Gu",
      url: "https://github.com/emilygu"
    }, {
      name: "Arvind Satyanarayan",
      url: "http://arvindsatya.com"
    }, {
      name: "Jeffrey Heer",
      url: "https://idl.cs.washington.edu"
    }, {
      name: "Dominik Moritz",
      url: "https://www.domoritz.de"
    }];
    main3 = "build/vega-themes.js";
    module2 = "build/vega-themes.module.js";
    unpkg2 = "build/vega-themes.min.js";
    jsdelivr2 = "build/vega-themes.min.js";
    types2 = "build/vega-themes.module.d.ts";
    repository2 = {
      type: "git",
      url: "https://github.com/vega/vega-themes.git"
    };
    files = ["src", "build"];
    scripts2 = {
      prebuild: "yarn clean",
      build: "rollup -c",
      clean: "rimraf build && rimraf examples/build",
      "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
      "copy:build": "rsync -r build/* examples/build",
      "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
      preversion: "yarn lint",
      serve: "browser-sync start -s -f build examples --serveStatic examples",
      start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
      format: "eslint . --fix",
      lint: "eslint .",
      release: "release-it"
    };
    devDependencies2 = {
      "@babel/core": "^7.22.9",
      "@babel/plugin-proposal-async-generator-functions": "^7.20.7",
      "@babel/plugin-proposal-json-strings": "^7.18.6",
      "@babel/plugin-proposal-object-rest-spread": "^7.20.7",
      "@babel/plugin-proposal-optional-catch-binding": "^7.18.6",
      "@babel/plugin-transform-runtime": "^7.22.9",
      "@babel/preset-env": "^7.22.9",
      "@babel/preset-typescript": "^7.22.5",
      "@release-it/conventional-changelog": "^7.0.0",
      "@rollup/plugin-json": "^6.0.0",
      "@rollup/plugin-node-resolve": "^15.1.0",
      "@rollup/plugin-terser": "^0.4.3",
      "@typescript-eslint/eslint-plugin": "^6.0.0",
      "@typescript-eslint/parser": "^6.0.0",
      "browser-sync": "^2.29.3",
      concurrently: "^8.2.0",
      eslint: "^8.45.0",
      "eslint-config-prettier": "^8.8.0",
      "eslint-plugin-prettier": "^5.0.0",
      "gh-pages": "^5.0.0",
      prettier: "^3.0.0",
      "release-it": "^16.1.0",
      rollup: "^3.26.2",
      "rollup-plugin-bundle-size": "^1.0.3",
      "rollup-plugin-ts": "^3.2.0",
      typescript: "^5.1.6",
      vega: "^5.25.0",
      "vega-lite": "^5.9.3"
    };
    peerDependencies = {
      vega: "*",
      "vega-lite": "*"
    };
    dependencies2 = {};
    pkg2 = {
      name: name2,
      version: version$12,
      description: description3,
      keywords: keywords5,
      license: license2,
      author: author2,
      contributors,
      main: main3,
      module: module2,
      unpkg: unpkg2,
      jsdelivr: jsdelivr2,
      types: types2,
      repository: repository2,
      files,
      scripts: scripts2,
      devDependencies: devDependencies2,
      peerDependencies,
      dependencies: dependencies2
    };
    lightColor = "#fff";
    medColor = "#888";
    darkTheme = {
      background: "#333",
      view: {
        stroke: medColor
      },
      title: {
        color: lightColor,
        subtitleColor: lightColor
      },
      style: {
        "guide-label": {
          fill: lightColor
        },
        "guide-title": {
          fill: lightColor
        }
      },
      axis: {
        domainColor: lightColor,
        gridColor: medColor,
        tickColor: lightColor
      }
    };
    markColor$7 = "#4572a7";
    excelTheme = {
      background: "#fff",
      arc: {
        fill: markColor$7
      },
      area: {
        fill: markColor$7
      },
      line: {
        stroke: markColor$7,
        strokeWidth: 2
      },
      path: {
        stroke: markColor$7
      },
      rect: {
        fill: markColor$7
      },
      shape: {
        stroke: markColor$7
      },
      symbol: {
        fill: markColor$7,
        strokeWidth: 1.5,
        size: 50
      },
      axis: {
        bandPosition: 0.5,
        grid: true,
        gridColor: "#000000",
        gridOpacity: 1,
        gridWidth: 0.5,
        labelPadding: 10,
        tickSize: 5,
        tickWidth: 0.5
      },
      axisBand: {
        grid: false,
        tickExtra: true
      },
      legend: {
        labelBaseline: "middle",
        labelFontSize: 11,
        symbolSize: 50,
        symbolType: "square"
      },
      range: {
        category: ["#4572a7", "#aa4643", "#8aa453", "#71598e", "#4598ae", "#d98445", "#94aace", "#d09393", "#b9cc98", "#a99cbc"]
      }
    };
    markColor$6 = "#30a2da";
    axisColor$2 = "#cbcbcb";
    guideLabelColor = "#999";
    guideTitleColor = "#333";
    backgroundColor$2 = "#f0f0f0";
    blackTitle = "#333";
    fiveThirtyEightTheme = {
      arc: {
        fill: markColor$6
      },
      area: {
        fill: markColor$6
      },
      axis: {
        domainColor: axisColor$2,
        grid: true,
        gridColor: axisColor$2,
        gridWidth: 1,
        labelColor: guideLabelColor,
        labelFontSize: 10,
        titleColor: guideTitleColor,
        tickColor: axisColor$2,
        tickSize: 10,
        titleFontSize: 14,
        titlePadding: 10,
        labelPadding: 4
      },
      axisBand: {
        grid: false
      },
      background: backgroundColor$2,
      group: {
        fill: backgroundColor$2
      },
      legend: {
        labelColor: blackTitle,
        labelFontSize: 11,
        padding: 1,
        symbolSize: 30,
        symbolType: "square",
        titleColor: blackTitle,
        titleFontSize: 14,
        titlePadding: 10
      },
      line: {
        stroke: markColor$6,
        strokeWidth: 2
      },
      path: {
        stroke: markColor$6,
        strokeWidth: 0.5
      },
      rect: {
        fill: markColor$6
      },
      range: {
        category: ["#30a2da", "#fc4f30", "#e5ae38", "#6d904f", "#8b8b8b", "#b96db8", "#ff9e27", "#56cc60", "#52d2ca", "#52689e", "#545454", "#9fe4f8"],
        diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
        heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
      },
      point: {
        filled: true,
        shape: "circle"
      },
      shape: {
        stroke: markColor$6
      },
      bar: {
        binSpacing: 2,
        fill: markColor$6,
        stroke: null
      },
      title: {
        anchor: "start",
        fontSize: 24,
        fontWeight: 600,
        offset: 20
      }
    };
    markColor$5 = "#000";
    ggplot2Theme = {
      group: {
        fill: "#e5e5e5"
      },
      arc: {
        fill: markColor$5
      },
      area: {
        fill: markColor$5
      },
      line: {
        stroke: markColor$5
      },
      path: {
        stroke: markColor$5
      },
      rect: {
        fill: markColor$5
      },
      shape: {
        stroke: markColor$5
      },
      symbol: {
        fill: markColor$5,
        size: 40
      },
      axis: {
        domain: false,
        grid: true,
        gridColor: "#FFFFFF",
        gridOpacity: 1,
        labelColor: "#7F7F7F",
        labelPadding: 4,
        tickColor: "#7F7F7F",
        tickSize: 5.67,
        titleFontSize: 16,
        titleFontWeight: "normal"
      },
      legend: {
        labelBaseline: "middle",
        labelFontSize: 11,
        symbolSize: 40
      },
      range: {
        category: ["#000000", "#7F7F7F", "#1A1A1A", "#999999", "#333333", "#B0B0B0", "#4D4D4D", "#C9C9C9", "#666666", "#DCDCDC"]
      }
    };
    headlineFontSize = 22;
    headlineFontWeight = "normal";
    labelFont$1 = "Benton Gothic, sans-serif";
    labelFontSize = 11.5;
    labelFontWeight = "normal";
    markColor$4 = "#82c6df";
    titleFont = "Benton Gothic Bold, sans-serif";
    titleFontWeight = "normal";
    titleFontSize$1 = 13;
    colorSchemes$1 = {
      "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
      "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
      "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
      "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
    };
    latimesTheme = {
      background: "#ffffff",
      title: {
        anchor: "start",
        color: "#000000",
        font: titleFont,
        fontSize: headlineFontSize,
        fontWeight: headlineFontWeight
      },
      arc: {
        fill: markColor$4
      },
      area: {
        fill: markColor$4
      },
      line: {
        stroke: markColor$4,
        strokeWidth: 2
      },
      path: {
        stroke: markColor$4
      },
      rect: {
        fill: markColor$4
      },
      shape: {
        stroke: markColor$4
      },
      symbol: {
        fill: markColor$4,
        size: 30
      },
      axis: {
        labelFont: labelFont$1,
        labelFontSize,
        labelFontWeight,
        titleFont,
        titleFontSize: titleFontSize$1,
        titleFontWeight
      },
      axisX: {
        labelAngle: 0,
        labelPadding: 4,
        tickSize: 3
      },
      axisY: {
        labelBaseline: "middle",
        maxExtent: 45,
        minExtent: 45,
        tickSize: 2,
        titleAlign: "left",
        titleAngle: 0,
        titleX: -45,
        titleY: -11
      },
      legend: {
        labelFont: labelFont$1,
        labelFontSize,
        symbolType: "square",
        titleFont,
        titleFontSize: titleFontSize$1,
        titleFontWeight
      },
      range: {
        category: colorSchemes$1["category-6"],
        diverging: colorSchemes$1["fireandice-6"],
        heatmap: colorSchemes$1["fire-7"],
        ordinal: colorSchemes$1["fire-7"],
        ramp: colorSchemes$1["fire-7"]
      }
    };
    markColor$3 = "#ab5787";
    axisColor$1 = "#979797";
    quartzTheme = {
      background: "#f9f9f9",
      arc: {
        fill: markColor$3
      },
      area: {
        fill: markColor$3
      },
      line: {
        stroke: markColor$3
      },
      path: {
        stroke: markColor$3
      },
      rect: {
        fill: markColor$3
      },
      shape: {
        stroke: markColor$3
      },
      symbol: {
        fill: markColor$3,
        size: 30
      },
      axis: {
        domainColor: axisColor$1,
        domainWidth: 0.5,
        gridWidth: 0.2,
        labelColor: axisColor$1,
        tickColor: axisColor$1,
        tickWidth: 0.2,
        titleColor: axisColor$1
      },
      axisBand: {
        grid: false
      },
      axisX: {
        grid: true,
        tickSize: 10
      },
      axisY: {
        domain: false,
        grid: true,
        tickSize: 0
      },
      legend: {
        labelFontSize: 11,
        padding: 1,
        symbolSize: 30,
        symbolType: "square"
      },
      range: {
        category: ["#ab5787", "#51b2e5", "#703c5c", "#168dd9", "#d190b6", "#00609f", "#d365ba", "#154866", "#666666", "#c4c4c4"]
      }
    };
    markColor$2 = "#3e5c69";
    voxTheme = {
      background: "#fff",
      arc: {
        fill: markColor$2
      },
      area: {
        fill: markColor$2
      },
      line: {
        stroke: markColor$2
      },
      path: {
        stroke: markColor$2
      },
      rect: {
        fill: markColor$2
      },
      shape: {
        stroke: markColor$2
      },
      symbol: {
        fill: markColor$2
      },
      axis: {
        domainWidth: 0.5,
        grid: true,
        labelPadding: 2,
        tickSize: 5,
        tickWidth: 0.5,
        titleFontWeight: "normal"
      },
      axisBand: {
        grid: false
      },
      axisX: {
        gridWidth: 0.2
      },
      axisY: {
        gridDash: [3],
        gridWidth: 0.4
      },
      legend: {
        labelFontSize: 11,
        padding: 1,
        symbolType: "square"
      },
      range: {
        category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
      }
    };
    markColor$1 = "#1696d2";
    axisColor = "#000000";
    backgroundColor$1 = "#FFFFFF";
    font3 = "Lato";
    labelFont = "Lato";
    sourceFont = "Lato";
    gridColor$1 = "#DEDDDD";
    titleFontSize = 18;
    colorSchemes = {
      "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
      "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
      "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
      "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
      "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
      "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
      "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
      "shades-red": ["#F8D5D4", "#F1AAA9", "#E9807D", "#E25552", "#DB2B27", "#A4201D", "#6E1614", "#370B0A"],
      "one-group": ["#1696d2", "#000000"],
      "two-groups-cat-1": ["#1696d2", "#000000"],
      "two-groups-cat-2": ["#1696d2", "#fdbf11"],
      "two-groups-cat-3": ["#1696d2", "#db2b27"],
      "two-groups-seq": ["#a2d4ec", "#1696d2"],
      "three-groups-cat": ["#1696d2", "#fdbf11", "#000000"],
      "three-groups-seq": ["#a2d4ec", "#1696d2", "#0a4c6a"],
      "four-groups-cat-1": ["#000000", "#d2d2d2", "#fdbf11", "#1696d2"],
      "four-groups-cat-2": ["#1696d2", "#ec0008b", "#fdbf11", "#5c5859"],
      "four-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"],
      "five-groups-cat-1": ["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"],
      "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
      "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
      "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
      "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
      "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
      "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
    };
    urbanInstituteTheme = {
      background: backgroundColor$1,
      title: {
        anchor: "start",
        fontSize: titleFontSize,
        font: font3
      },
      axisX: {
        domain: true,
        domainColor: axisColor,
        domainWidth: 1,
        grid: false,
        labelFontSize: 12,
        labelFont,
        labelAngle: 0,
        tickColor: axisColor,
        tickSize: 5,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font3
      },
      axisY: {
        domain: false,
        domainWidth: 1,
        grid: true,
        gridColor: gridColor$1,
        gridWidth: 1,
        labelFontSize: 12,
        labelFont,
        labelPadding: 8,
        ticks: false,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font3,
        titleAngle: 0,
        titleY: -10,
        titleX: 18
      },
      legend: {
        labelFontSize: 12,
        labelFont,
        symbolSize: 100,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font3,
        orient: "right",
        offset: 10
      },
      view: {
        stroke: "transparent"
      },
      range: {
        category: colorSchemes["six-groups-cat-1"],
        diverging: colorSchemes["diverging-colors"],
        heatmap: colorSchemes["diverging-colors"],
        ordinal: colorSchemes["six-groups-seq"],
        ramp: colorSchemes["shades-blue"]
      },
      area: {
        fill: markColor$1
      },
      rect: {
        fill: markColor$1
      },
      line: {
        color: markColor$1,
        stroke: markColor$1,
        strokeWidth: 5
      },
      trail: {
        color: markColor$1,
        stroke: markColor$1,
        strokeWidth: 0,
        size: 1
      },
      path: {
        stroke: markColor$1,
        strokeWidth: 0.5
      },
      point: {
        filled: true
      },
      text: {
        font: sourceFont,
        color: markColor$1,
        fontSize: 11,
        align: "center",
        fontWeight: 400,
        size: 11
      },
      style: {
        bar: {
          fill: markColor$1,
          stroke: null
        }
      },
      arc: {
        fill: markColor$1
      },
      shape: {
        stroke: markColor$1
      },
      symbol: {
        fill: markColor$1,
        size: 30
      }
    };
    markColor = "#3366CC";
    gridColor = "#ccc";
    defaultFont$1 = "Arial, sans-serif";
    googlechartsTheme = {
      arc: {
        fill: markColor
      },
      area: {
        fill: markColor
      },
      path: {
        stroke: markColor
      },
      rect: {
        fill: markColor
      },
      shape: {
        stroke: markColor
      },
      symbol: {
        stroke: markColor
      },
      circle: {
        fill: markColor
      },
      background: "#fff",
      padding: {
        top: 10,
        right: 10,
        bottom: 10,
        left: 10
      },
      style: {
        "guide-label": {
          font: defaultFont$1,
          fontSize: 12
        },
        "guide-title": {
          font: defaultFont$1,
          fontSize: 12
        },
        "group-title": {
          font: defaultFont$1,
          fontSize: 12
        }
      },
      title: {
        font: defaultFont$1,
        fontSize: 14,
        fontWeight: "bold",
        dy: -3,
        anchor: "start"
      },
      axis: {
        gridColor,
        tickColor: gridColor,
        domain: false,
        grid: true
      },
      range: {
        category: ["#4285F4", "#DB4437", "#F4B400", "#0F9D58", "#AB47BC", "#00ACC1", "#FF7043", "#9E9D24", "#5C6BC0", "#F06292", "#00796B", "#C2185B"],
        heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
      }
    };
    ptToPx = (value4) => value4 * (1 / 3 + 1);
    fontSmallPx = ptToPx(9);
    legendFontPx = ptToPx(10);
    fontLargePx = ptToPx(12);
    fontStandard = "Segoe UI";
    fontTitle = "wf_standard-font, helvetica, arial, sans-serif";
    firstLevelElementColor = "#252423";
    secondLevelElementColor = "#605E5C";
    backgroundColor = "transparent";
    backgroundSecondaryColor = "#C8C6C4";
    paletteColor1 = "#118DFF";
    paletteColor2 = "#12239E";
    paletteColor3 = "#E66C37";
    paletteColor4 = "#6B007B";
    paletteColor5 = "#E044A7";
    paletteColor6 = "#744EC2";
    paletteColor7 = "#D9B300";
    paletteColor8 = "#D64550";
    divergentColorMax = paletteColor1;
    divergentColorMin = "#DEEFFF";
    divergentPalette = [divergentColorMin, divergentColorMax];
    ordinalPalette = [divergentColorMin, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", divergentColorMax];
    powerbiTheme = {
      view: {
        stroke: backgroundColor
      },
      background: backgroundColor,
      font: fontStandard,
      header: {
        titleFont: fontTitle,
        titleFontSize: fontLargePx,
        titleColor: firstLevelElementColor,
        labelFont: fontStandard,
        labelFontSize: legendFontPx,
        labelColor: secondLevelElementColor
      },
      axis: {
        ticks: false,
        grid: false,
        domain: false,
        labelColor: secondLevelElementColor,
        labelFontSize: fontSmallPx,
        titleFont: fontTitle,
        titleColor: firstLevelElementColor,
        titleFontSize: fontLargePx,
        titleFontWeight: "normal"
      },
      axisQuantitative: {
        tickCount: 3,
        grid: true,
        gridColor: backgroundSecondaryColor,
        gridDash: [1, 5],
        labelFlush: false
      },
      axisBand: {
        tickExtra: true
      },
      axisX: {
        labelPadding: 5
      },
      axisY: {
        labelPadding: 10
      },
      bar: {
        fill: paletteColor1
      },
      line: {
        stroke: paletteColor1,
        strokeWidth: 3,
        strokeCap: "round",
        strokeJoin: "round"
      },
      text: {
        font: fontStandard,
        fontSize: fontSmallPx,
        fill: secondLevelElementColor
      },
      arc: {
        fill: paletteColor1
      },
      area: {
        fill: paletteColor1,
        line: true,
        opacity: 0.6
      },
      path: {
        stroke: paletteColor1
      },
      rect: {
        fill: paletteColor1
      },
      point: {
        fill: paletteColor1,
        filled: true,
        size: 75
      },
      shape: {
        stroke: paletteColor1
      },
      symbol: {
        fill: paletteColor1,
        strokeWidth: 1.5,
        size: 50
      },
      legend: {
        titleFont: fontStandard,
        titleFontWeight: "bold",
        titleColor: secondLevelElementColor,
        labelFont: fontStandard,
        labelFontSize: legendFontPx,
        labelColor: secondLevelElementColor,
        symbolType: "circle",
        symbolSize: 75
      },
      range: {
        category: [paletteColor1, paletteColor2, paletteColor3, paletteColor4, paletteColor5, paletteColor6, paletteColor7, paletteColor8],
        diverging: divergentPalette,
        heatmap: divergentPalette,
        ordinal: ordinalPalette
      }
    };
    defaultFont = 'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif';
    fontWeight = 400;
    darkCategories = ["#8a3ffc", "#33b1ff", "#007d79", "#ff7eb6", "#fa4d56", "#fff1f1", "#6fdc8c", "#4589ff", "#d12771", "#d2a106", "#08bdba", "#bae6ff", "#ba4e00", "#d4bbff"];
    lightCategories = ["#6929c4", "#1192e8", "#005d5d", "#9f1853", "#fa4d56", "#570408", "#198038", "#002d9c", "#ee538b", "#b28600", "#009d9a", "#012749", "#8a3800", "#a56eff"];
    carbonwhite = genCarbonConfig({
      type: "light",
      background: "#ffffff"
    });
    carbong10 = genCarbonConfig({
      type: "light",
      background: "#f4f4f4"
    });
    carbong90 = genCarbonConfig({
      type: "dark",
      background: "#262626"
    });
    carbong100 = genCarbonConfig({
      type: "dark",
      background: "#161616"
    });
    version3 = pkg2.version;
  }
});

// node_modules/.pnpm/vega-tooltip@0.25.1/node_modules/vega-tooltip/build/vega-tooltip.module.js
function escapeHTML(value4) {
  return String(value4).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function createDefaultStyle(id4) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(id4)) {
    throw new Error("Invalid HTML ID");
  }
  return defaultStyle.toString().replace(EL_ID, id4);
}
function __rest2(s3, e3) {
  var t = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e3.indexOf(p) < 0)
      t[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s3); i < p.length; i++) {
      if (e3.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i]))
        t[p[i]] = s3[p[i]];
    }
  return t;
}
function formatValue4(value4, valueToHtml, maxDepth2) {
  if (isArray2(value4)) {
    return `[${value4.map((v) => valueToHtml(isString2(v) ? v : stringify3(v, maxDepth2))).join(", ")}]`;
  }
  if (isObject2(value4)) {
    let content3 = "";
    const _a2 = value4, { title: title2, image: image4 } = _a2, rest = __rest2(_a2, ["title", "image"]);
    if (title2) {
      content3 += `<h2>${valueToHtml(title2)}</h2>`;
    }
    if (image4) {
      content3 += `<img src="${valueToHtml(image4)}">`;
    }
    const keys5 = Object.keys(rest);
    if (keys5.length > 0) {
      content3 += "<table>";
      for (const key3 of keys5) {
        let val = rest[key3];
        if (val === void 0) {
          continue;
        }
        if (isObject2(val)) {
          val = stringify3(val, maxDepth2);
        }
        content3 += `<tr><td class="key">${valueToHtml(key3)}:</td><td class="value">${valueToHtml(val)}</td></tr>`;
      }
      content3 += `</table>`;
    }
    return content3 || "{}";
  }
  return valueToHtml(value4);
}
function replacer(maxDepth2) {
  const stack3 = [];
  return function(key3, value4) {
    if (typeof value4 !== "object" || value4 === null) {
      return value4;
    }
    const pos = stack3.indexOf(this) + 1;
    stack3.length = pos;
    if (stack3.length > maxDepth2) {
      return "[Object]";
    }
    if (stack3.indexOf(value4) >= 0) {
      return "[Circular]";
    }
    stack3.push(value4);
    return value4;
  };
}
function stringify3(obj, maxDepth2) {
  return JSON.stringify(obj, replacer(maxDepth2));
}
function calculatePosition(event3, tooltipBox, offsetX, offsetY) {
  let x7 = event3.clientX + offsetX;
  if (x7 + tooltipBox.width > window.innerWidth) {
    x7 = +event3.clientX - offsetX - tooltipBox.width;
  }
  let y7 = event3.clientY + offsetY;
  if (y7 + tooltipBox.height > window.innerHeight) {
    y7 = +event3.clientY - offsetY - tooltipBox.height;
  }
  return { x: x7, y: y7 };
}
var name3, version4, description4, keywords6, repository3, author3, collaborators, license3, bugs, homepage, main4, module3, unpkg3, jsdelivr3, types3, files2, scripts3, devDependencies3, dependencies3, pkg3, defaultStyle, EL_ID, DEFAULT_OPTIONS, Handler3, version$13;
var init_vega_tooltip_module = __esm({
  "node_modules/.pnpm/vega-tooltip@0.25.1/node_modules/vega-tooltip/build/vega-tooltip.module.js"() {
    init_vega_util_module2();
    name3 = "vega-tooltip";
    version4 = "0.25.1";
    description4 = "A tooltip plugin for Vega-Lite and Vega visualizations.";
    keywords6 = [
      "vega-lite",
      "vega",
      "tooltip"
    ];
    repository3 = {
      type: "git",
      url: "https://github.com/vega/vega-tooltip.git"
    };
    author3 = {
      name: "UW Interactive Data Lab",
      url: "https://idl.cs.washington.edu"
    };
    collaborators = [
      "Dominik Moritz",
      "Sira Horradarn",
      "Zening Qu",
      "Kanit Wongsuphasawat",
      "Yuri Astrakhan",
      "Jeffrey Heer"
    ];
    license3 = "BSD-3-Clause";
    bugs = {
      url: "https://github.com/vega/vega-tooltip/issues"
    };
    homepage = "https://github.com/vega/vega-tooltip#readme";
    main4 = "build/vega-tooltip.js";
    module3 = "build/vega-tooltip.module.js";
    unpkg3 = "build/vega-tooltip.min.js";
    jsdelivr3 = "build/vega-tooltip.min.js";
    types3 = "build/vega-tooltip.module.d.ts";
    files2 = [
      "src",
      "build",
      "types"
    ];
    scripts3 = {
      prebuild: "yarn clean && yarn build:style",
      build: "rollup -c",
      "build:style": "./build-style.sh",
      clean: "rimraf build && rimraf src/style.ts",
      "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
      "copy:build": "rsync -r build/* examples/build",
      "deploy:gh": "yarn build && yarn copy:build && gh-pages -d examples && yarn clean",
      prepublishOnly: "yarn clean && yarn build",
      preversion: "yarn lint && yarn test",
      serve: "browser-sync start -s -f build examples --serveStatic examples",
      start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
      pretest: "yarn build:style",
      test: "beemo jest",
      "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand",
      prepare: "beemo create-config && yarn copy:data",
      prettierbase: "beemo prettier '*.{css,scss,html}'",
      eslintbase: "beemo eslint .",
      format: "yarn eslintbase --fix && yarn prettierbase --write",
      lint: "yarn eslintbase && yarn prettierbase --check"
    };
    devDependencies3 = {
      "@rollup/plugin-json": "^4.1.0",
      "@rollup/plugin-node-resolve": "^11.2.0",
      "@wessberg/rollup-plugin-ts": "^1.3.8",
      "browser-sync": "^2.26.14",
      concurrently: "^6.0.0",
      "gh-pages": "^3.1.0",
      "node-sass": "^5.0.0",
      path: "^0.12.7",
      rollup: "^2.39.1",
      "rollup-plugin-bundle-size": "^1.0.3",
      "rollup-plugin-terser": "^7.0.2",
      typescript: "~4.2.2",
      "vega-datasets": "^2.2.0",
      "vega-lite-dev-config": "^0.16.1",
      "vega-typings": "^0.19.2"
    };
    dependencies3 = {
      "vega-util": "^1.16.0"
    };
    pkg3 = {
      name: name3,
      version: version4,
      description: description4,
      keywords: keywords6,
      repository: repository3,
      author: author3,
      collaborators,
      license: license3,
      bugs,
      homepage,
      main: main4,
      module: module3,
      unpkg: unpkg3,
      jsdelivr: jsdelivr3,
      types: types3,
      files: files2,
      scripts: scripts3,
      devDependencies: devDependencies3,
      dependencies: dependencies3
    };
    defaultStyle = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black; }
  #vg-tooltip-element.visible {
    visibility: visible; }
  #vg-tooltip-element h2 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 13px; }
  #vg-tooltip-element img {
    max-width: 200px;
    max-height: 200px; }
  #vg-tooltip-element table {
    border-spacing: 0; }
    #vg-tooltip-element table tr {
      border: none; }
      #vg-tooltip-element table tr td {
        overflow: hidden;
        text-overflow: ellipsis;
        padding-top: 2px;
        padding-bottom: 2px; }
        #vg-tooltip-element table tr td.key {
          color: #808080;
          max-width: 150px;
          text-align: right;
          padding-right: 4px; }
        #vg-tooltip-element table tr td.value {
          display: block;
          max-width: 300px;
          max-height: 7em;
          text-align: left; }
  #vg-tooltip-element.dark-theme {
    background-color: rgba(32, 32, 32, 0.9);
    border: 1px solid #f5f5f5;
    color: white; }
    #vg-tooltip-element.dark-theme td.key {
      color: #bfbfbf; }
`;
    EL_ID = "vg-tooltip-element";
    DEFAULT_OPTIONS = {
      offsetX: 10,
      offsetY: 10,
      id: EL_ID,
      styleId: "vega-tooltip-style",
      theme: "light",
      disableDefaultStyle: false,
      sanitize: escapeHTML,
      maxDepth: 2
    };
    Handler3 = class {
      constructor(options2) {
        this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options2);
        const elementId = this.options.id;
        this.el = null;
        this.call = this.tooltipHandler.bind(this);
        if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
          const style3 = document.createElement("style");
          style3.setAttribute("id", this.options.styleId);
          style3.innerHTML = createDefaultStyle(elementId);
          const head = document.head;
          if (head.childNodes.length > 0) {
            head.insertBefore(style3, head.childNodes[0]);
          } else {
            head.appendChild(style3);
          }
        }
      }
      tooltipHandler(handler, event3, item, value4) {
        this.el = document.getElementById(this.options.id);
        if (!this.el) {
          this.el = document.createElement("div");
          this.el.setAttribute("id", this.options.id);
          this.el.classList.add("vg-tooltip");
          document.body.appendChild(this.el);
        }
        const tooltipContainer = document.fullscreenElement != null ? document.fullscreenElement : document.body;
        tooltipContainer.appendChild(this.el);
        if (value4 == null || value4 === "") {
          this.el.classList.remove("visible", `${this.options.theme}-theme`);
          return;
        }
        this.el.innerHTML = formatValue4(value4, this.options.sanitize, this.options.maxDepth);
        this.el.classList.add("visible", `${this.options.theme}-theme`);
        const { x: x7, y: y7 } = calculatePosition(event3, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
        this.el.setAttribute("style", `top: ${y7}px; left: ${x7}px`);
      }
    };
    version$13 = pkg3.version;
  }
});

// node_modules/.pnpm/vega-embed@6.17.0_vega-lite@4.13.1_vega@5.20.0/node_modules/vega-embed/build/vega-embed.module.js
var vega_embed_module_exports = {};
__export(vega_embed_module_exports, {
  DEFAULT_ACTIONS: () => DEFAULT_ACTIONS,
  default: () => vega_embed_module_default,
  guessMode: () => guessMode,
  vega: () => vega,
  vegaLite: () => vegaLite
});
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value4) {
    return value4 instanceof P ? value4 : new P(function(resolve2) {
      resolve2(value4);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value4) {
      try {
        step(generator.next(value4));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value4) {
      try {
        step(generator["throw"](value4));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function post(window2, url, data3) {
  const editor = window2.open(url);
  const wait = 1e4;
  const step = 250;
  const { origin } = new URL(url);
  let count5 = ~~(wait / step);
  function listen(evt) {
    if (evt.source === editor) {
      count5 = 0;
      window2.removeEventListener("message", listen, false);
    }
  }
  window2.addEventListener("message", listen, false);
  function send() {
    if (count5 <= 0) {
      return;
    }
    editor.postMessage(data3, origin);
    setTimeout(send, step);
    count5 -= 1;
  }
  setTimeout(send, step);
}
function mergeDeep2(dest, ...src) {
  for (const s3 of src) {
    deepMerge_2(dest, s3);
  }
  return dest;
}
function deepMerge_2(dest, src) {
  for (const property2 of Object.keys(src)) {
    writeConfig(dest, property2, src[property2], true);
  }
}
function isTooltipHandler(h4) {
  return typeof h4 === "function";
}
function viewSource(source5, sourceHeader, sourceFooter, mode3) {
  const header = `<html><head>${sourceHeader}</head><body><pre><code class="json">`;
  const footer = `</code></pre>${sourceFooter}</body></html>`;
  const win = window.open("");
  win.document.write(header + source5 + footer);
  win.document.title = `${NAMES[mode3]} JSON Source`;
}
function guessMode(spec, providedMode) {
  var _a2;
  if (spec.$schema) {
    const parsed = parser_module_default(spec.$schema);
    if (providedMode && providedMode !== parsed.library) {
      console.warn(`The given visualization spec is written in ${NAMES[parsed.library]}, but mode argument sets ${(_a2 = NAMES[providedMode]) !== null && _a2 !== void 0 ? _a2 : providedMode}.`);
    }
    const mode3 = parsed.library;
    if (!(0, import_semver.satisfies)(VERSION[mode3], `^${parsed.version.slice(1)}`)) {
      console.warn(`The input spec uses ${NAMES[mode3]} ${parsed.version}, but the current version of ${NAMES[mode3]} is v${VERSION[mode3]}.`);
    }
    return mode3;
  }
  if ("mark" in spec || "encoding" in spec || "layer" in spec || "hconcat" in spec || "vconcat" in spec || "facet" in spec || "repeat" in spec) {
    return "vega-lite";
  }
  if ("marks" in spec || "signals" in spec || "scales" in spec || "axes" in spec) {
    return "vega";
  }
  return providedMode !== null && providedMode !== void 0 ? providedMode : "vega";
}
function isLoader(o) {
  return !!(o && "load" in o);
}
function createLoader(opts) {
  return isLoader(opts) ? opts : vega.loader(opts);
}
function embedOptionsFromUsermeta(parsedSpec) {
  var _a2;
  return (_a2 = parsedSpec.usermeta && parsedSpec.usermeta["embedOptions"]) !== null && _a2 !== void 0 ? _a2 : {};
}
function embed(el, spec, opts = {}) {
  var _a2, _b, _c2;
  return __awaiter(this, void 0, void 0, function* () {
    let parsedSpec;
    let loader3;
    if (isString(spec)) {
      loader3 = createLoader(opts.loader);
      parsedSpec = JSON.parse(yield loader3.load(spec));
    } else {
      parsedSpec = spec;
    }
    const usermetaLoader = embedOptionsFromUsermeta(parsedSpec).loader;
    if (!loader3 || usermetaLoader) {
      loader3 = createLoader((_a2 = opts.loader) !== null && _a2 !== void 0 ? _a2 : usermetaLoader);
    }
    const usermetaOpts = yield loadOpts(embedOptionsFromUsermeta(parsedSpec), loader3);
    const parsedOpts = yield loadOpts(opts, loader3);
    const mergedOpts = Object.assign(Object.assign({}, mergeDeep2(parsedOpts, usermetaOpts)), { config: mergeConfig((_b = parsedOpts.config) !== null && _b !== void 0 ? _b : {}, (_c2 = usermetaOpts.config) !== null && _c2 !== void 0 ? _c2 : {}) });
    return yield _embed(el, parsedSpec, mergedOpts, loader3);
  });
}
function loadOpts(opt, loader3) {
  var _a2;
  return __awaiter(this, void 0, void 0, function* () {
    const config = isString(opt.config) ? JSON.parse(yield loader3.load(opt.config)) : (_a2 = opt.config) !== null && _a2 !== void 0 ? _a2 : {};
    const patch2 = isString(opt.patch) ? JSON.parse(yield loader3.load(opt.patch)) : opt.patch;
    return Object.assign(Object.assign(Object.assign({}, opt), patch2 ? { patch: patch2 } : {}), config ? { config } : {});
  });
}
function getRoot(el) {
  var _a2;
  const possibleRoot = el.getRootNode ? el.getRootNode() : document;
  if (possibleRoot instanceof ShadowRoot) {
    return { root: possibleRoot, rootContainer: possibleRoot };
  } else {
    return { root: document, rootContainer: (_a2 = document.head) !== null && _a2 !== void 0 ? _a2 : document.body };
  }
}
function _embed(el, spec, opts = {}, loader3) {
  var _a2, _b, _c2, _d2, _e, _f2;
  return __awaiter(this, void 0, void 0, function* () {
    const config = opts.theme ? mergeConfig(vega_themes_module_exports[opts.theme], (_a2 = opts.config) !== null && _a2 !== void 0 ? _a2 : {}) : opts.config;
    const actions = isBoolean(opts.actions) ? opts.actions : mergeDeep2({}, DEFAULT_ACTIONS, (_b = opts.actions) !== null && _b !== void 0 ? _b : {});
    const i18n = Object.assign(Object.assign({}, I18N), opts.i18n);
    const renderer = (_c2 = opts.renderer) !== null && _c2 !== void 0 ? _c2 : "canvas";
    const logLevel = (_d2 = opts.logLevel) !== null && _d2 !== void 0 ? _d2 : vega.Warn;
    const downloadFileName = (_e = opts.downloadFileName) !== null && _e !== void 0 ? _e : "visualization";
    const element4 = typeof el === "string" ? document.querySelector(el) : el;
    if (!element4) {
      throw new Error(`${el} does not exist`);
    }
    if (opts.defaultStyle !== false) {
      const ID = "vega-embed-style";
      const { root: root2, rootContainer } = getRoot(element4);
      if (!root2.getElementById(ID)) {
        const style3 = document.createElement("style");
        style3.id = ID;
        style3.innerText = opts.defaultStyle === void 0 || opts.defaultStyle === true ? embedStyle.toString() : opts.defaultStyle;
        rootContainer.appendChild(style3);
      }
    }
    const mode3 = guessMode(spec, opts.mode);
    let vgSpec = PREPROCESSOR[mode3](spec, config);
    if (mode3 === "vega-lite") {
      if (vgSpec.$schema) {
        const parsed = parser_module_default(vgSpec.$schema);
        if (!(0, import_semver.satisfies)(VERSION.vega, `^${parsed.version.slice(1)}`)) {
          console.warn(`The compiled spec uses Vega ${parsed.version}, but current version is v${VERSION.vega}.`);
        }
      }
    }
    element4.classList.add("vega-embed");
    if (actions) {
      element4.classList.add("has-actions");
    }
    element4.innerHTML = "";
    let container = element4;
    if (actions) {
      const chartWrapper = document.createElement("div");
      chartWrapper.classList.add(CHART_WRAPPER_CLASS);
      element4.appendChild(chartWrapper);
      container = chartWrapper;
    }
    const patch2 = opts.patch;
    if (patch2) {
      if (patch2 instanceof Function) {
        vgSpec = patch2(vgSpec);
      } else {
        vgSpec = applyPatch(vgSpec, patch2, true, false).newDocument;
      }
    }
    if (opts.formatLocale) {
      vega.formatLocale(opts.formatLocale);
    }
    if (opts.timeFormatLocale) {
      vega.timeFormatLocale(opts.timeFormatLocale);
    }
    const { ast } = opts;
    const runtime2 = vega.parse(vgSpec, mode3 === "vega-lite" ? {} : config, { ast });
    const view = new (opts.viewClass || vega.View)(runtime2, Object.assign({
      loader: loader3,
      logLevel,
      renderer
    }, ast ? { expr: vega.expressionInterpreter } : {}));
    if (opts.tooltip !== false) {
      let handler;
      if (isTooltipHandler(opts.tooltip)) {
        handler = opts.tooltip;
      } else {
        handler = new Handler3(opts.tooltip === true ? {} : opts.tooltip).call;
      }
      view.tooltip(handler);
    }
    let { hover: hover2 } = opts;
    if (hover2 === void 0) {
      hover2 = mode3 === "vega";
    }
    if (hover2) {
      const { hoverSet, updateSet } = typeof hover2 === "boolean" ? {} : hover2;
      view.hover(hoverSet, updateSet);
    }
    if (opts) {
      if (opts.width != null) {
        view.width(opts.width);
      }
      if (opts.height != null) {
        view.height(opts.height);
      }
      if (opts.padding != null) {
        view.padding(opts.padding);
      }
    }
    yield view.initialize(container, opts.bind).runAsync();
    let documentClickHandler;
    if (actions !== false) {
      let wrapper = element4;
      if (opts.defaultStyle !== false) {
        const details = document.createElement("details");
        details.title = i18n.CLICK_TO_VIEW_ACTIONS;
        element4.append(details);
        wrapper = details;
        const summary = document.createElement("summary");
        summary.innerHTML = SVG_CIRCLES;
        details.append(summary);
        documentClickHandler = (ev) => {
          if (!details.contains(ev.target)) {
            details.removeAttribute("open");
          }
        };
        document.addEventListener("click", documentClickHandler);
      }
      const ctrl = document.createElement("div");
      wrapper.append(ctrl);
      ctrl.classList.add("vega-actions");
      if (actions === true || actions.export !== false) {
        for (const ext of ["svg", "png"]) {
          if (actions === true || actions.export === true || actions.export[ext]) {
            const i18nExportAction = i18n[`${ext.toUpperCase()}_ACTION`];
            const exportLink = document.createElement("a");
            exportLink.text = i18nExportAction;
            exportLink.href = "#";
            exportLink.target = "_blank";
            exportLink.download = `${downloadFileName}.${ext}`;
            exportLink.addEventListener("mousedown", function(e3) {
              return __awaiter(this, void 0, void 0, function* () {
                e3.preventDefault();
                const url = yield view.toImageURL(ext, opts.scaleFactor);
                this.href = url;
              });
            });
            ctrl.append(exportLink);
          }
        }
      }
      if (actions === true || actions.source !== false) {
        const viewSourceLink = document.createElement("a");
        viewSourceLink.text = i18n.SOURCE_ACTION;
        viewSourceLink.href = "#";
        viewSourceLink.addEventListener("click", function(e3) {
          var _a3, _b2;
          viewSource((0, import_json_stringify_pretty_compact.default)(spec), (_a3 = opts.sourceHeader) !== null && _a3 !== void 0 ? _a3 : "", (_b2 = opts.sourceFooter) !== null && _b2 !== void 0 ? _b2 : "", mode3);
          e3.preventDefault();
        });
        ctrl.append(viewSourceLink);
      }
      if (mode3 === "vega-lite" && (actions === true || actions.compiled !== false)) {
        const compileLink = document.createElement("a");
        compileLink.text = i18n.COMPILED_ACTION;
        compileLink.href = "#";
        compileLink.addEventListener("click", function(e3) {
          var _a3, _b2;
          viewSource((0, import_json_stringify_pretty_compact.default)(vgSpec), (_a3 = opts.sourceHeader) !== null && _a3 !== void 0 ? _a3 : "", (_b2 = opts.sourceFooter) !== null && _b2 !== void 0 ? _b2 : "", "vega");
          e3.preventDefault();
        });
        ctrl.append(compileLink);
      }
      if (actions === true || actions.editor !== false) {
        const editorUrl = (_f2 = opts.editorUrl) !== null && _f2 !== void 0 ? _f2 : "https://vega.github.io/editor/";
        const editorLink = document.createElement("a");
        editorLink.text = i18n.EDITOR_ACTION;
        editorLink.href = "#";
        editorLink.addEventListener("click", function(e3) {
          post(window, editorUrl, {
            config,
            mode: mode3,
            renderer,
            spec: (0, import_json_stringify_pretty_compact.default)(spec)
          });
          e3.preventDefault();
        });
        ctrl.append(editorLink);
      }
    }
    function finalize2() {
      if (documentClickHandler) {
        document.removeEventListener("click", documentClickHandler);
      }
      view.finalize();
    }
    return { view, spec, vgSpec, finalize: finalize2 };
  });
}
var import_json_stringify_pretty_compact, import_semver, embedStyle, _a, vega, vegaLite, w4, DEFAULT_ACTIONS, I18N, NAMES, VERSION, PREPROCESSOR, SVG_CIRCLES, CHART_WRAPPER_CLASS, vega_embed_module_default;
var init_vega_embed_module = __esm({
  "node_modules/.pnpm/vega-embed@6.17.0_vega-lite@4.13.1_vega@5.20.0/node_modules/vega-embed/build/vega-embed.module.js"() {
    init_fast_json_patch();
    import_json_stringify_pretty_compact = __toESM(require_json_stringify_pretty_compact());
    import_semver = __toESM(require_semver2());
    init_vega_module();
    init_vega_module();
    init_src34();
    init_parser_module();
    init_vega_themes_module();
    init_vega_tooltip_module();
    embedStyle = `.vega-embed {
  position: relative;
  display: inline-block;
  box-sizing: border-box; }
  .vega-embed.has-actions {
    padding-right: 38px; }
  .vega-embed details:not([open]) > :not(summary) {
    display: none !important; }
  .vega-embed summary {
    list-style: none;
    position: absolute;
    top: 0;
    right: 0;
    padding: 6px;
    z-index: 1000;
    background: white;
    box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
    color: #1b1e23;
    border: 1px solid #aaa;
    border-radius: 999px;
    opacity: 0.2;
    transition: opacity 0.4s ease-in;
    outline: none;
    cursor: pointer;
    line-height: 0px; }
    .vega-embed summary::-webkit-details-marker {
      display: none; }
    .vega-embed summary:active {
      box-shadow: #aaa 0px 0px 0px 1px inset; }
    .vega-embed summary svg {
      width: 14px;
      height: 14px; }
  .vega-embed details[open] summary {
    opacity: 0.7; }
  .vega-embed:hover summary,
  .vega-embed:focus summary {
    opacity: 1 !important;
    transition: opacity 0.2s ease; }
  .vega-embed .vega-actions {
    position: absolute;
    z-index: 1001;
    top: 35px;
    right: -9px;
    display: flex;
    flex-direction: column;
    padding-bottom: 8px;
    padding-top: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
    border: 1px solid #d9d9d9;
    background: white;
    animation-duration: 0.15s;
    animation-name: scale-in;
    animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
    text-align: left; }
    .vega-embed .vega-actions a {
      padding: 8px 16px;
      font-family: sans-serif;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      color: #434a56;
      text-decoration: none; }
      .vega-embed .vega-actions a:hover {
        background-color: #f7f7f9;
        color: black; }
    .vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
      content: "";
      display: inline-block;
      position: absolute; }
    .vega-embed .vega-actions::before {
      left: auto;
      right: 14px;
      top: -16px;
      border: 8px solid #0000;
      border-bottom-color: #d9d9d9; }
    .vega-embed .vega-actions::after {
      left: auto;
      right: 15px;
      top: -14px;
      border: 7px solid #0000;
      border-bottom-color: #fff; }
  .vega-embed .chart-wrapper {
    width: 100%;
    height: 100%; }

.vega-embed-wrapper {
  max-width: 100%;
  overflow: auto;
  padding-right: 14px; }

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.6); }
  to {
    opacity: 1;
    transform: scale(1); } }
`;
    if (!String.prototype.startsWith) {
      String.prototype.startsWith = function(search, pos) {
        return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      };
    }
    vega = vega_module_exports;
    vegaLite = src_exports5;
    w4 = typeof window !== "undefined" ? window : void 0;
    if (vegaLite === void 0 && ((_a = w4 === null || w4 === void 0 ? void 0 : w4["vl"]) === null || _a === void 0 ? void 0 : _a.compile)) {
      vegaLite = w4["vl"];
    }
    DEFAULT_ACTIONS = { export: { svg: true, png: true }, source: true, compiled: true, editor: true };
    I18N = {
      CLICK_TO_VIEW_ACTIONS: "Click to view actions",
      COMPILED_ACTION: "View Compiled Vega",
      EDITOR_ACTION: "Open in Vega Editor",
      PNG_ACTION: "Save as PNG",
      SOURCE_ACTION: "View Source",
      SVG_ACTION: "Save as SVG"
    };
    NAMES = {
      vega: "Vega",
      "vega-lite": "Vega-Lite"
    };
    VERSION = {
      vega: vega.version,
      "vega-lite": vegaLite ? vegaLite.version : "not available"
    };
    PREPROCESSOR = {
      vega: (vgSpec) => vgSpec,
      "vega-lite": (vlSpec, config) => vegaLite.compile(vlSpec, { config }).spec
    };
    SVG_CIRCLES = `
<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
  <circle r="2" cy="8" cx="2"></circle>
  <circle r="2" cy="8" cx="8"></circle>
  <circle r="2" cy="8" cx="14"></circle>
</svg>`;
    CHART_WRAPPER_CLASS = "chart-wrapper";
    vega_embed_module_default = embed;
  }
});

// node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js"(exports, module4) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module4.exports = shouldUseNative() ? Object.assign : function(target2, source5) {
      var from;
      var to = toObject(target2);
      var symbols7;
      for (var s3 = 1; s3 < arguments.length; s3++) {
        from = Object(arguments[s3]);
        for (var key3 in from) {
          if (hasOwnProperty2.call(from, key3)) {
            to[key3] = from[key3];
          }
        }
        if (getOwnPropertySymbols) {
          symbols7 = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols7.length; i++) {
            if (propIsEnumerable.call(from, symbols7[i])) {
              to[symbols7[i]] = from[symbols7[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/sheet.js
var require_sheet = __commonJS({
  "node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/sheet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.StyleSheet = StyleSheet;
    var _objectAssign = require_object_assign();
    var _objectAssign2 = _interopRequireDefault(_objectAssign);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function last(arr) {
      return arr[arr.length - 1];
    }
    function sheetForTag(tag) {
      if (tag.sheet) {
        return tag.sheet;
      }
      for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].ownerNode === tag) {
          return document.styleSheets[i];
        }
      }
    }
    var isBrowser = typeof window !== "undefined";
    var isDev = true;
    var isTest = false;
    var oldIE = function() {
      if (isBrowser) {
        var div = document.createElement("div");
        div.innerHTML = "<!--[if lt IE 10]><i></i><![endif]-->";
        return div.getElementsByTagName("i").length === 1;
      }
    }();
    function makeStyleTag() {
      var tag = document.createElement("style");
      tag.type = "text/css";
      tag.setAttribute("data-glamor", "");
      tag.appendChild(document.createTextNode(""));
      (document.head || document.getElementsByTagName("head")[0]).appendChild(tag);
      return tag;
    }
    function StyleSheet() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$speedy = _ref.speedy, speedy = _ref$speedy === void 0 ? !isDev && !isTest : _ref$speedy, _ref$maxLength = _ref.maxLength, maxLength = _ref$maxLength === void 0 ? isBrowser && oldIE ? 4e3 : 65e3 : _ref$maxLength;
      this.isSpeedy = speedy;
      this.sheet = void 0;
      this.tags = [];
      this.maxLength = maxLength;
      this.ctr = 0;
    }
    (0, _objectAssign2.default)(StyleSheet.prototype, {
      getSheet: function getSheet() {
        return sheetForTag(last(this.tags));
      },
      inject: function inject() {
        var _this = this;
        if (this.injected) {
          throw new Error("already injected stylesheet!");
        }
        if (isBrowser) {
          this.tags[0] = makeStyleTag();
        } else {
          this.sheet = {
            cssRules: [],
            insertRule: function insertRule(rule5) {
              _this.sheet.cssRules.push({ cssText: rule5 });
            }
          };
        }
        this.injected = true;
      },
      speedy: function speedy(bool) {
        if (this.ctr !== 0) {
          throw new Error("cannot change speedy mode after inserting any rule to sheet. Either call speedy(" + bool + ") earlier in your app, or call flush() before speedy(" + bool + ")");
        }
        this.isSpeedy = !!bool;
      },
      _insert: function _insert(rule5) {
        try {
          var sheet = this.getSheet();
          sheet.insertRule(rule5, rule5.indexOf("@import") !== -1 ? 0 : sheet.cssRules.length);
        } catch (e3) {
          if (isDev) {
            console.warn("whoops, illegal rule inserted", rule5);
          }
        }
      },
      insert: function insert2(rule5) {
        if (isBrowser) {
          if (this.isSpeedy && this.getSheet().insertRule) {
            this._insert(rule5);
          } else {
            if (rule5.indexOf("@import") !== -1) {
              var tag = last(this.tags);
              tag.insertBefore(document.createTextNode(rule5), tag.firstChild);
            } else {
              last(this.tags).appendChild(document.createTextNode(rule5));
            }
          }
        } else {
          this.sheet.insertRule(rule5, rule5.indexOf("@import") !== -1 ? 0 : this.sheet.cssRules.length);
        }
        this.ctr++;
        if (isBrowser && this.ctr % this.maxLength === 0) {
          this.tags.push(makeStyleTag());
        }
        return this.ctr - 1;
      },
      delete: function _delete(index8) {
        return this.replace(index8, "");
      },
      flush: function flush2() {
        if (isBrowser) {
          this.tags.forEach(function(tag) {
            return tag.parentNode.removeChild(tag);
          });
          this.tags = [];
          this.sheet = null;
          this.ctr = 0;
        } else {
          this.sheet.cssRules = [];
        }
        this.injected = false;
      },
      rules: function rules() {
        if (!isBrowser) {
          return this.sheet.cssRules;
        }
        var arr = [];
        this.tags.forEach(function(tag) {
          return arr.splice.apply(arr, [arr.length, 0].concat(_toConsumableArray(Array.from(sheetForTag(tag).cssRules))));
        });
        return arr;
      }
    });
  }
});

// node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/camelize.js
var require_camelize = __commonJS({
  "node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/camelize.js"(exports, module4) {
    "use strict";
    var _hyphenPattern = /-(.)/g;
    function camelize(string) {
      return string.replace(_hyphenPattern, function(_, character) {
        return character.toUpperCase();
      });
    }
    module4.exports = camelize;
  }
});

// node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/camelizeStyleName.js
var require_camelizeStyleName = __commonJS({
  "node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/camelizeStyleName.js"(exports, module4) {
    "use strict";
    var camelize = require_camelize();
    var msPattern2 = /^-ms-/;
    function camelizeStyleName(string) {
      return camelize(string.replace(msPattern2, "ms-"));
    }
    module4.exports = camelizeStyleName;
  }
});

// node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/CSSPropertyOperations/CSSProperty.js
var require_CSSProperty = __commonJS({
  "node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/CSSPropertyOperations/CSSProperty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var isUnitlessNumber = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridRow: true,
      gridRowStart: true,
      gridRowEnd: true,
      gridColumn: true,
      gridColumnStart: true,
      gridColumnEnd: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    function prefixKey(prefix, key3) {
      return prefix + key3.charAt(0).toUpperCase() + key3.substring(1);
    }
    var prefixes4 = ["Webkit", "ms", "Moz", "O"];
    Object.keys(isUnitlessNumber).forEach(function(prop) {
      prefixes4.forEach(function(prefix) {
        isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
      });
    });
    var shorthandPropertyExpansions = {
      background: {
        backgroundAttachment: true,
        backgroundColor: true,
        backgroundImage: true,
        backgroundPositionX: true,
        backgroundPositionY: true,
        backgroundRepeat: true
      },
      backgroundPosition: {
        backgroundPositionX: true,
        backgroundPositionY: true
      },
      border: {
        borderWidth: true,
        borderStyle: true,
        borderColor: true
      },
      borderBottom: {
        borderBottomWidth: true,
        borderBottomStyle: true,
        borderBottomColor: true
      },
      borderLeft: {
        borderLeftWidth: true,
        borderLeftStyle: true,
        borderLeftColor: true
      },
      borderRight: {
        borderRightWidth: true,
        borderRightStyle: true,
        borderRightColor: true
      },
      borderTop: {
        borderTopWidth: true,
        borderTopStyle: true,
        borderTopColor: true
      },
      font: {
        fontStyle: true,
        fontVariant: true,
        fontWeight: true,
        fontSize: true,
        lineHeight: true,
        fontFamily: true
      },
      outline: {
        outlineWidth: true,
        outlineStyle: true,
        outlineColor: true
      }
    };
    var CSSProperty = {
      isUnitlessNumber,
      shorthandPropertyExpansions
    };
    exports.default = CSSProperty;
  }
});

// node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/emptyFunction.js
var require_emptyFunction = __commonJS({
  "node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/emptyFunction.js"(exports, module4) {
    "use strict";
    function makeEmptyFunction(arg) {
      return function() {
        return arg;
      };
    }
    var emptyFunction = function emptyFunction2() {
    };
    emptyFunction.thatReturns = makeEmptyFunction;
    emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
    emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
    emptyFunction.thatReturnsNull = makeEmptyFunction(null);
    emptyFunction.thatReturnsThis = function() {
      return this;
    };
    emptyFunction.thatReturnsArgument = function(arg) {
      return arg;
    };
    module4.exports = emptyFunction;
  }
});

// node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/warning.js
var require_warning = __commonJS({
  "node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/warning.js"(exports, module4) {
    "use strict";
    var emptyFunction = require_emptyFunction();
    var warning = emptyFunction;
    if (true) {
      printWarning = function printWarning2(format9) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var argIndex = 0;
        var message = "Warning: " + format9.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x7) {
        }
      };
      warning = function warning2(condition, format9) {
        if (format9 === void 0) {
          throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
        }
        if (format9.indexOf("Failed Composite propType: ") === 0) {
          return;
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }
          printWarning.apply(void 0, [format9].concat(args));
        }
      };
    }
    var printWarning;
    module4.exports = warning;
  }
});

// node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/CSSPropertyOperations/dangerousStyleValue.js
var require_dangerousStyleValue = __commonJS({
  "node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/CSSPropertyOperations/dangerousStyleValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _CSSProperty = require_CSSProperty();
    var _CSSProperty2 = _interopRequireDefault(_CSSProperty);
    var _warning = require_warning();
    var _warning2 = _interopRequireDefault(_warning);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isUnitlessNumber = _CSSProperty2.default.isUnitlessNumber;
    var styleWarnings = {};
    function dangerousStyleValue(name4, value4, component) {
      var isEmpty2 = value4 == null || typeof value4 === "boolean" || value4 === "";
      if (isEmpty2) {
        return "";
      }
      var isNonNumeric = isNaN(value4);
      if (isNonNumeric || value4 === 0 || isUnitlessNumber.hasOwnProperty(name4) && isUnitlessNumber[name4]) {
        return "" + value4;
      }
      if (typeof value4 === "string") {
        if (true) {
          if (component && value4 !== "0") {
            var owner = component._currentElement._owner;
            var ownerName = owner ? owner.getName() : null;
            if (ownerName && !styleWarnings[ownerName]) {
              styleWarnings[ownerName] = {};
            }
            var warned = false;
            if (ownerName) {
              var warnings = styleWarnings[ownerName];
              warned = warnings[name4];
              if (!warned) {
                warnings[name4] = true;
              }
            }
            if (!warned) {
              true ? (0, _warning2.default)(false, "a `%s` tag (owner: `%s`) was passed a numeric string value for CSS property `%s` (value: `%s`) which will be treated as a unitless number in a future version of React.", component._currentElement.type, ownerName || "unknown", name4, value4) : void 0;
            }
          }
        }
        value4 = value4.trim();
      }
      return value4 + "px";
    }
    exports.default = dangerousStyleValue;
  }
});

// node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/hyphenate.js
var require_hyphenate = __commonJS({
  "node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/hyphenate.js"(exports, module4) {
    "use strict";
    var _uppercasePattern = /([A-Z])/g;
    function hyphenate(string) {
      return string.replace(_uppercasePattern, "-$1").toLowerCase();
    }
    module4.exports = hyphenate;
  }
});

// node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/hyphenateStyleName.js
var require_hyphenateStyleName = __commonJS({
  "node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/hyphenateStyleName.js"(exports, module4) {
    "use strict";
    var hyphenate = require_hyphenate();
    var msPattern2 = /^ms-/;
    function hyphenateStyleName2(string) {
      return hyphenate(string).replace(msPattern2, "-ms-");
    }
    module4.exports = hyphenateStyleName2;
  }
});

// node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/memoizeStringOnly.js
var require_memoizeStringOnly = __commonJS({
  "node_modules/.pnpm/fbjs@0.8.18/node_modules/fbjs/lib/memoizeStringOnly.js"(exports, module4) {
    "use strict";
    function memoizeStringOnly(callback) {
      var cache3 = {};
      return function(string) {
        if (!cache3.hasOwnProperty(string)) {
          cache3[string] = callback.call(this, string);
        }
        return cache3[string];
      };
    }
    module4.exports = memoizeStringOnly;
  }
});

// node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/CSSPropertyOperations/index.js
var require_CSSPropertyOperations = __commonJS({
  "node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/CSSPropertyOperations/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.processStyleName = void 0;
    exports.createMarkupForStyles = createMarkupForStyles;
    var _camelizeStyleName = require_camelizeStyleName();
    var _camelizeStyleName2 = _interopRequireDefault(_camelizeStyleName);
    var _dangerousStyleValue = require_dangerousStyleValue();
    var _dangerousStyleValue2 = _interopRequireDefault(_dangerousStyleValue);
    var _hyphenateStyleName = require_hyphenateStyleName();
    var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
    var _memoizeStringOnly = require_memoizeStringOnly();
    var _memoizeStringOnly2 = _interopRequireDefault(_memoizeStringOnly);
    var _warning = require_warning();
    var _warning2 = _interopRequireDefault(_warning);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var processStyleName = exports.processStyleName = (0, _memoizeStringOnly2.default)(_hyphenateStyleName2.default);
    if (true) {
      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
      badStyleValueWithSemicolonPattern = /;\s*$/;
      warnedStyleNames = {};
      warnedStyleValues = {};
      warnedForNaNValue = false;
      warnHyphenatedStyleName = function warnHyphenatedStyleName2(name4, owner) {
        if (warnedStyleNames.hasOwnProperty(name4) && warnedStyleNames[name4]) {
          return;
        }
        warnedStyleNames[name4] = true;
        true ? (0, _warning2.default)(false, "Unsupported style property %s. Did you mean %s?%s", name4, (0, _camelizeStyleName2.default)(name4), checkRenderMessage(owner)) : void 0;
      };
      warnBadVendoredStyleName = function warnBadVendoredStyleName2(name4, owner) {
        if (warnedStyleNames.hasOwnProperty(name4) && warnedStyleNames[name4]) {
          return;
        }
        warnedStyleNames[name4] = true;
        true ? (0, _warning2.default)(false, "Unsupported vendor-prefixed style property %s. Did you mean %s?%s", name4, name4.charAt(0).toUpperCase() + name4.slice(1), checkRenderMessage(owner)) : void 0;
      };
      warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon2(name4, value4, owner) {
        if (warnedStyleValues.hasOwnProperty(value4) && warnedStyleValues[value4]) {
          return;
        }
        warnedStyleValues[value4] = true;
        true ? (0, _warning2.default)(false, `Style property values shouldn't contain a semicolon.%s Try "%s: %s" instead.`, checkRenderMessage(owner), name4, value4.replace(badStyleValueWithSemicolonPattern, "")) : void 0;
      };
      warnStyleValueIsNaN = function warnStyleValueIsNaN2(name4, value4, owner) {
        if (warnedForNaNValue) {
          return;
        }
        warnedForNaNValue = true;
        true ? (0, _warning2.default)(false, "`NaN` is an invalid value for the `%s` css style property.%s", name4, checkRenderMessage(owner)) : void 0;
      };
      checkRenderMessage = function checkRenderMessage2(owner) {
        if (owner) {
          var name4 = owner.getName();
          if (name4) {
            return " Check the render method of `" + name4 + "`.";
          }
        }
        return "";
      };
      warnValidStyle = function warnValidStyle2(name4, value4, component) {
        var owner = void 0;
        if (component) {
          owner = component._currentElement._owner;
        }
        if (name4.indexOf("-") > -1) {
          warnHyphenatedStyleName(name4, owner);
        } else if (badVendoredStyleNamePattern.test(name4)) {
          warnBadVendoredStyleName(name4, owner);
        } else if (badStyleValueWithSemicolonPattern.test(value4)) {
          warnStyleValueWithSemicolon(name4, value4, owner);
        }
        if (typeof value4 === "number" && isNaN(value4)) {
          warnStyleValueIsNaN(name4, value4, owner);
        }
      };
    }
    var badVendoredStyleNamePattern;
    var badStyleValueWithSemicolonPattern;
    var warnedStyleNames;
    var warnedStyleValues;
    var warnedForNaNValue;
    var warnHyphenatedStyleName;
    var warnBadVendoredStyleName;
    var warnStyleValueWithSemicolon;
    var warnStyleValueIsNaN;
    var checkRenderMessage;
    var warnValidStyle;
    function createMarkupForStyles(styles2, component) {
      var serialized = "";
      for (var styleName in styles2) {
        var isCustomProp = styleName.indexOf("--") === 0;
        if (!styles2.hasOwnProperty(styleName)) {
          continue;
        }
        if (styleName === "label") {
          continue;
        }
        var styleValue2 = styles2[styleName];
        if (!isCustomProp) {
          warnValidStyle(styleName, styleValue2, component);
        }
        if (styleValue2 != null) {
          if (isCustomProp) {
            serialized += styleName + ":" + styleValue2 + ";";
          } else {
            serialized += processStyleName(styleName) + ":";
            serialized += (0, _dangerousStyleValue2.default)(styleName, styleValue2, component) + ";";
          }
        }
      }
      return serialized || null;
    }
  }
});

// node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/clean.js
var require_clean2 = __commonJS({
  "node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/clean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.default = clean;
    function isFalsy(value4) {
      return value4 === null || value4 === void 0 || value4 === false || (typeof value4 === "undefined" ? "undefined" : _typeof(value4)) === "object" && Object.keys(value4).length === 0;
    }
    function cleanObject(object2) {
      if (isFalsy(object2))
        return null;
      if ((typeof object2 === "undefined" ? "undefined" : _typeof(object2)) !== "object")
        return object2;
      var acc = {}, keys5 = Object.keys(object2), hasFalsy = false;
      for (var i = 0; i < keys5.length; i++) {
        var value4 = object2[keys5[i]];
        var filteredValue = clean(value4);
        if (filteredValue === null || filteredValue !== value4) {
          hasFalsy = true;
        }
        if (filteredValue !== null) {
          acc[keys5[i]] = filteredValue;
        }
      }
      return Object.keys(acc).length === 0 ? null : hasFalsy ? acc : object2;
    }
    function cleanArray(rules) {
      var hasFalsy = false;
      var filtered = [];
      rules.forEach(function(rule5) {
        var filteredRule = clean(rule5);
        if (filteredRule === null || filteredRule !== rule5) {
          hasFalsy = true;
        }
        if (filteredRule !== null) {
          filtered.push(filteredRule);
        }
      });
      return filtered.length == 0 ? null : hasFalsy ? filtered : rules;
    }
    function clean(input) {
      return Array.isArray(input) ? cleanArray(input) : cleanObject(input);
    }
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/staticData.js
var require_staticData = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/staticData.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var w5 = ["Webkit"];
    var m2 = ["Moz"];
    var ms = ["ms"];
    var wm = ["Webkit", "Moz"];
    var wms = ["Webkit", "ms"];
    var wmms = ["Webkit", "Moz", "ms"];
    exports.default = {
      plugins: [],
      prefixMap: { "appearance": wm, "userSelect": wmms, "textEmphasisPosition": w5, "textEmphasis": w5, "textEmphasisStyle": w5, "textEmphasisColor": w5, "boxDecorationBreak": w5, "clipPath": w5, "maskImage": w5, "maskMode": w5, "maskRepeat": w5, "maskPosition": w5, "maskClip": w5, "maskOrigin": w5, "maskSize": w5, "maskComposite": w5, "mask": w5, "maskBorderSource": w5, "maskBorderMode": w5, "maskBorderSlice": w5, "maskBorderWidth": w5, "maskBorderOutset": w5, "maskBorderRepeat": w5, "maskBorder": w5, "maskType": w5, "textDecorationStyle": w5, "textDecorationSkip": w5, "textDecorationLine": w5, "textDecorationColor": w5, "filter": w5, "fontFeatureSettings": w5, "breakAfter": wmms, "breakBefore": wmms, "breakInside": wmms, "columnCount": wm, "columnFill": wm, "columnGap": wm, "columnRule": wm, "columnRuleColor": wm, "columnRuleStyle": wm, "columnRuleWidth": wm, "columns": wm, "columnSpan": wm, "columnWidth": wm, "writingMode": wms, "flex": w5, "flexBasis": w5, "flexDirection": w5, "flexGrow": w5, "flexFlow": w5, "flexShrink": w5, "flexWrap": w5, "alignContent": w5, "alignItems": w5, "alignSelf": w5, "justifyContent": w5, "order": w5, "transform": w5, "transformOrigin": w5, "transformOriginX": w5, "transformOriginY": w5, "backfaceVisibility": w5, "perspective": w5, "perspectiveOrigin": w5, "transformStyle": w5, "transformOriginZ": w5, "animation": w5, "animationDelay": w5, "animationDirection": w5, "animationFillMode": w5, "animationDuration": w5, "animationIterationCount": w5, "animationName": w5, "animationPlayState": w5, "animationTimingFunction": w5, "backdropFilter": w5, "fontKerning": w5, "scrollSnapType": wms, "scrollSnapPointsX": wms, "scrollSnapPointsY": wms, "scrollSnapDestination": wms, "scrollSnapCoordinate": wms, "shapeImageThreshold": w5, "shapeImageMargin": w5, "shapeImageOutside": w5, "hyphens": wmms, "flowInto": wms, "flowFrom": wms, "regionFragment": wms, "textAlignLast": m2, "tabSize": m2, "wrapFlow": ms, "wrapThrough": ms, "wrapMargin": ms, "gridTemplateColumns": ms, "gridTemplateRows": ms, "gridTemplateAreas": ms, "gridTemplate": ms, "gridAutoColumns": ms, "gridAutoRows": ms, "gridAutoFlow": ms, "grid": ms, "gridRowStart": ms, "gridColumnStart": ms, "gridRowEnd": ms, "gridRow": ms, "gridColumn": ms, "gridColumnEnd": ms, "gridColumnGap": ms, "gridRowGap": ms, "gridArea": ms, "gridGap": ms, "textSizeAdjust": wms, "borderImage": w5, "borderImageOutset": w5, "borderImageRepeat": w5, "borderImageSlice": w5, "borderImageSource": w5, "borderImageWidth": w5, "transitionDelay": w5, "transitionDuration": w5, "transitionProperty": w5, "transitionTimingFunction": w5 }
    };
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/utils/capitalizeString.js
var require_capitalizeString = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/utils/capitalizeString.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = capitalizeString;
    function capitalizeString(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/utils/prefixProperty.js
var require_prefixProperty = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/utils/prefixProperty.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = prefixProperty;
    var _capitalizeString = require_capitalizeString();
    var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function prefixProperty(prefixProperties, property2, style3) {
      if (prefixProperties.hasOwnProperty(property2)) {
        var requiredPrefixes = prefixProperties[property2];
        for (var i = 0, len = requiredPrefixes.length; i < len; ++i) {
          style3[requiredPrefixes[i] + (0, _capitalizeString2.default)(property2)] = style3[property2];
        }
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/utils/prefixValue.js
var require_prefixValue = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/utils/prefixValue.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = prefixValue;
    function prefixValue(plugins, property2, value4, style3, metaData) {
      for (var i = 0, len = plugins.length; i < len; ++i) {
        var processedValue = plugins[i](property2, value4, style3, metaData);
        if (processedValue) {
          return processedValue;
        }
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/cursor.js
var require_cursor = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/cursor.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = cursor3;
    var prefixes4 = ["-webkit-", "-moz-", ""];
    var values5 = {
      "zoom-in": true,
      "zoom-out": true,
      grab: true,
      grabbing: true
    };
    function cursor3(property2, value4) {
      if (property2 === "cursor" && values5.hasOwnProperty(value4)) {
        return prefixes4.map(function(prefix) {
          return prefix + value4;
        });
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/css-in-js-utils@2.0.1/node_modules/css-in-js-utils/lib/isPrefixedValue.js
var require_isPrefixedValue = __commonJS({
  "node_modules/.pnpm/css-in-js-utils@2.0.1/node_modules/css-in-js-utils/lib/isPrefixedValue.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPrefixedValue;
    var regex = /-webkit-|-moz-|-ms-/;
    function isPrefixedValue(value4) {
      return typeof value4 === "string" && regex.test(value4);
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/crossFade.js
var require_crossFade = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/crossFade.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = crossFade;
    var _isPrefixedValue = require_isPrefixedValue();
    var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var prefixes4 = ["-webkit-", ""];
    function crossFade(property2, value4) {
      if (typeof value4 === "string" && !(0, _isPrefixedValue2.default)(value4) && value4.indexOf("cross-fade(") > -1) {
        return prefixes4.map(function(prefix) {
          return value4.replace(/cross-fade\(/g, prefix + "cross-fade(");
        });
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/filter.js
var require_filter = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/filter.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = filter6;
    var _isPrefixedValue = require_isPrefixedValue();
    var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var prefixes4 = ["-webkit-", ""];
    function filter6(property2, value4) {
      if (typeof value4 === "string" && !(0, _isPrefixedValue2.default)(value4) && value4.indexOf("filter(") > -1) {
        return prefixes4.map(function(prefix) {
          return value4.replace(/filter\(/g, prefix + "filter(");
        });
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/flex.js
var require_flex = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/flex.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = flex;
    var values5 = {
      flex: ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex", "flex"],
      "inline-flex": ["-webkit-inline-box", "-moz-inline-box", "-ms-inline-flexbox", "-webkit-inline-flex", "inline-flex"]
    };
    function flex(property2, value4) {
      if (property2 === "display" && values5.hasOwnProperty(value4)) {
        return values5[value4];
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/flexboxOld.js
var require_flexboxOld = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/flexboxOld.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = flexboxOld;
    var alternativeValues = {
      "space-around": "justify",
      "space-between": "justify",
      "flex-start": "start",
      "flex-end": "end",
      "wrap-reverse": "multiple",
      wrap: "multiple"
    };
    var alternativeProps = {
      alignItems: "WebkitBoxAlign",
      justifyContent: "WebkitBoxPack",
      flexWrap: "WebkitBoxLines"
    };
    function flexboxOld(property2, value4, style3) {
      if (property2 === "flexDirection" && typeof value4 === "string") {
        if (value4.indexOf("column") > -1) {
          style3.WebkitBoxOrient = "vertical";
        } else {
          style3.WebkitBoxOrient = "horizontal";
        }
        if (value4.indexOf("reverse") > -1) {
          style3.WebkitBoxDirection = "reverse";
        } else {
          style3.WebkitBoxDirection = "normal";
        }
      }
      if (alternativeProps.hasOwnProperty(property2)) {
        style3[alternativeProps[property2]] = alternativeValues[value4] || value4;
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/gradient.js
var require_gradient = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/gradient.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = gradient5;
    var _isPrefixedValue = require_isPrefixedValue();
    var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var prefixes4 = ["-webkit-", "-moz-", ""];
    var values5 = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/;
    function gradient5(property2, value4) {
      if (typeof value4 === "string" && !(0, _isPrefixedValue2.default)(value4) && values5.test(value4)) {
        return prefixes4.map(function(prefix) {
          return prefix + value4;
        });
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/imageSet.js
var require_imageSet = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/imageSet.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = imageSet;
    var _isPrefixedValue = require_isPrefixedValue();
    var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var prefixes4 = ["-webkit-", ""];
    function imageSet(property2, value4) {
      if (typeof value4 === "string" && !(0, _isPrefixedValue2.default)(value4) && value4.indexOf("image-set(") > -1) {
        return prefixes4.map(function(prefix) {
          return value4.replace(/image-set\(/g, prefix + "image-set(");
        });
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/position.js
var require_position = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/position.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = position2;
    function position2(property2, value4) {
      if (property2 === "position" && value4 === "sticky") {
        return ["-webkit-sticky", "sticky"];
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/sizing.js
var require_sizing = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/sizing.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = sizing;
    var prefixes4 = ["-webkit-", "-moz-", ""];
    var properties = {
      maxHeight: true,
      maxWidth: true,
      width: true,
      height: true,
      columnWidth: true,
      minWidth: true,
      minHeight: true
    };
    var values5 = {
      "min-content": true,
      "max-content": true,
      "fill-available": true,
      "fit-content": true,
      "contain-floats": true
    };
    function sizing(property2, value4) {
      if (properties.hasOwnProperty(property2) && values5.hasOwnProperty(value4)) {
        return prefixes4.map(function(prefix) {
          return prefix + value4;
        });
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/hyphenate-style-name@1.0.4/node_modules/hyphenate-style-name/index.js
var hyphenate_style_name_exports = {};
__export(hyphenate_style_name_exports, {
  default: () => hyphenate_style_name_default
});
function toHyphenLower(match4) {
  return "-" + match4.toLowerCase();
}
function hyphenateStyleName(name4) {
  if (cache2.hasOwnProperty(name4)) {
    return cache2[name4];
  }
  var hName = name4.replace(uppercasePattern, toHyphenLower);
  return cache2[name4] = msPattern.test(hName) ? "-" + hName : hName;
}
var uppercasePattern, msPattern, cache2, hyphenate_style_name_default;
var init_hyphenate_style_name = __esm({
  "node_modules/.pnpm/hyphenate-style-name@1.0.4/node_modules/hyphenate-style-name/index.js"() {
    uppercasePattern = /[A-Z]/g;
    msPattern = /^ms-/;
    cache2 = {};
    hyphenate_style_name_default = hyphenateStyleName;
  }
});

// node_modules/.pnpm/css-in-js-utils@2.0.1/node_modules/css-in-js-utils/lib/hyphenateProperty.js
var require_hyphenateProperty = __commonJS({
  "node_modules/.pnpm/css-in-js-utils@2.0.1/node_modules/css-in-js-utils/lib/hyphenateProperty.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = hyphenateProperty;
    var _hyphenateStyleName = (init_hyphenate_style_name(), __toCommonJS(hyphenate_style_name_exports));
    var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function hyphenateProperty(property2) {
      return (0, _hyphenateStyleName2.default)(property2);
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/transition.js
var require_transition = __commonJS({
  "node_modules/.pnpm/inline-style-prefixer@3.0.8/node_modules/inline-style-prefixer/static/plugins/transition.js"(exports, module4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = transition;
    var _hyphenateProperty = require_hyphenateProperty();
    var _hyphenateProperty2 = _interopRequireDefault(_hyphenateProperty);
    var _isPrefixedValue = require_isPrefixedValue();
    var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
    var _capitalizeString = require_capitalizeString();
    var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var properties = {
      transition: true,
      transitionProperty: true,
      WebkitTransition: true,
      WebkitTransitionProperty: true,
      MozTransition: true,
      MozTransitionProperty: true
    };
    var prefixMapping = {
      Webkit: "-webkit-",
      Moz: "-moz-",
      ms: "-ms-"
    };
    function prefixValue(value4, propertyPrefixMap) {
      if ((0, _isPrefixedValue2.default)(value4)) {
        return value4;
      }
      var multipleValues = value4.split(/,(?![^()]*(?:\([^()]*\))?\))/g);
      for (var i = 0, len = multipleValues.length; i < len; ++i) {
        var singleValue = multipleValues[i];
        var values5 = [singleValue];
        for (var property2 in propertyPrefixMap) {
          var dashCaseProperty = (0, _hyphenateProperty2.default)(property2);
          if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== "order") {
            var prefixes4 = propertyPrefixMap[property2];
            for (var j = 0, pLen = prefixes4.length; j < pLen; ++j) {
              values5.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes4[j]] + dashCaseProperty));
            }
          }
        }
        multipleValues[i] = values5.join(",");
      }
      return multipleValues.join(",");
    }
    function transition(property2, value4, style3, propertyPrefixMap) {
      if (typeof value4 === "string" && properties.hasOwnProperty(property2)) {
        var outputValue = prefixValue(value4, propertyPrefixMap);
        var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(val) {
          return !/-moz-|-ms-/.test(val);
        }).join(",");
        if (property2.indexOf("Webkit") > -1) {
          return webkitOutput;
        }
        var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(val) {
          return !/-webkit-|-ms-/.test(val);
        }).join(",");
        if (property2.indexOf("Moz") > -1) {
          return mozOutput;
        }
        style3["Webkit" + (0, _capitalizeString2.default)(property2)] = webkitOutput;
        style3["Moz" + (0, _capitalizeString2.default)(property2)] = mozOutput;
        return outputValue;
      }
    }
    module4.exports = exports["default"];
  }
});

// node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/prefixer.js
var require_prefixer = __commonJS({
  "node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/prefixer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = prefixer;
    var _staticData = require_staticData();
    var _staticData2 = _interopRequireDefault(_staticData);
    var _prefixProperty = require_prefixProperty();
    var _prefixProperty2 = _interopRequireDefault(_prefixProperty);
    var _prefixValue = require_prefixValue();
    var _prefixValue2 = _interopRequireDefault(_prefixValue);
    var _cursor = require_cursor();
    var _cursor2 = _interopRequireDefault(_cursor);
    var _crossFade = require_crossFade();
    var _crossFade2 = _interopRequireDefault(_crossFade);
    var _filter = require_filter();
    var _filter2 = _interopRequireDefault(_filter);
    var _flex = require_flex();
    var _flex2 = _interopRequireDefault(_flex);
    var _flexboxOld = require_flexboxOld();
    var _flexboxOld2 = _interopRequireDefault(_flexboxOld);
    var _gradient = require_gradient();
    var _gradient2 = _interopRequireDefault(_gradient);
    var _imageSet = require_imageSet();
    var _imageSet2 = _interopRequireDefault(_imageSet);
    var _position = require_position();
    var _position2 = _interopRequireDefault(_position);
    var _sizing = require_sizing();
    var _sizing2 = _interopRequireDefault(_sizing);
    var _transition = require_transition();
    var _transition2 = _interopRequireDefault(_transition);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var plugins = [_crossFade2.default, _cursor2.default, _filter2.default, _flexboxOld2.default, _gradient2.default, _imageSet2.default, _position2.default, _sizing2.default, _transition2.default, _flex2.default];
    var prefixMap = _staticData2.default.prefixMap;
    function prefixer(style3) {
      for (var property2 in style3) {
        var value4 = style3[property2];
        var processedValue = (0, _prefixValue2.default)(plugins, property2, value4, style3, prefixMap);
        if (processedValue) {
          style3[property2] = processedValue;
        }
        (0, _prefixProperty2.default)(prefixMap, property2, style3);
      }
      return style3;
    }
  }
});

// node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/plugins.js
var require_plugins = __commonJS({
  "node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/plugins.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _extends = Object.assign || function(target2) {
      for (var i = 1; i < arguments.length; i++) {
        var source5 = arguments[i];
        for (var key3 in source5) {
          if (Object.prototype.hasOwnProperty.call(source5, key3)) {
            target2[key3] = source5[key3];
          }
        }
      }
      return target2;
    };
    exports.PluginSet = PluginSet;
    exports.fallbacks = fallbacks;
    exports.contentWrap = contentWrap;
    exports.prefixes = prefixes4;
    var _objectAssign = require_object_assign();
    var _objectAssign2 = _interopRequireDefault(_objectAssign);
    var _CSSPropertyOperations = require_CSSPropertyOperations();
    var _prefixer = require_prefixer();
    var _prefixer2 = _interopRequireDefault(_prefixer);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isDev = function(x7) {
      return x7 === "development" || !x7;
    }("development");
    function PluginSet(initial) {
      this.fns = initial || [];
    }
    (0, _objectAssign2.default)(PluginSet.prototype, {
      add: function add7() {
        var _this = this;
        for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
          fns[_key] = arguments[_key];
        }
        fns.forEach(function(fn) {
          if (_this.fns.indexOf(fn) >= 0) {
            if (isDev) {
              console.warn("adding the same plugin again, ignoring");
            }
          } else {
            _this.fns = [fn].concat(_this.fns);
          }
        });
      },
      remove: function remove3(fn) {
        this.fns = this.fns.filter(function(x7) {
          return x7 !== fn;
        });
      },
      clear: function clear2() {
        this.fns = [];
      },
      transform: function transform4(o) {
        return this.fns.reduce(function(o2, fn) {
          return fn(o2);
        }, o);
      }
    });
    function fallbacks(node) {
      var hasArray = Object.keys(node.style).map(function(x7) {
        return Array.isArray(node.style[x7]);
      }).indexOf(true) >= 0;
      if (hasArray) {
        var style3 = node.style;
        var flattened = Object.keys(style3).reduce(function(o, key3) {
          o[key3] = Array.isArray(style3[key3]) ? style3[key3].join("; " + (0, _CSSPropertyOperations.processStyleName)(key3) + ": ") : style3[key3];
          return o;
        }, {});
        return (0, _objectAssign2.default)({}, node, { style: flattened });
      }
      return node;
    }
    var contentValues = ["normal", "none", "counter", "open-quote", "close-quote", "no-open-quote", "no-close-quote", "initial", "inherit"];
    function contentWrap(node) {
      if (node.style.content) {
        var cont = node.style.content;
        if (contentValues.indexOf(cont) >= 0) {
          return node;
        }
        if (/^(attr|calc|counters?|url)\(/.test(cont)) {
          return node;
        }
        if (cont.charAt(0) === cont.charAt(cont.length - 1) && (cont.charAt(0) === '"' || cont.charAt(0) === "'")) {
          return node;
        }
        return _extends({}, node, { style: _extends({}, node.style, { content: '"' + cont + '"' }) });
      }
      return node;
    }
    function prefixes4(node) {
      return (0, _objectAssign2.default)({}, node, { style: (0, _prefixer2.default)(_extends({}, node.style)) });
    }
  }
});

// node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/hash.js
var require_hash = __commonJS({
  "node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doHash;
    function doHash(str, seed) {
      var m2 = 1540483477;
      var r2 = 24;
      var h4 = seed ^ str.length;
      var length4 = str.length;
      var currentIndex = 0;
      while (length4 >= 4) {
        var k4 = UInt32(str, currentIndex);
        k4 = Umul32(k4, m2);
        k4 ^= k4 >>> r2;
        k4 = Umul32(k4, m2);
        h4 = Umul32(h4, m2);
        h4 ^= k4;
        currentIndex += 4;
        length4 -= 4;
      }
      switch (length4) {
        case 3:
          h4 ^= UInt16(str, currentIndex);
          h4 ^= str.charCodeAt(currentIndex + 2) << 16;
          h4 = Umul32(h4, m2);
          break;
        case 2:
          h4 ^= UInt16(str, currentIndex);
          h4 = Umul32(h4, m2);
          break;
        case 1:
          h4 ^= str.charCodeAt(currentIndex);
          h4 = Umul32(h4, m2);
          break;
      }
      h4 ^= h4 >>> 13;
      h4 = Umul32(h4, m2);
      h4 ^= h4 >>> 15;
      return h4 >>> 0;
    }
    function UInt32(str, pos) {
      return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8) + (str.charCodeAt(pos++) << 16) + (str.charCodeAt(pos) << 24);
    }
    function UInt16(str, pos) {
      return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8);
    }
    function Umul32(n, m2) {
      n = n | 0;
      m2 = m2 | 0;
      var nlo = n & 65535;
      var nhi = n >>> 16;
      var res = nlo * m2 + ((nhi * m2 & 65535) << 16) | 0;
      return res;
    }
  }
});

// node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/glamor@2.20.40/node_modules/glamor/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.compose = exports.merge = exports.$ = exports.style = exports.presets = exports.keyframes = exports.fontFace = exports.insertGlobal = exports.insertRule = exports.plugins = exports.styleSheet = void 0;
    exports.speedy = speedy;
    exports.simulations = simulations;
    exports.simulate = simulate;
    exports.cssLabels = cssLabels;
    exports.isLikeRule = isLikeRule;
    exports.idFor = idFor;
    exports.css = css;
    exports.rehydrate = rehydrate;
    exports.flush = flush2;
    exports.select = select2;
    exports.parent = parent;
    exports.media = media;
    exports.pseudo = pseudo;
    exports.active = active;
    exports.any = any;
    exports.checked = checked;
    exports.disabled = disabled;
    exports.empty = empty3;
    exports.enabled = enabled;
    exports._default = _default;
    exports.first = first;
    exports.firstChild = firstChild;
    exports.firstOfType = firstOfType;
    exports.fullscreen = fullscreen;
    exports.focus = focus;
    exports.hover = hover2;
    exports.indeterminate = indeterminate;
    exports.inRange = inRange;
    exports.invalid = invalid;
    exports.lastChild = lastChild;
    exports.lastOfType = lastOfType;
    exports.left = left;
    exports.link = link3;
    exports.onlyChild = onlyChild;
    exports.onlyOfType = onlyOfType;
    exports.optional = optional2;
    exports.outOfRange = outOfRange;
    exports.readOnly = readOnly;
    exports.readWrite = readWrite;
    exports.required = required2;
    exports.right = right;
    exports.root = root2;
    exports.scope = scope;
    exports.target = target2;
    exports.valid = valid;
    exports.visited = visited;
    exports.dir = dir;
    exports.lang = lang;
    exports.not = not;
    exports.nthChild = nthChild;
    exports.nthLastChild = nthLastChild;
    exports.nthLastOfType = nthLastOfType;
    exports.nthOfType = nthOfType;
    exports.after = after;
    exports.before = before;
    exports.firstLetter = firstLetter;
    exports.firstLine = firstLine;
    exports.selection = selection2;
    exports.backdrop = backdrop;
    exports.placeholder = placeholder;
    exports.cssFor = cssFor;
    exports.attribsFor = attribsFor;
    var _objectAssign = require_object_assign();
    var _objectAssign2 = _interopRequireDefault(_objectAssign);
    var _sheet = require_sheet();
    var _CSSPropertyOperations = require_CSSPropertyOperations();
    var _clean = require_clean2();
    var _clean2 = _interopRequireDefault(_clean);
    var _plugins = require_plugins();
    var _hash = require_hash();
    var _hash2 = _interopRequireDefault(_hash);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function _defineProperty(obj, key3, value4) {
      if (key3 in obj) {
        Object.defineProperty(obj, key3, { value: value4, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key3] = value4;
      }
      return obj;
    }
    var styleSheet = exports.styleSheet = new _sheet.StyleSheet();
    styleSheet.inject();
    function speedy(bool) {
      return styleSheet.speedy(bool);
    }
    var plugins = exports.plugins = styleSheet.plugins = new _plugins.PluginSet([_plugins.prefixes, _plugins.contentWrap, _plugins.fallbacks]);
    plugins.media = new _plugins.PluginSet();
    plugins.fontFace = new _plugins.PluginSet();
    plugins.keyframes = new _plugins.PluginSet([_plugins.prefixes, _plugins.fallbacks]);
    var isDev = true;
    var isTest = false;
    var isBrowser = typeof window !== "undefined";
    var canSimulate = isDev;
    var warned1 = false;
    var warned2 = false;
    function simulations() {
      var bool = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      canSimulate = !!bool;
    }
    function simulate() {
      for (var _len = arguments.length, pseudos = Array(_len), _key = 0; _key < _len; _key++) {
        pseudos[_key] = arguments[_key];
      }
      pseudos = (0, _clean2.default)(pseudos);
      if (!pseudos)
        return {};
      if (!canSimulate) {
        if (!warned1) {
          console.warn("can't simulate without once calling simulations(true)");
          warned1 = true;
        }
        if (!isDev && !isTest && !warned2) {
          console.warn("don't use simulation outside dev");
          warned2 = true;
        }
        return {};
      }
      return pseudos.reduce(function(o, p) {
        return o["data-simulate-" + simple(p)] = "", o;
      }, {});
    }
    var hasLabels = isDev;
    function cssLabels(bool) {
      hasLabels = !!bool;
    }
    function simple(str) {
      var char = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      return str.toLowerCase().replace(/[^a-z0-9]/g, char);
    }
    function hashify(obj) {
      var str = JSON.stringify(obj);
      var toRet = (0, _hash2.default)(str).toString(36);
      if (obj.label && obj.label.length > 0 && isDev) {
        return simple(obj.label.join("."), "-") + "-" + toRet;
      }
      return toRet;
    }
    function isLikeRule(rule5) {
      var keys5 = Object.keys(rule5).filter(function(x7) {
        return x7 !== "toString";
      });
      if (keys5.length !== 1) {
        return false;
      }
      return !!/data\-css\-([a-zA-Z0-9\-_]+)/.exec(keys5[0]);
    }
    function idFor(rule5) {
      var keys5 = Object.keys(rule5).filter(function(x7) {
        return x7 !== "toString";
      });
      if (keys5.length !== 1)
        throw new Error("not a rule");
      var regex = /data\-css\-([a-zA-Z0-9\-_]+)/;
      var match4 = regex.exec(keys5[0]);
      if (!match4)
        throw new Error("not a rule");
      return match4[1];
    }
    var selectorTokenizer = /[(),]|"(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\//g;
    function splitSelector(selector2) {
      if (selector2.indexOf(",") === -1) {
        return [selector2];
      }
      var indices = [], res = [], inParen = 0, o;
      while (o = selectorTokenizer.exec(selector2)) {
        switch (o[0]) {
          case "(":
            inParen++;
            break;
          case ")":
            inParen--;
            break;
          case ",":
            if (inParen)
              break;
            indices.push(o.index);
        }
      }
      for (o = indices.length; o--; ) {
        res.unshift(selector2.slice(indices[o] + 1));
        selector2 = selector2.slice(0, indices[o]);
      }
      res.unshift(selector2);
      return res;
    }
    function selector(id4, path5) {
      if (!id4) {
        return path5.replace(/\&/g, "");
      }
      if (!path5)
        return ".css-" + id4 + ",[data-css-" + id4 + "]";
      var x7 = splitSelector(path5).map(function(x8) {
        return x8.indexOf("&") >= 0 ? [x8.replace(/\&/mg, ".css-" + id4), x8.replace(/\&/mg, "[data-css-" + id4 + "]")].join(",") : ".css-" + id4 + x8 + ",[data-css-" + id4 + "]" + x8;
      }).join(",");
      if (canSimulate && /^\&\:/.exec(path5) && !/\s/.exec(path5)) {
        x7 += ",.css-" + id4 + "[data-simulate-" + simple(path5) + "],[data-css-" + id4 + "][data-simulate-" + simple(path5) + "]";
      }
      return x7;
    }
    function toCSS(_ref) {
      var selector2 = _ref.selector, style4 = _ref.style;
      var result = plugins.transform({ selector: selector2, style: style4 });
      return result.selector + "{" + (0, _CSSPropertyOperations.createMarkupForStyles)(result.style) + "}";
    }
    function deconstruct(style4) {
      var plain = void 0, selects = void 0, medias = void 0, supports = void 0;
      Object.keys(style4).forEach(function(key3) {
        if (key3.indexOf("&") >= 0) {
          selects = selects || {};
          selects[key3] = style4[key3];
        } else if (key3.indexOf("@media") === 0) {
          medias = medias || {};
          medias[key3] = deconstruct(style4[key3]);
        } else if (key3.indexOf("@supports") === 0) {
          supports = supports || {};
          supports[key3] = deconstruct(style4[key3]);
        } else if (key3 === "label") {
          if (style4.label.length > 0) {
            plain = plain || {};
            plain.label = hasLabels ? style4.label.join(".") : "";
          }
        } else {
          plain = plain || {};
          plain[key3] = style4[key3];
        }
      });
      return { plain, selects, medias, supports };
    }
    function deconstructedStyleToCSS(id4, style4) {
      var css2 = [];
      var plain = style4.plain, selects = style4.selects, medias = style4.medias, supports = style4.supports;
      if (plain) {
        css2.push(toCSS({ style: plain, selector: selector(id4) }));
      }
      if (selects) {
        Object.keys(selects).forEach(function(key3) {
          return css2.push(toCSS({ style: selects[key3], selector: selector(id4, key3) }));
        });
      }
      if (medias) {
        Object.keys(medias).forEach(function(key3) {
          return css2.push(key3 + "{" + deconstructedStyleToCSS(id4, medias[key3]).join("") + "}");
        });
      }
      if (supports) {
        Object.keys(supports).forEach(function(key3) {
          return css2.push(key3 + "{" + deconstructedStyleToCSS(id4, supports[key3]).join("") + "}");
        });
      }
      return css2;
    }
    var inserted = styleSheet.inserted = {};
    function insert2(spec) {
      if (!inserted[spec.id]) {
        inserted[spec.id] = true;
        var deconstructed = deconstruct(spec.style);
        var rules = deconstructedStyleToCSS(spec.id, deconstructed);
        inserted[spec.id] = isBrowser ? true : rules;
        rules.forEach(function(cssRule) {
          return styleSheet.insert(cssRule);
        });
      }
    }
    var registered = styleSheet.registered = {};
    function register(spec) {
      if (!registered[spec.id]) {
        registered[spec.id] = spec;
      }
    }
    function _getRegistered(rule5) {
      if (isLikeRule(rule5)) {
        var ret = registered[idFor(rule5)];
        if (ret == null) {
          throw new Error("[glamor] an unexpected rule cache miss occurred. This is probably a sign of multiple glamor instances in your app. See https://github.com/threepointone/glamor/issues/79");
        }
        return ret;
      }
      return rule5;
    }
    var ruleCache = {};
    function toRule(spec) {
      register(spec);
      insert2(spec);
      if (ruleCache[spec.id]) {
        return ruleCache[spec.id];
      }
      var ret = _defineProperty({}, "data-css-" + spec.id, hasLabels ? spec.label || "" : "");
      Object.defineProperty(ret, "toString", {
        enumerable: false,
        value: function value4() {
          return "css-" + spec.id;
        }
      });
      ruleCache[spec.id] = ret;
      return ret;
    }
    function isSelector(key3) {
      var possibles = [":", ".", "[", ">", " "], found = false, ch2 = key3.charAt(0);
      for (var i = 0; i < possibles.length; i++) {
        if (ch2 === possibles[i]) {
          found = true;
          break;
        }
      }
      return found || key3.indexOf("&") >= 0;
    }
    function joinSelectors(a4, b3) {
      var as = splitSelector(a4).map(function(a5) {
        return !(a5.indexOf("&") >= 0) ? "&" + a5 : a5;
      });
      var bs = splitSelector(b3).map(function(b4) {
        return !(b4.indexOf("&") >= 0) ? "&" + b4 : b4;
      });
      return bs.reduce(function(arr, b4) {
        return arr.concat(as.map(function(a5) {
          return b4.replace(/\&/g, a5);
        }));
      }, []).join(",");
    }
    function joinMediaQueries(a4, b3) {
      return a4 ? "@media " + a4.substring(6) + " and " + b3.substring(6) : b3;
    }
    function isMediaQuery(key3) {
      return key3.indexOf("@media") === 0;
    }
    function isSupports(key3) {
      return key3.indexOf("@supports") === 0;
    }
    function joinSupports(a4, b3) {
      return a4 ? "@supports " + a4.substring(9) + " and " + b3.substring(9) : b3;
    }
    function flatten2(inArr) {
      var arr = [];
      for (var i = 0; i < inArr.length; i++) {
        if (Array.isArray(inArr[i]))
          arr = arr.concat(flatten2(inArr[i]));
        else
          arr = arr.concat(inArr[i]);
      }
      return arr;
    }
    var prefixedPseudoSelectors = {
      "::placeholder": ["::-webkit-input-placeholder", "::-moz-placeholder", "::-ms-input-placeholder"],
      ":fullscreen": [":-webkit-full-screen", ":-moz-full-screen", ":-ms-fullscreen"]
    };
    function build(dest, _ref2) {
      var _ref2$selector = _ref2.selector, selector2 = _ref2$selector === void 0 ? "" : _ref2$selector, _ref2$mq = _ref2.mq, mq = _ref2$mq === void 0 ? "" : _ref2$mq, _ref2$supp = _ref2.supp, supp = _ref2$supp === void 0 ? "" : _ref2$supp, _ref2$src = _ref2.src, src = _ref2$src === void 0 ? {} : _ref2$src;
      if (!Array.isArray(src)) {
        src = [src];
      }
      src = flatten2(src);
      src.forEach(function(_src) {
        if (isLikeRule(_src)) {
          var reg = _getRegistered(_src);
          if (reg.type !== "css") {
            throw new Error("cannot merge this rule");
          }
          _src = reg.style;
        }
        _src = (0, _clean2.default)(_src);
        if (_src && _src.composes) {
          build(dest, { selector: selector2, mq, supp, src: _src.composes });
        }
        Object.keys(_src || {}).forEach(function(key3) {
          if (isSelector(key3)) {
            if (prefixedPseudoSelectors[key3]) {
              prefixedPseudoSelectors[key3].forEach(function(p) {
                return build(dest, { selector: joinSelectors(selector2, p), mq, supp, src: _src[key3] });
              });
            }
            build(dest, { selector: joinSelectors(selector2, key3), mq, supp, src: _src[key3] });
          } else if (isMediaQuery(key3)) {
            build(dest, { selector: selector2, mq: joinMediaQueries(mq, key3), supp, src: _src[key3] });
          } else if (isSupports(key3)) {
            build(dest, { selector: selector2, mq, supp: joinSupports(supp, key3), src: _src[key3] });
          } else if (key3 === "composes") {
          } else {
            var _dest = dest;
            if (supp) {
              _dest[supp] = _dest[supp] || {};
              _dest = _dest[supp];
            }
            if (mq) {
              _dest[mq] = _dest[mq] || {};
              _dest = _dest[mq];
            }
            if (selector2) {
              _dest[selector2] = _dest[selector2] || {};
              _dest = _dest[selector2];
            }
            if (key3 === "label") {
              if (hasLabels) {
                dest.label = dest.label.concat(_src.label);
              }
            } else {
              _dest[key3] = _src[key3];
            }
          }
        });
      });
    }
    function _css(rules) {
      var style4 = { label: [] };
      build(style4, { src: rules });
      var spec = {
        id: hashify(style4),
        style: style4,
        label: hasLabels ? style4.label.join(".") : "",
        type: "css"
      };
      return toRule(spec);
    }
    var nullrule = {};
    Object.defineProperty(nullrule, "toString", {
      enumerable: false,
      value: function value4() {
        return "css-nil";
      }
    });
    var inputCaches = typeof WeakMap !== "undefined" ? [nullrule, /* @__PURE__ */ new WeakMap(), /* @__PURE__ */ new WeakMap(), /* @__PURE__ */ new WeakMap()] : [nullrule];
    var warnedWeakMapError = false;
    function multiIndexCache(fn) {
      return function(args) {
        if (inputCaches[args.length]) {
          var coi = inputCaches[args.length];
          var ctr = 0;
          while (ctr < args.length - 1) {
            if (!coi.has(args[ctr])) {
              coi.set(args[ctr], /* @__PURE__ */ new WeakMap());
            }
            coi = coi.get(args[ctr]);
            ctr++;
          }
          if (coi.has(args[args.length - 1])) {
            var ret = coi.get(args[ctr]);
            if (registered[ret.toString().substring(4)]) {
              return ret;
            }
          }
        }
        var value4 = fn(args);
        if (inputCaches[args.length]) {
          var _ctr = 0, _coi = inputCaches[args.length];
          while (_ctr < args.length - 1) {
            _coi = _coi.get(args[_ctr]);
            _ctr++;
          }
          try {
            _coi.set(args[_ctr], value4);
          } catch (err) {
            if (isDev && !warnedWeakMapError) {
              var _console;
              warnedWeakMapError = true;
              (_console = console).warn.apply(_console, ["failed setting the WeakMap cache for args:"].concat(_toConsumableArray(args)));
              console.warn("this should NOT happen, please file a bug on the github repo.");
            }
          }
        }
        return value4;
      };
    }
    var cachedCss = typeof WeakMap !== "undefined" ? multiIndexCache(_css) : _css;
    function css() {
      for (var _len2 = arguments.length, rules = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        rules[_key2] = arguments[_key2];
      }
      if (rules[0] && rules[0].length && rules[0].raw) {
        throw new Error("you forgot to include glamor/babel in your babel plugins.");
      }
      rules = (0, _clean2.default)(rules);
      if (!rules) {
        return nullrule;
      }
      return cachedCss(rules);
    }
    css.insert = function(css2) {
      var spec = {
        id: hashify(css2),
        css: css2,
        type: "raw"
      };
      register(spec);
      if (!inserted[spec.id]) {
        styleSheet.insert(spec.css);
        inserted[spec.id] = isBrowser ? true : [spec.css];
      }
    };
    var insertRule = exports.insertRule = css.insert;
    css.global = function(selector2, style4) {
      style4 = (0, _clean2.default)(style4);
      if (style4) {
        return css.insert(toCSS({ selector: selector2, style: style4 }));
      }
    };
    var insertGlobal = exports.insertGlobal = css.global;
    function insertKeyframe(spec) {
      if (!inserted[spec.id]) {
        var inner = Object.keys(spec.keyframes).map(function(kf) {
          var result = plugins.keyframes.transform({ id: spec.id, name: kf, style: spec.keyframes[kf] });
          return result.name + "{" + (0, _CSSPropertyOperations.createMarkupForStyles)(result.style) + "}";
        }).join("");
        var rules = ["-webkit-", "-moz-", "-o-", ""].map(function(prefix) {
          return "@" + prefix + "keyframes " + (spec.name + "_" + spec.id) + "{" + inner + "}";
        });
        rules.forEach(function(rule5) {
          return styleSheet.insert(rule5);
        });
        inserted[spec.id] = isBrowser ? true : rules;
      }
    }
    css.keyframes = function(name4, kfs) {
      if (!kfs) {
        kfs = name4, name4 = "animation";
      }
      kfs = (0, _clean2.default)(kfs) || {};
      var spec = {
        id: hashify({ name: name4, kfs }),
        type: "keyframes",
        name: name4,
        keyframes: kfs
      };
      register(spec);
      insertKeyframe(spec);
      return name4 + "_" + spec.id;
    };
    css.fontFace = function(font4) {
      font4 = (0, _clean2.default)(font4);
      var spec = {
        id: hashify(font4),
        type: "font-face",
        font: font4
      };
      register(spec);
      insertFontFace(spec);
      return font4.fontFamily;
    };
    var fontFace = exports.fontFace = css.fontFace;
    var keyframes = exports.keyframes = css.keyframes;
    function insertFontFace(spec) {
      if (!inserted[spec.id]) {
        var rule5 = "@font-face{" + (0, _CSSPropertyOperations.createMarkupForStyles)(spec.font) + "}";
        styleSheet.insert(rule5);
        inserted[spec.id] = isBrowser ? true : [rule5];
      }
    }
    function rehydrate(ids) {
      (0, _objectAssign2.default)(inserted, ids.reduce(function(o, i) {
        return o[i] = true, o;
      }, {}));
    }
    function flush2() {
      inserted = styleSheet.inserted = {};
      registered = styleSheet.registered = {};
      ruleCache = {};
      styleSheet.flush();
      styleSheet.inject();
    }
    var presets = exports.presets = {
      mobile: "(min-width: 400px)",
      Mobile: "@media (min-width: 400px)",
      phablet: "(min-width: 550px)",
      Phablet: "@media (min-width: 550px)",
      tablet: "(min-width: 750px)",
      Tablet: "@media (min-width: 750px)",
      desktop: "(min-width: 1000px)",
      Desktop: "@media (min-width: 1000px)",
      hd: "(min-width: 1200px)",
      Hd: "@media (min-width: 1200px)"
    };
    var style3 = exports.style = css;
    function select2(selector2) {
      for (var _len3 = arguments.length, styles2 = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        styles2[_key3 - 1] = arguments[_key3];
      }
      if (!selector2) {
        return style3(styles2);
      }
      return css(_defineProperty({}, selector2, styles2));
    }
    var $4 = exports.$ = select2;
    function parent(selector2) {
      for (var _len4 = arguments.length, styles2 = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        styles2[_key4 - 1] = arguments[_key4];
      }
      return css(_defineProperty({}, selector2 + " &", styles2));
    }
    var merge7 = exports.merge = css;
    var compose = exports.compose = css;
    function media(query) {
      for (var _len5 = arguments.length, rules = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        rules[_key5 - 1] = arguments[_key5];
      }
      return css(_defineProperty({}, "@media " + query, rules));
    }
    function pseudo(selector2) {
      for (var _len6 = arguments.length, styles2 = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        styles2[_key6 - 1] = arguments[_key6];
      }
      return css(_defineProperty({}, selector2, styles2));
    }
    function active(x7) {
      return pseudo(":active", x7);
    }
    function any(x7) {
      return pseudo(":any", x7);
    }
    function checked(x7) {
      return pseudo(":checked", x7);
    }
    function disabled(x7) {
      return pseudo(":disabled", x7);
    }
    function empty3(x7) {
      return pseudo(":empty", x7);
    }
    function enabled(x7) {
      return pseudo(":enabled", x7);
    }
    function _default(x7) {
      return pseudo(":default", x7);
    }
    function first(x7) {
      return pseudo(":first", x7);
    }
    function firstChild(x7) {
      return pseudo(":first-child", x7);
    }
    function firstOfType(x7) {
      return pseudo(":first-of-type", x7);
    }
    function fullscreen(x7) {
      return pseudo(":fullscreen", x7);
    }
    function focus(x7) {
      return pseudo(":focus", x7);
    }
    function hover2(x7) {
      return pseudo(":hover", x7);
    }
    function indeterminate(x7) {
      return pseudo(":indeterminate", x7);
    }
    function inRange(x7) {
      return pseudo(":in-range", x7);
    }
    function invalid(x7) {
      return pseudo(":invalid", x7);
    }
    function lastChild(x7) {
      return pseudo(":last-child", x7);
    }
    function lastOfType(x7) {
      return pseudo(":last-of-type", x7);
    }
    function left(x7) {
      return pseudo(":left", x7);
    }
    function link3(x7) {
      return pseudo(":link", x7);
    }
    function onlyChild(x7) {
      return pseudo(":only-child", x7);
    }
    function onlyOfType(x7) {
      return pseudo(":only-of-type", x7);
    }
    function optional2(x7) {
      return pseudo(":optional", x7);
    }
    function outOfRange(x7) {
      return pseudo(":out-of-range", x7);
    }
    function readOnly(x7) {
      return pseudo(":read-only", x7);
    }
    function readWrite(x7) {
      return pseudo(":read-write", x7);
    }
    function required2(x7) {
      return pseudo(":required", x7);
    }
    function right(x7) {
      return pseudo(":right", x7);
    }
    function root2(x7) {
      return pseudo(":root", x7);
    }
    function scope(x7) {
      return pseudo(":scope", x7);
    }
    function target2(x7) {
      return pseudo(":target", x7);
    }
    function valid(x7) {
      return pseudo(":valid", x7);
    }
    function visited(x7) {
      return pseudo(":visited", x7);
    }
    function dir(p, x7) {
      return pseudo(":dir(" + p + ")", x7);
    }
    function lang(p, x7) {
      return pseudo(":lang(" + p + ")", x7);
    }
    function not(p, x7) {
      var selector2 = p.split(",").map(function(x8) {
        return x8.trim();
      }).map(function(x8) {
        return ":not(" + x8 + ")";
      });
      if (selector2.length === 1) {
        return pseudo(":not(" + p + ")", x7);
      }
      return select2(selector2.join(""), x7);
    }
    function nthChild(p, x7) {
      return pseudo(":nth-child(" + p + ")", x7);
    }
    function nthLastChild(p, x7) {
      return pseudo(":nth-last-child(" + p + ")", x7);
    }
    function nthLastOfType(p, x7) {
      return pseudo(":nth-last-of-type(" + p + ")", x7);
    }
    function nthOfType(p, x7) {
      return pseudo(":nth-of-type(" + p + ")", x7);
    }
    function after(x7) {
      return pseudo("::after", x7);
    }
    function before(x7) {
      return pseudo("::before", x7);
    }
    function firstLetter(x7) {
      return pseudo("::first-letter", x7);
    }
    function firstLine(x7) {
      return pseudo("::first-line", x7);
    }
    function selection2(x7) {
      return pseudo("::selection", x7);
    }
    function backdrop(x7) {
      return pseudo("::backdrop", x7);
    }
    function placeholder(x7) {
      return css({ "::placeholder": x7 });
    }
    function cssFor() {
      for (var _len7 = arguments.length, rules = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        rules[_key7] = arguments[_key7];
      }
      rules = (0, _clean2.default)(rules);
      return rules ? rules.map(function(r2) {
        var style4 = { label: [] };
        build(style4, { src: r2 });
        return deconstructedStyleToCSS(hashify(style4), deconstruct(style4)).join("");
      }).join("") : "";
    }
    function attribsFor() {
      for (var _len8 = arguments.length, rules = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        rules[_key8] = arguments[_key8];
      }
      rules = (0, _clean2.default)(rules);
      var htmlAttributes = rules ? rules.map(function(rule5) {
        idFor(rule5);
        var key3 = Object.keys(rule5)[0], value4 = rule5[key3];
        return key3 + '="' + (value4 || "") + '"';
      }).join(" ") : "";
      return htmlAttributes;
    }
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSurfaceInfo(drawable) {
      if (drawable.name != null) {
        return true;
      }
      return false;
    }
    exports.isSurfaceInfo = isSurfaceInfo;
    function isSurface(drawable) {
      if (drawable.drawArea instanceof HTMLElement) {
        return true;
      }
      return false;
    }
    exports.isSurface = isSurface;
  }
});

// node_modules/.pnpm/preact@8.2.9/node_modules/preact/dist/preact.esm.js
var preact_esm_exports = {};
__export(preact_esm_exports, {
  Component: () => Component,
  cloneElement: () => cloneElement,
  createElement: () => h3,
  default: () => preact_esm_default,
  h: () => h3,
  options: () => options,
  render: () => render2,
  rerender: () => rerender
});
function VNode() {
}
function h3(nodeName, attributes) {
  var children5 = EMPTY_CHILDREN, lastSimple, child, simple, i;
  for (i = arguments.length; i-- > 2; ) {
    stack2.push(arguments[i]);
  }
  if (attributes && attributes.children != null) {
    if (!stack2.length)
      stack2.push(attributes.children);
    delete attributes.children;
  }
  while (stack2.length) {
    if ((child = stack2.pop()) && child.pop !== void 0) {
      for (i = child.length; i--; ) {
        stack2.push(child[i]);
      }
    } else {
      if (typeof child === "boolean")
        child = null;
      if (simple = typeof nodeName !== "function") {
        if (child == null)
          child = "";
        else if (typeof child === "number")
          child = String(child);
        else if (typeof child !== "string")
          simple = false;
      }
      if (simple && lastSimple) {
        children5[children5.length - 1] += child;
      } else if (children5 === EMPTY_CHILDREN) {
        children5 = [child];
      } else {
        children5.push(child);
      }
      lastSimple = simple;
    }
  }
  var p = new VNode();
  p.nodeName = nodeName;
  p.children = children5;
  p.attributes = attributes == null ? void 0 : attributes;
  p.key = attributes == null ? void 0 : attributes.key;
  if (options.vnode !== void 0)
    options.vnode(p);
  return p;
}
function extend5(obj, props) {
  for (var i in props) {
    obj[i] = props[i];
  }
  return obj;
}
function cloneElement(vnode, props) {
  return h3(vnode.nodeName, extend5(extend5({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
}
function enqueueRender(component) {
  if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
    (options.debounceRendering || defer)(rerender);
  }
}
function rerender() {
  var p, list = items;
  items = [];
  while (p = list.pop()) {
    if (p._dirty)
      renderComponent(p);
  }
}
function isSameNodeType(node, vnode, hydrating2) {
  if (typeof vnode === "string" || typeof vnode === "number") {
    return node.splitText !== void 0;
  }
  if (typeof vnode.nodeName === "string") {
    return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
  }
  return hydrating2 || node._componentConstructor === vnode.nodeName;
}
function isNamedNode(node, nodeName) {
  return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
}
function getNodeProps(vnode) {
  var props = extend5({}, vnode.attributes);
  props.children = vnode.children;
  var defaultProps = vnode.nodeName.defaultProps;
  if (defaultProps !== void 0) {
    for (var i in defaultProps) {
      if (props[i] === void 0) {
        props[i] = defaultProps[i];
      }
    }
  }
  return props;
}
function createNode(nodeName, isSvg) {
  var node = isSvg ? document.createElementNS("http://www.w3.org/2000/svg", nodeName) : document.createElement(nodeName);
  node.normalizedNodeName = nodeName;
  return node;
}
function removeNode(node) {
  var parentNode = node.parentNode;
  if (parentNode)
    parentNode.removeChild(node);
}
function setAccessor(node, name4, old, value4, isSvg) {
  if (name4 === "className")
    name4 = "class";
  if (name4 === "key") {
  } else if (name4 === "ref") {
    if (old)
      old(null);
    if (value4)
      value4(node);
  } else if (name4 === "class" && !isSvg) {
    node.className = value4 || "";
  } else if (name4 === "style") {
    if (!value4 || typeof value4 === "string" || typeof old === "string") {
      node.style.cssText = value4 || "";
    }
    if (value4 && typeof value4 === "object") {
      if (typeof old !== "string") {
        for (var i in old) {
          if (!(i in value4))
            node.style[i] = "";
        }
      }
      for (var i in value4) {
        node.style[i] = typeof value4[i] === "number" && IS_NON_DIMENSIONAL.test(i) === false ? value4[i] + "px" : value4[i];
      }
    }
  } else if (name4 === "dangerouslySetInnerHTML") {
    if (value4)
      node.innerHTML = value4.__html || "";
  } else if (name4[0] == "o" && name4[1] == "n") {
    var useCapture = name4 !== (name4 = name4.replace(/Capture$/, ""));
    name4 = name4.toLowerCase().substring(2);
    if (value4) {
      if (!old)
        node.addEventListener(name4, eventProxy, useCapture);
    } else {
      node.removeEventListener(name4, eventProxy, useCapture);
    }
    (node._listeners || (node._listeners = {}))[name4] = value4;
  } else if (name4 !== "list" && name4 !== "type" && !isSvg && name4 in node) {
    setProperty(node, name4, value4 == null ? "" : value4);
    if (value4 == null || value4 === false)
      node.removeAttribute(name4);
  } else {
    var ns = isSvg && name4 !== (name4 = name4.replace(/^xlink:?/, ""));
    if (value4 == null || value4 === false) {
      if (ns)
        node.removeAttributeNS("http://www.w3.org/1999/xlink", name4.toLowerCase());
      else
        node.removeAttribute(name4);
    } else if (typeof value4 !== "function") {
      if (ns)
        node.setAttributeNS("http://www.w3.org/1999/xlink", name4.toLowerCase(), value4);
      else
        node.setAttribute(name4, value4);
    }
  }
}
function setProperty(node, name4, value4) {
  try {
    node[name4] = value4;
  } catch (e3) {
  }
}
function eventProxy(e3) {
  return this._listeners[e3.type](options.event && options.event(e3) || e3);
}
function flushMounts() {
  var c2;
  while (c2 = mounts.pop()) {
    if (options.afterMount)
      options.afterMount(c2);
    if (c2.componentDidMount)
      c2.componentDidMount();
  }
}
function diff(dom, vnode, context4, mountAll, parent, componentRoot) {
  if (!diffLevel++) {
    isSvgMode = parent != null && parent.ownerSVGElement !== void 0;
    hydrating = dom != null && !("__preactattr_" in dom);
  }
  var ret = idiff(dom, vnode, context4, mountAll, componentRoot);
  if (parent && ret.parentNode !== parent)
    parent.appendChild(ret);
  if (!--diffLevel) {
    hydrating = false;
    if (!componentRoot)
      flushMounts();
  }
  return ret;
}
function idiff(dom, vnode, context4, mountAll, componentRoot) {
  var out = dom, prevSvgMode = isSvgMode;
  if (vnode == null || typeof vnode === "boolean")
    vnode = "";
  if (typeof vnode === "string" || typeof vnode === "number") {
    if (dom && dom.splitText !== void 0 && dom.parentNode && (!dom._component || componentRoot)) {
      if (dom.nodeValue != vnode) {
        dom.nodeValue = vnode;
      }
    } else {
      out = document.createTextNode(vnode);
      if (dom) {
        if (dom.parentNode)
          dom.parentNode.replaceChild(out, dom);
        recollectNodeTree(dom, true);
      }
    }
    out["__preactattr_"] = true;
    return out;
  }
  var vnodeName = vnode.nodeName;
  if (typeof vnodeName === "function") {
    return buildComponentFromVNode(dom, vnode, context4, mountAll);
  }
  isSvgMode = vnodeName === "svg" ? true : vnodeName === "foreignObject" ? false : isSvgMode;
  vnodeName = String(vnodeName);
  if (!dom || !isNamedNode(dom, vnodeName)) {
    out = createNode(vnodeName, isSvgMode);
    if (dom) {
      while (dom.firstChild) {
        out.appendChild(dom.firstChild);
      }
      if (dom.parentNode)
        dom.parentNode.replaceChild(out, dom);
      recollectNodeTree(dom, true);
    }
  }
  var fc = out.firstChild, props = out["__preactattr_"], vchildren = vnode.children;
  if (props == null) {
    props = out["__preactattr_"] = {};
    for (var a4 = out.attributes, i = a4.length; i--; ) {
      props[a4[i].name] = a4[i].value;
    }
  }
  if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === "string" && fc != null && fc.splitText !== void 0 && fc.nextSibling == null) {
    if (fc.nodeValue != vchildren[0]) {
      fc.nodeValue = vchildren[0];
    }
  } else if (vchildren && vchildren.length || fc != null) {
    innerDiffNode(out, vchildren, context4, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
  }
  diffAttributes(out, vnode.attributes, props);
  isSvgMode = prevSvgMode;
  return out;
}
function innerDiffNode(dom, vchildren, context4, mountAll, isHydrating) {
  var originalChildren = dom.childNodes, children5 = [], keyed = {}, keyedLen = 0, min8 = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren ? vchildren.length : 0, j, c2, f, vchild, child;
  if (len !== 0) {
    for (var i = 0; i < len; i++) {
      var _child = originalChildren[i], props = _child["__preactattr_"], key3 = vlen && props ? _child._component ? _child._component.__key : props.key : null;
      if (key3 != null) {
        keyedLen++;
        keyed[key3] = _child;
      } else if (props || (_child.splitText !== void 0 ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
        children5[childrenLen++] = _child;
      }
    }
  }
  if (vlen !== 0) {
    for (var i = 0; i < vlen; i++) {
      vchild = vchildren[i];
      child = null;
      var key3 = vchild.key;
      if (key3 != null) {
        if (keyedLen && keyed[key3] !== void 0) {
          child = keyed[key3];
          keyed[key3] = void 0;
          keyedLen--;
        }
      } else if (!child && min8 < childrenLen) {
        for (j = min8; j < childrenLen; j++) {
          if (children5[j] !== void 0 && isSameNodeType(c2 = children5[j], vchild, isHydrating)) {
            child = c2;
            children5[j] = void 0;
            if (j === childrenLen - 1)
              childrenLen--;
            if (j === min8)
              min8++;
            break;
          }
        }
      }
      child = idiff(child, vchild, context4, mountAll);
      f = originalChildren[i];
      if (child && child !== dom && child !== f) {
        if (f == null) {
          dom.appendChild(child);
        } else if (child === f.nextSibling) {
          removeNode(f);
        } else {
          dom.insertBefore(child, f);
        }
      }
    }
  }
  if (keyedLen) {
    for (var i in keyed) {
      if (keyed[i] !== void 0)
        recollectNodeTree(keyed[i], false);
    }
  }
  while (min8 <= childrenLen) {
    if ((child = children5[childrenLen--]) !== void 0)
      recollectNodeTree(child, false);
  }
}
function recollectNodeTree(node, unmountOnly) {
  var component = node._component;
  if (component) {
    unmountComponent(component);
  } else {
    if (node["__preactattr_"] != null && node["__preactattr_"].ref)
      node["__preactattr_"].ref(null);
    if (unmountOnly === false || node["__preactattr_"] == null) {
      removeNode(node);
    }
    removeChildren(node);
  }
}
function removeChildren(node) {
  node = node.lastChild;
  while (node) {
    var next = node.previousSibling;
    recollectNodeTree(node, true);
    node = next;
  }
}
function diffAttributes(dom, attrs, old) {
  var name4;
  for (name4 in old) {
    if (!(attrs && attrs[name4] != null) && old[name4] != null) {
      setAccessor(dom, name4, old[name4], old[name4] = void 0, isSvgMode);
    }
  }
  for (name4 in attrs) {
    if (name4 !== "children" && name4 !== "innerHTML" && (!(name4 in old) || attrs[name4] !== (name4 === "value" || name4 === "checked" ? dom[name4] : old[name4]))) {
      setAccessor(dom, name4, old[name4], old[name4] = attrs[name4], isSvgMode);
    }
  }
}
function collectComponent(component) {
  var name4 = component.constructor.name;
  (components[name4] || (components[name4] = [])).push(component);
}
function createComponent(Ctor, props, context4) {
  var list = components[Ctor.name], inst;
  if (Ctor.prototype && Ctor.prototype.render) {
    inst = new Ctor(props, context4);
    Component.call(inst, props, context4);
  } else {
    inst = new Component(props, context4);
    inst.constructor = Ctor;
    inst.render = doRender;
  }
  if (list) {
    for (var i = list.length; i--; ) {
      if (list[i].constructor === Ctor) {
        inst.nextBase = list[i].nextBase;
        list.splice(i, 1);
        break;
      }
    }
  }
  return inst;
}
function doRender(props, state, context4) {
  return this.constructor(props, context4);
}
function setComponentProps(component, props, opts, context4, mountAll) {
  if (component._disable)
    return;
  component._disable = true;
  if (component.__ref = props.ref)
    delete props.ref;
  if (component.__key = props.key)
    delete props.key;
  if (!component.base || mountAll) {
    if (component.componentWillMount)
      component.componentWillMount();
  } else if (component.componentWillReceiveProps) {
    component.componentWillReceiveProps(props, context4);
  }
  if (context4 && context4 !== component.context) {
    if (!component.prevContext)
      component.prevContext = component.context;
    component.context = context4;
  }
  if (!component.prevProps)
    component.prevProps = component.props;
  component.props = props;
  component._disable = false;
  if (opts !== 0) {
    if (opts === 1 || options.syncComponentUpdates !== false || !component.base) {
      renderComponent(component, 1, mountAll);
    } else {
      enqueueRender(component);
    }
  }
  if (component.__ref)
    component.__ref(component);
}
function renderComponent(component, opts, mountAll, isChild) {
  if (component._disable)
    return;
  var props = component.props, state = component.state, context4 = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context4, isUpdate = component.base, nextBase = component.nextBase, initialBase = isUpdate || nextBase, initialChildComponent = component._component, skip = false, rendered, inst, cbase;
  if (isUpdate) {
    component.props = previousProps;
    component.state = previousState;
    component.context = previousContext;
    if (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context4) === false) {
      skip = true;
    } else if (component.componentWillUpdate) {
      component.componentWillUpdate(props, state, context4);
    }
    component.props = props;
    component.state = state;
    component.context = context4;
  }
  component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
  component._dirty = false;
  if (!skip) {
    rendered = component.render(props, state, context4);
    if (component.getChildContext) {
      context4 = extend5(extend5({}, context4), component.getChildContext());
    }
    var childComponent = rendered && rendered.nodeName, toUnmount, base3;
    if (typeof childComponent === "function") {
      var childProps = getNodeProps(rendered);
      inst = initialChildComponent;
      if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
        setComponentProps(inst, childProps, 1, context4, false);
      } else {
        toUnmount = inst;
        component._component = inst = createComponent(childComponent, childProps, context4);
        inst.nextBase = inst.nextBase || nextBase;
        inst._parentComponent = component;
        setComponentProps(inst, childProps, 0, context4, false);
        renderComponent(inst, 1, mountAll, true);
      }
      base3 = inst.base;
    } else {
      cbase = initialBase;
      toUnmount = initialChildComponent;
      if (toUnmount) {
        cbase = component._component = null;
      }
      if (initialBase || opts === 1) {
        if (cbase)
          cbase._component = null;
        base3 = diff(cbase, rendered, context4, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
      }
    }
    if (initialBase && base3 !== initialBase && inst !== initialChildComponent) {
      var baseParent = initialBase.parentNode;
      if (baseParent && base3 !== baseParent) {
        baseParent.replaceChild(base3, initialBase);
        if (!toUnmount) {
          initialBase._component = null;
          recollectNodeTree(initialBase, false);
        }
      }
    }
    if (toUnmount) {
      unmountComponent(toUnmount);
    }
    component.base = base3;
    if (base3 && !isChild) {
      var componentRef = component, t = component;
      while (t = t._parentComponent) {
        (componentRef = t).base = base3;
      }
      base3._component = componentRef;
      base3._componentConstructor = componentRef.constructor;
    }
  }
  if (!isUpdate || mountAll) {
    mounts.unshift(component);
  } else if (!skip) {
    if (component.componentDidUpdate) {
      component.componentDidUpdate(previousProps, previousState, previousContext);
    }
    if (options.afterUpdate)
      options.afterUpdate(component);
  }
  if (component._renderCallbacks != null) {
    while (component._renderCallbacks.length) {
      component._renderCallbacks.pop().call(component);
    }
  }
  if (!diffLevel && !isChild)
    flushMounts();
}
function buildComponentFromVNode(dom, vnode, context4, mountAll) {
  var c2 = dom && dom._component, originalComponent = c2, oldDom = dom, isDirectOwner = c2 && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);
  while (c2 && !isOwner && (c2 = c2._parentComponent)) {
    isOwner = c2.constructor === vnode.nodeName;
  }
  if (c2 && isOwner && (!mountAll || c2._component)) {
    setComponentProps(c2, props, 3, context4, mountAll);
    dom = c2.base;
  } else {
    if (originalComponent && !isDirectOwner) {
      unmountComponent(originalComponent);
      dom = oldDom = null;
    }
    c2 = createComponent(vnode.nodeName, props, context4);
    if (dom && !c2.nextBase) {
      c2.nextBase = dom;
      oldDom = null;
    }
    setComponentProps(c2, props, 1, context4, mountAll);
    dom = c2.base;
    if (oldDom && dom !== oldDom) {
      oldDom._component = null;
      recollectNodeTree(oldDom, false);
    }
  }
  return dom;
}
function unmountComponent(component) {
  if (options.beforeUnmount)
    options.beforeUnmount(component);
  var base3 = component.base;
  component._disable = true;
  if (component.componentWillUnmount)
    component.componentWillUnmount();
  component.base = null;
  var inner = component._component;
  if (inner) {
    unmountComponent(inner);
  } else if (base3) {
    if (base3["__preactattr_"] && base3["__preactattr_"].ref)
      base3["__preactattr_"].ref(null);
    component.nextBase = base3;
    removeNode(base3);
    collectComponent(component);
    removeChildren(base3);
  }
  if (component.__ref)
    component.__ref(null);
}
function Component(props, context4) {
  this._dirty = true;
  this.context = context4;
  this.props = props;
  this.state = this.state || {};
}
function render2(vnode, parent, merge7) {
  return diff(merge7, vnode, {}, false, parent, false);
}
var options, stack2, EMPTY_CHILDREN, defer, IS_NON_DIMENSIONAL, items, mounts, diffLevel, isSvgMode, hydrating, components, preact, preact_esm_default;
var init_preact_esm = __esm({
  "node_modules/.pnpm/preact@8.2.9/node_modules/preact/dist/preact.esm.js"() {
    options = {};
    stack2 = [];
    EMPTY_CHILDREN = [];
    defer = typeof Promise == "function" ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;
    IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    items = [];
    mounts = [];
    diffLevel = 0;
    isSvgMode = false;
    hydrating = false;
    components = {};
    extend5(Component.prototype, {
      setState: function setState3(state, callback) {
        var s3 = this.state;
        if (!this.prevState)
          this.prevState = extend5({}, s3);
        extend5(s3, typeof state === "function" ? state(s3, this.props) : state);
        if (callback)
          (this._renderCallbacks = this._renderCallbacks || []).push(callback);
        enqueueRender(this);
      },
      forceUpdate: function forceUpdate(callback) {
        if (callback)
          (this._renderCallbacks = this._renderCallbacks || []).push(callback);
        renderComponent(this, 2);
      },
      render: function render() {
      }
    });
    preact = {
      h: h3,
      createElement: h3,
      cloneElement,
      Component,
      render: render2,
      rerender,
      options
    };
    preact_esm_default = preact;
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/components/surface.js
var require_surface = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/components/surface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var preact_1 = (init_preact_esm(), __toCommonJS(preact_esm_exports));
    var glamor_1 = require_lib();
    var SurfaceComponent = class extends preact_1.Component {
      componentDidMount() {
        const { name: name4, tab } = this.props;
        this.props.registerSurface(name4, tab, this);
      }
      componentDidUpdate() {
        return false;
      }
      render() {
        const { name: name4, visible, styles: styles2 } = this.props;
        const finalStyles = Object.assign({}, SurfaceComponent.defaultStyles, styles2);
        const { width: width2, height: height2 } = finalStyles;
        let { maxHeight, maxWidth } = finalStyles;
        maxHeight = height2 === SurfaceComponent.defaultStyles.height ? maxHeight : height2;
        maxWidth = width2 === SurfaceComponent.defaultStyles.width ? maxWidth : width2;
        const surfaceStyle = glamor_1.css({
          display: visible ? "block" : "none",
          backgroundColor: "white",
          marginTop: "10px",
          marginBottom: "10px",
          boxShadow: "0 0 6px -3px #777",
          padding: "10px !important",
          height: height2,
          width: width2,
          maxHeight,
          maxWidth,
          overflow: "auto"
        });
        const labelStyle = glamor_1.css({
          backgroundColor: "white",
          boxSizing: "border-box",
          borderBottom: "1px solid #357EDD",
          lineHeight: "2em",
          marginBottom: "20px",
          fontWeight: "600",
          textAlign: "center"
        });
        const drawAreaStyle = glamor_1.css({
          boxSizing: "border-box"
        });
        return preact_1.h(
          "div",
          { className: `${surfaceStyle} tf-surface`, ref: (r2) => this.container = r2, "data-visible": visible },
          preact_1.h("div", { className: `${labelStyle} tf-label`, ref: (r2) => this.label = r2 }, name4),
          preact_1.h("div", { className: `${drawAreaStyle} tf-draw-area`, ref: (r2) => this.drawArea = r2 })
        );
      }
    };
    SurfaceComponent.defaultStyles = {
      maxWidth: "550px",
      maxHeight: "580px",
      height: "auto",
      width: "auto"
    };
    exports.SurfaceComponent = SurfaceComponent;
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/components/tabs.js
var require_tabs = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/components/tabs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var preact_1 = (init_preact_esm(), __toCommonJS(preact_esm_exports));
    var glamor_1 = require_lib();
    var Tabs = class extends preact_1.Component {
      render() {
        const { tabNames, activeTab, handleClick } = this.props;
        const tabs = tabNames.length > 0 ? tabNames.map((name4) => preact_1.h(Tab, { key: name4, id: name4, handleClick, isActive: name4 === activeTab }, name4)) : null;
        const tabStyle = glamor_1.css({
          overflowX: "scroll",
          overflowY: "hidden",
          whiteSpace: "nowrap",
          borderBottomStyle: "solid",
          borderBottomWidth: "1px",
          borderColor: "#eee",
          paddingBottom: "1rem",
          marginTop: "1rem"
        });
        return preact_1.h("div", { className: `${tabStyle} visor-tabs` }, tabs);
      }
    };
    exports.Tabs = Tabs;
    var Tab = class extends preact_1.Component {
      render() {
        const { children: children5, isActive, handleClick, id: id4 } = this.props;
        const tabStyle = glamor_1.css({
          borderBottomColor: isActive ? "#357EDD" : "#AAAAAA",
          borderBottomWidth: "1px",
          borderBottomStyle: "solid",
          cursor: "pointer",
          ":hover": {
            color: "#357EDD"
          },
          display: "inline-block",
          marginRight: "1rem",
          padding: ".5rem",
          fontSize: "1rem",
          fontWeight: "bold"
        });
        return preact_1.h("a", { className: `${tabStyle} tf-tab`, "data-isactive": isActive, onClick: () => handleClick(id4) }, children5);
      }
    };
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/components/visor.js
var require_visor = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/components/visor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var preact_1 = (init_preact_esm(), __toCommonJS(preact_esm_exports));
    var glamor_1 = require_lib();
    var surface_1 = require_surface();
    var tabs_1 = require_tabs();
    var VisorComponent = class extends preact_1.Component {
      static render(parent, replaceNode, props) {
        return preact_1.render(preact_1.h(VisorComponent, Object.assign({}, props)), parent, replaceNode);
      }
      constructor(props) {
        super(props);
        this.surfaces = /* @__PURE__ */ new Map();
        const startOpen = props.startOpen == null ? true : props.startOpen;
        this.state = {
          isOpen: startOpen,
          isFullscreen: false,
          activeTab: null,
          tabs: /* @__PURE__ */ new Set()
        };
        this.keyHandler = this.keyHandler.bind(this);
      }
      close() {
        this.setState({ isOpen: false });
      }
      open() {
        this.setState({ isOpen: true });
      }
      toggle() {
        this.setState({ isOpen: !this.state.isOpen });
      }
      toggleFullScreen() {
        this.setState({ isFullscreen: !this.state.isFullscreen });
      }
      isOpen() {
        return this.state.isOpen;
      }
      isFullscreen() {
        return this.state.isFullscreen;
      }
      getSurface(label, tab) {
        const surfaceId = this.surfaceId(label, tab);
        let surface;
        if (this.surfaces.has(surfaceId)) {
          surface = this.surfaces.get(surfaceId);
        } else {
          throw Error(`Surface not found with id: ${surfaceId}`);
        }
        return {
          container: surface.container,
          label: surface.label,
          drawArea: surface.drawArea
        };
      }
      bindKeys() {
        document.addEventListener("keydown", this.keyHandler, false);
      }
      unbindKeys() {
        document.removeEventListener("keydown", this.keyHandler);
      }
      surfaceId(label, tab) {
        return label + tab;
      }
      setTabs(surfaceList) {
        const nextTabs = surfaceList.map((s3) => s3.tab);
        const tabs = this.state.tabs;
        let newActiveTab;
        for (const tab of nextTabs) {
          if (!tabs.has(tab)) {
            tabs.add(tab);
            newActiveTab = tab;
          }
        }
        if (newActiveTab != null) {
          this.setState({
            tabs,
            activeTab: newActiveTab
          });
        }
      }
      getTabs() {
        return this.state.tabs;
      }
      registerSurface(name4, tab, surface) {
        const surfaceId = this.surfaceId(name4, tab);
        this.surfaces.set(surfaceId, surface);
      }
      keyHandler(event3) {
        const BACKTICK_KEY = 192;
        if (event3.keyCode === BACKTICK_KEY) {
          if (event3.shiftKey) {
            this.toggleFullScreen();
          } else {
            this.toggle();
          }
        }
      }
      setActiveTab(tab) {
        this.setState({ activeTab: tab });
      }
      componentDidMount() {
        this.bindKeys();
      }
      componentWillMount() {
        this.setTabs(this.props.surfaceList);
      }
      componentWillReceiveProps(nextProps) {
        this.setTabs(nextProps.surfaceList);
      }
      render() {
        const { isOpen, isFullscreen, activeTab } = this.state;
        const { surfaceList } = this.props;
        const tabNames = Array.from(this.getTabs().values());
        const SMALL_WIDTH = "550px";
        const LARGE_WIDTH = "90vw";
        const width2 = isFullscreen ? LARGE_WIDTH : SMALL_WIDTH;
        const defaultStyles = glamor_1.css({
          width: width2,
          height: "100%",
          backgroundColor: "#fafafa",
          boxSizing: "border-box",
          padding: "10px",
          position: "fixed",
          top: "0px",
          transition: `right 0.5s cubic-bezier(0.645, 0.045, 0.355, 1), width 0.5s cubic-bezier(0.645, 0.045, 0.355, 1)`,
          boxShadow: "0 2px 5px rgba(0, 0, 0, 0.12), 0 2px 5px rgba(0, 0, 0, 0.24)",
          overflow: "auto",
          fontFamily: "sans-serif",
          fontSize: "14px",
          zIndex: 1e3
        });
        const openStyle = glamor_1.css({ right: "0" });
        const closedStyle = glamor_1.css({ right: `calc(-${width2} - 10px)` });
        const position2 = isOpen ? openStyle : closedStyle;
        const surfacesContainerStyle = glamor_1.css({});
        return preact_1.h(
          "div",
          { className: `${defaultStyles} ${position2} visor`, "data-isopen": isOpen, "data-isfullscreen": isFullscreen },
          preact_1.h(VisorControls, { fullScreenHandler: this.toggleFullScreen.bind(this), closeHandler: this.close.bind(this), isFullScreen: isFullscreen }),
          preact_1.h(tabs_1.Tabs, { tabNames, activeTab, handleClick: this.setActiveTab.bind(this) }),
          preact_1.h("div", { className: `${surfacesContainerStyle} visor-surfaces` }, surfaceList.map((surfaceInfo) => preact_1.h(surface_1.SurfaceComponent, { key: surfaceInfo.name + surfaceInfo.tab, name: surfaceInfo.name, tab: surfaceInfo.tab, styles: surfaceInfo.styles, registerSurface: this.registerSurface.bind(this), visible: activeTab === surfaceInfo.tab })))
        );
      }
    };
    exports.VisorComponent = VisorComponent;
    function VisorControls(props) {
      const { isFullScreen, fullScreenHandler, closeHandler } = props;
      const toolBarStyle = glamor_1.css({
        display: "flex",
        backgroundColor: "white",
        border: "1px solid white",
        padding: "6px",
        paddingTop: "10px",
        marginBottom: "10px",
        borderRadius: "6px",
        marginTop: "-16px"
      });
      const controlsButtonClass = glamor_1.css({
        fontSize: ".875rem",
        borderRadius: ".25rem",
        paddingLeft: "1rem",
        paddingRight: "1rem",
        paddingTop: ".5rem",
        paddingBottom: ".5rem",
        textDecoration: "none",
        transition: "color .15s ease-in",
        color: "#111"
      });
      const floatRight = glamor_1.css({
        marginLeft: "auto"
      });
      return preact_1.h(
        "div",
        { className: `${toolBarStyle} visor-controls` },
        preact_1.h("button", { className: `${controlsButtonClass}`, onClick: fullScreenHandler }, isFullScreen ? "Minimize" : "Maximize"),
        preact_1.h("button", { className: `${controlsButtonClass} ${floatRight}`, onClick: closeHandler }, "Hide")
      );
    }
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/visor.js
var require_visor2 = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/visor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visor_1 = require_visor();
    var visorSingleton;
    var DEFAULT_TAB = "Visor";
    var VISOR_CONTAINER_ID = "tfjs-visor-container";
    function visor() {
      if (typeof document === "undefined") {
        throw new Error("No document defined. This library needs a browser/dom to work");
      }
      if (document.getElementById(VISOR_CONTAINER_ID) && visorSingleton != null) {
        return visorSingleton;
      }
      let visorEl = document.getElementById(VISOR_CONTAINER_ID);
      if (visorEl == null) {
        visorEl = document.createElement("div");
        visorEl.id = VISOR_CONTAINER_ID;
        document.body.appendChild(visorEl);
      }
      let renderRoot;
      function renderVisor(domNode, surfaceList2) {
        let visorInstance = null;
        renderRoot = visor_1.VisorComponent.render(domNode, renderRoot, {
          ref: (r2) => visorInstance = r2,
          surfaceList: Array.from(surfaceList2.values())
        });
        return visorInstance;
      }
      const surfaceList = /* @__PURE__ */ new Map();
      const visorComponentInstance = renderVisor(visorEl, surfaceList);
      visorSingleton = new Visor(visorComponentInstance, visorEl, surfaceList, renderVisor);
      return visorSingleton;
    }
    exports.visor = visor;
    var Visor = class {
      constructor(visorComponent, visorEl, surfaceList, renderVisor) {
        this.visorComponent = visorComponent;
        this.el = visorEl;
        this.surfaceList = surfaceList;
        this.renderVisor = renderVisor;
      }
      surface(options2) {
        const { name: name4 } = options2;
        const tab = options2.tab == null ? DEFAULT_TAB : options2.tab;
        if (name4 == null || !(typeof name4 === "string" || name4 instanceof String)) {
          throw new Error(
            "You must pass a config object with a 'name' property to create or retrieve a surface"
          );
        }
        const finalOptions = Object.assign({}, options2, { tab });
        const key3 = `${name4}-${tab}`;
        if (!this.surfaceList.has(key3)) {
          this.surfaceList.set(key3, finalOptions);
        }
        this.renderVisor(this.el, this.surfaceList);
        return this.visorComponent.getSurface(name4, tab);
      }
      isFullscreen() {
        return this.visorComponent.isFullscreen();
      }
      isOpen() {
        return this.visorComponent.isOpen();
      }
      close() {
        return this.visorComponent.close();
      }
      open() {
        return this.visorComponent.open();
      }
      toggle() {
        return this.visorComponent.toggle();
      }
      toggleFullScreen() {
        return this.visorComponent.toggleFullScreen();
      }
      bindKeys() {
        return this.visorComponent.bindKeys();
      }
      unbindKeys() {
        return this.visorComponent.unbindKeys();
      }
      setActiveTab(tabName) {
        const tabs = this.visorComponent.state.tabs;
        if (!tabs.has(tabName)) {
          throw new Error(`Tab '${tabName}' does not exist`);
        }
        this.visorComponent.setState({ activeTab: tabName });
      }
    };
    exports.Visor = Visor;
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/render_utils.js
var require_render_utils = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/render_utils.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    var visor_1 = require_visor2();
    function getDrawArea(drawable) {
      if (drawable instanceof HTMLElement) {
        return drawable;
      } else if (types_1.isSurface(drawable)) {
        return drawable.drawArea;
      } else if (types_1.isSurfaceInfo(drawable)) {
        const surface = visor_1.visor().surface({ name: drawable.name, tab: drawable.tab, styles: drawable.styles });
        return surface.drawArea;
      } else {
        throw new Error("Not a drawable");
      }
    }
    exports.getDrawArea = getDrawArea;
    function shallowEquals(a4, b3) {
      const aProps = Object.getOwnPropertyNames(a4);
      const bProps = Object.getOwnPropertyNames(b3);
      if (aProps.length !== bProps.length) {
        return false;
      }
      for (let i = 0; i < aProps.length; i++) {
        const prop = aProps[i];
        if (a4[prop] !== b3[prop]) {
          return false;
        }
      }
      return true;
    }
    exports.shallowEquals = shallowEquals;
    function nextFrame() {
      return __awaiter2(this, void 0, void 0, function* () {
        yield new Promise((r2) => requestAnimationFrame(r2));
      });
    }
    exports.nextFrame = nextFrame;
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/util/dom.js
var require_dom = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/util/dom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var glamor_1 = require_lib();
    var render_utils_1 = require_render_utils();
    var DEFAULT_SUBSURFACE_OPTS = {
      prepend: false
    };
    function subSurface(parent, name4, opts = {}) {
      const container = render_utils_1.getDrawArea(parent);
      const style3 = glamor_1.css({
        "& canvas": {
          display: "block"
        },
        marginTop: ".5rem",
        marginBottom: ".5rem"
      });
      const titleStyle = glamor_1.css({
        backgroundColor: "white",
        display: "inline-block",
        boxSizing: "border-box",
        borderBottom: "1px solid #357EDD",
        lineHeight: "2em",
        padding: "0 10px 0 10px",
        marginBottom: "20px",
        fontWeight: "600",
        textAlign: "left"
      });
      const options2 = Object.assign({}, DEFAULT_SUBSURFACE_OPTS, opts);
      let sub = container.querySelector(`div[data-name=${name4}]`);
      if (!sub) {
        sub = document.createElement("div");
        sub.setAttribute("class", `${style3}`);
        sub.dataset.name = name4;
        if (options2.title) {
          const title2 = document.createElement("div");
          title2.setAttribute("class", `subsurface-title ${titleStyle}`);
          title2.innerText = options2.title;
          sub.appendChild(title2);
        }
        if (options2.prepend) {
          container.insertBefore(sub, container.firstChild);
        } else {
          container.appendChild(sub);
        }
      }
      return sub;
    }
    exports.subSurface = subSurface;
    function getDefaultWidth(element4) {
      const DEFAULT_PADDING = 50;
      let padding3 = 0;
      let current2 = element4;
      while (current2 && current2.clientWidth === 0) {
        current2 = current2.parentElement;
        padding3 = DEFAULT_PADDING;
      }
      return current2.clientWidth - padding3;
    }
    exports.getDefaultWidth = getDefaultWidth;
    function getDefaultHeight(element4) {
      if (element4.clientHeight === 0) {
        return 200;
      } else {
        return element4.clientHeight;
      }
    }
    exports.getDefaultHeight = getDefaultHeight;
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/barchart.js
var require_barchart = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/barchart.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var vega_embed_1 = __importDefault((init_vega_embed_module(), __toCommonJS(vega_embed_module_exports)));
    var dom_1 = require_dom();
    var render_utils_1 = require_render_utils();
    function barchart(container, data3, opts = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        const drawArea = render_utils_1.getDrawArea(container);
        const values5 = data3;
        const options2 = Object.assign({}, defaultOpts, opts);
        if (instances.has(drawArea)) {
          const instanceInfo = instances.get(drawArea);
          if (render_utils_1.shallowEquals(options2, instanceInfo.lastOptions)) {
            yield render_utils_1.nextFrame();
            const view = instanceInfo.view;
            const changes = view.changeset().remove(() => true).insert(values5);
            yield view.change("values", changes).runAsync();
            return;
          }
        }
        const { xLabel, yLabel, xType, yType } = options2;
        let xAxis = null;
        if (xLabel != null) {
          xAxis = { title: xLabel };
        }
        let yAxis = null;
        if (yLabel != null) {
          yAxis = { title: yLabel };
        }
        const embedOpts = {
          actions: false,
          mode: "vega-lite",
          defaultStyle: false
        };
        let colorEncoding;
        if (options2.color != null) {
          if (Array.isArray(options2.color)) {
            colorEncoding = {
              "field": "index",
              "type": "nominal",
              "scale": {
                "range": options2.color
              }
            };
          } else {
            colorEncoding = { "value": options2.color };
          }
        } else {
          colorEncoding = { "value": "#4C78A0" };
        }
        const spec = {
          "width": options2.width || dom_1.getDefaultWidth(drawArea),
          "height": options2.height || dom_1.getDefaultHeight(drawArea),
          "padding": 0,
          "autosize": {
            "type": "fit",
            "contains": "padding",
            "resize": true
          },
          "config": {
            "axis": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            },
            "text": { "fontSize": options2.fontSize },
            "legend": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            }
          },
          "data": { "values": values5, "name": "values" },
          "mark": {
            "type": "bar",
            "tooltip": true
          },
          "encoding": {
            "x": { "field": "index", "type": xType, "axis": xAxis },
            "y": { "field": "value", "type": yType, "axis": yAxis },
            "color": colorEncoding
          }
        };
        yield render_utils_1.nextFrame();
        const embedRes = yield vega_embed_1.default(drawArea, spec, embedOpts);
        instances.set(drawArea, {
          view: embedRes.view,
          lastOptions: options2
        });
      });
    }
    exports.barchart = barchart;
    var defaultOpts = {
      xLabel: "",
      yLabel: "",
      xType: "ordinal",
      yType: "quantitative",
      fontSize: 11
    };
    var instances = /* @__PURE__ */ new Map();
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/confusion_matrix.js
var require_confusion_matrix = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/confusion_matrix.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var vega_embed_1 = __importDefault((init_vega_embed_module(), __toCommonJS(vega_embed_module_exports)));
    var dom_1 = require_dom();
    var render_utils_1 = require_render_utils();
    function confusionMatrix(container, data3, opts = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        const options2 = Object.assign({}, defaultOpts, opts);
        const drawArea = render_utils_1.getDrawArea(container);
        const values5 = [];
        const inputArray = data3.values;
        const tickLabels = data3.tickLabels || [];
        const generateLabels = tickLabels.length === 0;
        let nonDiagonalIsAllZeroes = true;
        for (let i = 0; i < inputArray.length; i++) {
          const label = generateLabels ? `Class ${i}` : tickLabels[i];
          if (generateLabels) {
            tickLabels.push(label);
          }
          for (let j = 0; j < inputArray[i].length; j++) {
            const prediction = generateLabels ? `Class ${j}` : tickLabels[j];
            const count5 = inputArray[i][j];
            if (i === j && !options2.shadeDiagonal) {
              values5.push({
                label,
                prediction,
                count: count5,
                noFill: true
              });
            } else {
              values5.push({
                label,
                prediction,
                count: count5,
                scaleCount: count5
              });
              if (count5 !== 0) {
                nonDiagonalIsAllZeroes = false;
              }
            }
          }
        }
        if (!options2.shadeDiagonal && nonDiagonalIsAllZeroes) {
          for (const val of values5) {
            if (val.noFill === true) {
              val.noFill = false;
              val.scaleCount = val.count;
            }
          }
        }
        const embedOpts = {
          actions: false,
          mode: "vega-lite",
          defaultStyle: false
        };
        const spec = {
          "width": options2.width || dom_1.getDefaultWidth(drawArea),
          "height": options2.height || dom_1.getDefaultHeight(drawArea),
          "padding": 0,
          "autosize": {
            "type": "fit",
            "contains": "padding",
            "resize": true
          },
          "config": {
            "axis": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            },
            "text": { "fontSize": options2.fontSize },
            "legend": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            }
          },
          "data": { "values": values5 },
          "encoding": {
            "x": {
              "field": "prediction",
              "type": "ordinal",
              "title": options2.xLabel || "prediction",
              "scale": { "domain": tickLabels }
            },
            "y": {
              "field": "label",
              "type": "ordinal",
              "title": options2.yLabel || "label",
              "scale": { "domain": tickLabels }
            }
          },
          "layer": [
            {
              "transform": [
                { "filter": "datum.noFill != true" }
              ],
              "mark": {
                "type": "rect"
              },
              "encoding": {
                "color": {
                  "field": "scaleCount",
                  "type": "quantitative",
                  "scale": { "range": options2.colorMap }
                },
                "tooltip": [
                  { "field": "label", "type": "nominal" },
                  { "field": "prediction", "type": "nominal" },
                  { "field": "count", "type": "quantitative" }
                ]
              }
            }
          ]
        };
        if (options2.shadeDiagonal === false) {
          spec.layer.push({
            "transform": [
              { "filter": "datum.noFill == true" }
            ],
            "mark": {
              "type": "rect",
              "fill": "white"
            },
            "encoding": {
              "tooltip": [
                { "field": "label", "type": "nominal" },
                { "field": "prediction", "type": "nominal" },
                { "field": "count", "type": "quantitative" }
              ]
            }
          });
        }
        if (options2.showTextOverlay) {
          spec.layer.push({
            "mark": { "type": "text", "baseline": "middle" },
            "encoding": {
              "text": {
                "field": "count",
                "type": "nominal"
              }
            }
          });
        }
        const colorMap = typeof options2.colorMap === "string" ? { scheme: options2.colorMap } : options2.colorMap;
        spec.layer[0].encoding.color.scale.range = colorMap;
        yield vega_embed_1.default(drawArea, spec, embedOpts);
      });
    }
    exports.confusionMatrix = confusionMatrix;
    var defaultOpts = {
      xLabel: null,
      yLabel: null,
      xType: "nominal",
      yType: "nominal",
      shadeDiagonal: true,
      fontSize: 12,
      showTextOverlay: true,
      height: 400,
      colorMap: ["#f7fbff", "#4292c6"]
    };
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/util/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/util/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function assert4(expr2, msg) {
      if (!expr2) {
        throw new Error(typeof msg === "string" ? msg : msg());
      }
    }
    exports.assert = assert4;
    function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = "") {
      assert4(arraysEqual(shapeA, shapeB), errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
    }
    exports.assertShapesMatch = assertShapesMatch;
    function arraysEqual(n1, n2) {
      if (n1.length !== n2.length) {
        return false;
      }
      for (let i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
          return false;
        }
      }
      return true;
    }
    exports.arraysEqual = arraysEqual;
    exports.DECIMAL_PLACES_TO_CHECK = 4;
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/heatmap.js
var require_heatmap = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/heatmap.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k4 in mod)
          if (Object.hasOwnProperty.call(mod, k4))
            result[k4] = mod[k4];
      }
      result["default"] = mod;
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var tf = __importStar((init_dist(), __toCommonJS(dist_exports)));
    var vega_embed_1 = __importDefault((init_vega_embed_module(), __toCommonJS(vega_embed_module_exports)));
    var dom_1 = require_dom();
    var utils_1 = require_utils();
    var render_utils_1 = require_render_utils();
    function heatmap(container, data3, opts = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        const options2 = Object.assign({}, defaultOpts, opts);
        const drawArea = render_utils_1.getDrawArea(container);
        let inputValues = data3.values;
        if (options2.rowMajor) {
          inputValues = yield convertToRowMajor(data3.values);
        }
        const { xTickLabels, yTickLabels } = data3;
        if (xTickLabels != null) {
          const dimension = 0;
          assertLabelsMatchShape(inputValues, xTickLabels, dimension);
        }
        if (yTickLabels != null) {
          const dimension = 1;
          assertLabelsMatchShape(inputValues, yTickLabels, dimension);
        }
        const IDX_SEPARATOR = "@tfidx@";
        const values5 = [];
        if (inputValues instanceof tf.Tensor) {
          utils_1.assert(inputValues.rank === 2, "Input to renderHeatmap must be a 2d array or Tensor2d");
          const inputArray = yield inputValues.data();
          const [numRows, numCols] = inputValues.shape;
          for (let row = 0; row < numRows; row++) {
            const x7 = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;
            for (let col = 0; col < numCols; col++) {
              const y7 = yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;
              const index8 = row * numCols + col;
              const value4 = inputArray[index8];
              values5.push({ x: x7, y: y7, value: value4 });
            }
          }
        } else {
          const inputArray = inputValues;
          for (let row = 0; row < inputArray.length; row++) {
            const x7 = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;
            for (let col = 0; col < inputArray[row].length; col++) {
              const y7 = yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;
              const value4 = inputArray[row][col];
              values5.push({ x: x7, y: y7, value: value4 });
            }
          }
        }
        const embedOpts = {
          actions: false,
          mode: "vega-lite",
          defaultStyle: false
        };
        const spec = {
          "width": options2.width || dom_1.getDefaultWidth(drawArea),
          "height": options2.height || dom_1.getDefaultHeight(drawArea),
          "padding": 0,
          "autosize": {
            "type": "fit",
            "contains": "padding",
            "resize": true
          },
          "config": {
            "axis": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            },
            "text": { "fontSize": options2.fontSize },
            "legend": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            },
            "scale": { "bandPaddingInner": 0, "bandPaddingOuter": 0 }
          },
          "data": { "values": values5 },
          "mark": { "type": "rect", "tooltip": true },
          "encoding": {
            "x": {
              "field": "x",
              "type": options2.xType,
              "title": options2.xLabel,
              "sort": false
            },
            "y": {
              "field": "y",
              "type": options2.yType,
              "title": options2.yLabel,
              "sort": false
            },
            "fill": {
              "field": "value",
              "type": "quantitative"
            }
          }
        };
        const suffixPattern = `${IDX_SEPARATOR}\\d+$`;
        const suffixRegex = new RegExp(suffixPattern);
        if (xTickLabels) {
          spec.encoding.x.axis = {
            "labelExpr": `replace(datum.value, regexp(/${suffixPattern}/), '')`
          };
        }
        if (yTickLabels) {
          spec.encoding.y.axis = {
            "labelExpr": `replace(datum.value, regexp(/${suffixPattern}/), '')`
          };
        }
        if (xTickLabels || yTickLabels) {
          embedOpts.tooltip = {
            sanitize: (value4) => {
              const valueString = String(value4);
              return valueString.replace(suffixRegex, "");
            }
          };
        }
        let colorRange;
        switch (options2.colorMap) {
          case "blues":
            colorRange = ["#f7fbff", "#4292c6"];
            break;
          case "greyscale":
            colorRange = ["#000000", "#ffffff"];
            break;
          case "viridis":
          default:
            colorRange = "viridis";
            break;
        }
        if (colorRange !== "viridis") {
          const fill3 = spec.encoding.fill;
          fill3.scale = { "range": colorRange };
        }
        if (options2.domain) {
          const fill3 = spec.encoding.fill;
          if (fill3.scale != null) {
            fill3.scale = Object.assign({}, fill3.scale, { "domain": options2.domain });
          } else {
            fill3.scale = { "domain": options2.domain };
          }
        }
        yield vega_embed_1.default(drawArea, spec, embedOpts);
      });
    }
    exports.heatmap = heatmap;
    function convertToRowMajor(inputValues) {
      return __awaiter2(this, void 0, void 0, function* () {
        let originalShape;
        let transposed;
        if (inputValues instanceof tf.Tensor) {
          originalShape = inputValues.shape;
          transposed = inputValues.transpose();
        } else {
          originalShape = [inputValues.length, inputValues[0].length];
          transposed = tf.tidy(() => tf.tensor2d(inputValues).transpose());
        }
        utils_1.assert(transposed.rank === 2, "Input to renderHeatmap must be a 2d array or Tensor2d");
        const transposedValues = yield transposed.array();
        transposed.dispose();
        const transposedShape = [transposedValues.length, transposedValues[0].length];
        utils_1.assert(originalShape[0] === transposedShape[1] && originalShape[1] === transposedShape[0], `Unexpected transposed shape. Original ${originalShape} : Transposed ${transposedShape}`);
        return transposedValues;
      });
    }
    function assertLabelsMatchShape(inputValues, labels3, dimension) {
      const shape3 = inputValues instanceof tf.Tensor ? inputValues.shape : [inputValues.length, inputValues[0].length];
      if (dimension === 0) {
        utils_1.assert(shape3[0] === labels3.length, `Length of xTickLabels (${labels3.length}) must match number of rows (${shape3[0]})`);
      } else if (dimension === 1) {
        utils_1.assert(shape3[1] === labels3.length, `Length of yTickLabels (${labels3.length}) must match number of columns (${shape3[1]})`);
      }
    }
    var defaultOpts = {
      xLabel: null,
      yLabel: null,
      xType: "ordinal",
      yType: "ordinal",
      colorMap: "viridis",
      fontSize: 12,
      domain: null,
      rowMajor: false
    };
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/util/math.js
var require_math = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/util/math.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var tfjs_core_1 = (init_dist(), __toCommonJS(dist_exports));
    var utils_1 = require_utils();
    function arrayStats(input) {
      if (!Array.isArray(input)) {
        throw new Error("input must be an array");
      }
      if (input.length === 0) {
        return {
          numVals: 0,
          numNans: 0,
          numZeros: 0,
          max: void 0,
          min: void 0
        };
      }
      const numVals = input.length;
      let max8 = -Infinity;
      let min8 = Infinity;
      let numZeros = 0;
      let numNans = 0;
      let numInfs = 0;
      for (let i = 0; i < numVals; i++) {
        const curr = input[i];
        if (curr > max8) {
          max8 = curr;
        }
        if (curr < min8) {
          min8 = curr;
        }
        if (curr === 0) {
          numZeros += 1;
        }
        if (isNaN(curr)) {
          numNans += 1;
        } else if (!isFinite(curr)) {
          numInfs += 1;
        }
      }
      const result = {
        numVals,
        numZeros,
        numNans,
        max: max8,
        min: min8,
        numInfs
      };
      if (result.max === -Infinity) {
        result.max = NaN;
      }
      if (result.min === Infinity) {
        result.min = NaN;
      }
      return result;
    }
    exports.arrayStats = arrayStats;
    function tensorStats(input) {
      return __awaiter2(this, void 0, void 0, function* () {
        const [min8, max8, numZeros] = tfjs_core_1.tidy(() => {
          const zero10 = tfjs_core_1.scalar(0, input.dtype);
          const min9 = input.min();
          const max9 = input.max();
          const numZeros2 = input.equal(zero10).sum();
          return [min9, max9, numZeros2];
        });
        return Promise.all([input.data(), min8.data(), max8.data(), numZeros.data()]).then(([tensorVal, minVal, maxVal, numZerosVal]) => {
          const numVals = tensorVal.length;
          let numNans = 0;
          let numInfs = 0;
          for (let i = 0; i < numVals; i++) {
            const curr = tensorVal[i];
            if (isNaN(curr)) {
              numNans += 1;
            } else if (!isFinite(curr)) {
              numInfs += 1;
            }
          }
          let trueMin = minVal[0];
          let trueMax = maxVal[0];
          if (numNans === numVals) {
            trueMin = NaN;
            trueMax = NaN;
          }
          const stats = {
            numVals,
            numZeros: numZerosVal[0],
            numNans,
            min: trueMin,
            max: trueMax,
            numInfs
          };
          return stats;
        });
      });
    }
    exports.tensorStats = tensorStats;
    function confusionMatrix(labels3, predictions, numClasses, weights) {
      return __awaiter2(this, void 0, void 0, function* () {
        utils_1.assert(labels3.rank === 1, "labels must be a 1D tensor");
        utils_1.assert(predictions.rank === 1, "predictions must be a 1D tensor");
        utils_1.assert(labels3.size === predictions.size, "labels and predictions must be the same length");
        if (weights != null) {
          utils_1.assert(weights.size === predictions.size, "labels and predictions must be the same length");
        }
        const labelsInt = labels3.cast("int32");
        const predictionsInt = predictions.cast("int32");
        if (numClasses == null) {
          numClasses = tfjs_core_1.tidy(() => {
            const max8 = tfjs_core_1.maximum(labelsInt.max(), predictionsInt.max()).cast("int32");
            return max8.dataSync()[0] + 1;
          });
        }
        let weightsPromise = Promise.resolve(null);
        if (weights != null) {
          weightsPromise = weights.data();
        }
        return Promise.all([labelsInt.data(), predictionsInt.data(), weightsPromise]).then(([labelsArray, predsArray, weightsArray]) => {
          const result = Array(numClasses).fill(0);
          for (let i = 0; i < numClasses; i++) {
            result[i] = Array(numClasses).fill(0);
          }
          for (let i = 0; i < labelsArray.length; i++) {
            const label = labelsArray[i];
            const pred = predsArray[i];
            if (weightsArray != null) {
              result[label][pred] += weightsArray[i];
            } else {
              result[label][pred] += 1;
            }
          }
          return result;
        });
      });
    }
    exports.confusionMatrix = confusionMatrix;
    function accuracy(labels3, predictions) {
      return __awaiter2(this, void 0, void 0, function* () {
        utils_1.assertShapesMatch(labels3.shape, predictions.shape, "Error computing accuracy.");
        const eq = labels3.equal(predictions);
        const mean4 = eq.mean();
        const acc = (yield mean4.data())[0];
        tfjs_core_1.dispose([eq, mean4]);
        return acc;
      });
    }
    exports.accuracy = accuracy;
    function perClassAccuracy(labels3, predictions, numClasses) {
      return __awaiter2(this, void 0, void 0, function* () {
        utils_1.assert(labels3.rank === 1, "labels must be a 1D tensor");
        utils_1.assert(predictions.rank === 1, "predictions must be a 1D tensor");
        utils_1.assert(labels3.size === predictions.size, "labels and predictions must be the same length");
        if (numClasses == null) {
          numClasses = tfjs_core_1.tidy(() => {
            return tfjs_core_1.maximum(labels3.max(), predictions.max()).dataSync()[0] + 1;
          });
        }
        return Promise.all([labels3.data(), predictions.data()]).then(([labelsArray, predsArray]) => {
          const counts = Array(numClasses).fill(0);
          const accuracy2 = Array(numClasses).fill(0);
          for (let i = 0; i < labelsArray.length; i++) {
            const label = labelsArray[i];
            const pred = predsArray[i];
            counts[label] += 1;
            if (label === pred) {
              accuracy2[label] += 1;
            }
          }
          const results = [];
          for (let i = 0; i < counts.length; i++) {
            results.push({
              count: counts[i],
              accuracy: counts[i] === 0 ? 0 : accuracy2[i] / counts[i]
            });
          }
          return results;
        });
      });
    }
    exports.perClassAccuracy = perClassAccuracy;
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/namespaces.js
var xhtml, namespaces_default;
var init_namespaces = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/namespaces.js"() {
    xhtml = "http://www.w3.org/1999/xhtml";
    namespaces_default = {
      svg: "http://www.w3.org/2000/svg",
      xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/namespace.js
function namespace_default(name4) {
  var prefix = name4 += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name4.slice(0, i)) !== "xmlns")
    name4 = name4.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name4 } : name4;
}
var init_namespace = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/namespace.js"() {
    init_namespaces();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/creator.js
function creatorInherit(name4) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name4) : document2.createElementNS(uri, name4);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name4) {
  var fullname = namespace_default(name4);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
var init_creator = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/creator.js"() {
    init_namespace();
    init_namespaces();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}
var init_selector = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selector.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/select.js
function select_default(select2) {
  if (typeof select2 !== "function")
    select2 = selector_default(select2);
  for (var groups4 = this._groups, m2 = groups4.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group6 = groups4[j], n = group6.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group6[i]) && (subnode = select2.call(node, node.__data__, i, group6))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
var init_select = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/select.js"() {
    init_selection3();
    init_selector();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}
var init_selectorAll = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selectorAll.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/selectAll.js
function selectAll_default(select2) {
  if (typeof select2 !== "function")
    select2 = selectorAll_default(select2);
  for (var groups4 = this._groups, m2 = groups4.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
    for (var group6 = groups4[j], n = group6.length, node, i = 0; i < n; ++i) {
      if (node = group6[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group6));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}
var init_selectAll = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/selectAll.js"() {
    init_selection3();
    init_selectorAll();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/matcher.js
var matcher, element4, vendorMatches, matcher_default;
var init_matcher = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/matcher.js"() {
    matcher = function(selector) {
      return function() {
        return this.matches(selector);
      };
    };
    if (typeof document !== "undefined") {
      element4 = document.documentElement;
      if (!element4.matches) {
        vendorMatches = element4.webkitMatchesSelector || element4.msMatchesSelector || element4.mozMatchesSelector || element4.oMatchesSelector;
        matcher = function(selector) {
          return function() {
            return vendorMatches.call(this, selector);
          };
        };
      }
    }
    matcher_default = matcher;
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/filter.js
function filter_default(match4) {
  if (typeof match4 !== "function")
    match4 = matcher_default(match4);
  for (var groups4 = this._groups, m2 = groups4.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group6 = groups4[j], n = group6.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group6[i]) && match4.call(node, node.__data__, i, group6)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
var init_filter5 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/filter.js"() {
    init_selection3();
    init_matcher();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update3) {
  return new Array(update3.length);
}
var init_sparse = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/sparse.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
var init_enter = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/enter.js"() {
    init_sparse();
    init_selection3();
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function(child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function(selector) {
        return this._parent.querySelector(selector);
      },
      querySelectorAll: function(selector) {
        return this._parent.querySelectorAll(selector);
      }
    };
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/constant.js
function constant_default10(x7) {
  return function() {
    return x7;
  };
}
var init_constant14 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/constant.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group6, enter, update3, exit, data3) {
  var i = 0, node, groupLength = group6.length, dataLength = data3.length;
  for (; i < dataLength; ++i) {
    if (node = group6[i]) {
      node.__data__ = data3[i];
      update3[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data3[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group6[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group6, enter, update3, exit, data3, key3) {
  var i, node, nodeByKeyValue = {}, groupLength = group6.length, dataLength = data3.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group6[i]) {
      keyValues[i] = keyValue = keyPrefix + key3.call(node, node.__data__, i, group6);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key3.call(parent, data3[i], i, data3);
    if (node = nodeByKeyValue[keyValue]) {
      update3[i] = node;
      node.__data__ = data3[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data3[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group6[i]) && nodeByKeyValue[keyValues[i]] === node) {
      exit[i] = node;
    }
  }
}
function data_default2(value4, key3) {
  if (!value4) {
    data3 = new Array(this.size()), j = -1;
    this.each(function(d) {
      data3[++j] = d;
    });
    return data3;
  }
  var bind4 = key3 ? bindKey : bindIndex, parents = this._parents, groups4 = this._groups;
  if (typeof value4 !== "function")
    value4 = constant_default10(value4);
  for (var m2 = groups4.length, update3 = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
    var parent = parents[j], group6 = groups4[j], groupLength = group6.length, data3 = value4.call(parent, parent && parent.__data__, j, parents), dataLength = data3.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update3[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind4(parent, group6, enterGroup, updateGroup, exitGroup, data3, key3);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update3 = new Selection(update3, parents);
  update3._enter = enter;
  update3._exit = exit;
  return update3;
}
var keyPrefix;
var init_data4 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/data.js"() {
    init_selection3();
    init_enter();
    init_constant14();
    keyPrefix = "$";
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}
var init_exit = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/exit.js"() {
    init_sparse();
    init_selection3();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/merge.js
function merge_default3(selection2) {
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge7 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge7[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}
var init_merge6 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/merge.js"() {
    init_selection3();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups4 = this._groups, j = -1, m2 = groups4.length; ++j < m2; ) {
    for (var group6 = groups4[j], i = group6.length - 1, next = group6[i], node; --i >= 0; ) {
      if (node = group6[i]) {
        if (next && next !== node.nextSibling)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
var init_order = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/order.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/sort.js
function sort_default2(compare6) {
  if (!compare6)
    compare6 = ascending7;
  function compareNode(a4, b3) {
    return a4 && b3 ? compare6(a4.__data__, b3.__data__) : !a4 - !b3;
  }
  for (var groups4 = this._groups, m2 = groups4.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group6 = groups4[j], n = group6.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group6[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending7(a4, b3) {
  return a4 < b3 ? -1 : a4 > b3 ? 1 : a4 >= b3 ? 0 : NaN;
}
var init_sort6 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/sort.js"() {
    init_selection3();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
var init_call = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/call.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() {
    nodes[++i] = this;
  });
  return nodes;
}
var init_nodes = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/nodes.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups4 = this._groups, j = 0, m2 = groups4.length; j < m2; ++j) {
    for (var group6 = groups4[j], i = 0, n = group6.length; i < n; ++i) {
      var node = group6[i];
      if (node)
        return node;
    }
  }
  return null;
}
var init_node = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/node.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/size.js
function size_default2() {
  var size = 0;
  this.each(function() {
    ++size;
  });
  return size;
}
var init_size2 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/size.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}
var init_empty = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/empty.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/each.js
function each_default2(callback) {
  for (var groups4 = this._groups, j = 0, m2 = groups4.length; j < m2; ++j) {
    for (var group6 = groups4[j], i = 0, n = group6.length, node; i < n; ++i) {
      if (node = group6[i])
        callback.call(node, node.__data__, i, group6);
    }
  }
  return this;
}
var init_each2 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/each.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/attr.js
function attrRemove(name4) {
  return function() {
    this.removeAttribute(name4);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name4, value4) {
  return function() {
    this.setAttribute(name4, value4);
  };
}
function attrConstantNS(fullname, value4) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value4);
  };
}
function attrFunction(name4, value4) {
  return function() {
    var v = value4.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name4);
    else
      this.setAttribute(name4, v);
  };
}
function attrFunctionNS(fullname, value4) {
  return function() {
    var v = value4.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name4, value4) {
  var fullname = namespace_default(name4);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value4 == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value4 === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value4));
}
var init_attr = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/attr.js"() {
    init_namespace();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
var init_window2 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/window.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/style.js
function styleRemove(name4) {
  return function() {
    this.style.removeProperty(name4);
  };
}
function styleConstant(name4, value4, priority) {
  return function() {
    this.style.setProperty(name4, value4, priority);
  };
}
function styleFunction(name4, value4, priority) {
  return function() {
    var v = value4.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name4);
    else
      this.style.setProperty(name4, v, priority);
  };
}
function style_default(name4, value4, priority) {
  return arguments.length > 1 ? this.each((value4 == null ? styleRemove : typeof value4 === "function" ? styleFunction : styleConstant)(name4, value4, priority == null ? "" : priority)) : styleValue(this.node(), name4);
}
function styleValue(node, name4) {
  return node.style.getPropertyValue(name4) || window_default(node).getComputedStyle(node, null).getPropertyValue(name4);
}
var init_style = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/style.js"() {
    init_window2();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/property.js
function propertyRemove(name4) {
  return function() {
    delete this[name4];
  };
}
function propertyConstant(name4, value4) {
  return function() {
    this[name4] = value4;
  };
}
function propertyFunction(name4, value4) {
  return function() {
    var v = value4.apply(this, arguments);
    if (v == null)
      delete this[name4];
    else
      this[name4] = v;
  };
}
function property_default(name4, value4) {
  return arguments.length > 1 ? this.each((value4 == null ? propertyRemove : typeof value4 === "function" ? propertyFunction : propertyConstant)(name4, value4)) : this.node()[name4];
}
var init_property = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/property.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value4) {
  return function() {
    (value4.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name4, value4) {
  var names = classArray(name4 + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value4 === "function" ? classedFunction : value4 ? classedTrue : classedFalse)(names, value4));
}
var init_classed = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/classed.js"() {
    ClassList.prototype = {
      add: function(name4) {
        var i = this._names.indexOf(name4);
        if (i < 0) {
          this._names.push(name4);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name4) {
        var i = this._names.indexOf(name4);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name4) {
        return this._names.indexOf(name4) >= 0;
      }
    };
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value4) {
  return function() {
    this.textContent = value4;
  };
}
function textFunction(value4) {
  return function() {
    var v = value4.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value4) {
  return arguments.length ? this.each(value4 == null ? textRemove : (typeof value4 === "function" ? textFunction : textConstant)(value4)) : this.node().textContent;
}
var init_text3 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/text.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value4) {
  return function() {
    this.innerHTML = value4;
  };
}
function htmlFunction(value4) {
  return function() {
    var v = value4.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value4) {
  return arguments.length ? this.each(value4 == null ? htmlRemove : (typeof value4 === "function" ? htmlFunction : htmlConstant)(value4)) : this.node().innerHTML;
}
var init_html = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/html.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}
var init_raise = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/raise.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}
var init_lower = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/lower.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/append.js
function append_default(name4) {
  var create5 = typeof name4 === "function" ? name4 : creator_default(name4);
  return this.select(function() {
    return this.appendChild(create5.apply(this, arguments));
  });
}
var init_append = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/append.js"() {
    init_creator();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name4, before) {
  var create5 = typeof name4 === "function" ? name4 : creator_default(name4), select2 = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create5.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
var init_insert = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/insert.js"() {
    init_creator();
    init_selector();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/remove.js
function remove2() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default2() {
  return this.each(remove2);
}
var init_remove2 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/remove.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}
function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
var init_clone = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/clone.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/datum.js
function datum_default(value4) {
  return arguments.length ? this.property("__data__", value4) : this.node().__data__;
}
var init_datum = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/datum.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/on.js
function filterContextListener(listener3, index8, group6) {
  listener3 = contextListener(listener3, index8, group6);
  return function(event3) {
    var related = event3.relatedTarget;
    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener3.call(this, event3);
    }
  };
}
function contextListener(listener3, index8, group6) {
  return function(event1) {
    var event0 = event2;
    event2 = event1;
    try {
      listener3.call(this, this.__data__, index8, group6);
    } finally {
      event2 = event0;
    }
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name4 = "", i = t.indexOf(".");
    if (i >= 0)
      name4 = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name: name4 };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2)
      return;
    for (var j = 0, i = -1, m2 = on2.length, o; j < m2; ++j) {
      if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on2[++i] = o;
      }
    }
    if (++i)
      on2.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value4, capture) {
  var wrap2 = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group6) {
    var on2 = this.__on, o, listener3 = wrap2(value4, i, group6);
    if (on2)
      for (var j = 0, m2 = on2.length; j < m2; ++j) {
        if ((o = on2[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener3, o.capture = capture);
          o.value = value4;
          return;
        }
      }
    this.addEventListener(typename.type, listener3, capture);
    o = { type: typename.type, name: typename.name, value: value4, listener: listener3, capture };
    if (!on2)
      this.__on = [o];
    else
      on2.push(o);
  };
}
function on_default(typename, value4, capture) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2)
      for (var j = 0, m2 = on2.length, o; j < m2; ++j) {
        for (i = 0, o = on2[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on2 = value4 ? onAdd : onRemove;
  if (capture == null)
    capture = false;
  for (i = 0; i < n; ++i)
    this.each(on2(typenames[i], value4, capture));
  return this;
}
function customEvent(event1, listener3, that, args) {
  var event0 = event2;
  event1.sourceEvent = event2;
  event2 = event1;
  try {
    return listener3.apply(that, args);
  } finally {
    event2 = event0;
  }
}
var filterEvents, event2, element4;
var init_on = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/on.js"() {
    filterEvents = {};
    event2 = null;
    if (typeof document !== "undefined") {
      element4 = document.documentElement;
      if (!("onmouseenter" in element4)) {
        filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
      }
    }
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type4, params2) {
  var window2 = window_default(node), event3 = window2.CustomEvent;
  if (typeof event3 === "function") {
    event3 = new event3(type4, params2);
  } else {
    event3 = window2.document.createEvent("Event");
    if (params2)
      event3.initEvent(type4, params2.bubbles, params2.cancelable), event3.detail = params2.detail;
    else
      event3.initEvent(type4, false, false);
  }
  node.dispatchEvent(event3);
}
function dispatchConstant(type4, params2) {
  return function() {
    return dispatchEvent(this, type4, params2);
  };
}
function dispatchFunction(type4, params2) {
  return function() {
    return dispatchEvent(this, type4, params2.apply(this, arguments));
  };
}
function dispatch_default2(type4, params2) {
  return this.each((typeof params2 === "function" ? dispatchFunction : dispatchConstant)(type4, params2));
}
var init_dispatch2 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/dispatch.js"() {
    init_window2();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/index.js
function Selection(groups4, parents) {
  this._groups = groups4;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
var root, selection_default;
var init_selection3 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selection/index.js"() {
    init_select();
    init_selectAll();
    init_filter5();
    init_data4();
    init_enter();
    init_exit();
    init_merge6();
    init_order();
    init_sort6();
    init_call();
    init_nodes();
    init_node();
    init_size2();
    init_empty();
    init_each2();
    init_attr();
    init_style();
    init_property();
    init_classed();
    init_text3();
    init_html();
    init_raise();
    init_lower();
    init_append();
    init_insert();
    init_remove2();
    init_clone();
    init_datum();
    init_on();
    init_dispatch2();
    root = [null];
    Selection.prototype = selection.prototype = {
      constructor: Selection,
      select: select_default,
      selectAll: selectAll_default,
      filter: filter_default,
      data: data_default2,
      enter: enter_default,
      exit: exit_default,
      merge: merge_default3,
      order: order_default,
      sort: sort_default2,
      call: call_default,
      nodes: nodes_default,
      node: node_default,
      size: size_default2,
      empty: empty_default,
      each: each_default2,
      attr: attr_default,
      style: style_default,
      property: property_default,
      classed: classed_default,
      text: text_default,
      html: html_default,
      raise: raise_default,
      lower: lower_default,
      append: append_default,
      insert: insert_default,
      remove: remove_default2,
      clone: clone_default,
      datum: datum_default,
      on: on_default,
      dispatch: dispatch_default2
    };
    selection_default = selection;
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}
var init_select2 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/select.js"() {
    init_selection3();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/create.js
function create_default(name4) {
  return select_default2(creator_default(name4).call(document.documentElement));
}
var init_create = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/create.js"() {
    init_creator();
    init_select2();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/local.js
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
var nextId;
var init_local = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/local.js"() {
    nextId = 0;
    Local.prototype = local.prototype = {
      constructor: Local,
      get: function(node) {
        var id4 = this._;
        while (!(id4 in node))
          if (!(node = node.parentNode))
            return;
        return node[id4];
      },
      set: function(node, value4) {
        return node[this._] = value4;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default() {
  var current2 = event2, source5;
  while (source5 = current2.sourceEvent)
    current2 = source5;
  return current2;
}
var init_sourceEvent = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/sourceEvent.js"() {
    init_on();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/point.js
function point_default(node, event3) {
  var svg = node.ownerSVGElement || node;
  if (svg.createSVGPoint) {
    var point16 = svg.createSVGPoint();
    point16.x = event3.clientX, point16.y = event3.clientY;
    point16 = point16.matrixTransform(node.getScreenCTM().inverse());
    return [point16.x, point16.y];
  }
  var rect4 = node.getBoundingClientRect();
  return [event3.clientX - rect4.left - node.clientLeft, event3.clientY - rect4.top - node.clientTop];
}
var init_point4 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/point.js"() {
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/mouse.js
function mouse_default(node) {
  var event3 = sourceEvent_default();
  if (event3.changedTouches)
    event3 = event3.changedTouches[0];
  return point_default(node, event3);
}
var init_mouse = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/mouse.js"() {
    init_sourceEvent();
    init_point4();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selectAll.js
function selectAll_default2(selector) {
  return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([selector == null ? [] : selector], root);
}
var init_selectAll2 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/selectAll.js"() {
    init_selection3();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/touch.js
function touch_default(node, touches, identifier) {
  if (arguments.length < 3)
    identifier = touches, touches = sourceEvent_default().changedTouches;
  for (var i = 0, n = touches ? touches.length : 0, touch2; i < n; ++i) {
    if ((touch2 = touches[i]).identifier === identifier) {
      return point_default(node, touch2);
    }
  }
  return null;
}
var init_touch = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/touch.js"() {
    init_sourceEvent();
    init_point4();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/touches.js
function touches_default(node, touches) {
  if (touches == null)
    touches = sourceEvent_default().touches;
  for (var i = 0, n = touches ? touches.length : 0, points2 = new Array(n); i < n; ++i) {
    points2[i] = point_default(node, touches[i]);
  }
  return points2;
}
var init_touches = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/touches.js"() {
    init_sourceEvent();
    init_point4();
  }
});

// node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/index.js
var src_exports6 = {};
__export(src_exports6, {
  clientPoint: () => point_default,
  create: () => create_default,
  creator: () => creator_default,
  customEvent: () => customEvent,
  event: () => event2,
  local: () => local,
  matcher: () => matcher_default,
  mouse: () => mouse_default,
  namespace: () => namespace_default,
  namespaces: () => namespaces_default,
  select: () => select_default2,
  selectAll: () => selectAll_default2,
  selection: () => selection_default,
  selector: () => selector_default,
  selectorAll: () => selectorAll_default,
  style: () => styleValue,
  touch: () => touch_default,
  touches: () => touches_default,
  window: () => window_default
});
var init_src35 = __esm({
  "node_modules/.pnpm/d3-selection@1.3.2/node_modules/d3-selection/src/index.js"() {
    init_create();
    init_creator();
    init_local();
    init_matcher();
    init_mouse();
    init_namespace();
    init_namespaces();
    init_point4();
    init_select2();
    init_selectAll2();
    init_selection3();
    init_selector();
    init_selectorAll();
    init_style();
    init_touch();
    init_touches();
    init_window2();
    init_on();
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/table.js
var require_table = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/table.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_format_1 = (init_src15(), __toCommonJS(src_exports2));
    var d3_selection_1 = (init_src35(), __toCommonJS(src_exports6));
    var glamor_1 = require_lib();
    var render_utils_1 = require_render_utils();
    function table(container, data3, opts = {}) {
      if (data3 && data3.headers == null) {
        throw new Error('Data to render must have a "headers" property');
      }
      if (data3 && data3.values == null) {
        throw new Error('Data to render must have a "values" property');
      }
      const drawArea = render_utils_1.getDrawArea(container);
      const options2 = Object.assign({}, defaultOpts, opts);
      let table2 = d3_selection_1.select(drawArea).select("table.tf-table");
      const tableStyle = glamor_1.css({
        fontSize: options2.fontSize || ".875rem",
        width: "100%",
        maxWidth: "64rem",
        marginRight: "auto",
        marginLeft: "auto"
      });
      if (table2.size() === 0) {
        table2 = d3_selection_1.select(drawArea).append("table");
        table2.attr("class", ` ${tableStyle} tf-table`);
        table2.append("thead").append("tr");
        table2.append("tbody");
      }
      if (table2.size() !== 1) {
        throw new Error("Error inserting table");
      }
      const headerRowStyle = glamor_1.css({
        fontWeight: "600",
        borderBottomStyle: "solid",
        borderBottomWidth: "1px",
        borderColor: "rgba( 0, 0, 0, .2 )",
        textAlign: "left",
        paddingBottom: "1rem",
        paddingRight: "1rem",
        backgroundColor: "#fff"
      });
      const headers = table2.select("thead").select("tr").selectAll("th").data(data3.headers);
      const headersEnter = headers.enter().append("th").attr("class", `${headerRowStyle}`);
      headers.merge(headersEnter).html((d) => d);
      headers.exit().remove();
      const format9 = d3_format_1.format(",.4~f");
      const rows = table2.select("tbody").selectAll("tr").data(data3.values);
      const rowsEnter = rows.enter().append("tr");
      const cellStyle = glamor_1.css({
        padding: "0.25rem",
        borderBottomStyle: "solid",
        borderBottomWidth: "1px",
        borderColor: "rgba( 0, 0, 0, .2 )"
      });
      const cells = rows.merge(rowsEnter).selectAll("td").data((d) => d);
      const cellsEnter = cells.enter().append("td").attr("class", `${cellStyle}`);
      cells.merge(cellsEnter).html((d) => typeof d === "number" ? format9(d) : d);
      cells.exit().remove();
      rows.exit().remove();
    }
    exports.table = table;
    var defaultOpts = {
      fontSize: 14
    };
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/histogram.js
var require_histogram = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/histogram.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_format_1 = (init_src15(), __toCommonJS(src_exports2));
    var vega_embed_1 = __importDefault((init_vega_embed_module(), __toCommonJS(vega_embed_module_exports)));
    var dom_1 = require_dom();
    var math_1 = require_math();
    var table_1 = require_table();
    var defaultOpts = {
      maxBins: 12,
      fontSize: 11
    };
    function histogram(container, data3, opts = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        const values5 = prepareData(data3);
        const options2 = Object.assign({}, defaultOpts, opts);
        const embedOpts = {
          actions: false,
          mode: "vega-lite",
          defaultStyle: false
        };
        const histogramContainer = dom_1.subSurface(container, "histogram");
        if (opts.stats !== false) {
          const statsContainer = dom_1.subSurface(container, "stats", {
            prepend: true
          });
          let stats;
          if (opts.stats) {
            stats = opts.stats;
          } else {
            stats = math_1.arrayStats(values5.map((x7) => x7.value));
          }
          renderStats(stats, statsContainer, { fontSize: options2.fontSize });
        }
        if (values5.length === 0) {
          return void 0;
        }
        const filtered = [];
        for (let i = 0; i < values5.length; i++) {
          const val = values5[i].value;
          if (val != null && isFinite(val)) {
            filtered.push(values5[i]);
          }
        }
        const histogramSpec = {
          "width": options2.width || dom_1.getDefaultWidth(histogramContainer),
          "height": options2.height || dom_1.getDefaultHeight(histogramContainer),
          "padding": 0,
          "autosize": {
            "type": "fit",
            "contains": "padding",
            "resize": true
          },
          "data": { "values": filtered },
          "mark": {
            "type": "bar",
            "tooltip": true
          },
          "config": {
            "axis": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            },
            "text": { "fontSize": options2.fontSize },
            "legend": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            }
          },
          "encoding": {
            "x": {
              "bin": { "maxbins": options2.maxBins },
              "field": "value",
              "type": "quantitative"
            },
            "y": {
              "aggregate": "count",
              "type": "quantitative"
            },
            "color": {
              "value": options2.color || "#001B44"
            }
          }
        };
        return vega_embed_1.default(histogramContainer, histogramSpec, embedOpts);
      });
    }
    exports.histogram = histogram;
    function renderStats(stats, container, opts) {
      const format9 = d3_format_1.format(",.4~f");
      const pctFormat = d3_format_1.format(".4~p");
      const headers = [];
      const vals2 = [];
      if (stats.numVals != null) {
        headers.push("Num Vals");
        vals2.push(format9(stats.numVals));
      }
      if (stats.min != null) {
        headers.push("Min");
        vals2.push(format9(stats.min));
      }
      if (stats.max != null) {
        headers.push("Max");
        vals2.push(format9(stats.max));
      }
      if (stats.numZeros != null) {
        headers.push("# Zeros");
        let zeroPct = "";
        if (stats.numVals) {
          zeroPct = stats.numZeros > 0 ? `(${pctFormat(stats.numZeros / stats.numVals)})` : "";
        }
        vals2.push(`${format9(stats.numZeros)} ${zeroPct}`);
      }
      if (stats.numNans != null) {
        headers.push("# NaNs");
        let nanPct = "";
        if (stats.numVals) {
          nanPct = stats.numNans > 0 ? `(${pctFormat(stats.numNans / stats.numVals)})` : "";
        }
        vals2.push(`${format9(stats.numNans)} ${nanPct}`);
      }
      if (stats.numInfs != null) {
        headers.push("# Infinity");
        let infPct = "";
        if (stats.numVals) {
          infPct = stats.numInfs > 0 ? `(${pctFormat(stats.numInfs / stats.numVals)})` : "";
        }
        vals2.push(`${format9(stats.numInfs)} ${infPct}`);
      }
      table_1.table(container, { headers, values: [vals2] }, opts);
    }
    function prepareData(data3) {
      if (data3.length == null) {
        throw new Error("input data must be an array");
      }
      if (data3.length === 0) {
        return [];
      } else if (typeof data3[0] === "object") {
        if (data3[0].value == null) {
          throw new Error("input data must have a value field");
        } else {
          return data3;
        }
      } else {
        const ret = Array(data3.length);
        for (let i = 0; i < data3.length; i++) {
          ret[i] = { value: data3[i] };
        }
        return ret;
      }
    }
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/linechart.js
var require_linechart = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/linechart.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var vega_embed_1 = __importDefault((init_vega_embed_module(), __toCommonJS(vega_embed_module_exports)));
    var dom_1 = require_dom();
    var utils_1 = require_utils();
    var render_utils_1 = require_render_utils();
    function linechart(container, data3, opts = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        const _data = Array.isArray(data3.values[0]) ? data3.values : [data3.values];
        const numValues = _data[0].length;
        const _series = data3.series ? data3.series : _data.map((_, i) => `Series ${i + 1}`);
        utils_1.assert(_series.length === _data.length, "Must have an equal number of series labels as there are data series");
        if (opts.seriesColors != null) {
          utils_1.assert(opts.seriesColors.length === _data.length, "Must have an equal number of series colors as there are data series");
        }
        const vlChartValues = [];
        for (let valueIdx = 0; valueIdx < numValues; valueIdx++) {
          const v = {
            x: valueIdx
          };
          _series.forEach((seriesName, seriesIdx) => {
            const seriesValue = _data[seriesIdx][valueIdx].y;
            v[seriesName] = seriesValue;
            v[`${seriesName}-name`] = seriesName;
          });
          vlChartValues.push(v);
        }
        const options2 = Object.assign({}, defaultOpts, opts);
        const yScale = () => {
          if (options2.zoomToFit) {
            return { "zero": false };
          } else if (options2.yAxisDomain != null) {
            return { "domain": options2.yAxisDomain };
          }
          return void 0;
        };
        const sharedEncoding = {
          x: {
            field: "x",
            type: options2.xType,
            title: options2.xLabel
          },
          tooltip: [
            { field: "x", type: "quantitative" },
            ..._series.map((seriesName) => {
              return {
                field: seriesName,
                type: "quantitative"
              };
            })
          ]
        };
        const lineLayers = _series.map((seriesName) => {
          return {
            "data": void 0,
            "mark": { "type": "line", "clip": true },
            "encoding": {
              "y": {
                "field": seriesName,
                "type": options2.yType,
                "title": options2.yLabel,
                "scale": yScale()
              },
              "color": {
                "field": `${seriesName}-name`,
                "type": "nominal",
                "legend": { "values": _series, title: null },
                "scale": {
                  "range": options2.seriesColors
                }
              }
            }
          };
        });
        const tooltipLayer = {
          "mark": "rule",
          "selection": {
            "hover": {
              "type": "single",
              "on": "mouseover",
              "nearest": true,
              clear: "mouseout"
            }
          },
          "encoding": {
            "color": {
              "value": "grey",
              "condition": {
                "selection": { "not": "hover" },
                "value": "transparent"
              }
            }
          }
        };
        const drawArea = render_utils_1.getDrawArea(container);
        const spec = {
          "width": options2.width || dom_1.getDefaultWidth(drawArea),
          "height": options2.height || dom_1.getDefaultHeight(drawArea),
          "padding": 0,
          "autosize": {
            "type": "fit",
            "contains": "padding",
            "resize": true
          },
          "config": {
            "axis": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            },
            "text": { "fontSize": options2.fontSize },
            "legend": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            }
          },
          "data": { "values": vlChartValues },
          "encoding": sharedEncoding,
          "layer": [
            ...lineLayers,
            tooltipLayer
          ]
        };
        const embedOpts = {
          actions: false,
          mode: "vega-lite",
          defaultStyle: false
        };
        yield vega_embed_1.default(drawArea, spec, embedOpts);
        return Promise.resolve();
      });
    }
    exports.linechart = linechart;
    var defaultOpts = {
      xLabel: "x",
      yLabel: "y",
      xType: "quantitative",
      yType: "quantitative",
      zoomToFit: false,
      fontSize: 11
    };
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/scatterplot.js
var require_scatterplot = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/render/scatterplot.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var vega_embed_1 = __importDefault((init_vega_embed_module(), __toCommonJS(vega_embed_module_exports)));
    var dom_1 = require_dom();
    var utils_1 = require_utils();
    var render_utils_1 = require_render_utils();
    function scatterplot(container, data3, opts = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        let _values = data3.values;
        const _series = data3.series == null ? [] : data3.series;
        _values = Array.isArray(_values[0]) ? _values : [_values];
        const values5 = [];
        _values.forEach((seriesData, i) => {
          const seriesName = _series[i] != null ? _series[i] : `Series ${i + 1}`;
          const seriesVals = seriesData.map((v) => Object.assign({}, v, { series: seriesName }));
          values5.push(...seriesVals);
        });
        if (opts.seriesColors != null) {
          utils_1.assert(opts.seriesColors.length === _values.length, "Must have an equal number of series colors as there are data series");
        }
        const drawArea = render_utils_1.getDrawArea(container);
        const options2 = Object.assign({}, defaultOpts, opts);
        const embedOpts = {
          actions: false,
          mode: "vega-lite",
          defaultStyle: false
        };
        const xDomain = () => {
          if (options2.zoomToFit) {
            return { "zero": false };
          } else if (options2.xAxisDomain != null) {
            return { "domain": options2.xAxisDomain };
          }
          return void 0;
        };
        const yDomain = () => {
          if (options2.zoomToFit) {
            return { "zero": false };
          } else if (options2.yAxisDomain != null) {
            return { "domain": options2.yAxisDomain };
          }
          return void 0;
        };
        const spec = {
          "width": options2.width || dom_1.getDefaultWidth(drawArea),
          "height": options2.height || dom_1.getDefaultHeight(drawArea),
          "padding": 0,
          "autosize": {
            "type": "fit",
            "contains": "padding",
            "resize": true
          },
          "config": {
            "axis": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            },
            "text": { "fontSize": options2.fontSize },
            "legend": {
              "labelFontSize": options2.fontSize,
              "titleFontSize": options2.fontSize
            }
          },
          "data": {
            "values": values5
          },
          "mark": {
            "type": "point",
            "clip": true,
            "tooltip": { "content": "data" }
          },
          "encoding": {
            "x": {
              "field": "x",
              "type": options2.xType,
              "title": options2.xLabel,
              "scale": xDomain()
            },
            "y": {
              "field": "y",
              "type": options2.yType,
              "title": options2.yLabel,
              "scale": yDomain()
            },
            "color": {
              "field": "series",
              "type": "nominal",
              "scale": {
                "range": options2.seriesColors
              }
            },
            "shape": {
              "field": "series",
              "type": "nominal"
            }
          }
        };
        yield vega_embed_1.default(drawArea, spec, embedOpts);
        return Promise.resolve();
      });
    }
    exports.scatterplot = scatterplot;
    var defaultOpts = {
      xLabel: "x",
      yLabel: "y",
      xType: "quantitative",
      yType: "quantitative",
      zoomToFit: false,
      fontSize: 11
    };
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/show/history.js
var require_history = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/show/history.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var linechart_1 = require_linechart();
    var render_utils_1 = require_render_utils();
    var dom_1 = require_dom();
    function history(container, history2, metrics, opts = {}) {
      return __awaiter2(this, void 0, void 0, function* () {
        const drawArea = render_utils_1.getDrawArea(container);
        const plots = {};
        for (const metric of metrics) {
          if (!/val_/.test(metric)) {
            const values5 = getValues(history2, metric, metrics.indexOf(metric));
            initPlot(plots, metric);
            plots[metric].series.push(metric);
            plots[metric].values.push(values5);
          } else {
            const nonValidationMetric = metric.replace("val_", "");
            initPlot(plots, nonValidationMetric);
            const values5 = getValues(history2, metric, metrics.indexOf(metric));
            plots[nonValidationMetric].series.push(metric);
            plots[nonValidationMetric].values.push(values5);
          }
        }
        const plotNames = Object.keys(plots);
        const options2 = Object.assign({}, { xLabel: "Iteration", yLabel: "Value" }, opts);
        const renderPromises = [];
        for (const name4 of plotNames) {
          const subContainer = dom_1.subSurface(drawArea, name4);
          const series = plots[name4].series;
          const values5 = plots[name4].values;
          if (series.every((seriesName) => Boolean(seriesName.match("acc")))) {
            if (options2.zoomToFitAccuracy) {
              options2.zoomToFit = true;
            } else {
              options2.yAxisDomain = [0, 1];
              delete options2.zoomToFit;
            }
          }
          const done = linechart_1.linechart(subContainer, { values: values5, series }, options2);
          renderPromises.push(done);
        }
        yield Promise.all(renderPromises);
      });
    }
    exports.history = history;
    function initPlot(plot, name4) {
      if (plot[name4] == null) {
        plot[name4] = { series: [], values: [] };
      }
    }
    function getValues(history2, metric, metricIndex) {
      if (Array.isArray(history2)) {
        const metricHistory = Array.isArray(history2[0]) ? history2[metricIndex] : history2;
        const points2 = [];
        for (let i = 0; i < metricHistory.length; i++) {
          const log9 = metricHistory[i];
          points2.push({ x: i, y: log9[metric] });
        }
        return points2;
      } else {
        return history2.history[metric].map((y7, x7) => ({ x: x7, y: y7 }));
      }
    }
    function fitCallbacks(container, metrics, opts = {}) {
      const accumulators = {};
      const callbackNames = opts.callbacks || ["onEpochEnd", "onBatchEnd"];
      const drawArea = render_utils_1.getDrawArea(container);
      const historyOpts = Object.assign({}, opts);
      delete historyOpts.callbacks;
      function makeCallbackFor(callbackName) {
        return (_, log9) => __awaiter2(this, void 0, void 0, function* () {
          if (/batch/i.test(callbackName)) {
            historyOpts.xLabel = "Batch";
          } else if (/epoch/i.test(callbackName)) {
            historyOpts.xLabel = "Epoch";
          }
          const metricLogs = [];
          const presentMetrics = [];
          for (const metric of metrics) {
            if (log9[metric] != null) {
              presentMetrics.push(metric);
              const accumulator = getAccumulator(accumulators, callbackName, metric);
              accumulator.push({ [metric]: log9[metric] });
              metricLogs.push(accumulator);
            }
          }
          const subContainer = dom_1.subSurface(drawArea, callbackName, { title: callbackName });
          history(subContainer, metricLogs, presentMetrics, historyOpts);
          yield render_utils_1.nextFrame();
        });
      }
      const callbacks = {};
      callbackNames.forEach((name4) => {
        callbacks[name4] = makeCallbackFor(name4);
      });
      return callbacks;
    }
    exports.fitCallbacks = fitCallbacks;
    function getAccumulator(accumulators, callback, metric) {
      if (accumulators[callback] == null) {
        accumulators[callback] = {};
      }
      if (accumulators[callback][metric] == null) {
        accumulators[callback][metric] = [];
      }
      return accumulators[callback][metric];
    }
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/show/model.js
var require_model = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/show/model.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var histogram_1 = require_histogram();
    var render_utils_1 = require_render_utils();
    var table_1 = require_table();
    var dom_1 = require_dom();
    var math_1 = require_math();
    function modelSummary(container, model) {
      return __awaiter2(this, void 0, void 0, function* () {
        const drawArea = render_utils_1.getDrawArea(container);
        const summary = getModelSummary(model);
        const headers = [
          "Layer Name",
          "Output Shape",
          "# Of Params",
          "Trainable"
        ];
        const values5 = summary.layers.map((l) => [
          l.name,
          l.outputShape,
          l.parameters,
          l.trainable
        ]);
        table_1.table(drawArea, { headers, values: values5 });
      });
    }
    exports.modelSummary = modelSummary;
    function layer(container, layer2) {
      return __awaiter2(this, void 0, void 0, function* () {
        const drawArea = render_utils_1.getDrawArea(container);
        const details = yield getLayerDetails(layer2);
        const headers = [
          "Weight Name",
          "Shape",
          "Min",
          "Max",
          "# Params",
          "# Zeros",
          "# NaNs",
          "# Infinity"
        ];
        const weightsInfoSurface = dom_1.subSurface(drawArea, "layer-weights-info");
        const detailValues = details.map((l) => [
          l.name,
          l.shape,
          l.stats.min,
          l.stats.max,
          l.weight.size,
          l.stats.numZeros,
          l.stats.numNans,
          l.stats.numInfs
        ]);
        table_1.table(weightsInfoSurface, { headers, values: detailValues });
        const histogramSelectorSurface = dom_1.subSurface(drawArea, "select-layer");
        const layerValuesHistogram = dom_1.subSurface(drawArea, "param-distribution");
        const handleSelection = (layerName) => __awaiter2(this, void 0, void 0, function* () {
          const layer3 = details.filter((d) => d.name === layerName)[0];
          const weights = yield layer3.weight.data();
          histogram_1.histogram(layerValuesHistogram, weights, { height: 150, width: 460, stats: false });
        });
        addHistogramSelector(details.map((d) => d.name), histogramSelectorSurface, handleSelection);
      });
    }
    exports.layer = layer;
    function getModelSummary(model) {
      return {
        layers: model.layers.map(getLayerSummary)
      };
    }
    function getLayerSummary(layer2) {
      let outputShape;
      if (Array.isArray(layer2.outputShape[0])) {
        const shapes = layer2.outputShape.map((s3) => formatShape(s3));
        outputShape = `[${shapes.join(", ")}]`;
      } else {
        outputShape = formatShape(layer2.outputShape);
      }
      return {
        name: layer2.name,
        trainable: layer2.trainable,
        parameters: layer2.countParams(),
        outputShape
      };
    }
    function getLayerDetails(layer2) {
      return __awaiter2(this, void 0, void 0, function* () {
        const weights = layer2.getWeights();
        const layerVariables = layer2.weights;
        const statsPromises = weights.map(math_1.tensorStats);
        const stats = yield Promise.all(statsPromises);
        const shapes = weights.map((w5) => w5.shape);
        return weights.map((weight, i) => ({
          name: layerVariables[i].name,
          stats: stats[i],
          shape: formatShape(shapes[i]),
          weight
        }));
      });
    }
    function formatShape(shape3) {
      const oShape = shape3.slice();
      if (oShape.length === 0) {
        return "Scalar";
      }
      if (oShape[0] === null) {
        oShape[0] = "batch";
      }
      return `[${oShape.join(",")}]`;
    }
    function addHistogramSelector(items2, parent, selectionHandler) {
      const select2 = `
    <select>
      ${items2.map((i) => `<option value=${i}>${i}</option>`)}
    </select>
  `;
      const button = `<button>Show Values Distribution for:</button>`;
      const content3 = `<div>${button}${select2}</div>`;
      parent.innerHTML = content3;
      const buttonEl = parent.querySelector("button");
      const selectEl = parent.querySelector("select");
      buttonEl.addEventListener("click", () => {
        selectionHandler(selectEl.selectedOptions[0].label);
      });
    }
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/show/quality.js
var require_quality = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/show/quality.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var render_utils_1 = require_render_utils();
    var table_1 = require_table();
    function perClassAccuracy(container, classAccuracy, classLabels) {
      return __awaiter2(this, void 0, void 0, function* () {
        const drawArea = render_utils_1.getDrawArea(container);
        const headers = [
          "Class",
          "Accuracy",
          "# Samples"
        ];
        const values5 = [];
        for (let i = 0; i < classAccuracy.length; i++) {
          const label = classLabels ? classLabels[i] : i.toString();
          const classAcc = classAccuracy[i];
          values5.push([label, classAcc.accuracy, classAcc.count]);
        }
        return table_1.table(drawArea, { headers, values: values5 });
      });
    }
    exports.perClassAccuracy = perClassAccuracy;
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/show/tensor.js
var require_tensor = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/show/tensor.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value4) {
          try {
            step(generator.next(value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value4) {
          try {
            step(generator["throw"](value4));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var histogram_1 = require_histogram();
    var render_utils_1 = require_render_utils();
    var math_1 = require_math();
    function valuesDistribution(container, tensor) {
      return __awaiter2(this, void 0, void 0, function* () {
        const drawArea = render_utils_1.getDrawArea(container);
        const stats = yield math_1.tensorStats(tensor);
        const values5 = yield tensor.data();
        histogram_1.histogram(drawArea, values5, { height: 150, stats });
      });
    }
    exports.valuesDistribution = valuesDistribution;
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var version5 = "1.5.1";
    exports.version = version5;
  }
});

// node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@tensorflow+tfjs-vis@1.5.1_@tensorflow+tfjs-core@4.10.0/node_modules/@tensorflow/tfjs-vis/dist/index.js"(exports) {
    function __export2(m2) {
      for (var p in m2)
        if (!exports.hasOwnProperty(p))
          exports[p] = m2[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    init_dist();
    init_register_all_chained_ops();
    var barchart_1 = require_barchart();
    var confusion_matrix_1 = require_confusion_matrix();
    var heatmap_1 = require_heatmap();
    var histogram_1 = require_histogram();
    var linechart_1 = require_linechart();
    var scatterplot_1 = require_scatterplot();
    var table_1 = require_table();
    var history_1 = require_history();
    var model_1 = require_model();
    var quality_1 = require_quality();
    var tensor_1 = require_tensor();
    var math_1 = require_math();
    var version_1 = require_version();
    exports.version_vis = version_1.version;
    var render3 = {
      barchart: barchart_1.barchart,
      table: table_1.table,
      histogram: histogram_1.histogram,
      linechart: linechart_1.linechart,
      scatterplot: scatterplot_1.scatterplot,
      confusionMatrix: confusion_matrix_1.confusionMatrix,
      heatmap: heatmap_1.heatmap
    };
    exports.render = render3;
    var metrics = {
      accuracy: math_1.accuracy,
      perClassAccuracy: math_1.perClassAccuracy,
      confusionMatrix: math_1.confusionMatrix
    };
    exports.metrics = metrics;
    var show = {
      history: history_1.history,
      fitCallbacks: history_1.fitCallbacks,
      perClassAccuracy: quality_1.perClassAccuracy,
      valuesDistribution: tensor_1.valuesDistribution,
      layer: model_1.layer,
      modelSummary: model_1.modelSummary
    };
    exports.show = show;
    var visor_1 = require_visor2();
    exports.visor = visor_1.visor;
    __export2(require_types());
  }
});
export default require_dist();
//# sourceMappingURL=@tensorflow_tfjs-vis.js.map
