/**
 * name: @tresjs/core
 * version: v3.0.1
 * (c) 2023
 * description: Declarative ThreeJS using Vue Components
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
import { ref as H, computed as _, watchEffect as b, onUnmounted as j, shallowRef as z, watch as K, reactive as re, readonly as ne, provide as ae, inject as oe, createRenderer as se, defineComponent as ie, useSlots as ue, onMounted as le, openBlock as ce, createElementBlock as fe, normalizeStyle as me } from "vue";
import * as pe from "three";
import { PerspectiveCamera as W, OrthographicCamera as ve, Camera as de, Clock as ge, SRGBColorSpace as we, ACESFilmicToneMapping as ye, PCFSoftShadowMap as Ce, Vector3 as Pe, Color as O, WebGLRenderer as V, LoadingManager as Me, TextureLoader as _e, Vector2 as Ee, Raycaster as xe, BufferAttribute as Le, Scene as Te } from "three";
import { createEventHook as A, useRafFn as be, toValue as y, unrefElement as De, useDevicePixelRatio as Ae, usePointer as ke, useElementBounding as Se, useWindowSize as he, useElementSize as Be } from "@vueuse/core";
const X = H({}), $ = (e) => void Object.assign(X.value, e), N = (e) => typeof e == "function", Y = (e) => !!e && e.constructor === Array, Oe = ({ sizes: e, scene: a }) => {
  const t = H([]), n = _(
    () => t.value[0]
  ), r = (o, s = !1) => {
    t.value.some(({ uuid: u }) => u === o.uuid) || (s ? l(o) : t.value.push(o));
  }, i = (o) => {
    t.value = t.value.filter(({ uuid: s }) => s !== o.uuid);
  }, l = (o) => {
    const s = o instanceof de ? o : t.value.find((c) => c.uuid === o);
    if (!s)
      return;
    const u = t.value.filter(({ uuid: c }) => c !== s.uuid);
    t.value = [s, ...u];
  };
  return b(() => {
    e.aspectRatio.value && t.value.forEach((o) => {
      o instanceof W && (o.aspect = e.aspectRatio.value), (o instanceof W || o instanceof ve) && o.updateProjectionMatrix();
    });
  }), a.userData.tres__registerCamera = r, a.userData.tres__deregisterCamera = i, j(() => {
    t.value = [];
  }), {
    camera: n,
    cameras: t,
    addCamera: r,
    removeCamera: i,
    setCameraActive: l
  };
}, Q = A(), Z = A(), I = A(), D = new ge();
let R = 0, F = 0;
const { pause: Re, resume: Fe, isActive: ze } = be(
  () => {
    Q.trigger({ delta: R, elapsed: F, clock: D }), Z.trigger({ delta: R, elapsed: F, clock: D }), I.trigger({ delta: R, elapsed: F, clock: D });
  },
  { immediate: !1 }
);
I.on(() => {
  R = D.getDelta(), F = D.getElapsedTime();
});
const ee = () => ({
  onBeforeLoop: Q.on,
  onLoop: Z.on,
  onAfterLoop: I.on,
  pause: Re,
  resume: Fe,
  isActive: ze
}), h = {
  realistic: {
    outputColorSpace: we,
    toneMapping: ye,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: !0,
      type: Ce
    }
  }
}, te = (e, a) => {
  for (const t of Object.keys(a))
    a[t] instanceof Object && Object.assign(a[t], te(e[t], a[t]));
  return Object.assign(e || {}, a), e;
}, He = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Ve = /* @__PURE__ */ Ge(He);
function B(e) {
  return e.replace(/-([a-z])/g, (a, t) => t.toUpperCase());
}
function Ge(e, a) {
  const t = /* @__PURE__ */ Object.create(null), n = e.split(",");
  for (let r = 0; r < n.length; r++)
    t[n[r]] = !0;
  return a ? (r) => !!t[r.toLowerCase()] : (r) => !!t[r];
}
const We = (e, a) => {
  const t = /* @__PURE__ */ new Set(), n = [];
  for (const r of e) {
    const i = a(r);
    t.has(i) || (t.add(i), n.push(r));
  }
  return n;
}, q = (e, a) => {
  if (!a)
    return;
  const t = Array.isArray(a) ? a : a.match(/([^[.\]])+/g);
  return t == null ? void 0 : t.reduce((n, r) => n && n[r], e);
}, je = (e, a, t) => {
  const n = Array.isArray(a) ? a : a.match(/([^[.\]])+/g);
  n && n.reduce((r, i, l) => (r[i] === void 0 && (r[i] = {}), l === n.length - 1 && (r[i] = t), r[i]), e);
}, st = !0, U = "[TresJS ▲ ■ ●] ";
function k() {
  function e(n, r) {
    console.error(`${U} ${n}`, r || "");
  }
  function a(n) {
    console.warn(`${U} ${n}`);
  }
  function t(n, r) {
  }
  return {
    logError: e,
    logWarning: a,
    logMessage: t
  };
}
function it(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof Pe ? [e.x, e.y, e.z] : e;
}
function $e(e) {
  return e instanceof O ? e : Array.isArray(e) ? new O(...e) : new O(e);
}
function Ie({
  scene: e,
  canvas: a,
  options: t,
  disableRender: n,
  contextParts: { sizes: r, camera: i }
}) {
  const l = _(() => ({
    alpha: y(t.alpha),
    depth: y(t.depth),
    canvas: De(a),
    context: y(t.context),
    stencil: y(t.stencil),
    antialias: y(t.antialias) === void 0 ? (
      // an opinionated default of tres
      !0
    ) : y(t.antialias),
    precision: y(t.precision),
    powerPreference: y(t.powerPreference),
    premultipliedAlpha: y(t.premultipliedAlpha),
    preserveDrawingBuffer: y(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: y(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: y(t.failIfMajorPerformanceCaveat)
  })), o = z(new V(l.value));
  K(l, () => {
    o.value.dispose(), o.value = new V(l.value);
  }), b(() => {
    o.value.setSize(r.width.value, r.height.value);
  });
  const { pixelRatio: s } = Ae();
  b(() => {
    o.value.setPixelRatio(s.value);
  });
  const { logError: u } = k(), f = (() => {
    const p = new V(), d = {
      shadowMap: {
        enabled: p.shadowMap.enabled,
        type: p.shadowMap.type
      },
      toneMapping: p.toneMapping,
      toneMappingExposure: p.toneMappingExposure,
      outputColorSpace: p.outputColorSpace,
      useLegacyLights: p.useLegacyLights
    };
    return p.dispose(), d;
  })();
  b(() => {
    const p = y(t.preset);
    p && (p in h || u("Renderer Preset must be one of these: " + Object.keys(h).join(", ")), te(o.value, h[p]));
    const d = (L, x) => {
      const T = y(L), S = () => {
        if (p)
          return q(h[p], x);
      };
      if (T !== void 0)
        return T;
      const m = S();
      return m !== void 0 ? m : q(f, x);
    }, v = (L, x) => je(o.value, x, d(L, x));
    v(t.shadows, "shadowMap.enabled"), v(t.toneMapping, "toneMapping"), v(t.shadowMapType, "shadowMap.type"), v(t.useLegacyLights, "useLegacyLights"), v(t.outputColorSpace, "outputColorSpace"), v(t.toneMappingExposure, "toneMappingExposure");
    const E = d(t.clearColor, "clearColor");
    E && o.value.setClearColor(
      E ? $e(E) : new O(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  });
  const { pause: w, resume: C, onLoop: M } = ee();
  return M(() => {
    i.value && !y(n) && o.value.render(e, i.value);
  }), C(), j(() => {
    w(), o.value.dispose(), o.value.forceContextLoss();
  }), {
    renderer: o
  };
}
function Ne(e) {
  const a = { nodes: {}, materials: {} };
  return e && e.traverse((t) => {
    t.name && (a.nodes[t.name] = t), t.material && !a.materials[t.material.name] && (a.materials[t.material.name] = t.material);
  }), a;
}
async function ut(e, a, t, n, r) {
  const { logError: i } = k(), l = new e();
  r && r(l), t && t(l);
  const s = (Array.isArray(a) ? a : [a]).map(
    (u) => new Promise((c, f) => {
      l.load(
        u,
        (w) => {
          w.scene && Object.assign(w, Ne(w.scene)), c(w);
        },
        n,
        (w) => f(i("[useLoader] - Failed to load resource", w))
      );
    })
  );
  return Y(a) ? await Promise.all(s) : await s[0];
}
async function lt(e) {
  const a = new Me(), t = new _e(a), n = (r) => new Promise((i, l) => {
    t.load(
      r,
      (o) => i(o),
      () => null,
      () => {
        l(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (Y(e)) {
    const r = await Promise.all(e.map((i) => n(i)));
    return e.length > 1 ? r : r[0];
  } else {
    const {
      map: r,
      displacementMap: i,
      normalMap: l,
      roughnessMap: o,
      metalnessMap: s,
      aoMap: u,
      alphaMap: c,
      matcap: f
    } = e;
    return {
      map: r ? await n(r) : null,
      displacementMap: i ? await n(i) : null,
      normalMap: l ? await n(l) : null,
      roughnessMap: o ? await n(o) : null,
      metalnessMap: s ? await n(s) : null,
      aoMap: u ? await n(u) : null,
      alphaMap: c ? await n(c) : null,
      matcap: f ? await n(f) : null
    };
  }
}
const qe = (e, { renderer: a, camera: t, raycaster: n }) => {
  const r = _(() => a.value.domElement), { x: i, y: l } = ke({ target: r }), { width: o, height: s, top: u, left: c } = Se(r), f = ({ x: m, y: P }) => {
    if (r.value)
      return {
        x: (m - c.value) / o.value * 2 - 1,
        y: -((P - u.value) / s.value) * 2 + 1
      };
  }, w = ({ x: m, y: P }) => {
    if (t.value)
      return n.value.setFromCamera(new Ee(m, P), t.value), n.value.intersectObjects(e.value, !1);
  }, C = (m) => {
    const P = f({
      x: (m == null ? void 0 : m.clientX) ?? i.value,
      y: (m == null ? void 0 : m.clientY) ?? l.value
    });
    return P ? w(P) || [] : [];
  }, M = _(() => C()), p = A(), d = A(), v = (m, P) => {
    m.trigger({ event: P, intersects: C(P) });
  }, E = (m) => {
    v(d, m);
  };
  let L;
  const x = (m) => {
    var P;
    L = (P = C(m)[0]) == null ? void 0 : P.object;
  }, T = (m) => {
    var P;
    m instanceof PointerEvent && L === ((P = C(m)[0]) == null ? void 0 : P.object) && v(p, m);
  }, S = (m) => d.trigger({ event: m, intersects: [] });
  return r.value.addEventListener("pointerup", T), r.value.addEventListener("pointerdown", x), r.value.addEventListener("pointermove", E), r.value.addEventListener("pointerleave", S), j(() => {
    r != null && r.value && (r.value.removeEventListener("pointerup", T), r.value.removeEventListener("pointerdown", x), r.value.removeEventListener("pointermove", E), r.value.removeEventListener("pointerleave", S));
  }), {
    intersects: M,
    onClick: (m) => p.on(m).off,
    onPointerMove: (m) => d.on(m).off
  };
};
function ct() {
  const { logWarning: e } = k();
  function a(n, r, i) {
    let l = null;
    return n.traverse((o) => {
      o[r] === i && (l = o);
    }), l || e(`Child with ${r} '${i}' not found.`), l;
  }
  function t(n, r) {
    return a(n, "name", r);
  }
  return {
    seek: a,
    seekByName: t
  };
}
const Ue = ({ scene: e, contextParts: a }) => {
  const t = re({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), n = (u) => {
    Object.values(t).forEach((c) => c.delete(u));
  }, r = (u) => {
    const { onClick: c, onPointerMove: f, onPointerEnter: w, onPointerLeave: C } = u;
    c && t.click.set(u, c), f && t.pointerMove.set(u, f), w && t.pointerEnter.set(u, w), C && t.pointerLeave.set(u, C);
  };
  e.userData.tres__registerAtPointerEventHandler = r, e.userData.tres__deregisterAtPointerEventHandler = n;
  const i = _(
    () => We(
      Object.values(t).map((u) => Array.from(u.keys())).flat(),
      ({ uuid: u }) => u
    )
  ), { onClick: l, onPointerMove: o } = qe(i, a);
  l(({ intersects: u, event: c }) => {
    var f;
    u.length && ((f = t.click.get(u[0].object)) == null || f(u[0], c));
  });
  let s;
  return o(({ intersects: u, event: c }) => {
    var p, d, v, E;
    const f = (p = u == null ? void 0 : u[0]) == null ? void 0 : p.object, { pointerLeave: w, pointerEnter: C, pointerMove: M } = t;
    s && s !== f && ((d = w.get(s)) == null || d(s, c)), f && (s !== f && ((v = C.get(f)) == null || v(u[0], c)), (E = M.get(f)) == null || E(u[0], c)), s = f || null;
  }), {
    registerObject: r,
    deregisterObject: n
  };
};
function Je({
  scene: e,
  canvas: a,
  windowSize: t,
  disableRender: n,
  rendererOptions: r
}) {
  const i = _(
    () => y(t) ? he() : Be(y(a).parentElement)
  ), l = _(() => i.value.width.value), o = _(() => i.value.height.value), s = _(() => l.value / o.value), u = {
    height: o,
    width: l,
    aspectRatio: s
  }, c = z(e), {
    camera: f,
    cameras: w,
    addCamera: C,
    removeCamera: M,
    setCameraActive: p
  } = Oe({ sizes: u, scene: e }), { renderer: d } = Ie(
    {
      scene: e,
      canvas: a,
      options: r,
      contextParts: { sizes: u, camera: f },
      disableRender: n
    }
  ), v = {
    sizes: u,
    scene: c,
    camera: f,
    cameras: ne(w),
    renderer: d,
    raycaster: z(new xe()),
    controls: H(null),
    extend: $,
    addCamera: C,
    removeCamera: M,
    setCameraActive: p
  };
  return ae("useTres", v), v;
}
function Ke() {
  const e = oe("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
const ft = Ke;
let G = null, g = null;
const { logError: J } = k(), Xe = {
  createElement(e, a, t, n) {
    var l, o;
    if (n || (n = {}), n.args || (n.args = []), e === "template" || Ve(e))
      return null;
    let r = e.replace("Tres", ""), i;
    if (e === "primitive") {
      (n == null ? void 0 : n.object) === void 0 && J("Tres primitives need a prop 'object'");
      const s = n.object;
      r = s.type, i = Object.assign(s, { type: r, attach: n.attach, primitive: !0 });
    } else {
      const s = X.value[r];
      s || J(`${r} is not defined on the THREE namespace. Use extend to add it to the catalog.`), i = new s(...n.args);
    }
    return i.isCamera && (n != null && n.position || i.position.set(3, 3, 3), n != null && n.lookAt || i.lookAt(0, 0, 0)), (n == null ? void 0 : n.attach) === void 0 && (i.isMaterial ? i.attach = "material" : i.isBufferGeometry && (i.attach = "geometry")), i.isObject3D && ((l = n == null ? void 0 : n.material) != null && l.isMaterial && (i.userData.tres__materialViaProp = !0), (o = n == null ? void 0 : n.geometry) != null && o.isBufferGeometry && (i.userData.tres__geometryViaProp = !0)), i;
  },
  insert(e, a) {
    var t, n, r, i, l, o, s, u, c;
    if (a && a.isScene && (g = a), (((t = e == null ? void 0 : e.__vnode) == null ? void 0 : t.type) === "TresGroup" || ((n = e == null ? void 0 : e.__vnode) == null ? void 0 : n.type) === "TresObject3D") && a === null && !((i = (r = e == null ? void 0 : e.__vnode) == null ? void 0 : r.ctx) != null && i.asyncResolved)) {
      G = e;
      return;
    } else
      (l = e == null ? void 0 : e.__vnode) != null && l.type.includes("Controls") && a === null && (G = g);
    if (a || (a = G), e != null && e.isObject3D) {
      if (e != null && e.isCamera) {
        if (!(g != null && g.userData.tres__registerCamera))
          throw "could not find tres__registerCamera on scene's userData";
        (s = g == null ? void 0 : (o = g.userData).tres__registerCamera) == null || s.call(o, e);
      }
      if (e != null && e.onClick || e != null && e.onPointerMove || e != null && e.onPointerEnter || e != null && e.onPointerLeave) {
        if (!(g != null && g.userData.tres__registerAtPointerEventHandler))
          throw "could not find tres__registerAtPointerEventHandler on scene's userData";
        (c = g == null ? void 0 : (u = g.userData).tres__registerAtPointerEventHandler) == null || c.call(u, e);
      }
    }
    e != null && e.isObject3D && (a != null && a.isObject3D) ? (a.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? a.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[a == null ? void 0 : a.attach], a && (a[e.attach] = e));
  },
  remove(e) {
    var a, t;
    if (e) {
      if (e.isObject3D) {
        const n = e, r = (s) => {
          var c, f;
          const u = s;
          s.userData.tres__materialViaProp || (c = u.material) == null || c.dispose(), s.userData.tres__geometryViaProp || (f = u.geometry) == null || f.dispose();
        }, i = g == null ? void 0 : g.userData.tres__deregisterAtPointerEventHandler, l = (s) => {
          if (!i)
            throw "could not find tres__deregisterAtPointerEventHandler on scene's userData";
          (s != null && s.onClick || s != null && s.onPointerMove || s != null && s.onPointerEnter || s != null && s.onPointerLeave) && (i == null || i(s));
        }, o = (s) => {
          const u = g == null ? void 0 : g.userData.tres__deregisterCamera;
          if (!u)
            throw "could not find tres__deregisterCamera on scene's userData";
          s.isCamera && (u == null || u(s));
        };
        n.traverse((s) => {
          r(s), o(s), l == null || l(s);
        }), r(n), o(n), l == null || l(n);
      }
      (a = e.removeFromParent) == null || a.call(e), (t = e.dispose) == null || t.call(e);
    }
  },
  patchProp(e, a, t, n) {
    if (e) {
      let r = e, i = a, l = B(i), o = r == null ? void 0 : r[l];
      if (r.type === "BufferGeometry") {
        if (i === "args")
          return;
        r.setAttribute(
          B(i),
          new Le(...n)
        );
        return;
      }
      if (i.includes("-") && o === void 0) {
        const u = i.split("-");
        o = u.reduce((c, f) => c[B(f)], r), i = u.pop(), l = i.toLowerCase(), o != null && o.set || (r = u.reduce((c, f) => c[B(f)], r));
      }
      let s = n;
      if (s === "" && (s = !0), N(o)) {
        Array.isArray(s) ? e[l](...s) : e[l](s);
        return;
      }
      !(o != null && o.set) && !N(o) ? r[l] = s : o.constructor === s.constructor && (o != null && o.copy) ? o == null || o.copy(s) : Array.isArray(s) ? o.set(...s) : !o.isColor && o.setScalar ? o.setScalar(s) : o.set(s);
    }
  },
  parentNode(e) {
    return (e == null ? void 0 : e.parent) || null;
  },
  createText: () => void 0,
  createComment: () => void 0,
  setText: () => void 0,
  setElementText: () => void 0,
  nextSibling: () => void 0,
  querySelector: () => void 0,
  setScopeId: () => void 0,
  cloneNode: () => void 0,
  insertStaticContent: () => void 0
}, { createApp: Ye } = se(Xe), Qe = (e) => {
  const a = Ye(t);
  function t() {
    return e && e.default ? e.default() : [];
  }
  return a;
};
$(pe);
const Ze = ["data-scene"], et = /* @__PURE__ */ ie({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean },
    outputColorSpace: {},
    toneMappingExposure: {},
    windowSize: { type: Boolean },
    preset: {},
    disableRender: { type: Boolean },
    camera: {},
    context: {},
    precision: {},
    alpha: { type: Boolean, default: !1 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: !0 },
    stencil: { type: Boolean, default: !0 },
    preserveDrawingBuffer: { type: Boolean, default: !1 },
    powerPreference: {},
    depth: { type: Boolean, default: !0 },
    logarithmicDepthBuffer: { type: Boolean },
    failIfMajorPerformanceCaveat: { type: Boolean }
  },
  setup(e) {
    const a = e, { logWarning: t } = k(), n = H(), r = z(new Te());
    ee();
    const i = ue();
    let l;
    const o = (u) => {
      l = Qe(i), l.provide("useTres", u), l.provide("extend", $), l.mount(r.value);
    }, s = _(() => a.disableRender);
    return le(() => {
      const u = n, c = Je({
        scene: r.value,
        canvas: u,
        windowSize: a.windowSize,
        disableRender: s,
        rendererOptions: a
      });
      Ue({ scene: r.value, contextParts: c });
      const { addCamera: f, camera: w, cameras: C, removeCamera: M } = c;
      o(c);
      const p = () => {
        const d = new W(45, window.innerWidth / window.innerHeight, 0.1, 1e3);
        d.position.set(3, 3, 3), d.lookAt(0, 0, 0), f(d);
        const v = b(
          () => {
            C.value.length >= 2 && (d.removeFromParent(), M(d), v == null || v());
          }
        );
      };
      K(() => a.camera, (d, v) => {
        d ? f(d) : v && (v.removeFromParent(), M(v));
      }, {
        immediate: !0
      }), w.value || (t(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), p());
    }), (u, c) => (ce(), fe("canvas", {
      ref_key: "canvas",
      ref: n,
      "data-scene": r.value.uuid,
      style: me({
        display: "block",
        width: "100%",
        height: "100%",
        position: u.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        zIndex: 1
      })
    }, null, 12, Ze));
  }
}), tt = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
], rt = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !tt.includes(e) || e === "primitive"
    }
  }
}, mt = rt, pt = {
  install(e) {
    e.component("TresCanvas", et);
  }
};
export {
  et as TresCanvas,
  X as catalogue,
  pt as default,
  $ as extend,
  st as isProd,
  $e as normalizeColor,
  it as normalizeVectorFlexibleParam,
  mt as templateCompilerOptions,
  Ne as trasverseObjects,
  Oe as useCamera,
  ut as useLoader,
  k as useLogger,
  Ue as usePointerEventHandler,
  qe as useRaycaster,
  ee as useRenderLoop,
  Ie as useRenderer,
  ct as useSeek,
  lt as useTexture,
  ft as useTres,
  Ke as useTresContext,
  Je as useTresContextProvider
};
