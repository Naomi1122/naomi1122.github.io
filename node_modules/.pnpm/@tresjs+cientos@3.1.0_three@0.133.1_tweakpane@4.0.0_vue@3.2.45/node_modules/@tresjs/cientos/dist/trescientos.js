/**
 * name: @tresjs/cientos
 * version: v3.1.0
 * (c) 2023
 * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
var Si = Object.defineProperty;
var Mi = (l, e, t) => e in l ? Si(l, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : l[e] = t;
var ds = (l, e, t) => (Mi(l, typeof e != "symbol" ? e + "" : e, t), t);
import { defineComponent as te, toRefs as pe, useSlots as Oi, computed as Ne, shallowRef as ue, withAsyncContext as ls, toValue as qe, watchEffect as at, unref as M, openBlock as Q, createElementBlock as J, createCommentVNode as lt, renderSlot as Ee, ref as G, shallowReactive as Li, createElementVNode as Y, mergeProps as Te, Fragment as Pi, renderList as Ri, resolveComponent as Gs, createVNode as Di, getCurrentScope as Ii, onScopeDispose as Ci, getCurrentInstance as Cn, onMounted as Ys, nextTick as ki, toRef as Fi, readonly as Ui, customRef as Bi, watch as Me, reactive as cn, createBlock as kn, onUnmounted as Lt, normalizeProps as zi, guardReactiveProps as Ni } from "vue";
import { TrianglesDrawMode as Hi, TriangleFanDrawMode as Is, TriangleStripDrawMode as Fn, Object3D as rt, Raycaster as Un, Vector3 as C, Quaternion as ce, Euler as _t, Matrix4 as re, MeshBasicMaterial as yt, DoubleSide as Xs, LineBasicMaterial as js, CylinderGeometry as Fe, BoxGeometry as ut, BufferGeometry as $e, Float32BufferAttribute as Qe, Mesh as F, Line as q, OctahedronGeometry as pt, PlaneGeometry as st, TorusGeometry as Kt, SphereGeometry as Vi, Color as ge, EventDispatcher as Bn, MOUSE as nt, TOUCH as Ye, Spherical as os, Vector2 as Se, PerspectiveCamera as Bt, OrthographicCamera as St, Loader as cs, LoaderUtils as Xe, FileLoader as Ot, SpotLight as zn, PointLight as Cs, DirectionalLight as Nn, MeshPhysicalMaterial as ht, InstancedMesh as Gi, REVISION as Yi, TextureLoader as Hn, ImageBitmapLoader as Xi, BufferAttribute as zt, InterleavedBuffer as ji, InterleavedBufferAttribute as Zi, LinearFilter as rs, LinearMipmapLinearFilter as Vn, RepeatWrapping as Vt, PointsMaterial as Ki, Material as fs, MeshStandardMaterial as Zs, PropertyBinding as Gt, SkinnedMesh as Gn, LineSegments as Qi, LineLoop as $i, Points as Wi, Group as Nt, MathUtils as Oe, Skeleton as Yn, InterpolateLinear as Xn, AnimationClip as jn, Bone as ks, NearestFilter as qi, NearestMipmapNearestFilter as Ji, LinearMipmapNearestFilter as eo, NearestMipmapLinearFilter as to, ClampToEdgeWrapping as Fs, MirroredRepeatWrapping as so, InterpolateDiscrete as no, FrontSide as io, Texture as as, VectorKeyframeTrack as Zn, QuaternionKeyframeTrack as Us, NumberKeyframeTrack as Kn, Box3 as Qn, Sphere as $n, Interpolant as oo, ExtrudeGeometry as ro, Vector4 as Xt, Curve as ao, MeshPhongMaterial as ms, MeshLambertMaterial as lo, EquirectangularReflectionMapping as Wn, AmbientLight as co, Uint16BufferAttribute as ho, Matrix3 as uo, ShapePath as po, DataTextureLoader as fo, HalfFloatType as Qt, FloatType as gs, DataUtils as $t, AnimationMixer as mo, CubeReflectionMapping as go, SRGBColorSpace as _o, CubeTextureLoader as yo, WebGLRenderTarget as hn, MeshDepthMaterial as vo, ShaderMaterial as un, DefaultLoadingManager as Wt, QuadraticBezierCurve3 as To } from "three";
import { useTresContext as Le, useRenderLoop as Ce, useLoader as Ks, useTexture as Eo, useLogger as wo } from "@tresjs/core";
import { Pane as Ao } from "tweakpane";
import * as xo from "@tweakpane/plugin-essentials";
function pn(l, e) {
  if (e === Hi)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), l;
  if (e === Is || e === Fn) {
    let t = l.getIndex();
    if (t === null) {
      const o = [], r = l.getAttribute("position");
      if (r !== void 0) {
        for (let a = 0; a < r.count; a++)
          o.push(a);
        l.setIndex(o), t = l.getIndex();
      } else
        return console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ), l;
    }
    const s = t.count - 2, n = [];
    if (t)
      if (e === Is)
        for (let o = 1; o <= s; o++)
          n.push(t.getX(0)), n.push(t.getX(o)), n.push(t.getX(o + 1));
      else
        for (let o = 0; o < s; o++)
          o % 2 === 0 ? (n.push(t.getX(o)), n.push(t.getX(o + 1)), n.push(t.getX(o + 2))) : (n.push(t.getX(o + 2)), n.push(t.getX(o + 1)), n.push(t.getX(o)));
    n.length / 3 !== s && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const i = l.clone();
    return i.setIndex(n), i.clearGroups(), i;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), l;
}
var Ie = Uint8Array, ot = Uint16Array, Bs = Uint32Array, qn = new Ie([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Jn = new Ie([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), bo = new Ie([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), ei = function(l, e) {
  for (var t = new ot(31), s = 0; s < 31; ++s)
    t[s] = e += 1 << l[s - 1];
  for (var n = new Bs(t[30]), s = 1; s < 30; ++s)
    for (var i = t[s]; i < t[s + 1]; ++i)
      n[i] = i - t[s] << 5 | s;
  return [t, n];
}, ti = ei(qn, 2), si = ti[0], So = ti[1];
si[28] = 258, So[258] = 28;
var Mo = ei(Jn, 0), Oo = Mo[0], zs = new ot(32768);
for (var he = 0; he < 32768; ++he) {
  var Je = (he & 43690) >>> 1 | (he & 21845) << 1;
  Je = (Je & 52428) >>> 2 | (Je & 13107) << 2, Je = (Je & 61680) >>> 4 | (Je & 3855) << 4, zs[he] = ((Je & 65280) >>> 8 | (Je & 255) << 8) >>> 1;
}
var Ht = function(l, e, t) {
  for (var s = l.length, n = 0, i = new ot(e); n < s; ++n)
    ++i[l[n] - 1];
  var o = new ot(e);
  for (n = 0; n < e; ++n)
    o[n] = o[n - 1] + i[n - 1] << 1;
  var r;
  if (t) {
    r = new ot(1 << e);
    var a = 15 - e;
    for (n = 0; n < s; ++n)
      if (l[n])
        for (var c = n << 4 | l[n], u = e - l[n], h = o[l[n] - 1]++ << u, p = h | (1 << u) - 1; h <= p; ++h)
          r[zs[h] >>> a] = c;
  } else
    for (r = new ot(s), n = 0; n < s; ++n)
      l[n] && (r[n] = zs[o[l[n] - 1]++] >>> 15 - l[n]);
  return r;
}, jt = new Ie(288);
for (var he = 0; he < 144; ++he)
  jt[he] = 8;
for (var he = 144; he < 256; ++he)
  jt[he] = 9;
for (var he = 256; he < 280; ++he)
  jt[he] = 7;
for (var he = 280; he < 288; ++he)
  jt[he] = 8;
var ni = new Ie(32);
for (var he = 0; he < 32; ++he)
  ni[he] = 5;
var Lo = /* @__PURE__ */ Ht(jt, 9, 1), Po = /* @__PURE__ */ Ht(ni, 5, 1), _s = function(l) {
  for (var e = l[0], t = 1; t < l.length; ++t)
    l[t] > e && (e = l[t]);
  return e;
}, Ue = function(l, e, t) {
  var s = e / 8 | 0;
  return (l[s] | l[s + 1] << 8) >> (e & 7) & t;
}, ys = function(l, e) {
  var t = e / 8 | 0;
  return (l[t] | l[t + 1] << 8 | l[t + 2] << 16) >> (e & 7);
}, Ro = function(l) {
  return (l / 8 | 0) + (l & 7 && 1);
}, Do = function(l, e, t) {
  (e == null || e < 0) && (e = 0), (t == null || t > l.length) && (t = l.length);
  var s = new (l instanceof ot ? ot : l instanceof Bs ? Bs : Ie)(t - e);
  return s.set(l.subarray(e, t)), s;
}, Io = function(l, e, t) {
  var s = l.length;
  if (!s || t && !t.l && s < 5)
    return e || new Ie(0);
  var n = !e || t, i = !t || t.i;
  t || (t = {}), e || (e = new Ie(s * 3));
  var o = function(Pe) {
    var ke = e.length;
    if (Pe > ke) {
      var We = new Ie(Math.max(ke * 2, Pe));
      We.set(e), e = We;
    }
  }, r = t.f || 0, a = t.p || 0, c = t.b || 0, u = t.l, h = t.d, p = t.m, d = t.n, g = s * 8;
  do {
    if (!u) {
      t.f = r = Ue(l, a, 1);
      var m = Ue(l, a + 1, 3);
      if (a += 3, m)
        if (m == 1)
          u = Lo, h = Po, p = 9, d = 5;
        else if (m == 2) {
          var E = Ue(l, a, 31) + 257, f = Ue(l, a + 10, 15) + 4, v = E + Ue(l, a + 5, 31) + 1;
          a += 14;
          for (var w = new Ie(v), _ = new Ie(19), y = 0; y < f; ++y)
            _[bo[y]] = Ue(l, a + y * 3, 7);
          a += f * 3;
          for (var L = _s(_), D = (1 << L) - 1, R = Ht(_, L, 1), y = 0; y < v; ) {
            var k = R[Ue(l, a, D)];
            a += k & 15;
            var T = k >>> 4;
            if (T < 16)
              w[y++] = T;
            else {
              var X = 0, se = 0;
              for (T == 16 ? (se = 3 + Ue(l, a, 3), a += 2, X = w[y - 1]) : T == 17 ? (se = 3 + Ue(l, a, 7), a += 3) : T == 18 && (se = 11 + Ue(l, a, 127), a += 7); se--; )
                w[y++] = X;
            }
          }
          var V = w.subarray(0, E), ae = w.subarray(E);
          p = _s(V), d = _s(ae), u = Ht(V, p, 1), h = Ht(ae, d, 1);
        } else
          throw "invalid block type";
      else {
        var T = Ro(a) + 4, x = l[T - 4] | l[T - 3] << 8, S = T + x;
        if (S > s) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        n && o(c + x), e.set(l.subarray(T, S), c), t.b = c += x, t.p = a = S * 8;
        continue;
      }
      if (a > g) {
        if (i)
          throw "unexpected EOF";
        break;
      }
    }
    n && o(c + 131072);
    for (var j = (1 << p) - 1, _e = (1 << d) - 1, fe = a; ; fe = a) {
      var X = u[ys(l, a) & j], ne = X >>> 4;
      if (a += X & 15, a > g) {
        if (i)
          throw "unexpected EOF";
        break;
      }
      if (!X)
        throw "invalid length/literal";
      if (ne < 256)
        e[c++] = ne;
      else if (ne == 256) {
        fe = a, u = null;
        break;
      } else {
        var $ = ne - 254;
        if (ne > 264) {
          var y = ne - 257, W = qn[y];
          $ = Ue(l, a, (1 << W) - 1) + si[y], a += W;
        }
        var ye = h[ys(l, a) & _e], b = ye >>> 4;
        if (!ye)
          throw "invalid distance";
        a += ye & 15;
        var ae = Oo[b];
        if (b > 3) {
          var W = Jn[b];
          ae += ys(l, a) & (1 << W) - 1, a += W;
        }
        if (a > g) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        n && o(c + 131072);
        for (var be = c + $; c < be; c += 4)
          e[c] = e[c - ae], e[c + 1] = e[c + 1 - ae], e[c + 2] = e[c + 2 - ae], e[c + 3] = e[c + 3 - ae];
        c = be;
      }
    }
    t.l = u, t.p = fe, t.b = c, u && (r = 1, t.m = p, t.d = h, t.n = d);
  } while (!r);
  return c == e.length ? e : Do(e, 0, c);
}, Co = /* @__PURE__ */ new Ie(0), ko = function(l) {
  if ((l[0] & 15) != 8 || l[0] >>> 4 > 7 || (l[0] << 8 | l[1]) % 31)
    throw "invalid zlib data";
  if (l[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Fo(l, e) {
  return Io((ko(l), l.subarray(2, -4)), e);
}
var Uo = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Bo = 0;
try {
  Uo.decode(Co, { stream: !0 }), Bo = 1;
} catch {
}
var zo = Object.defineProperty, No = (l, e, t) => e in l ? zo(l, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : l[e] = t, O = (l, e, t) => (No(l, typeof e != "symbol" ? e + "" : e, t), t);
class Ho extends rt {
  constructor(e, t) {
    super(), O(this, "isTransformControls", !0), O(this, "visible", !1), O(this, "domElement"), O(this, "raycaster", new Un()), O(this, "gizmo"), O(this, "plane"), O(this, "tempVector", new C()), O(this, "tempVector2", new C()), O(this, "tempQuaternion", new ce()), O(this, "unit", {
      X: new C(1, 0, 0),
      Y: new C(0, 1, 0),
      Z: new C(0, 0, 1)
    }), O(this, "pointStart", new C()), O(this, "pointEnd", new C()), O(this, "offset", new C()), O(this, "rotationAxis", new C()), O(this, "startNorm", new C()), O(this, "endNorm", new C()), O(this, "rotationAngle", 0), O(this, "cameraPosition", new C()), O(this, "cameraQuaternion", new ce()), O(this, "cameraScale", new C()), O(this, "parentPosition", new C()), O(this, "parentQuaternion", new ce()), O(this, "parentQuaternionInv", new ce()), O(this, "parentScale", new C()), O(this, "worldPositionStart", new C()), O(this, "worldQuaternionStart", new ce()), O(this, "worldScaleStart", new C()), O(this, "worldPosition", new C()), O(this, "worldQuaternion", new ce()), O(this, "worldQuaternionInv", new ce()), O(this, "worldScale", new C()), O(this, "eye", new C()), O(this, "positionStart", new C()), O(this, "quaternionStart", new ce()), O(this, "scaleStart", new C()), O(this, "camera"), O(this, "object"), O(this, "enabled", !0), O(this, "axis", null), O(this, "mode", "translate"), O(this, "translationSnap", null), O(this, "rotationSnap", null), O(this, "scaleSnap", null), O(this, "space", "world"), O(this, "size", 1), O(this, "dragging", !1), O(this, "showX", !0), O(this, "showY", !0), O(this, "showZ", !0), O(this, "changeEvent", { type: "change" }), O(this, "mouseDownEvent", { type: "mouseDown", mode: this.mode }), O(this, "mouseUpEvent", { type: "mouseUp", mode: this.mode }), O(this, "objectChangeEvent", { type: "objectChange" }), O(this, "intersectObjectWithRay", (n, i, o) => {
      const r = i.intersectObject(n, !0);
      for (let a = 0; a < r.length; a++)
        if (r[a].object.visible || o)
          return r[a];
      return !1;
    }), O(this, "attach", (n) => (this.object = n, this.visible = !0, this)), O(this, "detach", () => (this.object = void 0, this.visible = !1, this.axis = null, this)), O(this, "reset", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), O(this, "updateMatrixWorld", () => {
      this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld();
    }), O(this, "pointerHover", (n) => {
      if (this.object === void 0 || this.dragging === !0)
        return;
      this.raycaster.setFromCamera(n, this.camera);
      const i = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
      i ? this.axis = i.object.name : this.axis = null;
    }), O(this, "pointerDown", (n) => {
      if (!(this.object === void 0 || this.dragging === !0 || n.button !== 0) && this.axis !== null) {
        this.raycaster.setFromCamera(n, this.camera);
        const i = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
        if (i) {
          let o = this.space;
          if (this.mode === "scale" ? o = "local" : (this.axis === "E" || this.axis === "XYZE" || this.axis === "XYZ") && (o = "world"), o === "local" && this.mode === "rotate") {
            const r = this.rotationSnap;
            this.axis === "X" && r && (this.object.rotation.x = Math.round(this.object.rotation.x / r) * r), this.axis === "Y" && r && (this.object.rotation.y = Math.round(this.object.rotation.y / r) * r), this.axis === "Z" && r && (this.object.rotation.z = Math.round(this.object.rotation.z / r) * r);
          }
          this.object.updateMatrixWorld(), this.object.parent && this.object.parent.updateMatrixWorld(), this.positionStart.copy(this.object.position), this.quaternionStart.copy(this.object.quaternion), this.scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart), this.pointStart.copy(i.point).sub(this.worldPositionStart);
        }
        this.dragging = !0, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent);
      }
    }), O(this, "pointerMove", (n) => {
      const i = this.axis, o = this.mode, r = this.object;
      let a = this.space;
      if (o === "scale" ? a = "local" : (i === "E" || i === "XYZE" || i === "XYZ") && (a = "world"), r === void 0 || i === null || this.dragging === !1 || n.button !== -1)
        return;
      this.raycaster.setFromCamera(n, this.camera);
      const c = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
      if (c) {
        if (this.pointEnd.copy(c.point).sub(this.worldPositionStart), o === "translate")
          this.offset.copy(this.pointEnd).sub(this.pointStart), a === "local" && i !== "XYZ" && this.offset.applyQuaternion(this.worldQuaternionInv), i.indexOf("X") === -1 && (this.offset.x = 0), i.indexOf("Y") === -1 && (this.offset.y = 0), i.indexOf("Z") === -1 && (this.offset.z = 0), a === "local" && i !== "XYZ" ? this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale) : this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale), r.position.copy(this.offset).add(this.positionStart), this.translationSnap && (a === "local" && (r.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()), i.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this.quaternionStart)), a === "world" && (r.parent && r.position.add(this.tempVector.setFromMatrixPosition(r.parent.matrixWorld)), i.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(this.tempVector.setFromMatrixPosition(r.parent.matrixWorld))));
        else if (o === "scale") {
          if (i.search("XYZ") !== -1) {
            let u = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (u *= -1), this.tempVector2.set(u, u, u);
          } else
            this.tempVector.copy(this.pointStart), this.tempVector2.copy(this.pointEnd), this.tempVector.applyQuaternion(this.worldQuaternionInv), this.tempVector2.applyQuaternion(this.worldQuaternionInv), this.tempVector2.divide(this.tempVector), i.search("X") === -1 && (this.tempVector2.x = 1), i.search("Y") === -1 && (this.tempVector2.y = 1), i.search("Z") === -1 && (this.tempVector2.z = 1);
          r.scale.copy(this.scaleStart).multiply(this.tempVector2), this.scaleSnap && this.object && (i.search("X") !== -1 && (this.object.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Y") !== -1 && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Z") !== -1 && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if (o === "rotate") {
          this.offset.copy(this.pointEnd).sub(this.pointStart);
          const u = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));
          i === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.startNorm.copy(this.pointStart).normalize(), this.endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1) : i === "XYZE" ? (this.rotationAxis.copy(this.offset).cross(this.eye).normalize(), this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * u) : (i === "X" || i === "Y" || i === "Z") && (this.rotationAxis.copy(this.unit[i]), this.tempVector.copy(this.unit[i]), a === "local" && this.tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * u), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), a === "local" && i !== "E" && i !== "XYZE" ? (r.quaternion.copy(this.quaternionStart), r.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.parentQuaternionInv), r.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this.quaternionStart).normalize());
        }
        this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent);
      }
    }), O(this, "pointerUp", (n) => {
      n.button === 0 && (this.dragging && this.axis !== null && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = !1, this.axis = null);
    }), O(this, "getPointer", (n) => {
      var i, o;
      if (this.domElement && ((i = this.domElement.ownerDocument) != null && i.pointerLockElement))
        return {
          x: 0,
          y: 0,
          button: n.button
        };
      {
        const r = n.changedTouches ? n.changedTouches[0] : n, a = (o = this.domElement) == null ? void 0 : o.getBoundingClientRect();
        return {
          x: (r.clientX - a.left) / a.width * 2 - 1,
          y: -(r.clientY - a.top) / a.height * 2 + 1,
          button: n.button
        };
      }
    }), O(this, "onPointerHover", (n) => {
      if (this.enabled)
        switch (n.pointerType) {
          case "mouse":
          case "pen":
            this.pointerHover(this.getPointer(n));
            break;
        }
    }), O(this, "onPointerDown", (n) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "none", this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.pointerHover(this.getPointer(n)), this.pointerDown(this.getPointer(n)));
    }), O(this, "onPointerMove", (n) => {
      this.enabled && this.pointerMove(this.getPointer(n));
    }), O(this, "onPointerUp", (n) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "", this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.pointerUp(this.getPointer(n)));
    }), O(this, "getMode", () => this.mode), O(this, "setMode", (n) => {
      this.mode = n;
    }), O(this, "setTranslationSnap", (n) => {
      this.translationSnap = n;
    }), O(this, "setRotationSnap", (n) => {
      this.rotationSnap = n;
    }), O(this, "setScaleSnap", (n) => {
      this.scaleSnap = n;
    }), O(this, "setSize", (n) => {
      this.size = n;
    }), O(this, "setSpace", (n) => {
      this.space = n;
    }), O(this, "update", () => {
      console.warn(
        "THREE.TransformControls: update function has no more functionality and therefore has been deprecated."
      );
    }), O(this, "connect", (n) => {
      n === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), this.domElement = n, this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointermove", this.onPointerHover), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
    }), O(this, "dispose", () => {
      var n, i, o, r, a, c;
      (n = this.domElement) == null || n.removeEventListener("pointerdown", this.onPointerDown), (i = this.domElement) == null || i.removeEventListener("pointermove", this.onPointerHover), (r = (o = this.domElement) == null ? void 0 : o.ownerDocument) == null || r.removeEventListener("pointermove", this.onPointerMove), (c = (a = this.domElement) == null ? void 0 : a.ownerDocument) == null || c.removeEventListener("pointerup", this.onPointerUp), this.traverse((u) => {
        const h = u;
        h.geometry && h.geometry.dispose(), h.material && h.material.dispose();
      });
    }), this.domElement = t, this.camera = e, this.gizmo = new Vo(), this.add(this.gizmo), this.plane = new Go(), this.add(this.plane);
    const s = (n, i) => {
      let o = i;
      Object.defineProperty(this, n, {
        get: function() {
          return o !== void 0 ? o : i;
        },
        set: function(r) {
          o !== r && (o = r, this.plane[n] = r, this.gizmo[n] = r, this.dispatchEvent({ type: n + "-changed", value: r }), this.dispatchEvent(this.changeEvent));
        }
      }), this[n] = i, this.plane[n] = i, this.gizmo[n] = i;
    };
    s("camera", this.camera), s("object", this.object), s("enabled", this.enabled), s("axis", this.axis), s("mode", this.mode), s("translationSnap", this.translationSnap), s("rotationSnap", this.rotationSnap), s("scaleSnap", this.scaleSnap), s("space", this.space), s("size", this.size), s("dragging", this.dragging), s("showX", this.showX), s("showY", this.showY), s("showZ", this.showZ), s("worldPosition", this.worldPosition), s("worldPositionStart", this.worldPositionStart), s("worldQuaternion", this.worldQuaternion), s("worldQuaternionStart", this.worldQuaternionStart), s("cameraPosition", this.cameraPosition), s("cameraQuaternion", this.cameraQuaternion), s("pointStart", this.pointStart), s("pointEnd", this.pointEnd), s("rotationAxis", this.rotationAxis), s("rotationAngle", this.rotationAngle), s("eye", this.eye), t !== void 0 && this.connect(t);
  }
}
class Vo extends rt {
  constructor() {
    super(), O(this, "isTransformControlsGizmo", !0), O(this, "type", "TransformControlsGizmo"), O(this, "tempVector", new C(0, 0, 0)), O(this, "tempEuler", new _t()), O(this, "alignVector", new C(0, 1, 0)), O(this, "zeroVector", new C(0, 0, 0)), O(this, "lookAtMatrix", new re()), O(this, "tempQuaternion", new ce()), O(this, "tempQuaternion2", new ce()), O(this, "identityQuaternion", new ce()), O(this, "unitX", new C(1, 0, 0)), O(this, "unitY", new C(0, 1, 0)), O(this, "unitZ", new C(0, 0, 1)), O(this, "gizmo"), O(this, "picker"), O(this, "helper"), O(this, "rotationAxis", new C()), O(this, "cameraPosition", new C()), O(this, "worldPositionStart", new C()), O(this, "worldQuaternionStart", new ce()), O(this, "worldPosition", new C()), O(this, "worldQuaternion", new ce()), O(this, "eye", new C()), O(this, "camera", null), O(this, "enabled", !0), O(this, "axis", null), O(this, "mode", "translate"), O(this, "space", "world"), O(this, "size", 1), O(this, "dragging", !1), O(this, "showX", !0), O(this, "showY", !0), O(this, "showZ", !0), O(this, "updateMatrixWorld", () => {
      let ne = this.space;
      this.mode === "scale" && (ne = "local");
      const $ = ne === "local" ? this.worldQuaternion : this.identityQuaternion;
      this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
      let W = [];
      W = W.concat(this.picker[this.mode].children), W = W.concat(this.gizmo[this.mode].children), W = W.concat(this.helper[this.mode].children);
      for (let ye = 0; ye < W.length; ye++) {
        const b = W[ye];
        b.visible = !0, b.rotation.set(0, 0, 0), b.position.copy(this.worldPosition);
        let be;
        if (this.camera.isOrthographicCamera ? be = (this.camera.top - this.camera.bottom) / this.camera.zoom : be = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), b.scale.set(1, 1, 1).multiplyScalar(be * this.size / 7), b.tag === "helper") {
          b.visible = !1, b.name === "AXIS" ? (b.position.copy(this.worldPositionStart), b.visible = !!this.axis, this.axis === "X" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), b.quaternion.copy($).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion($).dot(this.eye)) > 0.9 && (b.visible = !1)), this.axis === "Y" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), b.quaternion.copy($).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion($).dot(this.eye)) > 0.9 && (b.visible = !1)), this.axis === "Z" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), b.quaternion.copy($).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion($).dot(this.eye)) > 0.9 && (b.visible = !1)), this.axis === "XYZE" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), b.quaternion.setFromRotationMatrix(
            this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)
          ), b.quaternion.multiply(this.tempQuaternion), b.visible = this.dragging), this.axis === "E" && (b.visible = !1)) : b.name === "START" ? (b.position.copy(this.worldPositionStart), b.visible = this.dragging) : b.name === "END" ? (b.position.copy(this.worldPosition), b.visible = this.dragging) : b.name === "DELTA" ? (b.position.copy(this.worldPositionStart), b.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), b.scale.copy(this.tempVector), b.visible = this.dragging) : (b.quaternion.copy($), this.dragging ? b.position.copy(this.worldPositionStart) : b.position.copy(this.worldPosition), this.axis && (b.visible = this.axis.search(b.name) !== -1));
          continue;
        }
        b.quaternion.copy($), this.mode === "translate" || this.mode === "scale" ? ((b.name === "X" || b.name === "XYZX") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion($).dot(this.eye)) > 0.99 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), (b.name === "Y" || b.name === "XYZY") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion($).dot(this.eye)) > 0.99 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), (b.name === "Z" || b.name === "XYZZ") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion($).dot(this.eye)) > 0.99 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name === "XY" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion($).dot(this.eye)) < 0.2 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name === "YZ" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion($).dot(this.eye)) < 0.2 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name === "XZ" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion($).dot(this.eye)) < 0.2 && (b.scale.set(1e-10, 1e-10, 1e-10), b.visible = !1), b.name.search("X") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion($).dot(this.eye) < 0 ? b.tag === "fwd" ? b.visible = !1 : b.scale.x *= -1 : b.tag === "bwd" && (b.visible = !1)), b.name.search("Y") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion($).dot(this.eye) < 0 ? b.tag === "fwd" ? b.visible = !1 : b.scale.y *= -1 : b.tag === "bwd" && (b.visible = !1)), b.name.search("Z") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion($).dot(this.eye) < 0 ? b.tag === "fwd" ? b.visible = !1 : b.scale.z *= -1 : b.tag === "bwd" && (b.visible = !1))) : this.mode === "rotate" && (this.tempQuaternion2.copy($), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy($).invert()), b.name.search("E") !== -1 && b.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), b.name === "X" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), b.quaternion.copy(this.tempQuaternion)), b.name === "Y" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), b.quaternion.copy(this.tempQuaternion)), b.name === "Z" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), b.quaternion.copy(this.tempQuaternion))), b.visible = b.visible && (b.name.indexOf("X") === -1 || this.showX), b.visible = b.visible && (b.name.indexOf("Y") === -1 || this.showY), b.visible = b.visible && (b.name.indexOf("Z") === -1 || this.showZ), b.visible = b.visible && (b.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), b.material.tempOpacity = b.material.tempOpacity || b.material.opacity, b.material.tempColor = b.material.tempColor || b.material.color.clone(), b.material.color.copy(b.material.tempColor), b.material.opacity = b.material.tempOpacity, this.enabled ? this.axis && (b.name === this.axis ? (b.material.opacity = 1, b.material.color.lerp(new ge(1, 1, 1), 0.5)) : this.axis.split("").some(function(Pe) {
          return b.name === Pe;
        }) ? (b.material.opacity = 1, b.material.color.lerp(new ge(1, 1, 1), 0.5)) : (b.material.opacity *= 0.25, b.material.color.lerp(new ge(1, 1, 1), 0.5))) : (b.material.opacity *= 0.5, b.material.color.lerp(new ge(1, 1, 1), 0.5));
      }
      super.updateMatrixWorld();
    });
    const e = new yt({
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      side: Xs,
      fog: !1,
      toneMapped: !1
    }), t = new js({
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      linewidth: 1,
      fog: !1,
      toneMapped: !1
    }), s = e.clone();
    s.opacity = 0.15;
    const n = e.clone();
    n.opacity = 0.33;
    const i = e.clone();
    i.color.set(16711680);
    const o = e.clone();
    o.color.set(65280);
    const r = e.clone();
    r.color.set(255);
    const a = e.clone();
    a.opacity = 0.25;
    const c = a.clone();
    c.color.set(16776960);
    const u = a.clone();
    u.color.set(65535);
    const h = a.clone();
    h.color.set(16711935), e.clone().color.set(16776960);
    const d = t.clone();
    d.color.set(16711680);
    const g = t.clone();
    g.color.set(65280);
    const m = t.clone();
    m.color.set(255);
    const T = t.clone();
    T.color.set(65535);
    const x = t.clone();
    x.color.set(16711935);
    const S = t.clone();
    S.color.set(16776960);
    const E = t.clone();
    E.color.set(7895160);
    const f = S.clone();
    f.opacity = 0.25;
    const v = new Fe(0, 0.05, 0.2, 12, 1, !1), w = new ut(0.125, 0.125, 0.125), _ = new $e();
    _.setAttribute("position", new Qe([0, 0, 0, 1, 0, 0], 3));
    const y = (ne, $) => {
      const W = new $e(), ye = [];
      for (let b = 0; b <= 64 * $; ++b)
        ye.push(0, Math.cos(b / 32 * Math.PI) * ne, Math.sin(b / 32 * Math.PI) * ne);
      return W.setAttribute("position", new Qe(ye, 3)), W;
    }, L = () => {
      const ne = new $e();
      return ne.setAttribute("position", new Qe([0, 0, 0, 1, 1, 1], 3)), ne;
    }, D = {
      X: [
        [new F(v, i), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"],
        [new F(v, i), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"],
        [new q(_, d)]
      ],
      Y: [
        [new F(v, o), [0, 1, 0], null, null, "fwd"],
        [new F(v, o), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"],
        [new q(_, g), null, [0, 0, Math.PI / 2]]
      ],
      Z: [
        [new F(v, r), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"],
        [new F(v, r), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"],
        [new q(_, m), null, [0, -Math.PI / 2, 0]]
      ],
      XYZ: [[new F(new pt(0.1, 0), a.clone()), [0, 0, 0], [0, 0, 0]]],
      XY: [
        [new F(new st(0.295, 0.295), c.clone()), [0.15, 0.15, 0]],
        [new q(_, S), [0.18, 0.3, 0], null, [0.125, 1, 1]],
        [new q(_, S), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new F(new st(0.295, 0.295), u.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
        [new q(_, T), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new q(_, T), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [
          new F(new st(0.295, 0.295), h.clone()),
          [0.15, 0, 0.15],
          [-Math.PI / 2, 0, 0]
        ],
        [new q(_, x), [0.18, 0, 0.3], null, [0.125, 1, 1]],
        [new q(_, x), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ]
    }, R = {
      X: [[new F(new Fe(0.2, 0, 1, 4, 1, !1), s), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new F(new Fe(0.2, 0, 1, 4, 1, !1), s), [0, 0.6, 0]]],
      Z: [[new F(new Fe(0.2, 0, 1, 4, 1, !1), s), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
      XYZ: [[new F(new pt(0.2, 0), s)]],
      XY: [[new F(new st(0.4, 0.4), s), [0.2, 0.2, 0]]],
      YZ: [[new F(new st(0.4, 0.4), s), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
      XZ: [[new F(new st(0.4, 0.4), s), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
    }, k = {
      START: [[new F(new pt(0.01, 2), n), null, null, null, "helper"]],
      END: [[new F(new pt(0.01, 2), n), null, null, null, "helper"]],
      DELTA: [[new q(L(), n), null, null, null, "helper"]],
      X: [[new q(_, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new q(_, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new q(_, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, X = {
      X: [
        [new q(y(1, 0.5), d)],
        [new F(new pt(0.04, 0), i), [0, 0, 0.99], null, [1, 3, 1]]
      ],
      Y: [
        [new q(y(1, 0.5), g), null, [0, 0, -Math.PI / 2]],
        [new F(new pt(0.04, 0), o), [0, 0, 0.99], null, [3, 1, 1]]
      ],
      Z: [
        [new q(y(1, 0.5), m), null, [0, Math.PI / 2, 0]],
        [new F(new pt(0.04, 0), r), [0.99, 0, 0], null, [1, 3, 1]]
      ],
      E: [
        [new q(y(1.25, 1), f), null, [0, Math.PI / 2, 0]],
        [
          new F(new Fe(0.03, 0, 0.15, 4, 1, !1), f),
          [1.17, 0, 0],
          [0, 0, -Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new F(new Fe(0.03, 0, 0.15, 4, 1, !1), f),
          [-1.17, 0, 0],
          [0, 0, Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new F(new Fe(0.03, 0, 0.15, 4, 1, !1), f),
          [0, -1.17, 0],
          [Math.PI, 0, 0],
          [1, 1, 1e-3]
        ],
        [
          new F(new Fe(0.03, 0, 0.15, 4, 1, !1), f),
          [0, 1.17, 0],
          [0, 0, 0],
          [1, 1, 1e-3]
        ]
      ],
      XYZE: [[new q(y(1, 1), E), null, [0, Math.PI / 2, 0]]]
    }, se = {
      AXIS: [[new q(_, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
    }, V = {
      X: [[new F(new Kt(1, 0.1, 4, 24), s), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
      Y: [[new F(new Kt(1, 0.1, 4, 24), s), [0, 0, 0], [Math.PI / 2, 0, 0]]],
      Z: [[new F(new Kt(1, 0.1, 4, 24), s), [0, 0, 0], [0, 0, -Math.PI / 2]]],
      E: [[new F(new Kt(1.25, 0.1, 2, 24), s)]],
      XYZE: [[new F(new Vi(0.7, 10, 8), s)]]
    }, ae = {
      X: [
        [new F(w, i), [0.8, 0, 0], [0, 0, -Math.PI / 2]],
        [new q(_, d), null, null, [0.8, 1, 1]]
      ],
      Y: [
        [new F(w, o), [0, 0.8, 0]],
        [new q(_, g), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]
      ],
      Z: [
        [new F(w, r), [0, 0, 0.8], [Math.PI / 2, 0, 0]],
        [new q(_, m), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]
      ],
      XY: [
        [new F(w, c), [0.85, 0.85, 0], null, [2, 2, 0.2]],
        [new q(_, S), [0.855, 0.98, 0], null, [0.125, 1, 1]],
        [new q(_, S), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new F(w, u), [0, 0.85, 0.85], null, [0.2, 2, 2]],
        [new q(_, T), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new q(_, T), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [new F(w, h), [0.85, 0, 0.85], null, [2, 0.2, 2]],
        [new q(_, x), [0.855, 0, 0.98], null, [0.125, 1, 1]],
        [new q(_, x), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XYZX: [[new F(new ut(0.125, 0.125, 0.125), a.clone()), [1.1, 0, 0]]],
      XYZY: [[new F(new ut(0.125, 0.125, 0.125), a.clone()), [0, 1.1, 0]]],
      XYZZ: [[new F(new ut(0.125, 0.125, 0.125), a.clone()), [0, 0, 1.1]]]
    }, j = {
      X: [[new F(new Fe(0.2, 0, 0.8, 4, 1, !1), s), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new F(new Fe(0.2, 0, 0.8, 4, 1, !1), s), [0, 0.5, 0]]],
      Z: [[new F(new Fe(0.2, 0, 0.8, 4, 1, !1), s), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
      XY: [[new F(w, s), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
      YZ: [[new F(w, s), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
      XZ: [[new F(w, s), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
      XYZX: [[new F(new ut(0.2, 0.2, 0.2), s), [1.1, 0, 0]]],
      XYZY: [[new F(new ut(0.2, 0.2, 0.2), s), [0, 1.1, 0]]],
      XYZZ: [[new F(new ut(0.2, 0.2, 0.2), s), [0, 0, 1.1]]]
    }, _e = {
      X: [[new q(_, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new q(_, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new q(_, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, fe = (ne) => {
      const $ = new rt();
      for (let W in ne)
        for (let ye = ne[W].length; ye--; ) {
          const b = ne[W][ye][0].clone(), be = ne[W][ye][1], Pe = ne[W][ye][2], ke = ne[W][ye][3], We = ne[W][ye][4];
          b.name = W, b.tag = We, be && b.position.set(be[0], be[1], be[2]), Pe && b.rotation.set(Pe[0], Pe[1], Pe[2]), ke && b.scale.set(ke[0], ke[1], ke[2]), b.updateMatrix();
          const Rt = b.geometry.clone();
          Rt.applyMatrix4(b.matrix), b.geometry = Rt, b.renderOrder = 1 / 0, b.position.set(0, 0, 0), b.rotation.set(0, 0, 0), b.scale.set(1, 1, 1), $.add(b);
        }
      return $;
    };
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = fe(D)), this.add(this.gizmo.rotate = fe(X)), this.add(this.gizmo.scale = fe(ae)), this.add(this.picker.translate = fe(R)), this.add(this.picker.rotate = fe(V)), this.add(this.picker.scale = fe(j)), this.add(this.helper.translate = fe(k)), this.add(this.helper.rotate = fe(se)), this.add(this.helper.scale = fe(_e)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
}
class Go extends F {
  constructor() {
    super(
      new st(1e5, 1e5, 2, 2),
      new yt({
        visible: !1,
        wireframe: !0,
        side: Xs,
        transparent: !0,
        opacity: 0.1,
        toneMapped: !1
      })
    ), O(this, "isTransformControlsPlane", !0), O(this, "type", "TransformControlsPlane"), O(this, "unitX", new C(1, 0, 0)), O(this, "unitY", new C(0, 1, 0)), O(this, "unitZ", new C(0, 0, 1)), O(this, "tempVector", new C()), O(this, "dirVector", new C()), O(this, "alignVector", new C()), O(this, "tempMatrix", new re()), O(this, "identityQuaternion", new ce()), O(this, "cameraQuaternion", new ce()), O(this, "worldPosition", new C()), O(this, "worldQuaternion", new ce()), O(this, "eye", new C()), O(this, "axis", null), O(this, "mode", "translate"), O(this, "space", "world"), O(this, "updateMatrixWorld", () => {
      let e = this.space;
      switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), this.unitX.set(1, 0, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              this.alignVector.copy(this.eye).cross(this.unitX), this.dirVector.copy(this.unitX).cross(this.alignVector);
              break;
            case "Y":
              this.alignVector.copy(this.eye).cross(this.unitY), this.dirVector.copy(this.unitY).cross(this.alignVector);
              break;
            case "Z":
              this.alignVector.copy(this.eye).cross(this.unitZ), this.dirVector.copy(this.unitZ).cross(this.alignVector);
              break;
            case "XY":
              this.dirVector.copy(this.unitZ);
              break;
            case "YZ":
              this.dirVector.copy(this.unitX);
              break;
            case "XZ":
              this.alignVector.copy(this.unitZ), this.dirVector.copy(this.unitY);
              break;
            case "XYZ":
            case "E":
              this.dirVector.set(0, 0, 0);
              break;
          }
          break;
        case "rotate":
        default:
          this.dirVector.set(0, 0, 0);
      }
      this.dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector), this.quaternion.setFromRotationMatrix(this.tempMatrix)), super.updateMatrixWorld();
    });
  }
}
var Yo = Object.defineProperty, Xo = (l, e, t) => e in l ? Yo(l, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : l[e] = t, ve = (l, e, t) => (Xo(l, typeof e != "symbol" ? e + "" : e, t), t);
const vt = /* @__PURE__ */ new _t(0, 0, 0, "YXZ"), Tt = /* @__PURE__ */ new C(), jo = { type: "change" }, Zo = { type: "lock" }, Ko = { type: "unlock" }, dn = Math.PI / 2;
class Ns extends Bn {
  constructor(e, t) {
    super(), ve(this, "camera"), ve(this, "domElement"), ve(this, "isLocked"), ve(this, "minPolarAngle"), ve(this, "maxPolarAngle"), ve(this, "pointerSpeed"), ve(this, "onMouseMove", (s) => {
      if (!this.domElement || this.isLocked === !1)
        return;
      const n = s.movementX || s.mozMovementX || s.webkitMovementX || 0, i = s.movementY || s.mozMovementY || s.webkitMovementY || 0;
      vt.setFromQuaternion(this.camera.quaternion), vt.y -= n * 2e-3 * this.pointerSpeed, vt.x -= i * 2e-3 * this.pointerSpeed, vt.x = Math.max(dn - this.maxPolarAngle, Math.min(dn - this.minPolarAngle, vt.x)), this.camera.quaternion.setFromEuler(vt), this.dispatchEvent(jo);
    }), ve(this, "onPointerlockChange", () => {
      this.domElement && (this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(Zo), this.isLocked = !0) : (this.dispatchEvent(Ko), this.isLocked = !1));
    }), ve(this, "onPointerlockError", () => {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    }), ve(this, "connect", (s) => {
      this.domElement = s || this.domElement, this.domElement && (this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError));
    }), ve(this, "disconnect", () => {
      this.domElement && (this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError));
    }), ve(this, "dispose", () => {
      this.disconnect();
    }), ve(this, "getObject", () => this.camera), ve(this, "direction", new C(0, 0, -1)), ve(this, "getDirection", (s) => s.copy(this.direction).applyQuaternion(this.camera.quaternion)), ve(this, "moveForward", (s) => {
      Tt.setFromMatrixColumn(this.camera.matrix, 0), Tt.crossVectors(this.camera.up, Tt), this.camera.position.addScaledVector(Tt, s);
    }), ve(this, "moveRight", (s) => {
      Tt.setFromMatrixColumn(this.camera.matrix, 0), this.camera.position.addScaledVector(Tt, s);
    }), ve(this, "lock", () => {
      this.domElement && this.domElement.requestPointerLock();
    }), ve(this, "unlock", () => {
      this.domElement && this.domElement.ownerDocument.exitPointerLock();
    }), this.camera = e, this.domElement = t, this.isLocked = !1, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, t && this.connect(t);
  }
}
var Qo = Object.defineProperty, $o = (l, e, t) => e in l ? Qo(l, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : l[e] = t, z = (l, e, t) => ($o(l, typeof e != "symbol" ? e + "" : e, t), t);
const fn = (l, e) => (l % e + e) % e;
class ii extends Bn {
  constructor(e, t) {
    super(), z(this, "object"), z(this, "domElement"), z(this, "enabled", !0), z(this, "target", new C()), z(this, "minDistance", 0), z(this, "maxDistance", 1 / 0), z(this, "minZoom", 0), z(this, "maxZoom", 1 / 0), z(this, "minPolarAngle", 0), z(this, "maxPolarAngle", Math.PI), z(this, "minAzimuthAngle", -1 / 0), z(this, "maxAzimuthAngle", 1 / 0), z(this, "enableDamping", !1), z(this, "dampingFactor", 0.05), z(this, "enableZoom", !0), z(this, "zoomSpeed", 1), z(this, "enableRotate", !0), z(this, "rotateSpeed", 1), z(this, "enablePan", !0), z(this, "panSpeed", 1), z(this, "screenSpacePanning", !0), z(this, "keyPanSpeed", 7), z(this, "autoRotate", !1), z(this, "autoRotateSpeed", 2), z(this, "reverseOrbit", !1), z(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), z(this, "mouseButtons", {
      LEFT: nt.ROTATE,
      MIDDLE: nt.DOLLY,
      RIGHT: nt.PAN
    }), z(this, "touches", { ONE: Ye.ROTATE, TWO: Ye.DOLLY_PAN }), z(this, "target0"), z(this, "position0"), z(this, "zoom0"), z(this, "_domElementKeyEvents", null), z(this, "getPolarAngle"), z(this, "getAzimuthalAngle"), z(this, "setPolarAngle"), z(this, "setAzimuthalAngle"), z(this, "getDistance"), z(this, "listenToKeyEvents"), z(this, "saveState"), z(this, "reset"), z(this, "update"), z(this, "connect"), z(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => u.phi, this.getAzimuthalAngle = () => u.theta, this.setPolarAngle = (A) => {
      let I = fn(A, 2 * Math.PI), N = u.phi;
      N < 0 && (N += 2 * Math.PI), I < 0 && (I += 2 * Math.PI);
      let oe = Math.abs(I - N);
      2 * Math.PI - oe < oe && (I < N ? I += 2 * Math.PI : N += 2 * Math.PI), h.phi = I - N, s.update();
    }, this.setAzimuthalAngle = (A) => {
      let I = fn(A, 2 * Math.PI), N = u.theta;
      N < 0 && (N += 2 * Math.PI), I < 0 && (I += 2 * Math.PI);
      let oe = Math.abs(I - N);
      2 * Math.PI - oe < oe && (I < N ? I += 2 * Math.PI : N += 2 * Math.PI), h.theta = I - N, s.update();
    }, this.getDistance = () => s.object.position.distanceTo(s.target), this.listenToKeyEvents = (A) => {
      A.addEventListener("keydown", nn), this._domElementKeyEvents = A;
    }, this.saveState = () => {
      s.target0.copy(s.target), s.position0.copy(s.object.position), s.zoom0 = s.object.zoom;
    }, this.reset = () => {
      s.target.copy(s.target0), s.object.position.copy(s.position0), s.object.zoom = s.zoom0, s.object.updateProjectionMatrix(), s.dispatchEvent(n), s.update(), a = r.NONE;
    }, this.update = (() => {
      const A = new C(), I = new ce().setFromUnitVectors(e.up, new C(0, 1, 0)), N = I.clone().invert(), oe = new C(), we = new ce(), je = 2 * Math.PI;
      return function() {
        const ln = s.object.position;
        A.copy(ln).sub(s.target), A.applyQuaternion(I), u.setFromVector3(A), s.autoRotate && a === r.NONE && k(D()), s.enableDamping ? (u.theta += h.theta * s.dampingFactor, u.phi += h.phi * s.dampingFactor) : (u.theta += h.theta, u.phi += h.phi);
        let Ze = s.minAzimuthAngle, Ke = s.maxAzimuthAngle;
        return isFinite(Ze) && isFinite(Ke) && (Ze < -Math.PI ? Ze += je : Ze > Math.PI && (Ze -= je), Ke < -Math.PI ? Ke += je : Ke > Math.PI && (Ke -= je), Ze <= Ke ? u.theta = Math.max(Ze, Math.min(Ke, u.theta)) : u.theta = u.theta > (Ze + Ke) / 2 ? Math.max(Ze, u.theta) : Math.min(Ke, u.theta)), u.phi = Math.max(s.minPolarAngle, Math.min(s.maxPolarAngle, u.phi)), u.makeSafe(), u.radius *= p, u.radius = Math.max(s.minDistance, Math.min(s.maxDistance, u.radius)), s.enableDamping === !0 ? s.target.addScaledVector(d, s.dampingFactor) : s.target.add(d), A.setFromSpherical(u), A.applyQuaternion(N), ln.copy(s.target).add(A), s.object.lookAt(s.target), s.enableDamping === !0 ? (h.theta *= 1 - s.dampingFactor, h.phi *= 1 - s.dampingFactor, d.multiplyScalar(1 - s.dampingFactor)) : (h.set(0, 0, 0), d.set(0, 0, 0)), p = 1, g || oe.distanceToSquared(s.object.position) > c || 8 * (1 - we.dot(s.object.quaternion)) > c ? (s.dispatchEvent(n), oe.copy(s.object.position), we.copy(s.object.quaternion), g = !1, !0) : !1;
      };
    })(), this.connect = (A) => {
      A === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), s.domElement = A, s.domElement.style.touchAction = "none", s.domElement.addEventListener("contextmenu", on), s.domElement.addEventListener("pointerdown", en), s.domElement.addEventListener("pointercancel", tn), s.domElement.addEventListener("wheel", sn);
    }, this.dispose = () => {
      var A, I, N, oe, we, je;
      (A = s.domElement) == null || A.removeEventListener("contextmenu", on), (I = s.domElement) == null || I.removeEventListener("pointerdown", en), (N = s.domElement) == null || N.removeEventListener("pointercancel", tn), (oe = s.domElement) == null || oe.removeEventListener("wheel", sn), (we = s.domElement) == null || we.ownerDocument.removeEventListener("pointermove", hs), (je = s.domElement) == null || je.ownerDocument.removeEventListener("pointerup", us), s._domElementKeyEvents !== null && s._domElementKeyEvents.removeEventListener("keydown", nn);
    };
    const s = this, n = { type: "change" }, i = { type: "start" }, o = { type: "end" }, r = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let a = r.NONE;
    const c = 1e-6, u = new os(), h = new os();
    let p = 1;
    const d = new C();
    let g = !1;
    const m = new Se(), T = new Se(), x = new Se(), S = new Se(), E = new Se(), f = new Se(), v = new Se(), w = new Se(), _ = new Se(), y = [], L = {};
    function D() {
      return 2 * Math.PI / 60 / 60 * s.autoRotateSpeed;
    }
    function R() {
      return Math.pow(0.95, s.zoomSpeed);
    }
    function k(A) {
      s.reverseOrbit ? h.theta += A : h.theta -= A;
    }
    function X(A) {
      s.reverseOrbit ? h.phi += A : h.phi -= A;
    }
    const se = (() => {
      const A = new C();
      return function(N, oe) {
        A.setFromMatrixColumn(oe, 0), A.multiplyScalar(-N), d.add(A);
      };
    })(), V = (() => {
      const A = new C();
      return function(N, oe) {
        s.screenSpacePanning === !0 ? A.setFromMatrixColumn(oe, 1) : (A.setFromMatrixColumn(oe, 0), A.crossVectors(s.object.up, A)), A.multiplyScalar(N), d.add(A);
      };
    })(), ae = (() => {
      const A = new C();
      return function(N, oe) {
        const we = s.domElement;
        if (we && s.object instanceof Bt && s.object.isPerspectiveCamera) {
          const je = s.object.position;
          A.copy(je).sub(s.target);
          let Zt = A.length();
          Zt *= Math.tan(s.object.fov / 2 * Math.PI / 180), se(2 * N * Zt / we.clientHeight, s.object.matrix), V(2 * oe * Zt / we.clientHeight, s.object.matrix);
        } else
          we && s.object instanceof St && s.object.isOrthographicCamera ? (se(
            N * (s.object.right - s.object.left) / s.object.zoom / we.clientWidth,
            s.object.matrix
          ), V(
            oe * (s.object.top - s.object.bottom) / s.object.zoom / we.clientHeight,
            s.object.matrix
          )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), s.enablePan = !1);
      };
    })();
    function j(A) {
      s.object instanceof Bt && s.object.isPerspectiveCamera ? p /= A : s.object instanceof St && s.object.isOrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom * A)), s.object.updateProjectionMatrix(), g = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = !1);
    }
    function _e(A) {
      s.object instanceof Bt && s.object.isPerspectiveCamera ? p *= A : s.object instanceof St && s.object.isOrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom / A)), s.object.updateProjectionMatrix(), g = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = !1);
    }
    function fe(A) {
      m.set(A.clientX, A.clientY);
    }
    function ne(A) {
      v.set(A.clientX, A.clientY);
    }
    function $(A) {
      S.set(A.clientX, A.clientY);
    }
    function W(A) {
      T.set(A.clientX, A.clientY), x.subVectors(T, m).multiplyScalar(s.rotateSpeed);
      const I = s.domElement;
      I && (k(2 * Math.PI * x.x / I.clientHeight), X(2 * Math.PI * x.y / I.clientHeight)), m.copy(T), s.update();
    }
    function ye(A) {
      w.set(A.clientX, A.clientY), _.subVectors(w, v), _.y > 0 ? j(R()) : _.y < 0 && _e(R()), v.copy(w), s.update();
    }
    function b(A) {
      E.set(A.clientX, A.clientY), f.subVectors(E, S).multiplyScalar(s.panSpeed), ae(f.x, f.y), S.copy(E), s.update();
    }
    function be(A) {
      A.deltaY < 0 ? _e(R()) : A.deltaY > 0 && j(R()), s.update();
    }
    function Pe(A) {
      let I = !1;
      switch (A.code) {
        case s.keys.UP:
          ae(0, s.keyPanSpeed), I = !0;
          break;
        case s.keys.BOTTOM:
          ae(0, -s.keyPanSpeed), I = !0;
          break;
        case s.keys.LEFT:
          ae(s.keyPanSpeed, 0), I = !0;
          break;
        case s.keys.RIGHT:
          ae(-s.keyPanSpeed, 0), I = !0;
          break;
      }
      I && (A.preventDefault(), s.update());
    }
    function ke() {
      if (y.length == 1)
        m.set(y[0].pageX, y[0].pageY);
      else {
        const A = 0.5 * (y[0].pageX + y[1].pageX), I = 0.5 * (y[0].pageY + y[1].pageY);
        m.set(A, I);
      }
    }
    function We() {
      if (y.length == 1)
        S.set(y[0].pageX, y[0].pageY);
      else {
        const A = 0.5 * (y[0].pageX + y[1].pageX), I = 0.5 * (y[0].pageY + y[1].pageY);
        S.set(A, I);
      }
    }
    function Rt() {
      const A = y[0].pageX - y[1].pageX, I = y[0].pageY - y[1].pageY, N = Math.sqrt(A * A + I * I);
      v.set(0, N);
    }
    function _i() {
      s.enableZoom && Rt(), s.enablePan && We();
    }
    function yi() {
      s.enableZoom && Rt(), s.enableRotate && ke();
    }
    function Ws(A) {
      if (y.length == 1)
        T.set(A.pageX, A.pageY);
      else {
        const N = ps(A), oe = 0.5 * (A.pageX + N.x), we = 0.5 * (A.pageY + N.y);
        T.set(oe, we);
      }
      x.subVectors(T, m).multiplyScalar(s.rotateSpeed);
      const I = s.domElement;
      I && (k(2 * Math.PI * x.x / I.clientHeight), X(2 * Math.PI * x.y / I.clientHeight)), m.copy(T);
    }
    function qs(A) {
      if (y.length == 1)
        E.set(A.pageX, A.pageY);
      else {
        const I = ps(A), N = 0.5 * (A.pageX + I.x), oe = 0.5 * (A.pageY + I.y);
        E.set(N, oe);
      }
      f.subVectors(E, S).multiplyScalar(s.panSpeed), ae(f.x, f.y), S.copy(E);
    }
    function Js(A) {
      const I = ps(A), N = A.pageX - I.x, oe = A.pageY - I.y, we = Math.sqrt(N * N + oe * oe);
      w.set(0, we), _.set(0, Math.pow(w.y / v.y, s.zoomSpeed)), j(_.y), v.copy(w);
    }
    function vi(A) {
      s.enableZoom && Js(A), s.enablePan && qs(A);
    }
    function Ti(A) {
      s.enableZoom && Js(A), s.enableRotate && Ws(A);
    }
    function en(A) {
      var I, N;
      s.enabled !== !1 && (y.length === 0 && ((I = s.domElement) == null || I.ownerDocument.addEventListener("pointermove", hs), (N = s.domElement) == null || N.ownerDocument.addEventListener("pointerup", us)), bi(A), A.pointerType === "touch" ? Ai(A) : Ei(A));
    }
    function hs(A) {
      s.enabled !== !1 && (A.pointerType === "touch" ? xi(A) : wi(A));
    }
    function us(A) {
      var I, N, oe;
      rn(A), y.length === 0 && ((I = s.domElement) == null || I.releasePointerCapture(A.pointerId), (N = s.domElement) == null || N.ownerDocument.removeEventListener("pointermove", hs), (oe = s.domElement) == null || oe.ownerDocument.removeEventListener("pointerup", us)), s.dispatchEvent(o), a = r.NONE;
    }
    function tn(A) {
      rn(A);
    }
    function Ei(A) {
      let I;
      switch (A.button) {
        case 0:
          I = s.mouseButtons.LEFT;
          break;
        case 1:
          I = s.mouseButtons.MIDDLE;
          break;
        case 2:
          I = s.mouseButtons.RIGHT;
          break;
        default:
          I = -1;
      }
      switch (I) {
        case nt.DOLLY:
          if (s.enableZoom === !1)
            return;
          ne(A), a = r.DOLLY;
          break;
        case nt.ROTATE:
          if (A.ctrlKey || A.metaKey || A.shiftKey) {
            if (s.enablePan === !1)
              return;
            $(A), a = r.PAN;
          } else {
            if (s.enableRotate === !1)
              return;
            fe(A), a = r.ROTATE;
          }
          break;
        case nt.PAN:
          if (A.ctrlKey || A.metaKey || A.shiftKey) {
            if (s.enableRotate === !1)
              return;
            fe(A), a = r.ROTATE;
          } else {
            if (s.enablePan === !1)
              return;
            $(A), a = r.PAN;
          }
          break;
        default:
          a = r.NONE;
      }
      a !== r.NONE && s.dispatchEvent(i);
    }
    function wi(A) {
      if (s.enabled !== !1)
        switch (a) {
          case r.ROTATE:
            if (s.enableRotate === !1)
              return;
            W(A);
            break;
          case r.DOLLY:
            if (s.enableZoom === !1)
              return;
            ye(A);
            break;
          case r.PAN:
            if (s.enablePan === !1)
              return;
            b(A);
            break;
        }
    }
    function sn(A) {
      s.enabled === !1 || s.enableZoom === !1 || a !== r.NONE && a !== r.ROTATE || (A.preventDefault(), s.dispatchEvent(i), be(A), s.dispatchEvent(o));
    }
    function nn(A) {
      s.enabled === !1 || s.enablePan === !1 || Pe(A);
    }
    function Ai(A) {
      switch (an(A), y.length) {
        case 1:
          switch (s.touches.ONE) {
            case Ye.ROTATE:
              if (s.enableRotate === !1)
                return;
              ke(), a = r.TOUCH_ROTATE;
              break;
            case Ye.PAN:
              if (s.enablePan === !1)
                return;
              We(), a = r.TOUCH_PAN;
              break;
            default:
              a = r.NONE;
          }
          break;
        case 2:
          switch (s.touches.TWO) {
            case Ye.DOLLY_PAN:
              if (s.enableZoom === !1 && s.enablePan === !1)
                return;
              _i(), a = r.TOUCH_DOLLY_PAN;
              break;
            case Ye.DOLLY_ROTATE:
              if (s.enableZoom === !1 && s.enableRotate === !1)
                return;
              yi(), a = r.TOUCH_DOLLY_ROTATE;
              break;
            default:
              a = r.NONE;
          }
          break;
        default:
          a = r.NONE;
      }
      a !== r.NONE && s.dispatchEvent(i);
    }
    function xi(A) {
      switch (an(A), a) {
        case r.TOUCH_ROTATE:
          if (s.enableRotate === !1)
            return;
          Ws(A), s.update();
          break;
        case r.TOUCH_PAN:
          if (s.enablePan === !1)
            return;
          qs(A), s.update();
          break;
        case r.TOUCH_DOLLY_PAN:
          if (s.enableZoom === !1 && s.enablePan === !1)
            return;
          vi(A), s.update();
          break;
        case r.TOUCH_DOLLY_ROTATE:
          if (s.enableZoom === !1 && s.enableRotate === !1)
            return;
          Ti(A), s.update();
          break;
        default:
          a = r.NONE;
      }
    }
    function on(A) {
      s.enabled !== !1 && A.preventDefault();
    }
    function bi(A) {
      y.push(A);
    }
    function rn(A) {
      delete L[A.pointerId];
      for (let I = 0; I < y.length; I++)
        if (y[I].pointerId == A.pointerId) {
          y.splice(I, 1);
          return;
        }
    }
    function an(A) {
      let I = L[A.pointerId];
      I === void 0 && (I = new Se(), L[A.pointerId] = I), I.set(A.pageX, A.pageY);
    }
    function ps(A) {
      const I = A.pointerId === y[0].pointerId ? y[1] : y[0];
      return L[I.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
}
class Wo extends ii {
  constructor(e, t) {
    super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = nt.PAN, this.mouseButtons.RIGHT = nt.ROTATE, this.touches.ONE = Ye.PAN, this.touches.TWO = Ye.DOLLY_ROTATE;
  }
}
class qo extends cs {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new nr(t);
    }), this.register(function(t) {
      return new ur(t);
    }), this.register(function(t) {
      return new pr(t);
    }), this.register(function(t) {
      return new dr(t);
    }), this.register(function(t) {
      return new or(t);
    }), this.register(function(t) {
      return new rr(t);
    }), this.register(function(t) {
      return new ar(t);
    }), this.register(function(t) {
      return new lr(t);
    }), this.register(function(t) {
      return new sr(t);
    }), this.register(function(t) {
      return new cr(t);
    }), this.register(function(t) {
      return new ir(t);
    }), this.register(function(t) {
      return new hr(t);
    }), this.register(function(t) {
      return new er(t);
    }), this.register(function(t) {
      return new fr(t);
    }), this.register(function(t) {
      return new mr(t);
    });
  }
  load(e, t, s, n) {
    const i = this;
    let o;
    this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = Xe.extractUrlBase(e), this.manager.itemStart(e);
    const r = function(c) {
      n ? n(c) : console.error(c), i.manager.itemError(e), i.manager.itemEnd(e);
    }, a = new Ot(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(
      e,
      function(c) {
        try {
          i.parse(
            c,
            o,
            function(u) {
              t(u), i.manager.itemEnd(e);
            },
            r
          );
        } catch (u) {
          r(u);
        }
      },
      s,
      r
    );
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, s, n) {
    let i;
    const o = {}, r = {};
    if (typeof e == "string")
      i = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (Xe.decodeText(new Uint8Array(e.slice(0, 4))) === oi) {
        try {
          o[K.KHR_BINARY_GLTF] = new gr(e);
        } catch (u) {
          n && n(u);
          return;
        }
        i = JSON.parse(o[K.KHR_BINARY_GLTF].content);
      } else
        i = JSON.parse(Xe.decodeText(new Uint8Array(e)));
    else
      i = e;
    if (i.asset === void 0 || i.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const a = new Lr(i, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    a.fileLoader.setRequestHeader(this.requestHeader);
    for (let c = 0; c < this.pluginCallbacks.length; c++) {
      const u = this.pluginCallbacks[c](a);
      r[u.name] = u, o[u.name] = !0;
    }
    if (i.extensionsUsed)
      for (let c = 0; c < i.extensionsUsed.length; ++c) {
        const u = i.extensionsUsed[c], h = i.extensionsRequired || [];
        switch (u) {
          case K.KHR_MATERIALS_UNLIT:
            o[u] = new tr();
            break;
          case K.KHR_DRACO_MESH_COMPRESSION:
            o[u] = new _r(i, this.dracoLoader);
            break;
          case K.KHR_TEXTURE_TRANSFORM:
            o[u] = new yr();
            break;
          case K.KHR_MESH_QUANTIZATION:
            o[u] = new vr();
            break;
          default:
            h.indexOf(u) >= 0 && r[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    a.setExtensions(o), a.setPlugins(r), a.parse(s, n);
  }
  parseAsync(e, t) {
    const s = this;
    return new Promise(function(n, i) {
      s.parse(e, t, n, i);
    });
  }
}
function Jo() {
  let l = {};
  return {
    get: function(e) {
      return l[e];
    },
    add: function(e, t) {
      l[e] = t;
    },
    remove: function(e) {
      delete l[e];
    },
    removeAll: function() {
      l = {};
    }
  };
}
const K = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class er {
  constructor(e) {
    this.parser = e, this.name = K.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let s = 0, n = t.length; s < n; s++) {
      const i = t[s];
      i.extensions && i.extensions[this.name] && i.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, i.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, s = "light:" + e;
    let n = t.cache.get(s);
    if (n)
      return n;
    const i = t.json, a = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
    let c;
    const u = new ge(16777215);
    a.color !== void 0 && u.fromArray(a.color);
    const h = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        c = new Nn(u), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new Cs(u), c.distance = h;
        break;
      case "spot":
        c = new zn(u), c.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, c.angle = a.spot.outerConeAngle, c.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, it(c, a), a.intensity !== void 0 && (c.intensity = a.intensity), c.name = t.createUniqueName(a.name || "light_" + e), n = Promise.resolve(c), t.cache.add(s, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, s = this.parser, i = s.json.nodes[e], r = (i.extensions && i.extensions[this.name] || {}).light;
    return r === void 0 ? null : this._loadLight(r).then(function(a) {
      return s._getNodeRef(t.cache, r, a);
    });
  }
}
class tr {
  constructor() {
    this.name = K.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return yt;
  }
  extendParams(e, t, s) {
    const n = [];
    e.color = new ge(1, 1, 1), e.opacity = 1;
    const i = t.pbrMetallicRoughness;
    if (i) {
      if (Array.isArray(i.baseColorFactor)) {
        const o = i.baseColorFactor;
        e.color.fromArray(o), e.opacity = o[3];
      }
      i.baseColorTexture !== void 0 && n.push(s.assignTexture(e, "map", i.baseColorTexture, 3001));
    }
    return Promise.all(n);
  }
}
class sr {
  constructor(e) {
    this.parser = e, this.name = K.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = n.extensions[this.name].emissiveStrength;
    return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();
  }
}
class nr {
  constructor(e) {
    this.parser = e, this.name = K.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : ht;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && i.push(s.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && i.push(s.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (i.push(s.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const r = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Se(r, r);
    }
    return Promise.all(i);
  }
}
class ir {
  constructor(e) {
    this.parser = e, this.name = K.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : ht;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && i.push(s.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && i.push(
      s.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)
    ), Promise.all(i);
  }
}
class or {
  constructor(e) {
    this.parser = e, this.name = K.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : ht;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [];
    t.sheenColor = new ge(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = n.extensions[this.name];
    return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor), o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && i.push(s.assignTexture(t, "sheenColorMap", o.sheenColorTexture, 3001)), o.sheenRoughnessTexture !== void 0 && i.push(s.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(i);
  }
}
class rr {
  constructor(e) {
    this.parser = e, this.name = K.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : ht;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && i.push(s.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(i);
  }
}
class ar {
  constructor(e) {
    this.parser = e, this.name = K.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : ht;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && i.push(s.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const r = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new ge(r[0], r[1], r[2]), Promise.all(i);
  }
}
class lr {
  constructor(e) {
    this.parser = e, this.name = K.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : ht;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = n.extensions[this.name];
    return t.ior = i.ior !== void 0 ? i.ior : 1.5, Promise.resolve();
  }
}
class cr {
  constructor(e) {
    this.parser = e, this.name = K.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : ht;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && i.push(s.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const r = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new ge(r[0], r[1], r[2]), o.specularColorTexture !== void 0 && i.push(
      s.assignTexture(t, "specularColorMap", o.specularColorTexture, 3001)
      // sRGBEncoding
    ), Promise.all(i);
  }
}
class hr {
  constructor(e) {
    this.parser = e, this.name = K.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : ht;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && i.push(s.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(i);
  }
}
class ur {
  constructor(e) {
    this.parser = e, this.name = K.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, s = t.json, n = s.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const i = n.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (s.extensionsRequired && s.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, i.source, o);
  }
}
class pr {
  constructor(e) {
    this.parser = e, this.name = K.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, s = this.parser, n = s.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const o = i.extensions[t], r = n.images[o.source];
    let a = s.textureLoader;
    if (r.uri) {
      const c = s.options.manager.getHandler(r.uri);
      c !== null && (a = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return s.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return s.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class dr {
  constructor(e) {
    this.parser = e, this.name = K.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, s = this.parser, n = s.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const o = i.extensions[t], r = n.images[o.source];
    let a = s.textureLoader;
    if (r.uri) {
      const c = s.options.manager.getHandler(r.uri);
      c !== null && (a = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return s.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return s.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class fr {
  constructor(e) {
    this.name = K.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, s = t.bufferViews[e];
    if (s.extensions && s.extensions[this.name]) {
      const n = s.extensions[this.name], i = this.parser.getDependency("buffer", n.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return i.then(function(r) {
        const a = n.byteOffset || 0, c = n.byteLength || 0, u = n.count, h = n.byteStride, p = new Uint8Array(r, a, c);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, h, p, n.mode, n.filter).then(function(d) {
          return d.buffer;
        }) : o.ready.then(function() {
          const d = new ArrayBuffer(u * h);
          return o.decodeGltfBuffer(
            new Uint8Array(d),
            u,
            h,
            p,
            n.mode,
            n.filter
          ), d;
        });
      });
    } else
      return null;
  }
}
class mr {
  constructor(e) {
    this.name = K.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, s = t.nodes[e];
    if (!s.extensions || !s.extensions[this.name] || s.mesh === void 0)
      return null;
    const n = t.meshes[s.mesh];
    for (const c of n.primitives)
      if (c.mode !== De.TRIANGLES && c.mode !== De.TRIANGLE_STRIP && c.mode !== De.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const o = s.extensions[this.name].attributes, r = [], a = {};
    for (const c in o)
      r.push(
        this.parser.getDependency("accessor", o[c]).then((u) => (a[c] = u, a[c]))
      );
    return r.length < 1 ? null : (r.push(this.parser.createNodeMesh(e)), Promise.all(r).then((c) => {
      const u = c.pop(), h = u.isGroup ? u.children : [u], p = c[0].count, d = [];
      for (const g of h) {
        const m = new re(), T = new C(), x = new ce(), S = new C(1, 1, 1), E = new Gi(g.geometry, g.material, p);
        for (let f = 0; f < p; f++)
          a.TRANSLATION && T.fromBufferAttribute(a.TRANSLATION, f), a.ROTATION && x.fromBufferAttribute(a.ROTATION, f), a.SCALE && S.fromBufferAttribute(a.SCALE, f), E.setMatrixAt(f, m.compose(T, x, S));
        for (const f in a)
          f !== "TRANSLATION" && f !== "ROTATION" && f !== "SCALE" && g.geometry.setAttribute(f, a[f]);
        rt.prototype.copy.call(E, g), this.parser.assignFinalMaterial(E), d.push(E);
      }
      return u.isGroup ? (u.clear(), u.add(...d), u) : d[0];
    }));
  }
}
const oi = "glTF", Dt = 12, mn = { JSON: 1313821514, BIN: 5130562 };
class gr {
  constructor(e) {
    this.name = K.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Dt);
    if (this.header = {
      magic: Xe.decodeText(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== oi)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const s = this.header.length - Dt, n = new DataView(e, Dt);
    let i = 0;
    for (; i < s; ) {
      const o = n.getUint32(i, !0);
      i += 4;
      const r = n.getUint32(i, !0);
      if (i += 4, r === mn.JSON) {
        const a = new Uint8Array(e, Dt + i, o);
        this.content = Xe.decodeText(a);
      } else if (r === mn.BIN) {
        const a = Dt + i;
        this.body = e.slice(a, a + o);
      }
      i += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class _r {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = K.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const s = this.json, n = this.dracoLoader, i = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, r = {}, a = {}, c = {};
    for (const u in o) {
      const h = Hs[u] || u.toLowerCase();
      r[h] = o[u];
    }
    for (const u in e.attributes) {
      const h = Hs[u] || u.toLowerCase();
      if (o[u] !== void 0) {
        const p = s.accessors[e.attributes[u]], d = Mt[p.componentType];
        c[h] = d.name, a[h] = p.normalized === !0;
      }
    }
    return t.getDependency("bufferView", i).then(function(u) {
      return new Promise(function(h) {
        n.decodeDracoFile(
          u,
          function(p) {
            for (const d in p.attributes) {
              const g = p.attributes[d], m = a[d];
              m !== void 0 && (g.normalized = m);
            }
            h(p);
          },
          r,
          c
        );
      });
    });
  }
}
class yr {
  constructor() {
    this.name = K.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class vr {
  constructor() {
    this.name = K.KHR_MESH_QUANTIZATION;
  }
}
class ri extends oo {
  constructor(e, t, s, n) {
    super(e, t, s, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, s = this.sampleValues, n = this.valueSize, i = e * n * 3 + n;
    for (let o = 0; o !== n; o++)
      t[o] = s[i + o];
    return t;
  }
  interpolate_(e, t, s, n) {
    const i = this.resultBuffer, o = this.sampleValues, r = this.valueSize, a = r * 2, c = r * 3, u = n - t, h = (s - t) / u, p = h * h, d = p * h, g = e * c, m = g - c, T = -2 * d + 3 * p, x = d - p, S = 1 - T, E = x - p + h;
    for (let f = 0; f !== r; f++) {
      const v = o[m + f + r], w = o[m + f + a] * u, _ = o[g + f + r], y = o[g + f] * u;
      i[f] = S * v + E * w + T * _ + x * y;
    }
    return i;
  }
}
const Tr = /* @__PURE__ */ new ce();
class Er extends ri {
  interpolate_(e, t, s, n) {
    const i = super.interpolate_(e, t, s, n);
    return Tr.fromArray(i).normalize().toArray(i), i;
  }
}
const De = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, Mt = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, gn = {
  9728: qi,
  9729: rs,
  9984: Ji,
  9985: eo,
  9986: to,
  9987: Vn
}, _n = {
  33071: Fs,
  33648: so,
  10497: Vt
}, vs = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Hs = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  // uv => uv1, 4 uv channels
  // https://github.com/mrdoob/three.js/pull/25943
  // https://github.com/mrdoob/three.js/pull/25788
  ...Yi.replace(/\D+/g, "") >= 152 ? {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3"
  } : {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2"
  },
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, et = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, wr = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: Xn,
  STEP: no
}, Ts = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function Ar(l) {
  return l.DefaultMaterial === void 0 && (l.DefaultMaterial = new Zs({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: io
  })), l.DefaultMaterial;
}
function dt(l, e, t) {
  for (const s in t.extensions)
    l[s] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[s] = t.extensions[s]);
}
function it(l, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(l.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function xr(l, e, t) {
  let s = !1, n = !1, i = !1;
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (h.POSITION !== void 0 && (s = !0), h.NORMAL !== void 0 && (n = !0), h.COLOR_0 !== void 0 && (i = !0), s && n && i)
      break;
  }
  if (!s && !n && !i)
    return Promise.resolve(l);
  const o = [], r = [], a = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (s) {
      const p = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : l.attributes.position;
      o.push(p);
    }
    if (n) {
      const p = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : l.attributes.normal;
      r.push(p);
    }
    if (i) {
      const p = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : l.attributes.color;
      a.push(p);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(r),
    Promise.all(a)
  ]).then(function(c) {
    const u = c[0], h = c[1], p = c[2];
    return s && (l.morphAttributes.position = u), n && (l.morphAttributes.normal = h), i && (l.morphAttributes.color = p), l.morphTargetsRelative = !0, l;
  });
}
function br(l, e) {
  if (l.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, s = e.weights.length; t < s; t++)
      l.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (l.morphTargetInfluences.length === t.length) {
      l.morphTargetDictionary = {};
      for (let s = 0, n = t.length; s < n; s++)
        l.morphTargetDictionary[t[s]] = s;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function Sr(l) {
  let e;
  const t = l.extensions && l.extensions[K.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Es(t.attributes) : e = l.indices + ":" + Es(l.attributes) + ":" + l.mode, l.targets !== void 0)
    for (let s = 0, n = l.targets.length; s < n; s++)
      e += ":" + Es(l.targets[s]);
  return e;
}
function Es(l) {
  let e = "";
  const t = Object.keys(l).sort();
  for (let s = 0, n = t.length; s < n; s++)
    e += t[s] + ":" + l[t[s]] + ";";
  return e;
}
function Vs(l) {
  switch (l) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function Mr(l) {
  return l.search(/\.jpe?g($|\?)/i) > 0 || l.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : l.search(/\.webp($|\?)/i) > 0 || l.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const Or = /* @__PURE__ */ new re();
class Lr {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Jo(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let s = !1, n = !1, i = -1;
    typeof navigator < "u" && typeof navigator.userAgent < "u" && (s = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, n = navigator.userAgent.indexOf("Firefox") > -1, i = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || s || n && i < 98 ? this.textureLoader = new Hn(this.options.manager) : this.textureLoader = new Xi(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Ot(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const s = this, n = this.json, i = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(
      this._invokeAll(function(o) {
        return o.beforeRoot && o.beforeRoot();
      })
    ).then(function() {
      return Promise.all([
        s.getDependencies("scene"),
        s.getDependencies("animation"),
        s.getDependencies("camera")
      ]);
    }).then(function(o) {
      const r = {
        scene: o[0][n.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: n.asset,
        parser: s,
        userData: {}
      };
      dt(i, r, n), it(r, n), Promise.all(
        s._invokeAll(function(a) {
          return a.afterRoot && a.afterRoot(r);
        })
      ).then(function() {
        e(r);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], s = this.json.meshes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const o = t[n].joints;
      for (let r = 0, a = o.length; r < a; r++)
        e[o[r]].isBone = !0;
    }
    for (let n = 0, i = e.length; n < i; n++) {
      const o = e[n];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (s[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, s) {
    if (e.refs[t] <= 1)
      return s;
    const n = s.clone(), i = (o, r) => {
      const a = this.associations.get(o);
      a != null && this.associations.set(r, a);
      for (const [c, u] of o.children.entries())
        i(u, r.children[c]);
    };
    return i(s, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let s = 0; s < t.length; s++) {
      const n = e(t[s]);
      if (n)
        return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const s = [];
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      i && s.push(i);
    }
    return s;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const s = e + ":" + t;
    let n = this.cache.get(s);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(i) {
            return i.loadNode && i.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(i) {
            return i.loadMesh && i.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(i) {
            return i.loadBufferView && i.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(i) {
            return i.loadMaterial && i.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(i) {
            return i.loadTexture && i.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(i) {
            return i.loadAnimation && i.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(i) {
            return i != this && i.getDependency && i.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(s, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const s = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(
        n.map(function(i, o) {
          return s.getDependency(e, o);
        })
      ), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], s = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[K.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(i, o) {
      s.load(Xe.resolveURL(t.uri, n.path), i, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(s) {
      const n = t.byteLength || 0, i = t.byteOffset || 0;
      return s.slice(i, i + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, s = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const o = vs[n.type], r = Mt[n.componentType], a = n.normalized === !0, c = new r(n.count * o);
      return Promise.resolve(new zt(c, o, a));
    }
    const i = [];
    return n.bufferView !== void 0 ? i.push(this.getDependency("bufferView", n.bufferView)) : i.push(null), n.sparse !== void 0 && (i.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(i).then(function(o) {
      const r = o[0], a = vs[n.type], c = Mt[n.componentType], u = c.BYTES_PER_ELEMENT, h = u * a, p = n.byteOffset || 0, d = n.bufferView !== void 0 ? s.bufferViews[n.bufferView].byteStride : void 0, g = n.normalized === !0;
      let m, T;
      if (d && d !== h) {
        const x = Math.floor(p / d), S = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + x + ":" + n.count;
        let E = t.cache.get(S);
        E || (m = new c(r, x * d, n.count * d / u), E = new ji(m, d / u), t.cache.add(S, E)), T = new Zi(
          E,
          a,
          p % d / u,
          g
        );
      } else
        r === null ? m = new c(n.count * a) : m = new c(r, p, n.count * a), T = new zt(m, a, g);
      if (n.sparse !== void 0) {
        const x = vs.SCALAR, S = Mt[n.sparse.indices.componentType], E = n.sparse.indices.byteOffset || 0, f = n.sparse.values.byteOffset || 0, v = new S(
          o[1],
          E,
          n.sparse.count * x
        ), w = new c(o[2], f, n.sparse.count * a);
        r !== null && (T = new zt(
          T.array.slice(),
          T.itemSize,
          T.normalized
        ));
        for (let _ = 0, y = v.length; _ < y; _++) {
          const L = v[_];
          if (T.setX(L, w[_ * a]), a >= 2 && T.setY(L, w[_ * a + 1]), a >= 3 && T.setZ(L, w[_ * a + 2]), a >= 4 && T.setW(L, w[_ * a + 3]), a >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return T;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, s = this.options, i = t.textures[e].source, o = t.images[i];
    let r = this.textureLoader;
    if (o.uri) {
      const a = s.manager.getHandler(o.uri);
      a !== null && (r = a);
    }
    return this.loadTextureImage(e, i, r);
  }
  loadTextureImage(e, t, s) {
    const n = this, i = this.json, o = i.textures[e], r = i.images[t], a = (r.uri || r.bufferView) + ":" + o.sampler;
    if (this.textureCache[a])
      return this.textureCache[a];
    const c = this.loadImageSource(t, s).then(function(u) {
      u.flipY = !1, u.name = o.name || r.name || "", u.name === "" && typeof r.uri == "string" && r.uri.startsWith("data:image/") === !1 && (u.name = r.uri);
      const p = (i.samplers || {})[o.sampler] || {};
      return u.magFilter = gn[p.magFilter] || rs, u.minFilter = gn[p.minFilter] || Vn, u.wrapS = _n[p.wrapS] || Vt, u.wrapT = _n[p.wrapT] || Vt, n.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[a] = c, c;
  }
  loadImageSource(e, t) {
    const s = this, n = this.json, i = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const o = n.images[e], r = self.URL || self.webkitURL;
    let a = o.uri || "", c = !1;
    if (o.bufferView !== void 0)
      a = s.getDependency("bufferView", o.bufferView).then(function(h) {
        c = !0;
        const p = new Blob([h], { type: o.mimeType });
        return a = r.createObjectURL(p), a;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(a).then(function(h) {
      return new Promise(function(p, d) {
        let g = p;
        t.isImageBitmapLoader === !0 && (g = function(m) {
          const T = new as(m);
          T.needsUpdate = !0, p(T);
        }), t.load(Xe.resolveURL(h, i.path), g, void 0, d);
      });
    }).then(function(h) {
      return c === !0 && r.revokeObjectURL(a), h.userData.mimeType = o.mimeType || Mr(o.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", a), h;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, s, n) {
    const i = this;
    return this.getDependency("texture", s.index).then(function(o) {
      if (!o)
        return null;
      if (s.texCoord !== void 0 && s.texCoord > 0 && (o = o.clone(), o.channel = s.texCoord), i.extensions[K.KHR_TEXTURE_TRANSFORM]) {
        const r = s.extensions !== void 0 ? s.extensions[K.KHR_TEXTURE_TRANSFORM] : void 0;
        if (r) {
          const a = i.associations.get(o);
          o = i.extensions[K.KHR_TEXTURE_TRANSFORM].extendTexture(o, r), i.associations.set(o, a);
        }
      }
      return n !== void 0 && ("colorSpace" in o ? o.colorSpace = n === 3001 ? "srgb" : "srgb-linear" : o.encoding = n), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let s = e.material;
    const n = t.attributes.tangent === void 0, i = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const r = "PointsMaterial:" + s.uuid;
      let a = this.cache.get(r);
      a || (a = new Ki(), fs.prototype.copy.call(a, s), a.color.copy(s.color), a.map = s.map, a.sizeAttenuation = !1, this.cache.add(r, a)), s = a;
    } else if (e.isLine) {
      const r = "LineBasicMaterial:" + s.uuid;
      let a = this.cache.get(r);
      a || (a = new js(), fs.prototype.copy.call(a, s), a.color.copy(s.color), a.map = s.map, this.cache.add(r, a)), s = a;
    }
    if (n || i || o) {
      let r = "ClonedMaterial:" + s.uuid + ":";
      n && (r += "derivative-tangents:"), i && (r += "vertex-colors:"), o && (r += "flat-shading:");
      let a = this.cache.get(r);
      a || (a = s.clone(), i && (a.vertexColors = !0), o && (a.flatShading = !0), n && (a.normalScale && (a.normalScale.y *= -1), a.clearcoatNormalScale && (a.clearcoatNormalScale.y *= -1)), this.cache.add(r, a), this.associations.set(a, this.associations.get(s))), s = a;
    }
    e.material = s;
  }
  getMaterialType() {
    return Zs;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, s = this.json, n = this.extensions, i = s.materials[e];
    let o;
    const r = {}, a = i.extensions || {}, c = [];
    if (a[K.KHR_MATERIALS_UNLIT]) {
      const h = n[K.KHR_MATERIALS_UNLIT];
      o = h.getMaterialType(), c.push(h.extendParams(r, i, t));
    } else {
      const h = i.pbrMetallicRoughness || {};
      if (r.color = new ge(1, 1, 1), r.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const p = h.baseColorFactor;
        r.color.fromArray(p), r.opacity = p[3];
      }
      h.baseColorTexture !== void 0 && c.push(t.assignTexture(r, "map", h.baseColorTexture, 3001)), r.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, r.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(r, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(r, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(p) {
        return p.getMaterialType && p.getMaterialType(e);
      }), c.push(
        Promise.all(
          this._invokeAll(function(p) {
            return p.extendMaterialParams && p.extendMaterialParams(e, r);
          })
        )
      );
    }
    i.doubleSided === !0 && (r.side = Xs);
    const u = i.alphaMode || Ts.OPAQUE;
    if (u === Ts.BLEND ? (r.transparent = !0, r.depthWrite = !1) : (r.transparent = !1, u === Ts.MASK && (r.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && o !== yt && (c.push(t.assignTexture(r, "normalMap", i.normalTexture)), r.normalScale = new Se(1, 1), i.normalTexture.scale !== void 0)) {
      const h = i.normalTexture.scale;
      r.normalScale.set(h, h);
    }
    return i.occlusionTexture !== void 0 && o !== yt && (c.push(t.assignTexture(r, "aoMap", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (r.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && o !== yt && (r.emissive = new ge().fromArray(i.emissiveFactor)), i.emissiveTexture !== void 0 && o !== yt && c.push(t.assignTexture(r, "emissiveMap", i.emissiveTexture, 3001)), Promise.all(c).then(function() {
      const h = new o(r);
      return i.name && (h.name = i.name), it(h, i), t.associations.set(h, { materials: e }), i.extensions && dt(n, h, i), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Gt.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, s = this.extensions, n = this.primitiveCache;
    function i(r) {
      return s[K.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(r, t).then(function(a) {
        return yn(a, r, t);
      });
    }
    const o = [];
    for (let r = 0, a = e.length; r < a; r++) {
      const c = e[r], u = Sr(c), h = n[u];
      if (h)
        o.push(h.promise);
      else {
        let p;
        c.extensions && c.extensions[K.KHR_DRACO_MESH_COMPRESSION] ? p = i(c) : p = yn(new $e(), c, t), n[u] = { primitive: c, promise: p }, o.push(p);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, s = this.json, n = this.extensions, i = s.meshes[e], o = i.primitives, r = [];
    for (let a = 0, c = o.length; a < c; a++) {
      const u = o[a].material === void 0 ? Ar(this.cache) : this.getDependency("material", o[a].material);
      r.push(u);
    }
    return r.push(t.loadGeometries(o)), Promise.all(r).then(function(a) {
      const c = a.slice(0, a.length - 1), u = a[a.length - 1], h = [];
      for (let d = 0, g = u.length; d < g; d++) {
        const m = u[d], T = o[d];
        let x;
        const S = c[d];
        if (T.mode === De.TRIANGLES || T.mode === De.TRIANGLE_STRIP || T.mode === De.TRIANGLE_FAN || T.mode === void 0)
          x = i.isSkinnedMesh === !0 ? new Gn(m, S) : new F(m, S), x.isSkinnedMesh === !0 && x.normalizeSkinWeights(), T.mode === De.TRIANGLE_STRIP ? x.geometry = pn(x.geometry, Fn) : T.mode === De.TRIANGLE_FAN && (x.geometry = pn(x.geometry, Is));
        else if (T.mode === De.LINES)
          x = new Qi(m, S);
        else if (T.mode === De.LINE_STRIP)
          x = new q(m, S);
        else if (T.mode === De.LINE_LOOP)
          x = new $i(m, S);
        else if (T.mode === De.POINTS)
          x = new Wi(m, S);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + T.mode);
        Object.keys(x.geometry.morphAttributes).length > 0 && br(x, i), x.name = t.createUniqueName(i.name || "mesh_" + e), it(x, i), T.extensions && dt(n, x, T), t.assignFinalMaterial(x), h.push(x);
      }
      for (let d = 0, g = h.length; d < g; d++)
        t.associations.set(h[d], {
          meshes: e,
          primitives: d
        });
      if (h.length === 1)
        return i.extensions && dt(n, h[0], i), h[0];
      const p = new Nt();
      i.extensions && dt(n, p, i), t.associations.set(p, { meshes: e });
      for (let d = 0, g = h.length; d < g; d++)
        p.add(h[d]);
      return p;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const s = this.json.cameras[e], n = s[s.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return s.type === "perspective" ? t = new Bt(
      Oe.radToDeg(n.yfov),
      n.aspectRatio || 1,
      n.znear || 1,
      n.zfar || 2e6
    ) : s.type === "orthographic" && (t = new St(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), s.name && (t.name = this.createUniqueName(s.name)), it(t, s), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], s = [];
    for (let n = 0, i = t.joints.length; n < i; n++)
      s.push(this._loadNodeShallow(t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? s.push(this.getDependency("accessor", t.inverseBindMatrices)) : s.push(null), Promise.all(s).then(function(n) {
      const i = n.pop(), o = n, r = [], a = [];
      for (let c = 0, u = o.length; c < u; c++) {
        const h = o[c];
        if (h) {
          r.push(h);
          const p = new re();
          i !== null && p.fromArray(i.array, c * 16), a.push(p);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new Yn(r, a);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const s = this.json.animations[e], n = s.name ? s.name : "animation_" + e, i = [], o = [], r = [], a = [], c = [];
    for (let u = 0, h = s.channels.length; u < h; u++) {
      const p = s.channels[u], d = s.samplers[p.sampler], g = p.target, m = g.node, T = s.parameters !== void 0 ? s.parameters[d.input] : d.input, x = s.parameters !== void 0 ? s.parameters[d.output] : d.output;
      g.node !== void 0 && (i.push(this.getDependency("node", m)), o.push(this.getDependency("accessor", T)), r.push(this.getDependency("accessor", x)), a.push(d), c.push(g));
    }
    return Promise.all([
      Promise.all(i),
      Promise.all(o),
      Promise.all(r),
      Promise.all(a),
      Promise.all(c)
    ]).then(function(u) {
      const h = u[0], p = u[1], d = u[2], g = u[3], m = u[4], T = [];
      for (let x = 0, S = h.length; x < S; x++) {
        const E = h[x], f = p[x], v = d[x], w = g[x], _ = m[x];
        if (E === void 0)
          continue;
        E.updateMatrix();
        let y;
        switch (et[_.path]) {
          case et.weights:
            y = Kn;
            break;
          case et.rotation:
            y = Us;
            break;
          case et.position:
          case et.scale:
          default:
            y = Zn;
            break;
        }
        const L = E.name ? E.name : E.uuid, D = w.interpolation !== void 0 ? wr[w.interpolation] : Xn, R = [];
        et[_.path] === et.weights ? E.traverse(function(X) {
          X.morphTargetInfluences && R.push(X.name ? X.name : X.uuid);
        }) : R.push(L);
        let k = v.array;
        if (v.normalized) {
          const X = Vs(k.constructor), se = new Float32Array(k.length);
          for (let V = 0, ae = k.length; V < ae; V++)
            se[V] = k[V] * X;
          k = se;
        }
        for (let X = 0, se = R.length; X < se; X++) {
          const V = new y(
            R[X] + "." + et[_.path],
            f.array,
            k,
            D
          );
          w.interpolation === "CUBICSPLINE" && (V.createInterpolant = function(j) {
            const _e = this instanceof Us ? Er : ri;
            return new _e(this.times, this.values, this.getValueSize() / 3, j);
          }, V.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), T.push(V);
        }
      }
      return new jn(n, void 0, T);
    });
  }
  createNodeMesh(e) {
    const t = this.json, s = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : s.getDependency("mesh", n.mesh).then(function(i) {
      const o = s._getNodeRef(s.meshCache, n.mesh, i);
      return n.weights !== void 0 && o.traverse(function(r) {
        if (r.isMesh)
          for (let a = 0, c = n.weights.length; a < c; a++)
            r.morphTargetInfluences[a] = n.weights[a];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, s = this, n = t.nodes[e], i = s._loadNodeShallow(e), o = [], r = n.children || [];
    for (let c = 0, u = r.length; c < u; c++)
      o.push(s.getDependency("node", r[c]));
    const a = n.skin === void 0 ? Promise.resolve(null) : s.getDependency("skin", n.skin);
    return Promise.all([i, Promise.all(o), a]).then(function(c) {
      const u = c[0], h = c[1], p = c[2];
      p !== null && u.traverse(function(d) {
        d.isSkinnedMesh && d.bind(p, Or);
      });
      for (let d = 0, g = h.length; d < g; d++)
        u.add(h[d]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, s = this.extensions, n = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const i = t.nodes[e], o = i.name ? n.createUniqueName(i.name) : "", r = [], a = n._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return a && r.push(a), i.camera !== void 0 && r.push(
      n.getDependency("camera", i.camera).then(function(c) {
        return n._getNodeRef(n.cameraCache, i.camera, c);
      })
    ), n._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      r.push(c);
    }), this.nodeCache[e] = Promise.all(r).then(function(c) {
      let u;
      if (i.isBone === !0 ? u = new ks() : c.length > 1 ? u = new Nt() : c.length === 1 ? u = c[0] : u = new rt(), u !== c[0])
        for (let h = 0, p = c.length; h < p; h++)
          u.add(c[h]);
      if (i.name && (u.userData.name = i.name, u.name = o), it(u, i), i.extensions && dt(s, u, i), i.matrix !== void 0) {
        const h = new re();
        h.fromArray(i.matrix), u.applyMatrix4(h);
      } else
        i.translation !== void 0 && u.position.fromArray(i.translation), i.rotation !== void 0 && u.quaternion.fromArray(i.rotation), i.scale !== void 0 && u.scale.fromArray(i.scale);
      return n.associations.has(u) || n.associations.set(u, {}), n.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, s = this.json.scenes[e], n = this, i = new Nt();
    s.name && (i.name = n.createUniqueName(s.name)), it(i, s), s.extensions && dt(t, i, s);
    const o = s.nodes || [], r = [];
    for (let a = 0, c = o.length; a < c; a++)
      r.push(n.getDependency("node", o[a]));
    return Promise.all(r).then(function(a) {
      for (let u = 0, h = a.length; u < h; u++)
        i.add(a[u]);
      const c = (u) => {
        const h = /* @__PURE__ */ new Map();
        for (const [p, d] of n.associations)
          (p instanceof fs || p instanceof as) && h.set(p, d);
        return u.traverse((p) => {
          const d = n.associations.get(p);
          d != null && h.set(p, d);
        }), h;
      };
      return n.associations = c(i), i;
    });
  }
}
function Pr(l, e, t) {
  const s = e.attributes, n = new Qn();
  if (s.POSITION !== void 0) {
    const r = t.json.accessors[s.POSITION], a = r.min, c = r.max;
    if (a !== void 0 && c !== void 0) {
      if (n.set(new C(a[0], a[1], a[2]), new C(c[0], c[1], c[2])), r.normalized) {
        const u = Vs(Mt[r.componentType]);
        n.min.multiplyScalar(u), n.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const i = e.targets;
  if (i !== void 0) {
    const r = new C(), a = new C();
    for (let c = 0, u = i.length; c < u; c++) {
      const h = i[c];
      if (h.POSITION !== void 0) {
        const p = t.json.accessors[h.POSITION], d = p.min, g = p.max;
        if (d !== void 0 && g !== void 0) {
          if (a.setX(Math.max(Math.abs(d[0]), Math.abs(g[0]))), a.setY(Math.max(Math.abs(d[1]), Math.abs(g[1]))), a.setZ(Math.max(Math.abs(d[2]), Math.abs(g[2]))), p.normalized) {
            const m = Vs(Mt[p.componentType]);
            a.multiplyScalar(m);
          }
          r.max(a);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(r);
  }
  l.boundingBox = n;
  const o = new $n();
  n.getCenter(o.center), o.radius = n.min.distanceTo(n.max) / 2, l.boundingSphere = o;
}
function yn(l, e, t) {
  const s = e.attributes, n = [];
  function i(o, r) {
    return t.getDependency("accessor", o).then(function(a) {
      l.setAttribute(r, a);
    });
  }
  for (const o in s) {
    const r = Hs[o] || o.toLowerCase();
    r in l.attributes || n.push(i(s[o], r));
  }
  if (e.indices !== void 0 && !l.index) {
    const o = t.getDependency("accessor", e.indices).then(function(r) {
      l.setIndex(r);
    });
    n.push(o);
  }
  return it(l, e), Pr(l, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? xr(l, e.targets, t) : l;
  });
}
class vn extends ro {
  constructor(e, t = {}) {
    const {
      bevelEnabled: s = !1,
      bevelSize: n = 8,
      bevelThickness: i = 10,
      font: o,
      height: r = 50,
      size: a = 100,
      lineHeight: c = 1,
      letterSpacing: u = 0,
      ...h
    } = t;
    if (o === void 0)
      super();
    else {
      const p = o.generateShapes(e, a, { lineHeight: c, letterSpacing: u });
      super(p, { ...h, bevelEnabled: s, bevelSize: n, bevelThickness: i, depth: r });
    }
    this.type = "TextGeometry";
  }
}
const Rr = {
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
  )
}, Dr = {
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `
  ),
  fragmentShader: (
    /* glsl */
    `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
  )
};
function ai(l, e, t) {
  const s = t.length - l - 1;
  if (e >= t[s])
    return s - 1;
  if (e <= t[l])
    return l;
  let n = l, i = s, o = Math.floor((n + i) / 2);
  for (; e < t[o] || e >= t[o + 1]; )
    e < t[o] ? i = o : n = o, o = Math.floor((n + i) / 2);
  return o;
}
function Ir(l, e, t, s) {
  const n = [], i = [], o = [];
  n[0] = 1;
  for (let r = 1; r <= t; ++r) {
    i[r] = e - s[l + 1 - r], o[r] = s[l + r] - e;
    let a = 0;
    for (let c = 0; c < r; ++c) {
      const u = o[c + 1], h = i[r - c], p = n[c] / (u + h);
      n[c] = a + u * p, a = h * p;
    }
    n[r] = a;
  }
  return n;
}
function Cr(l, e, t, s) {
  const n = ai(l, s, e), i = Ir(n, s, l, e), o = new Xt(0, 0, 0, 0);
  for (let r = 0; r <= l; ++r) {
    const a = t[n - l + r], c = i[r], u = a.w * c;
    o.x += a.x * u, o.y += a.y * u, o.z += a.z * u, o.w += a.w * c;
  }
  return o;
}
function kr(l, e, t, s, n) {
  const i = [];
  for (let h = 0; h <= t; ++h)
    i[h] = 0;
  const o = [];
  for (let h = 0; h <= s; ++h)
    o[h] = i.slice(0);
  const r = [];
  for (let h = 0; h <= t; ++h)
    r[h] = i.slice(0);
  r[0][0] = 1;
  const a = i.slice(0), c = i.slice(0);
  for (let h = 1; h <= t; ++h) {
    a[h] = e - n[l + 1 - h], c[h] = n[l + h] - e;
    let p = 0;
    for (let d = 0; d < h; ++d) {
      const g = c[d + 1], m = a[h - d];
      r[h][d] = g + m;
      const T = r[d][h - 1] / r[h][d];
      r[d][h] = p + g * T, p = m * T;
    }
    r[h][h] = p;
  }
  for (let h = 0; h <= t; ++h)
    o[0][h] = r[h][t];
  for (let h = 0; h <= t; ++h) {
    let p = 0, d = 1;
    const g = [];
    for (let m = 0; m <= t; ++m)
      g[m] = i.slice(0);
    g[0][0] = 1;
    for (let m = 1; m <= s; ++m) {
      let T = 0;
      const x = h - m, S = t - m;
      h >= m && (g[d][0] = g[p][0] / r[S + 1][x], T = g[d][0] * r[x][S]);
      const E = x >= -1 ? 1 : -x, f = h - 1 <= S ? m - 1 : t - h;
      for (let w = E; w <= f; ++w)
        g[d][w] = (g[p][w] - g[p][w - 1]) / r[S + 1][x + w], T += g[d][w] * r[x + w][S];
      h <= S && (g[d][m] = -g[p][m - 1] / r[S + 1][h], T += g[d][m] * r[h][S]), o[m][h] = T;
      const v = p;
      p = d, d = v;
    }
  }
  let u = t;
  for (let h = 1; h <= s; ++h) {
    for (let p = 0; p <= t; ++p)
      o[h][p] *= u;
    u *= t - h;
  }
  return o;
}
function Fr(l, e, t, s, n) {
  const i = n < l ? n : l, o = [], r = ai(l, s, e), a = kr(r, s, l, i, e), c = [];
  for (let u = 0; u < t.length; ++u) {
    const h = t[u].clone(), p = h.w;
    h.x *= p, h.y *= p, h.z *= p, c[u] = h;
  }
  for (let u = 0; u <= i; ++u) {
    const h = c[r - l].clone().multiplyScalar(a[u][0]);
    for (let p = 1; p <= l; ++p)
      h.add(c[r - l + p].clone().multiplyScalar(a[u][p]));
    o[u] = h;
  }
  for (let u = i + 1; u <= n + 1; ++u)
    o[u] = new Xt(0, 0, 0);
  return o;
}
function Ur(l, e) {
  let t = 1;
  for (let n = 2; n <= l; ++n)
    t *= n;
  let s = 1;
  for (let n = 2; n <= e; ++n)
    s *= n;
  for (let n = 2; n <= l - e; ++n)
    s *= n;
  return t / s;
}
function Br(l) {
  const e = l.length, t = [], s = [];
  for (let i = 0; i < e; ++i) {
    const o = l[i];
    t[i] = new C(o.x, o.y, o.z), s[i] = o.w;
  }
  const n = [];
  for (let i = 0; i < e; ++i) {
    const o = t[i].clone();
    for (let r = 1; r <= i; ++r)
      o.sub(n[i - r].clone().multiplyScalar(Ur(i, r) * s[r]));
    n[i] = o.divideScalar(s[0]);
  }
  return n;
}
function zr(l, e, t, s, n) {
  const i = Fr(l, e, t, s, n);
  return Br(i);
}
class Tn extends ao {
  constructor(e, t, s, n, i) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = i || this.knots.length - 1;
    for (let o = 0; o < s.length; ++o) {
      const r = s[o];
      this.controlPoints[o] = new Xt(r.x, r.y, r.z, r.w);
    }
  }
  getPoint(e, t) {
    const s = t || new C(), n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = Cr(this.degree, this.knots, this.controlPoints, n);
    return i.w != 1 && i.divideScalar(i.w), s.set(i.x, i.y, i.z);
  }
  getTangent(e, t) {
    const s = t || new C(), n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = zr(this.degree, this.knots, this.controlPoints, n, 1);
    return s.copy(i[1]).normalize(), s;
  }
}
let Z, me, xe;
class Nr extends cs {
  constructor(e) {
    super(e);
  }
  load(e, t, s, n) {
    const i = this, o = i.path === "" ? Xe.extractUrlBase(e) : i.path, r = new Ot(this.manager);
    r.setPath(i.path), r.setResponseType("arraybuffer"), r.setRequestHeader(i.requestHeader), r.setWithCredentials(i.withCredentials), r.load(
      e,
      function(a) {
        try {
          t(i.parse(a, o));
        } catch (c) {
          n ? n(c) : console.error(c), i.manager.itemError(e);
        }
      },
      s,
      n
    );
  }
  parse(e, t) {
    if (jr(e))
      Z = new Xr().parse(e);
    else {
      const n = ui(e);
      if (!Zr(n))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (wn(n) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + wn(n));
      Z = new Yr().parse(n);
    }
    const s = new Hn(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new Hr(s, this.manager).parse(Z);
  }
}
class Hr {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    me = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), s = this.parseMaterials(t), n = this.parseDeformers(), i = new Vr().parse(n);
    return this.parseScene(n, i, s), xe;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in Z && Z.Connections.connections.forEach(function(s) {
      const n = s[0], i = s[1], o = s[2];
      e.has(n) || e.set(n, {
        parents: [],
        children: []
      });
      const r = { ID: i, relationship: o };
      e.get(n).parents.push(r), e.has(i) || e.set(i, {
        parents: [],
        children: []
      });
      const a = { ID: n, relationship: o };
      e.get(i).children.push(a);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in Z.Objects) {
      const s = Z.Objects.Video;
      for (const n in s) {
        const i = s[n], o = parseInt(n);
        if (e[o] = i.RelativeFilename || i.Filename, "Content" in i) {
          const r = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, a = typeof i.Content == "string" && i.Content !== "";
          if (r || a) {
            const c = this.parseImage(s[n]);
            t[i.RelativeFilename || i.Filename] = c;
          }
        }
      }
    }
    for (const s in e) {
      const n = e[s];
      t[n] !== void 0 ? e[s] = t[n] : e[s] = e[s].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, s = e.RelativeFilename || e.Filename, n = s.slice(s.lastIndexOf(".") + 1).toLowerCase();
    let i;
    switch (n) {
      case "bmp":
        i = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        i = "image/jpeg";
        break;
      case "png":
        i = "image/png";
        break;
      case "tif":
        i = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", s), i = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + n + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + i + ";base64," + t;
    {
      const o = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([o], { type: i }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in Z.Objects) {
      const s = Z.Objects.Texture;
      for (const n in s) {
        const i = this.parseTexture(s[n], e);
        t.set(parseInt(n), i);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const s = this.loadTexture(e, t);
    s.ID = e.id, s.name = e.attrName;
    const n = e.WrapModeU, i = e.WrapModeV, o = n !== void 0 ? n.value : 0, r = i !== void 0 ? i.value : 0;
    if (s.wrapS = o === 0 ? Vt : Fs, s.wrapT = r === 0 ? Vt : Fs, "Scaling" in e) {
      const a = e.Scaling.value;
      s.repeat.x = a[0], s.repeat.y = a[1];
    }
    return s;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let s;
    const n = this.textureLoader.path, i = me.get(e.id).children;
    i !== void 0 && i.length > 0 && t[i[0].ID] !== void 0 && (s = t[i[0].ID], (s.indexOf("blob:") === 0 || s.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let o;
    const r = e.FileName.slice(-3).toLowerCase();
    if (r === "tga") {
      const a = this.manager.getHandler(".tga");
      a === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new as()) : (a.setPath(this.textureLoader.path), o = a.load(s));
    } else
      r === "psd" ? (console.warn(
        "FBXLoader: PSD textures are not supported, creating placeholder texture for",
        e.RelativeFilename
      ), o = new as()) : o = this.textureLoader.load(s);
    return this.textureLoader.setPath(n), o;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in Z.Objects) {
      const s = Z.Objects.Material;
      for (const n in s) {
        const i = this.parseMaterial(s[n], e);
        i !== null && t.set(parseInt(n), i);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const s = e.id, n = e.attrName;
    let i = e.ShadingModel;
    if (typeof i == "object" && (i = i.value), !me.has(s))
      return null;
    const o = this.parseParameters(e, t, s);
    let r;
    switch (i.toLowerCase()) {
      case "phong":
        r = new ms();
        break;
      case "lambert":
        r = new lo();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), r = new ms();
        break;
    }
    return r.setValues(o), r.name = n, r;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, s) {
    const n = {};
    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = new ge().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = new ge().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = new ge().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = new ge().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = new ge().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = new ge().fromArray(e.SpecularColor.value));
    const i = this;
    return me.get(s).children.forEach(function(o) {
      const r = o.relationship;
      switch (r) {
        case "Bump":
          n.bumpMap = i.getTexture(t, o.ID);
          break;
        case "Maya|TEX_ao_map":
          n.aoMap = i.getTexture(t, o.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n.map = i.getTexture(t, o.ID), n.map !== void 0 && ("colorSpace" in n.map ? n.map.colorSpace = "srgb" : n.map.encoding = 3001);
          break;
        case "DisplacementColor":
          n.displacementMap = i.getTexture(t, o.ID);
          break;
        case "EmissiveColor":
          n.emissiveMap = i.getTexture(t, o.ID), n.emissiveMap !== void 0 && ("colorSpace" in n.emissiveMap ? n.emissiveMap.colorSpace = "srgb" : n.emissiveMap.encoding = 3001);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n.normalMap = i.getTexture(t, o.ID);
          break;
        case "ReflectionColor":
          n.envMap = i.getTexture(t, o.ID), n.envMap !== void 0 && (n.envMap.mapping = Wn, "colorSpace" in n.envMap ? n.envMap.colorSpace = "srgb" : n.envMap.encoding = 3001);
          break;
        case "SpecularColor":
          n.specularMap = i.getTexture(t, o.ID), n.specularMap !== void 0 && ("colorSpace" in n.specularMap ? n.specularMap.colorSpace = "srgb" : n.specularMap.encoding = 3001);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n.alphaMap = i.getTexture(t, o.ID), n.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", r);
          break;
      }
    }), n;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in Z.Objects && t in Z.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = me.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in Z.Objects) {
      const s = Z.Objects.Deformer;
      for (const n in s) {
        const i = s[n], o = me.get(parseInt(n));
        if (i.attrType === "Skin") {
          const r = this.parseSkeleton(o, s);
          r.ID = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), r.geometryID = o.parents[0].ID, e[n] = r;
        } else if (i.attrType === "BlendShape") {
          const r = {
            id: n
          };
          r.rawTargets = this.parseMorphTargets(o, s), r.id = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = r;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const s = [];
    return e.children.forEach(function(n) {
      const i = t[n.ID];
      if (i.attrType !== "Cluster")
        return;
      const o = {
        ID: n.ID,
        indices: [],
        weights: [],
        transformLink: new re().fromArray(i.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in i && (o.indices = i.Indexes.a, o.weights = i.Weights.a), s.push(o);
    }), {
      rawBones: s,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const s = [];
    for (let n = 0; n < e.children.length; n++) {
      const i = e.children[n], o = t[i.ID], r = {
        name: o.attrName,
        initialWeight: o.DeformPercent,
        id: o.id,
        fullWeights: o.FullWeights.a
      };
      if (o.attrType !== "BlendShapeChannel")
        return;
      r.geoID = me.get(parseInt(i.ID)).children.filter(function(a) {
        return a.relationship === void 0;
      })[0].ID, s.push(r);
    }
    return s;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, s) {
    xe = new Nt();
    const n = this.parseModels(e.skeletons, t, s), i = Z.Objects.Model, o = this;
    n.forEach(function(a) {
      const c = i[a.ID];
      o.setLookAtProperties(a, c), me.get(a.ID).parents.forEach(function(h) {
        const p = n.get(h.ID);
        p !== void 0 && p.add(a);
      }), a.parent === null && xe.add(a);
    }), this.bindSkeleton(e.skeletons, t, n), this.createAmbientLight(), xe.traverse(function(a) {
      if (a.userData.transformData) {
        a.parent && (a.userData.transformData.parentMatrix = a.parent.matrix, a.userData.transformData.parentMatrixWorld = a.parent.matrixWorld);
        const c = ci(a.userData.transformData);
        a.applyMatrix4(c), a.updateWorldMatrix();
      }
    });
    const r = new Gr().parse();
    xe.children.length === 1 && xe.children[0].isGroup && (xe.children[0].animations = r, xe = xe.children[0]), xe.animations = r;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, s) {
    const n = /* @__PURE__ */ new Map(), i = Z.Objects.Model;
    for (const o in i) {
      const r = parseInt(o), a = i[o], c = me.get(r);
      let u = this.buildSkeleton(c, e, r, a.attrName);
      if (!u) {
        switch (a.attrType) {
          case "Camera":
            u = this.createCamera(c);
            break;
          case "Light":
            u = this.createLight(c);
            break;
          case "Mesh":
            u = this.createMesh(c, t, s);
            break;
          case "NurbsCurve":
            u = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            u = new ks();
            break;
          case "Null":
          default:
            u = new Nt();
            break;
        }
        u.name = a.attrName ? Gt.sanitizeNodeName(a.attrName) : "", u.ID = r;
      }
      this.getTransformData(u, a), n.set(r, u);
    }
    return n;
  }
  buildSkeleton(e, t, s, n) {
    let i = null;
    return e.parents.forEach(function(o) {
      for (const r in t) {
        const a = t[r];
        a.rawBones.forEach(function(c, u) {
          if (c.ID === o.ID) {
            const h = i;
            i = new ks(), i.matrixWorld.copy(c.transformLink), i.name = n ? Gt.sanitizeNodeName(n) : "", i.ID = s, a.bones[u] = i, h !== null && i.add(h);
          }
        });
      }
    }), i;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, s;
    if (e.children.forEach(function(n) {
      const i = Z.Objects.NodeAttribute[n.ID];
      i !== void 0 && (s = i);
    }), s === void 0)
      t = new rt();
    else {
      let n = 0;
      s.CameraProjectionType !== void 0 && s.CameraProjectionType.value === 1 && (n = 1);
      let i = 1;
      s.NearPlane !== void 0 && (i = s.NearPlane.value / 1e3);
      let o = 1e3;
      s.FarPlane !== void 0 && (o = s.FarPlane.value / 1e3);
      let r = window.innerWidth, a = window.innerHeight;
      s.AspectWidth !== void 0 && s.AspectHeight !== void 0 && (r = s.AspectWidth.value, a = s.AspectHeight.value);
      const c = r / a;
      let u = 45;
      s.FieldOfView !== void 0 && (u = s.FieldOfView.value);
      const h = s.FocalLength ? s.FocalLength.value : null;
      switch (n) {
        case 0:
          t = new Bt(u, c, i, o), h !== null && t.setFocalLength(h);
          break;
        case 1:
          t = new St(
            -r / 2,
            r / 2,
            a / 2,
            -a / 2,
            i,
            o
          );
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new rt();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, s;
    if (e.children.forEach(function(n) {
      const i = Z.Objects.NodeAttribute[n.ID];
      i !== void 0 && (s = i);
    }), s === void 0)
      t = new rt();
    else {
      let n;
      s.LightType === void 0 ? n = 0 : n = s.LightType.value;
      let i = 16777215;
      s.Color !== void 0 && (i = new ge().fromArray(s.Color.value));
      let o = s.Intensity === void 0 ? 1 : s.Intensity.value / 100;
      s.CastLightOnObject !== void 0 && s.CastLightOnObject.value === 0 && (o = 0);
      let r = 0;
      s.FarAttenuationEnd !== void 0 && (s.EnableFarAttenuation !== void 0 && s.EnableFarAttenuation.value === 0 ? r = 0 : r = s.FarAttenuationEnd.value);
      const a = 1;
      switch (n) {
        case 0:
          t = new Cs(i, o, r, a);
          break;
        case 1:
          t = new Nn(i, o);
          break;
        case 2:
          let c = Math.PI / 3;
          s.InnerAngle !== void 0 && (c = Oe.degToRad(s.InnerAngle.value));
          let u = 0;
          s.OuterAngle !== void 0 && (u = Oe.degToRad(s.OuterAngle.value), u = Math.max(u, 1)), t = new zn(i, o, r, c, u, a);
          break;
        default:
          console.warn(
            "THREE.FBXLoader: Unknown light type " + s.LightType.value + ", defaulting to a PointLight."
          ), t = new Cs(i, o);
          break;
      }
      s.CastShadows !== void 0 && s.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, s) {
    let n, i = null, o = null;
    const r = [];
    return e.children.forEach(function(a) {
      t.has(a.ID) && (i = t.get(a.ID)), s.has(a.ID) && r.push(s.get(a.ID));
    }), r.length > 1 ? o = r : r.length > 0 ? o = r[0] : (o = new ms({ color: 13421772 }), r.push(o)), "color" in i.attributes && r.forEach(function(a) {
      a.vertexColors = !0;
    }), i.FBX_Deformer ? (n = new Gn(i, o), n.normalizeSkinWeights()) : n = new F(i, o), n;
  }
  createCurve(e, t) {
    const s = e.children.reduce(function(i, o) {
      return t.has(o.ID) && (i = t.get(o.ID)), i;
    }, null), n = new js({ color: 3342591, linewidth: 1 });
    return new q(s, n);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const s = {};
    "InheritType" in t && (s.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? s.eulerOrder = hi(t.RotationOrder.value) : s.eulerOrder = "ZYX", "Lcl_Translation" in t && (s.translation = t.Lcl_Translation.value), "PreRotation" in t && (s.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (s.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (s.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (s.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (s.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (s.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (s.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (s.rotationPivot = t.RotationPivot.value), e.userData.transformData = s;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && me.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const i = Z.Objects.Model[n.ID];
        if ("Lcl_Translation" in i) {
          const o = i.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(o), xe.add(e.target)) : e.lookAt(new C().fromArray(o));
        }
      }
    });
  }
  bindSkeleton(e, t, s) {
    const n = this.parsePoseNodes();
    for (const i in e) {
      const o = e[i];
      me.get(parseInt(o.ID)).parents.forEach(function(a) {
        if (t.has(a.ID)) {
          const c = a.ID;
          me.get(c).parents.forEach(function(h) {
            s.has(h.ID) && s.get(h.ID).bind(new Yn(o.bones), n[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in Z.Objects) {
      const t = Z.Objects.Pose;
      for (const s in t)
        if (t[s].attrType === "BindPose" && t[s].NbPoseNodes > 0) {
          const n = t[s].PoseNode;
          Array.isArray(n) ? n.forEach(function(i) {
            e[i.Node] = new re().fromArray(i.Matrix.a);
          }) : e[n.Node] = new re().fromArray(n.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in Z && "AmbientColor" in Z.GlobalSettings) {
      const e = Z.GlobalSettings.AmbientColor.value, t = e[0], s = e[1], n = e[2];
      if (t !== 0 || s !== 0 || n !== 0) {
        const i = new ge(t, s, n);
        xe.add(new co(i, 1));
      }
    }
  }
}
class Vr {
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in Z.Objects) {
      const s = Z.Objects.Geometry;
      for (const n in s) {
        const i = me.get(parseInt(n)), o = this.parseGeometry(i, s[n], e);
        t.set(parseInt(n), o);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, s) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, s);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, s) {
    const n = s.skeletons, i = [], o = e.parents.map(function(h) {
      return Z.Objects.Model[h.ID];
    });
    if (o.length === 0)
      return;
    const r = e.children.reduce(function(h, p) {
      return n[p.ID] !== void 0 && (h = n[p.ID]), h;
    }, null);
    e.children.forEach(function(h) {
      s.morphTargets[h.ID] !== void 0 && i.push(s.morphTargets[h.ID]);
    });
    const a = o[0], c = {};
    "RotationOrder" in a && (c.eulerOrder = hi(a.RotationOrder.value)), "InheritType" in a && (c.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (c.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (c.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (c.scale = a.GeometricScaling.value);
    const u = ci(c);
    return this.genGeometry(t, r, i, u);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, s, n) {
    const i = new $e();
    e.attrName && (i.name = e.attrName);
    const o = this.parseGeoNode(e, t), r = this.genBuffers(o), a = new Qe(r.vertex, 3);
    if (a.applyMatrix4(n), i.setAttribute("position", a), r.colors.length > 0 && i.setAttribute("color", new Qe(r.colors, 3)), t && (i.setAttribute("skinIndex", new ho(r.weightsIndices, 4)), i.setAttribute("skinWeight", new Qe(r.vertexWeights, 4)), i.FBX_Deformer = t), r.normal.length > 0) {
      const c = new uo().getNormalMatrix(n), u = new Qe(r.normal, 3);
      u.applyNormalMatrix(c), i.setAttribute("normal", u);
    }
    if (r.uvs.forEach(function(c, u) {
      let h = "uv" + (u + 1).toString();
      u === 0 && (h = "uv"), i.setAttribute(h, new Qe(r.uvs[u], 2));
    }), o.material && o.material.mappingType !== "AllSame") {
      let c = r.materialIndex[0], u = 0;
      if (r.materialIndex.forEach(function(h, p) {
        h !== c && (i.addGroup(u, p - u, c), c = h, u = p);
      }), i.groups.length > 0) {
        const h = i.groups[i.groups.length - 1], p = h.start + h.count;
        p !== r.materialIndex.length && i.addGroup(p, r.materialIndex.length - p, c);
      }
      i.groups.length === 0 && i.addGroup(0, r.materialIndex.length, r.materialIndex[0]);
    }
    return this.addMorphTargets(i, e, s, n), i;
  }
  parseGeoNode(e, t) {
    const s = {};
    if (s.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], s.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (s.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (s.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (s.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      s.uv = [];
      let n = 0;
      for (; e.LayerElementUV[n]; )
        e.LayerElementUV[n].UV && s.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
    }
    return s.weightTable = {}, t !== null && (s.skeleton = t, t.rawBones.forEach(function(n, i) {
      n.indices.forEach(function(o, r) {
        s.weightTable[o] === void 0 && (s.weightTable[o] = []), s.weightTable[o].push({
          id: i,
          weight: n.weights[r]
        });
      });
    })), s;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let s = 0, n = 0, i = !1, o = [], r = [], a = [], c = [], u = [], h = [];
    const p = this;
    return e.vertexIndices.forEach(function(d, g) {
      let m, T = !1;
      d < 0 && (d = d ^ -1, T = !0);
      let x = [], S = [];
      if (o.push(d * 3, d * 3 + 1, d * 3 + 2), e.color) {
        const E = qt(g, s, d, e.color);
        a.push(E[0], E[1], E[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[d] !== void 0 && e.weightTable[d].forEach(function(E) {
          S.push(E.weight), x.push(E.id);
        }), S.length > 4) {
          i || (console.warn(
            "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
          ), i = !0);
          const E = [0, 0, 0, 0], f = [0, 0, 0, 0];
          S.forEach(function(v, w) {
            let _ = v, y = x[w];
            f.forEach(function(L, D, R) {
              if (_ > L) {
                R[D] = _, _ = L;
                const k = E[D];
                E[D] = y, y = k;
              }
            });
          }), x = E, S = f;
        }
        for (; S.length < 4; )
          S.push(0), x.push(0);
        for (let E = 0; E < 4; ++E)
          u.push(S[E]), h.push(x[E]);
      }
      if (e.normal) {
        const E = qt(g, s, d, e.normal);
        r.push(E[0], E[1], E[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (m = qt(g, s, d, e.material)[0]), e.uv && e.uv.forEach(function(E, f) {
        const v = qt(g, s, d, E);
        c[f] === void 0 && (c[f] = []), c[f].push(v[0]), c[f].push(v[1]);
      }), n++, T && (p.genFace(
        t,
        e,
        o,
        m,
        r,
        a,
        c,
        u,
        h,
        n
      ), s++, n = 0, o = [], r = [], a = [], c = [], u = [], h = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, s, n, i, o, r, a, c, u) {
    for (let h = 2; h < u; h++)
      e.vertex.push(t.vertexPositions[s[0]]), e.vertex.push(t.vertexPositions[s[1]]), e.vertex.push(t.vertexPositions[s[2]]), e.vertex.push(t.vertexPositions[s[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[s[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[s[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[s[h * 3]]), e.vertex.push(t.vertexPositions[s[h * 3 + 1]]), e.vertex.push(t.vertexPositions[s[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(a[0]), e.vertexWeights.push(a[1]), e.vertexWeights.push(a[2]), e.vertexWeights.push(a[3]), e.vertexWeights.push(a[(h - 1) * 4]), e.vertexWeights.push(a[(h - 1) * 4 + 1]), e.vertexWeights.push(a[(h - 1) * 4 + 2]), e.vertexWeights.push(a[(h - 1) * 4 + 3]), e.vertexWeights.push(a[h * 4]), e.vertexWeights.push(a[h * 4 + 1]), e.vertexWeights.push(a[h * 4 + 2]), e.vertexWeights.push(a[h * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(h - 1) * 4]), e.weightsIndices.push(c[(h - 1) * 4 + 1]), e.weightsIndices.push(c[(h - 1) * 4 + 2]), e.weightsIndices.push(c[(h - 1) * 4 + 3]), e.weightsIndices.push(c[h * 4]), e.weightsIndices.push(c[h * 4 + 1]), e.weightsIndices.push(c[h * 4 + 2]), e.weightsIndices.push(c[h * 4 + 3])), t.color && (e.colors.push(o[0]), e.colors.push(o[1]), e.colors.push(o[2]), e.colors.push(o[(h - 1) * 3]), e.colors.push(o[(h - 1) * 3 + 1]), e.colors.push(o[(h - 1) * 3 + 2]), e.colors.push(o[h * 3]), e.colors.push(o[h * 3 + 1]), e.colors.push(o[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[(h - 1) * 3]), e.normal.push(i[(h - 1) * 3 + 1]), e.normal.push(i[(h - 1) * 3 + 2]), e.normal.push(i[h * 3]), e.normal.push(i[h * 3 + 1]), e.normal.push(i[h * 3 + 2])), t.uv && t.uv.forEach(function(p, d) {
        e.uvs[d] === void 0 && (e.uvs[d] = []), e.uvs[d].push(r[d][0]), e.uvs[d].push(r[d][1]), e.uvs[d].push(r[d][(h - 1) * 2]), e.uvs[d].push(r[d][(h - 1) * 2 + 1]), e.uvs[d].push(r[d][h * 2]), e.uvs[d].push(r[d][h * 2 + 1]);
      });
  }
  addMorphTargets(e, t, s, n) {
    if (s.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const i = this;
    s.forEach(function(o) {
      o.rawTargets.forEach(function(r) {
        const a = Z.Objects.Geometry[r.geoID];
        a !== void 0 && i.genMorphGeometry(e, t, a, n, r.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, s, n, i) {
    const o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], r = s.Vertices !== void 0 ? s.Vertices.a : [], a = s.Indexes !== void 0 ? s.Indexes.a : [], c = e.attributes.position.count * 3, u = new Float32Array(c);
    for (let g = 0; g < a.length; g++) {
      const m = a[g] * 3;
      u[m] = r[g * 3], u[m + 1] = r[g * 3 + 1], u[m + 2] = r[g * 3 + 2];
    }
    const h = {
      vertexIndices: o,
      vertexPositions: u
    }, p = this.genBuffers(h), d = new Qe(p.vertex, 3);
    d.name = i || s.attrName, d.applyMatrix4(n), e.morphAttributes.position.push(d);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.Normals.a;
    let i = [];
    return s === "IndexToDirect" && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.UV.a;
    let i = [];
    return s === "IndexToDirect" && (i = e.UVIndex.a), {
      dataSize: 2,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.Colors.a;
    let i = [];
    return s === "IndexToDirect" && (i = e.ColorIndex.a), {
      dataSize: 4,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: s
      };
    const n = e.Materials.a, i = [];
    for (let o = 0; o < n.length; ++o)
      i.push(o);
    return {
      dataSize: 1,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    if (Tn === void 0)
      return console.error(
        "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
      ), new $e();
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new $e();
    const s = t - 1, n = e.KnotVector.a, i = [], o = e.Points.a;
    for (let h = 0, p = o.length; h < p; h += 4)
      i.push(new Xt().fromArray(o, h));
    let r, a;
    if (e.Form === "Closed")
      i.push(i[0]);
    else if (e.Form === "Periodic") {
      r = s, a = n.length - 1 - r;
      for (let h = 0; h < s; ++h)
        i.push(i[h]);
    }
    const u = new Tn(s, n, i, r, a).getPoints(i.length * 12);
    return new $e().setFromPoints(u);
  }
}
class Gr {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const s in t) {
        const n = t[s], i = this.addClip(n);
        e.push(i);
      }
    return e;
  }
  parseClips() {
    if (Z.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = Z.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const s in e) {
      const n = e[s];
      if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const i = {
          id: n.id,
          attr: n.attrName,
          curves: {}
        };
        t.set(i.id, i);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = Z.Objects.AnimationCurve;
    for (const s in t) {
      const n = {
        id: t[s].id,
        times: t[s].KeyTime.a.map(Kr),
        values: t[s].KeyValueFloat.a
      }, i = me.get(n.id);
      if (i !== void 0) {
        const o = i.parents[0].ID, r = i.parents[0].relationship;
        r.match(/X/) ? e.get(o).curves.x = n : r.match(/Y/) ? e.get(o).curves.y = n : r.match(/Z/) ? e.get(o).curves.z = n : r.match(/d|DeformPercent/) && e.has(o) && (e.get(o).curves.morph = n);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = Z.Objects.AnimationLayer, s = /* @__PURE__ */ new Map();
    for (const n in t) {
      const i = [], o = me.get(parseInt(n));
      o !== void 0 && (o.children.forEach(function(a, c) {
        if (e.has(a.ID)) {
          const u = e.get(a.ID);
          if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
            if (i[c] === void 0) {
              const h = me.get(a.ID).parents.filter(function(p) {
                return p.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const p = Z.Objects.Model[h.toString()];
                if (p === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", a);
                  return;
                }
                const d = {
                  modelName: p.attrName ? Gt.sanitizeNodeName(p.attrName) : "",
                  ID: p.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                xe.traverse(function(g) {
                  g.ID === p.id && (d.transform = g.matrix, g.userData.transformData && (d.eulerOrder = g.userData.transformData.eulerOrder));
                }), d.transform || (d.transform = new re()), "PreRotation" in p && (d.preRotation = p.PreRotation.value), "PostRotation" in p && (d.postRotation = p.PostRotation.value), i[c] = d;
              }
            }
            i[c] && (i[c][u.attr] = u);
          } else if (u.curves.morph !== void 0) {
            if (i[c] === void 0) {
              const h = me.get(a.ID).parents.filter(function(x) {
                return x.relationship !== void 0;
              })[0].ID, p = me.get(h).parents[0].ID, d = me.get(p).parents[0].ID, g = me.get(d).parents[0].ID, m = Z.Objects.Model[g], T = {
                modelName: m.attrName ? Gt.sanitizeNodeName(m.attrName) : "",
                morphName: Z.Objects.Deformer[h].attrName
              };
              i[c] = T;
            }
            i[c][u.attr] = u;
          }
        }
      }), s.set(parseInt(n), i));
    }
    return s;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = Z.Objects.AnimationStack, s = {};
    for (const n in t) {
      const i = me.get(parseInt(n)).children;
      i.length > 1 && console.warn(
        "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
      );
      const o = e.get(i[0].ID);
      s[n] = {
        name: t[n].attrName,
        layer: o
      };
    }
    return s;
  }
  addClip(e) {
    let t = [];
    const s = this;
    return e.layer.forEach(function(n) {
      t = t.concat(s.generateTracks(n));
    }), new jn(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let s = new C(), n = new ce(), i = new C();
    if (e.transform && e.transform.decompose(s, n, i), s = s.toArray(), n = new _t().setFromQuaternion(n, e.eulerOrder).toArray(), i = i.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const o = this.generateVectorTrack(
        e.modelName,
        e.T.curves,
        s,
        "position"
      );
      o !== void 0 && t.push(o);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const o = this.generateRotationTrack(
        e.modelName,
        e.R.curves,
        n,
        e.preRotation,
        e.postRotation,
        e.eulerOrder
      );
      o !== void 0 && t.push(o);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.S.curves, i, "scale");
      o !== void 0 && t.push(o);
    }
    if (e.DeformPercent !== void 0) {
      const o = this.generateMorphTrack(e);
      o !== void 0 && t.push(o);
    }
    return t;
  }
  generateVectorTrack(e, t, s, n) {
    const i = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(i, t, s);
    return new Zn(e + "." + n, i, o);
  }
  generateRotationTrack(e, t, s, n, i, o) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Oe.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Oe.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Oe.degToRad));
    const r = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(r, t, s);
    n !== void 0 && (n = n.map(Oe.degToRad), n.push(o), n = new _t().fromArray(n), n = new ce().setFromEuler(n)), i !== void 0 && (i = i.map(Oe.degToRad), i.push(o), i = new _t().fromArray(i), i = new ce().setFromEuler(i).invert());
    const c = new ce(), u = new _t(), h = [];
    for (let p = 0; p < a.length; p += 3)
      u.set(a[p], a[p + 1], a[p + 2], o), c.setFromEuler(u), n !== void 0 && c.premultiply(n), i !== void 0 && c.multiply(i), c.toArray(h, p / 3 * 4);
    return new Us(e + ".quaternion", r, h);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, s = t.values.map(function(i) {
      return i / 100;
    }), n = xe.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new Kn(
      e.modelName + ".morphTargetInfluences[" + n + "]",
      t.times,
      s
    );
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(s, n) {
      return s - n;
    }), t.length > 1) {
      let s = 1, n = t[0];
      for (let i = 1; i < t.length; i++) {
        const o = t[i];
        o !== n && (t[s] = o, n = o, s++);
      }
      t = t.slice(0, s);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, s) {
    const n = s, i = [];
    let o = -1, r = -1, a = -1;
    return e.forEach(function(c) {
      if (t.x && (o = t.x.times.indexOf(c)), t.y && (r = t.y.times.indexOf(c)), t.z && (a = t.z.times.indexOf(c)), o !== -1) {
        const u = t.x.values[o];
        i.push(u), n[0] = u;
      } else
        i.push(n[0]);
      if (r !== -1) {
        const u = t.y.values[r];
        i.push(u), n[1] = u;
      } else
        i.push(n[1]);
      if (a !== -1) {
        const u = t.z.values[a];
        i.push(u), n[2] = u;
      } else
        i.push(n[2]);
    }), i;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const s = e.values[t - 1], n = e.values[t] - s, i = Math.abs(n);
      if (i >= 180) {
        const o = i / 180, r = n / o;
        let a = s + r;
        const c = e.times[t - 1], h = (e.times[t] - c) / o;
        let p = c + h;
        const d = [], g = [];
        for (; p < e.times[t]; )
          d.push(p), p += h, g.push(a), a += r;
        e.times = An(e.times, t, d), e.values = An(e.values, t, g);
      }
    }
  }
}
class Yr {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new li(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, s = e.split(/[\r\n]+/);
    return s.forEach(function(n, i) {
      const o = n.match(/^[\s\t]*;/), r = n.match(/^[\s\t]*$/);
      if (o || r)
        return;
      const a = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), u = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
      a ? t.parseNodeBegin(n, a) : c ? t.parseNodeProperty(n, c, s[++i]) : u ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const s = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(a) {
      return a.trim().replace(/^"/, "").replace(/"$/, "");
    }), i = { name: s }, o = this.parseNodeAttr(n), r = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(s, i) : s in r ? (s === "PoseNode" ? r.PoseNode.push(i) : r[s].id !== void 0 && (r[s] = {}, r[s][r[s].id] = r[s]), o.id !== "" && (r[s][o.id] = i)) : typeof o.id == "number" ? (r[s] = {}, r[s][o.id] = i) : s !== "Properties70" && (s === "PoseNode" ? r[s] = [i] : r[s] = i), typeof o.id == "number" && (i.id = o.id), o.name !== "" && (i.attrName = o.name), o.type !== "" && (i.attrType = o.type), this.pushStack(i);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let s = "", n = "";
    return e.length > 1 && (s = e[1].replace(/^(\w+)::/, ""), n = e[2]), { id: t, name: s, type: n };
  }
  parseNodeProperty(e, t, s) {
    let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    n === "Content" && i === "," && (i = s.replace(/"/g, "").replace(/,$/, "").trim());
    const o = this.getCurrentNode();
    if (o.name === "Properties70") {
      this.parseNodeSpecialProperty(e, n, i);
      return;
    }
    if (n === "C") {
      const a = i.split(",").slice(1), c = parseInt(a[0]), u = parseInt(a[1]);
      let h = i.split(",").slice(3);
      h = h.map(function(p) {
        return p.trim().replace(/^"/, "");
      }), n = "connections", i = [c, u], $r(i, h), o[n] === void 0 && (o[n] = []);
    }
    n === "Node" && (o.id = i), n in o && Array.isArray(o[n]) ? o[n].push(i) : n !== "a" ? o[n] = i : o.a = i, this.setCurrentProp(o, n), n === "a" && i.slice(-1) !== "," && (o.a = As(i));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = As(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, s) {
    const n = s.split('",').map(function(u) {
      return u.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), i = n[0], o = n[1], r = n[2], a = n[3];
    let c = n[4];
    switch (o) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = As(c);
        break;
    }
    this.getPrevNode()[i] = {
      type: o,
      type2: r,
      flag: a,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), i);
  }
}
class Xr {
  parse(e) {
    const t = new En(e);
    t.skip(23);
    const s = t.getUint32();
    if (s < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + s);
    const n = new li();
    for (; !this.endOfContent(t); ) {
      const i = this.parseNode(t, s);
      i !== null && n.add(i.name, i);
    }
    return n;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const s = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), i = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const o = e.getUint8(), r = e.getString(o);
    if (n === 0)
      return null;
    const a = [];
    for (let p = 0; p < i; p++)
      a.push(this.parseProperty(e));
    const c = a.length > 0 ? a[0] : "", u = a.length > 1 ? a[1] : "", h = a.length > 2 ? a[2] : "";
    for (s.singleProperty = i === 1 && e.getOffset() === n; n > e.getOffset(); ) {
      const p = this.parseNode(e, t);
      p !== null && this.parseSubNode(r, s, p);
    }
    return s.propertyList = a, typeof c == "number" && (s.id = c), u !== "" && (s.attrName = u), h !== "" && (s.attrType = h), r !== "" && (s.name = r), s;
  }
  parseSubNode(e, t, s) {
    if (s.singleProperty === !0) {
      const n = s.propertyList[0];
      Array.isArray(n) ? (t[s.name] = s, s.a = n) : t[s.name] = n;
    } else if (e === "Connections" && s.name === "C") {
      const n = [];
      s.propertyList.forEach(function(i, o) {
        o !== 0 && n.push(i);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
    } else if (s.name === "Properties70")
      Object.keys(s).forEach(function(i) {
        t[i] = s[i];
      });
    else if (e === "Properties70" && s.name === "P") {
      let n = s.propertyList[0], i = s.propertyList[1];
      const o = s.propertyList[2], r = s.propertyList[3];
      let a;
      n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), i === "Color" || i === "ColorRGB" || i === "Vector" || i === "Vector3D" || i.indexOf("Lcl_") === 0 ? a = [s.propertyList[4], s.propertyList[5], s.propertyList[6]] : a = s.propertyList[4], t[n] = {
        type: i,
        type2: o,
        flag: r,
        value: a
      };
    } else
      t[s.name] === void 0 ? typeof s.id == "number" ? (t[s.name] = {}, t[s.name][s.id] = s) : t[s.name] = s : s.name === "PoseNode" ? (Array.isArray(t[s.name]) || (t[s.name] = [t[s.name]]), t[s.name].push(s)) : t[s.name][s.id] === void 0 && (t[s.name][s.id] = s);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let s;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return s = e.getUint32(), e.getArrayBuffer(s);
      case "S":
        return s = e.getUint32(), e.getString(s);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n = e.getUint32(), i = e.getUint32(), o = e.getUint32();
        if (i === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(n);
            case "d":
              return e.getFloat64Array(n);
            case "f":
              return e.getFloat32Array(n);
            case "i":
              return e.getInt32Array(n);
            case "l":
              return e.getInt64Array(n);
          }
        const r = Fo(new Uint8Array(e.getArrayBuffer(o))), a = new En(r.buffer);
        switch (t) {
          case "b":
          case "c":
            return a.getBooleanArray(n);
          case "d":
            return a.getFloat64Array(n);
          case "f":
            return a.getFloat32Array(n);
          case "i":
            return a.getInt32Array(n);
          case "l":
            return a.getInt64Array(n);
        }
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class En {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0;
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    let t = [];
    for (let n = 0; n < e; n++)
      t[n] = this.getUint8();
    const s = t.indexOf(0);
    return s >= 0 && (t = t.slice(0, s)), Xe.decodeText(new Uint8Array(t));
  }
}
class li {
  add(e, t) {
    this[e] = t;
  }
}
function jr(l) {
  const e = "Kaydara FBX Binary  \0";
  return l.byteLength >= e.length && e === ui(l, 0, e.length);
}
function Zr(l) {
  const e = [
    "K",
    "a",
    "y",
    "d",
    "a",
    "r",
    "a",
    "\\",
    "F",
    "B",
    "X",
    "\\",
    "B",
    "i",
    "n",
    "a",
    "r",
    "y",
    "\\",
    "\\"
  ];
  let t = 0;
  function s(n) {
    const i = l[n - 1];
    return l = l.slice(t + n), t++, i;
  }
  for (let n = 0; n < e.length; ++n)
    if (s(1) === e[n])
      return !1;
  return !0;
}
function wn(l) {
  const e = /FBXVersion: (\d+)/, t = l.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function Kr(l) {
  return l / 46186158e3;
}
const Qr = [];
function qt(l, e, t, s) {
  let n;
  switch (s.mappingType) {
    case "ByPolygonVertex":
      n = l;
      break;
    case "ByPolygon":
      n = e;
      break;
    case "ByVertice":
      n = t;
      break;
    case "AllSame":
      n = s.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + s.mappingType);
  }
  s.referenceType === "IndexToDirect" && (n = s.indices[n]);
  const i = n * s.dataSize, o = i + s.dataSize;
  return Wr(Qr, s.buffer, i, o);
}
const ws = /* @__PURE__ */ new _t(), Et = /* @__PURE__ */ new C();
function ci(l) {
  const e = new re(), t = new re(), s = new re(), n = new re(), i = new re(), o = new re(), r = new re(), a = new re(), c = new re(), u = new re(), h = new re(), p = new re(), d = l.inheritType ? l.inheritType : 0;
  if (l.translation && e.setPosition(Et.fromArray(l.translation)), l.preRotation) {
    const D = l.preRotation.map(Oe.degToRad);
    D.push(l.eulerOrder), t.makeRotationFromEuler(ws.fromArray(D));
  }
  if (l.rotation) {
    const D = l.rotation.map(Oe.degToRad);
    D.push(l.eulerOrder), s.makeRotationFromEuler(ws.fromArray(D));
  }
  if (l.postRotation) {
    const D = l.postRotation.map(Oe.degToRad);
    D.push(l.eulerOrder), n.makeRotationFromEuler(ws.fromArray(D)), n.invert();
  }
  l.scale && i.scale(Et.fromArray(l.scale)), l.scalingOffset && r.setPosition(Et.fromArray(l.scalingOffset)), l.scalingPivot && o.setPosition(Et.fromArray(l.scalingPivot)), l.rotationOffset && a.setPosition(Et.fromArray(l.rotationOffset)), l.rotationPivot && c.setPosition(Et.fromArray(l.rotationPivot)), l.parentMatrixWorld && (h.copy(l.parentMatrix), u.copy(l.parentMatrixWorld));
  const g = t.clone().multiply(s).multiply(n), m = new re();
  m.extractRotation(u);
  const T = new re();
  T.copyPosition(u);
  const x = T.clone().invert().multiply(u), S = m.clone().invert().multiply(x), E = i, f = new re();
  if (d === 0)
    f.copy(m).multiply(g).multiply(S).multiply(E);
  else if (d === 1)
    f.copy(m).multiply(S).multiply(g).multiply(E);
  else {
    const R = new re().scale(new C().setFromMatrixScale(h)).clone().invert(), k = S.clone().multiply(R);
    f.copy(m).multiply(g).multiply(k).multiply(E);
  }
  const v = c.clone().invert(), w = o.clone().invert();
  let _ = e.clone().multiply(a).multiply(c).multiply(t).multiply(s).multiply(n).multiply(v).multiply(r).multiply(o).multiply(i).multiply(w);
  const y = new re().copyPosition(_), L = u.clone().multiply(y);
  return p.copyPosition(L), _ = p.clone().multiply(f), _.premultiply(u.invert()), _;
}
function hi(l) {
  l = l || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return l === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[l];
}
function As(l) {
  return l.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function ui(l, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = l.byteLength), Xe.decodeText(new Uint8Array(l, e, t));
}
function $r(l, e) {
  for (let t = 0, s = l.length, n = e.length; t < n; t++, s++)
    l[s] = e[t];
}
function Wr(l, e, t, s) {
  for (let n = t, i = 0; n < s; n++, i++)
    l[i] = e[n];
  return l;
}
function An(l, e, t) {
  return l.slice(0, e).concat(t).concat(l.slice(e));
}
var qr = Object.defineProperty, Jr = (l, e, t) => e in l ? qr(l, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : l[e] = t, Qs = (l, e, t) => (Jr(l, typeof e != "symbol" ? e + "" : e, t), t);
class ea extends cs {
  constructor(e) {
    super(e);
  }
  load(e, t, s, n) {
    const i = new Ot(this.manager);
    i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (o) => {
        if (typeof o != "string")
          throw new Error("unsupported data type");
        const r = JSON.parse(o), a = this.parse(r);
        t && t(a);
      },
      s,
      n
    );
  }
  loadAsync(e, t) {
    return super.loadAsync(e, t);
  }
  parse(e) {
    return new $s(e);
  }
}
class $s {
  constructor(e) {
    Qs(this, "data"), this.data = e;
  }
  generateShapes(e, t = 100, s) {
    const n = [], i = { letterSpacing: 0, lineHeight: 1, ...s }, o = ta(e, t, this.data, i);
    for (let r = 0, a = o.length; r < a; r++)
      Array.prototype.push.apply(n, o[r].toShapes(!1));
    return n;
  }
}
Qs($s, "isFont");
Qs($s, "type");
function ta(l, e, t, s) {
  const n = Array.from(l), i = e / t.resolution, o = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i, r = [];
  let a = 0, c = 0;
  for (let u = 0; u < n.length; u++) {
    const h = n[u];
    if (h === `
`)
      a = 0, c -= o * s.lineHeight;
    else {
      const p = sa(h, i, a, c, t);
      p && (a += p.offsetX + s.letterSpacing, r.push(p.path));
    }
  }
  return r;
}
function sa(l, e, t, s, n) {
  const i = n.glyphs[l] || n.glyphs["?"];
  if (!i) {
    console.error('THREE.Font: character "' + l + '" does not exists in font family ' + n.familyName + ".");
    return;
  }
  const o = new po();
  let r, a, c, u, h, p, d, g;
  if (i.o) {
    const m = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
    for (let T = 0, x = m.length; T < x; )
      switch (m[T++]) {
        case "m":
          r = parseInt(m[T++]) * e + t, a = parseInt(m[T++]) * e + s, o.moveTo(r, a);
          break;
        case "l":
          r = parseInt(m[T++]) * e + t, a = parseInt(m[T++]) * e + s, o.lineTo(r, a);
          break;
        case "q":
          c = parseInt(m[T++]) * e + t, u = parseInt(m[T++]) * e + s, h = parseInt(m[T++]) * e + t, p = parseInt(m[T++]) * e + s, o.quadraticCurveTo(h, p, c, u);
          break;
        case "b":
          c = parseInt(m[T++]) * e + t, u = parseInt(m[T++]) * e + s, h = parseInt(m[T++]) * e + t, p = parseInt(m[T++]) * e + s, d = parseInt(m[T++]) * e + t, g = parseInt(m[T++]) * e + s, o.bezierCurveTo(h, p, d, g, c, u);
          break;
      }
  }
  return { offsetX: i.ha * e, path: o };
}
class na extends fo {
  constructor(e) {
    super(e), this.type = Qt;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const r = function(E, f) {
      switch (E) {
        case 1:
          console.error("THREE.RGBELoader Read Error: " + (f || ""));
          break;
        case 2:
          console.error("THREE.RGBELoader Write Error: " + (f || ""));
          break;
        case 3:
          console.error("THREE.RGBELoader Bad File Format: " + (f || ""));
          break;
        default:
        case 4:
          console.error("THREE.RGBELoader: Error: " + (f || ""));
      }
      return -1;
    }, h = `
`, p = function(E, f, v) {
      f = f || 1024;
      let _ = E.pos, y = -1, L = 0, D = "", R = String.fromCharCode.apply(null, new Uint16Array(E.subarray(_, _ + 128)));
      for (; 0 > (y = R.indexOf(h)) && L < f && _ < E.byteLength; )
        D += R, L += R.length, _ += 128, R += String.fromCharCode.apply(null, new Uint16Array(E.subarray(_, _ + 128)));
      return -1 < y ? (v !== !1 && (E.pos += L + y + 1), D + R.slice(0, y)) : !1;
    }, d = function(E) {
      const f = /^#\?(\S+)/, v = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, w = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, _ = /^\s*FORMAT=(\S+)\s*$/, y = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, L = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let D, R;
      if (E.pos >= E.byteLength || !(D = p(E)))
        return r(1, "no header found");
      if (!(R = D.match(f)))
        return r(3, "bad initial token");
      for (L.valid |= 1, L.programtype = R[1], L.string += D + `
`; D = p(E), D !== !1; ) {
        if (L.string += D + `
`, D.charAt(0) === "#") {
          L.comments += D + `
`;
          continue;
        }
        if ((R = D.match(v)) && (L.gamma = parseFloat(R[1])), (R = D.match(w)) && (L.exposure = parseFloat(R[1])), (R = D.match(_)) && (L.valid |= 2, L.format = R[1]), (R = D.match(y)) && (L.valid |= 4, L.height = parseInt(R[1], 10), L.width = parseInt(R[2], 10)), L.valid & 2 && L.valid & 4)
          break;
      }
      return L.valid & 2 ? L.valid & 4 ? L : r(3, "missing image size specifier") : r(3, "missing format specifier");
    }, g = function(E, f, v) {
      const w = f;
      if (
        // run length encoding is not allowed so read flat
        w < 8 || w > 32767 || // this file is not run length encoded
        E[0] !== 2 || E[1] !== 2 || E[2] & 128
      )
        return new Uint8Array(E);
      if (w !== (E[2] << 8 | E[3]))
        return r(3, "wrong scanline width");
      const _ = new Uint8Array(4 * f * v);
      if (!_.length)
        return r(4, "unable to allocate buffer space");
      let y = 0, L = 0;
      const D = 4 * w, R = new Uint8Array(4), k = new Uint8Array(D);
      let X = v;
      for (; X > 0 && L < E.byteLength; ) {
        if (L + 4 > E.byteLength)
          return r(1);
        if (R[0] = E[L++], R[1] = E[L++], R[2] = E[L++], R[3] = E[L++], R[0] != 2 || R[1] != 2 || (R[2] << 8 | R[3]) != w)
          return r(3, "bad rgbe scanline format");
        let se = 0, V;
        for (; se < D && L < E.byteLength; ) {
          V = E[L++];
          const j = V > 128;
          if (j && (V -= 128), V === 0 || se + V > D)
            return r(3, "bad scanline data");
          if (j) {
            const _e = E[L++];
            for (let fe = 0; fe < V; fe++)
              k[se++] = _e;
          } else
            k.set(E.subarray(L, L + V), se), se += V, L += V;
        }
        const ae = w;
        for (let j = 0; j < ae; j++) {
          let _e = 0;
          _[y] = k[j + _e], _e += w, _[y + 1] = k[j + _e], _e += w, _[y + 2] = k[j + _e], _e += w, _[y + 3] = k[j + _e], y += 4;
        }
        X--;
      }
      return _;
    }, m = function(E, f, v, w) {
      const _ = E[f + 3], y = Math.pow(2, _ - 128) / 255;
      v[w + 0] = E[f + 0] * y, v[w + 1] = E[f + 1] * y, v[w + 2] = E[f + 2] * y, v[w + 3] = 1;
    }, T = function(E, f, v, w) {
      const _ = E[f + 3], y = Math.pow(2, _ - 128) / 255;
      v[w + 0] = $t.toHalfFloat(Math.min(E[f + 0] * y, 65504)), v[w + 1] = $t.toHalfFloat(Math.min(E[f + 1] * y, 65504)), v[w + 2] = $t.toHalfFloat(Math.min(E[f + 2] * y, 65504)), v[w + 3] = $t.toHalfFloat(1);
    }, x = new Uint8Array(e);
    x.pos = 0;
    const S = d(x);
    if (S !== -1) {
      const E = S.width, f = S.height, v = g(x.subarray(x.pos), E, f);
      if (v !== -1) {
        let w, _, y;
        switch (this.type) {
          case gs:
            y = v.length / 4;
            const L = new Float32Array(y * 4);
            for (let R = 0; R < y; R++)
              m(v, R * 4, L, R * 4);
            w = L, _ = gs;
            break;
          case Qt:
            y = v.length / 4;
            const D = new Uint16Array(y * 4);
            for (let R = 0; R < y; R++)
              T(v, R * 4, D, R * 4);
            w = D, _ = Qt;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
            break;
        }
        return {
          width: E,
          height: f,
          data: w,
          header: S.string,
          gamma: S.gamma,
          exposure: S.exposure,
          type: _
        };
      }
    }
    return null;
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, s, n) {
    function i(o, r) {
      switch (o.type) {
        case gs:
        case Qt:
          "colorSpace" in o ? o.colorSpace = "srgb-linear" : o.encoding = 3e3, o.minFilter = rs, o.magFilter = rs, o.generateMipmaps = !1, o.flipY = !0;
          break;
      }
      t && t(o, r);
    }
    return super.load(e, i, s, n);
  }
}
const xs = /* @__PURE__ */ new WeakMap();
class ia extends cs {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, s, n) {
    const i = new Ot(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (o) => {
        const r = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: !1
        };
        this.decodeGeometry(o, r).then(t).catch(n);
      },
      s,
      n
    );
  }
  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
  decodeDracoFile(e, t, s, n) {
    const i = {
      attributeIDs: s || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!s
    };
    this.decodeGeometry(e, i).then(t);
  }
  decodeGeometry(e, t) {
    for (const a in t.attributeTypes) {
      const c = t.attributeTypes[a];
      c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[a] = c.name);
    }
    const s = JSON.stringify(t);
    if (xs.has(e)) {
      const a = xs.get(e);
      if (a.key === s)
        return a.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const i = this.workerNextTaskID++, o = e.byteLength, r = this._getWorker(i, o).then((a) => (n = a, new Promise((c, u) => {
      n._callbacks[i] = { resolve: c, reject: u }, n.postMessage({ type: "decode", id: i, taskConfig: t, buffer: e }, [e]);
    }))).then((a) => this._createGeometry(a.geometry));
    return r.catch(() => !0).then(() => {
      n && i && this._releaseTask(n, i);
    }), xs.set(e, {
      key: s,
      promise: r
    }), r;
  }
  _createGeometry(e) {
    const t = new $e();
    e.index && t.setIndex(new zt(e.index.array, 1));
    for (let s = 0; s < e.attributes.length; s++) {
      const n = e.attributes[s], i = n.name, o = n.array, r = n.itemSize;
      t.setAttribute(i, new zt(o, r));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const s = new Ot(this.manager);
    return s.setPath(this.decoderPath), s.setResponseType(t), s.setWithCredentials(this.withCredentials), new Promise((n, i) => {
      s.load(e, n, void 0, i);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((s) => {
      const n = s[0];
      e || (this.decoderConfig.wasmBinary = s[1]);
      const i = oa.toString(), o = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(i) {
          const o = i.data;
          switch (o.type) {
            case "decode":
              n._callbacks[o.id].resolve(o);
              break;
            case "error":
              n._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, i) {
          return n._taskLoad > i._taskLoad ? -1 : 1;
        });
      const s = this.workerPool[this.workerPool.length - 1];
      return s._taskCosts[e] = t, s._taskLoad += t, s;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
}
function oa() {
  let l, e;
  onmessage = function(o) {
    const r = o.data;
    switch (r.type) {
      case "init":
        l = r.decoderConfig, e = new Promise(function(u) {
          l.onModuleLoaded = function(h) {
            u({ draco: h });
          }, DracoDecoderModule(l);
        });
        break;
      case "decode":
        const a = r.buffer, c = r.taskConfig;
        e.then((u) => {
          const h = u.draco, p = new h.Decoder(), d = new h.DecoderBuffer();
          d.Init(new Int8Array(a), a.byteLength);
          try {
            const g = t(h, p, d, c), m = g.attributes.map((T) => T.array.buffer);
            g.index && m.push(g.index.array.buffer), self.postMessage({ type: "decode", id: r.id, geometry: g }, m);
          } catch (g) {
            console.error(g), self.postMessage({ type: "error", id: r.id, error: g.message });
          } finally {
            h.destroy(d), h.destroy(p);
          }
        });
        break;
    }
  };
  function t(o, r, a, c) {
    const u = c.attributeIDs, h = c.attributeTypes;
    let p, d;
    const g = r.GetEncodedGeometryType(a);
    if (g === o.TRIANGULAR_MESH)
      p = new o.Mesh(), d = r.DecodeBufferToMesh(a, p);
    else if (g === o.POINT_CLOUD)
      p = new o.PointCloud(), d = r.DecodeBufferToPointCloud(a, p);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!d.ok() || p.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + d.error_msg());
    const m = { index: null, attributes: [] };
    for (const T in u) {
      const x = self[h[T]];
      let S, E;
      if (c.useUniqueIDs)
        E = u[T], S = r.GetAttributeByUniqueId(p, E);
      else {
        if (E = r.GetAttributeId(p, o[u[T]]), E === -1)
          continue;
        S = r.GetAttribute(p, E);
      }
      m.attributes.push(n(o, r, p, T, x, S));
    }
    return g === o.TRIANGULAR_MESH && (m.index = s(o, r, p)), o.destroy(p), m;
  }
  function s(o, r, a) {
    const u = a.num_faces() * 3, h = u * 4, p = o._malloc(h);
    r.GetTrianglesUInt32Array(a, h, p);
    const d = new Uint32Array(o.HEAPF32.buffer, p, u).slice();
    return o._free(p), { array: d, itemSize: 1 };
  }
  function n(o, r, a, c, u, h) {
    const p = h.num_components(), g = a.num_points() * p, m = g * u.BYTES_PER_ELEMENT, T = i(o, u), x = o._malloc(m);
    r.GetAttributeDataArrayForAllPoints(a, h, T, m, x);
    const S = new u(o.HEAPF32.buffer, x, g).slice();
    return o._free(x), {
      name: c,
      array: S,
      itemSize: p
    };
  }
  function i(o, r) {
    switch (r) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
const ra = ["args", "center"], Fl = /* @__PURE__ */ te({
  __name: "Text3D",
  props: {
    font: {},
    text: {},
    size: { default: 0.5 },
    height: { default: 0.2 },
    curveSegments: { default: 5 },
    bevelEnabled: { type: Boolean, default: !0 },
    bevelThickness: { default: 0.05 },
    bevelSize: { default: 0.02 },
    bevelOffset: { default: 0 },
    bevelSegments: { default: 4 },
    center: { type: Boolean, default: !1 },
    needUpdates: { type: Boolean, default: !1 }
  },
  async setup(l, { expose: e }) {
    let t, s;
    const n = l, {
      center: i,
      font: o,
      text: r,
      needUpdates: a,
      size: c,
      height: u,
      curveSegments: h,
      bevelEnabled: p,
      bevelThickness: d,
      bevelSize: g,
      bevelOffset: m,
      bevelSegments: T
    } = pe(n), { extend: x } = Le();
    x({ TextGeometry: vn });
    const S = new ea(), E = Oi(), f = Ne(() => {
      var y;
      return r != null && r.value ? r.value : E.default ? (y = E.default()[0].children) == null ? void 0 : y.trim() : a.value ? "" : "TresJS";
    }), v = ue();
    e({
      value: v
    });
    const w = ([t, s] = ls(() => new Promise((y, L) => {
      try {
        typeof o.value == "string" ? S.load(o.value, (D) => {
          y(D);
        }) : y(o.value);
      } catch (D) {
        L(console.error("cientos", D));
      }
    })), t = await t, s(), t), _ = Ne(() => ({
      font: w,
      size: qe(c),
      height: qe(u),
      curveSegments: qe(h),
      bevelEnabled: qe(p),
      bevelThickness: qe(d),
      bevelSize: qe(g),
      bevelOffset: qe(m),
      bevelSegments: qe(T)
    }));
    return at(() => {
      v.value && a.value && (v.value.geometry.dispose(), v.value.geometry = new vn(f.value, _.value), i.value && v.value.geometry.center());
    }), (y, L) => M(o) ? (Q(), J("TresMesh", {
      key: 0,
      ref_key: "text3DRef",
      ref: v
    }, [
      f.value ? (Q(), J("TresTextGeometry", {
        key: 0,
        args: [f.value, _.value],
        center: M(i)
      }, null, 8, ra)) : lt("", !0),
      Ee(y.$slots, "default")
    ], 512)) : lt("", !0);
  }
});
function Ul(l, e) {
  const t = G(e), s = new mo(t.value), n = Li({});
  l.forEach((o) => {
    const r = s.clipAction(o, t.value);
    n[o.name] = r;
  });
  const { onLoop: i } = Ce();
  return i(({ delta: o }) => {
    s.update(o);
  }), {
    actions: n,
    mixer: s
  };
}
const bs = {
  sunset: "venice/venice_sunset_4k.hdr"
};
async function aa({
  files: l = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"],
  blur: e = 0,
  background: t = !1,
  path: s = "/",
  preset: n = void 0
}) {
  const { scene: i } = Le();
  if (n) {
    if (!(n in bs))
      throw new Error("Preset must be one of: " + Object.keys(bs).join(", "));
    l = bs[n], s = "https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";
  }
  const o = Array.isArray(l), a = await Ks(
    o ? yo : na,
    o ? [l] : l,
    (u) => {
      s && u.setPath(s);
    }
  ), c = o ? a[0] : a;
  return c && (c.mapping = o ? go : Wn, c.colorSpace = _o), i.value && (i.value.environment = c, t && (i.value.background = c), e && (i.value.backgroundBlurriness = e | 0)), c;
}
const Bl = te({
  name: "Environment",
  props: ["background", "blur", "files", "encoding", "path", "preset"],
  async setup(l, { expose: e }) {
    let t = null;
    return e({ getTexture: () => t }), t = await aa(l), () => {
    };
  }
}), la = ["position", "a-scale"], ca = ["size", "size-attenuation", "transparent", "alpha-test", "alpha-map"], zl = /* @__PURE__ */ te({
  __name: "Stars",
  props: {
    size: { default: 0.1 },
    sizeAttenuation: { type: Boolean, default: !0 },
    transparent: { type: Boolean, default: !0 },
    alphaTest: { default: 0.01 },
    count: { default: 5e3 },
    depth: { default: 50 },
    radius: { default: 100 },
    alphaMap: { default: null }
  },
  setup(l, { expose: e }) {
    const t = l, s = G(), n = G(), { radius: i, depth: o, count: r, size: a, sizeAttenuation: c, transparent: u, alphaMap: h, alphaTest: p } = pe(t), d = () => {
      let m = i.value + o.value;
      const T = Ne(() => o.value / r.value), x = [], S = Array.from(
        { length: r.value },
        () => (0.5 + 0.5 * Math.random()) * 4
      ), E = (f) => new C().setFromSpherical(new os(f, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)).toArray();
      for (let f = 0; f < r.value; f++)
        m -= T.value * Math.random(), x.push(...E(m));
      s.value = new Float32Array(x), n.value = new Float32Array(S);
    };
    at(() => {
      d();
    });
    const g = ue();
    return e({
      value: g
    }), (m, T) => (Q(), J("TresPoints", {
      ref_key: "starsRef",
      ref: g
    }, [
      Y("TresBufferGeometry", {
        position: [s.value, 3],
        "a-scale": [n.value, 1]
      }, null, 8, la),
      Y("TresPointsMaterial", {
        size: M(a),
        "size-attenuation": M(c),
        transparent: M(u),
        "alpha-test": M(p),
        "alpha-map": M(h)
      }, null, 8, ca)
    ], 512));
  }
}), ha = ["size", "color", "alpha-map", "map", "opacity", "alpha-test", "depth-write", "transparent", "size-attenuation"], ua = ["position", "velocity"], Nl = /* @__PURE__ */ te({
  __name: "Precipitation",
  props: {
    size: { default: 0.1 },
    area: { default: () => [10, 10, 20] },
    color: { default: 16777215 },
    map: {},
    alphaMap: {},
    alphaTest: { default: 0.01 },
    opacity: { default: 0.8 },
    count: { default: 5e3 },
    speed: { default: 0.1 },
    randomness: { default: 0.5 },
    depthWrite: { type: Boolean, default: !1 },
    transparent: { type: Boolean, default: !0 },
    sizeAttenuation: { type: Boolean, default: !0 }
  },
  setup(l) {
    const e = l, {
      size: t,
      area: s,
      color: n,
      alphaMap: i,
      map: o,
      opacity: r,
      alphaTest: a,
      depthWrite: c,
      transparent: u,
      sizeAttenuation: h,
      count: p,
      speed: d,
      randomness: g
    } = pe(e), m = ue();
    let T = [], x = [];
    const S = () => {
      T = new Float32Array(p.value * 3);
      for (let v = 0; v < p.value; v++) {
        const w = v * 3;
        T[w] = (Math.random() - 0.5) * s.value[0], T[w + 1] = (Math.random() - 0.5) * s.value[1], T[w + 2] = (Math.random() - 0.5) * s.value[2];
      }
    }, E = () => {
      x = new Float32Array(p.value * 2);
      for (let v = 0; v < p.value * 2; v += 2)
        x[v] = (Math.random() - 0.5) / 5 * d.value * g.value, x[v + 1] = Math.random() / 5 * d.value + 0.01;
    };
    E(), S(), at(() => {
      E(), S();
    });
    const { onLoop: f } = Ce();
    return f(() => {
      var v, w;
      if ((v = m.value) != null && v.attributes.position.array && ((w = m.value) != null && w.attributes.position.count)) {
        const _ = m.value.attributes.position.array;
        for (let y = 0; y < m.value.attributes.position.count; y++) {
          const L = x[y * 2], D = x[y * 2 + 1];
          _[y * 3] += L, _[y * 3 + 1] -= D, (_[y * 3] <= -s.value[0] / 2 || _[y * 3] >= s.value[0] / 2) && (_[y * 3] = _[y * 3] * -1), (_[y * 3 + 1] <= -s.value[1] / 2 || _[y * 3 + 1] >= s.value[1] / 2) && (_[y * 3 + 1] = _[y * 3 + 1] * -1);
        }
        m.value.attributes.position.needsUpdate = !0;
      }
    }), (v, w) => (Q(), J("TresPoints", null, [
      Y("TresPointsMaterial", {
        size: M(t),
        color: M(n),
        "alpha-map": M(i),
        map: M(o),
        opacity: M(r),
        "alpha-test": M(a),
        "depth-write": M(c),
        transparent: M(u),
        "size-attenuation": M(h)
      }, null, 8, ha),
      Y("TresBufferGeometry", {
        ref_key: "geometryRef",
        ref: m,
        position: [M(T), 3],
        velocity: [M(x)]
      }, null, 8, ua)
    ]));
  }
}), pa = ["position"], da = ["position"], fa = ["scale"], ma = ["map", "depth-test", "color-space", "color", "opacity"], Hl = /* @__PURE__ */ te({
  __name: "Smoke",
  props: {
    color: { default: "#ffffff" },
    opacity: { default: 0.5 },
    speed: { default: 0.4 },
    width: { default: 10 },
    depth: { default: 1.5 },
    segments: { default: 20 },
    texture: { default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png" },
    depthTest: { type: Boolean, default: !0 }
  },
  async setup(l, { expose: e }) {
    let t, s;
    const n = l, { width: i, depth: o, segments: r, texture: a, color: c, depthTest: u, opacity: h, speed: p } = pe(n), d = ue(), g = ue();
    e({
      value: d
    });
    const m = [...new Array(r)].map((w, _) => ({
      x: i.value / 2 - Math.random() * i.value,
      y: i.value / 2 - Math.random() * i.value,
      scale: 0.4 + Math.sin((_ + 1) / r.value * Math.PI) * ((0.2 + Math.random()) * 10),
      density: Math.max(0.2, Math.random()),
      rotation: Math.max(2e-3, 5e-3 * Math.random()) * p.value
    })), T = (w, _) => w / 6 * _ * h.value, { map: x } = ([t, s] = ls(() => Eo({ map: a.value })), t = await t, s(), t), { renderer: S, camera: E } = Le(), f = Ne(() => {
      var w;
      return (w = S.value) == null ? void 0 : w.outputColorSpace;
    }), { onLoop: v } = Ce();
    return v(() => {
      var w, _;
      d.value && E.value && g.value && ((w = g.value) == null || w.children.forEach((y, L) => {
        y.rotation.z += m[L].rotation;
      }), d.value.lookAt((_ = E.value) == null ? void 0 : _.position));
    }), (w, _) => (Q(), J("TresGroup", Te({
      ref_key: "smokeRef",
      ref: d
    }, w.$attrs), [
      Y("TresGroup", {
        ref_key: "groupRef",
        ref: g,
        position: [0, 0, M(r) / 2 * M(o)]
      }, [
        (Q(!0), J(Pi, null, Ri(M(m), ({ scale: y, x: L, y: D, density: R }, k) => (Q(), J("TresMesh", {
          key: `${k}`,
          position: [L, D, -k * M(o)]
        }, [
          Y("TresPlaneGeometry", {
            scale: [y, y, y],
            rotation: [0, 0, 0]
          }, null, 8, fa),
          Y("TresMeshStandardMaterial", {
            map: M(x),
            "depth-test": M(u),
            "color-space": f.value,
            color: M(c),
            "depth-write": !1,
            transparent: "",
            opacity: T(y, R)
          }, null, 8, ma)
        ], 8, da))), 128))
      ], 8, pa)
    ], 16));
  }
}), Vl = /* @__PURE__ */ te({
  __name: "Levioso",
  props: {
    speed: { default: 1 },
    rotationFactor: { default: 1 },
    floatFactor: { default: 1 },
    range: { default: () => [-0.1, 0.1] }
  },
  setup(l, { expose: e }) {
    const t = l, s = ue();
    e({
      value: s
    });
    const { onLoop: n } = Ce(), i = G(Math.random() * 1e4);
    return n(({ elapsed: o }) => {
      var c, u;
      if (!s.value)
        return;
      const r = i.value + o;
      s.value.rotation.x = Math.cos(r / 4 * t.speed) / 8 * t.rotationFactor, s.value.rotation.y = Math.sin(r / 4 * t.speed) / 8 * t.rotationFactor, s.value.rotation.z = Math.sin(r / 4 * t.speed) / 20 * t.rotationFactor;
      let a = Math.sin(r / 4 * t.speed) / 10;
      a = Oe.mapLinear(a, -0.1, 0.1, ((c = t.range) == null ? void 0 : c[0]) ?? -0.1, ((u = t.range) == null ? void 0 : u[1]) ?? 0.1), s.value.position.y = a * t.floatFactor;
    }), (o, r) => (Q(), J("TresGroup", Te(o.$attrs, {
      ref_key: "groupRef",
      ref: s
    }), [
      Ee(o.$slots, "default")
    ], 16));
  }
}), ga = ["geometry"], _a = ["map", "opacity", "depth-write"], ya = ["args"], va = ["rotation", "args"], Gl = /* @__PURE__ */ te({
  __name: "ContactShadows",
  props: {
    opacity: { default: 1 },
    width: { default: 1 },
    height: { default: 1 },
    blur: { default: 1 },
    far: { default: 10 },
    smooth: { type: Boolean, default: !0 },
    resolution: { default: 512 },
    frames: { default: 1 / 0 },
    scale: { default: 10 },
    color: { default: "#000000" },
    depthWrite: { type: Boolean, default: !1 },
    helper: { type: Boolean, default: !1 }
  },
  setup(l, { expose: e }) {
    const t = l, s = ue(), n = ue();
    e(s);
    let i, o, r, a, c;
    const { renderer: u, scene: h } = Le(), p = Ne(() => t.width * (Array.isArray(t.scale) ? t.scale[0] : t.scale || 1)), d = Ne(() => t.height * (Array.isArray(t.scale) ? t.scale[1] : t.scale || 1));
    at(() => {
      i && i.dispose(), o && o.dispose(), r && r.dispose(), a && a.geometry.dispose(), i = new hn(t.resolution, t.resolution), o = new hn(t.resolution, t.resolution), o.texture.generateMipmaps = i.texture.generateMipmaps = !1, n.value = new St(
        -p.value / 2,
        p.value / 2,
        d.value / 2,
        -d.value / 2,
        0,
        t.far
      ), r = new st(p.value, d.value).rotateX(Math.PI / 2), a = new F(r), a.visible = !1;
    }), at(() => {
      t.color && (c && c.dispose(), c = new vo(), c.depthTest = c.depthWrite = !1, c.onBeforeCompile = (v) => {
        v.uniforms = {
          ...v.uniforms,
          ucolor: { value: t.color ? new ge(t.color) : new ge() }
        }, v.fragmentShader = v.fragmentShader.replace(
          "void main() {",
          //
          `uniform vec3 ucolor;
             void main() {
            `
        ), v.fragmentShader = v.fragmentShader.replace(
          "vec4( vec3( 1.0 - fragCoordZ ), opacity );",
          // Colorize the shadow, multiply by the falloff so that the center can remain darker
          "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );"
        );
      });
    });
    const g = new un(Rr), m = new un(Dr);
    m.depthTest = g.depthTest = !1;
    function T(v) {
      !u.value || !n.value || (a.visible = !0, a.material = g, g.uniforms.tDiffuse.value = i.texture, g.uniforms.h.value = v / 256, u.value.setRenderTarget(o), u.value.render(a, n.value), a.material = m, m.uniforms.tDiffuse.value = o.texture, m.uniforms.v.value = v / 256, u.value.setRenderTarget(i), u.value.render(a, n.value), a.visible = !1);
    }
    const { onLoop: x } = Ce();
    let S = 0, E, f;
    return x(() => {
      !n.value || h.value === void 0 || u.value === void 0 || (t.frames === 1 / 0 || S < t.frames) && (S++, E = h.value.background, f = h.value.overrideMaterial, s.value.visible = !1, h.value.background = null, h.value.overrideMaterial = c, u.value.setRenderTarget(i), u.value.render(h.value, n.value), T(t.blur), t.smooth && T(t.blur * 0.4), u.value.setRenderTarget(null), s.value.visible = !0, h.value.background = E, h.value.overrideMaterial = f);
    }), (v, w) => {
      const _ = Gs("primitive");
      return Q(), J("TresGroup", Te({
        ref_key: "groupRef",
        ref: s
      }, v.$attrs), [
        Y("TresMesh", {
          scale: [1, -1, 1],
          geometry: M(r)
        }, [
          Y("TresMeshBasicMaterial", {
            map: M(i).texture,
            opacity: v.opacity,
            "depth-write": v.depthWrite,
            transparent: !0
          }, null, 8, _a)
        ], 8, ga),
        Di(_, { object: M(a) }, null, 8, ["object"]),
        n.value && v.helper ? (Q(), J("TresCameraHelper", {
          key: 0,
          args: [n.value]
        }, null, 8, ya)) : lt("", !0),
        Y("TresOrthographicCamera", {
          ref_key: "shadowCamera",
          ref: n,
          position: [0, 0, 0],
          rotation: [Math.PI / 2, 0, 0],
          args: [-p.value / 2, p.value / 2, d.value / 2, -d.value / 2, 0, v.far]
        }, null, 8, va)
      ], 16);
    };
  }
});
function pi(l) {
  return Ii() ? (Ci(l), !0) : !1;
}
function ze(l) {
  return typeof l == "function" ? l() : M(l);
}
const Ta = typeof window < "u", ct = () => {
};
function di(l, e) {
  function t(...s) {
    return new Promise((n, i) => {
      Promise.resolve(l(() => e.apply(this, s), { fn: e, thisArg: this, args: s })).then(n).catch(i);
    });
  }
  return t;
}
function Ea(l, e = {}) {
  let t, s, n = ct;
  const i = (r) => {
    clearTimeout(r), n(), n = ct;
  };
  return (r) => {
    const a = ze(l), c = ze(e.maxWait);
    return t && i(t), a <= 0 || c !== void 0 && c <= 0 ? (s && (i(s), s = null), Promise.resolve(r())) : new Promise((u, h) => {
      n = e.rejectOnCancel ? h : u, c && !s && (s = setTimeout(() => {
        t && i(t), s = null, u(r());
      }, c)), t = setTimeout(() => {
        s && i(s), s = null, u(r());
      }, a);
    });
  };
}
function wa(l, e = !0, t = !0, s = !1) {
  let n = 0, i, o = !0, r = ct, a;
  const c = () => {
    i && (clearTimeout(i), i = void 0, r(), r = ct);
  };
  return (h) => {
    const p = ze(l), d = Date.now() - n, g = () => a = h();
    return c(), p <= 0 ? (n = Date.now(), g()) : (d > p && (t || !o) ? (n = Date.now(), g()) : e && (a = new Promise((m, T) => {
      r = s ? T : m, i = setTimeout(() => {
        n = Date.now(), o = !0, m(g()), c();
      }, Math.max(0, p - d));
    })), !t && !i && (i = setTimeout(() => o = !0, p)), o = !1, a);
  };
}
function Aa(...l) {
  if (l.length !== 1)
    return Fi(...l);
  const e = l[0];
  return typeof e == "function" ? Ui(Bi(() => ({ get: e, set: ct }))) : G(e);
}
function xa(l, e = 200, t = {}) {
  return di(
    Ea(e, t),
    l
  );
}
function ba(l, e = 200, t = !1, s = !0, n = !1) {
  return di(
    wa(e, t, s, n),
    l
  );
}
function Sa(l, e = !0) {
  Cn() ? Ys(l) : e ? l() : ki(l);
}
function Ma(l) {
  var e;
  const t = ze(l);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const Pt = Ta ? window : void 0;
function de(...l) {
  let e, t, s, n;
  if (typeof l[0] == "string" || Array.isArray(l[0]) ? ([t, s, n] = l, e = Pt) : [e, t, s, n] = l, !e)
    return ct;
  Array.isArray(t) || (t = [t]), Array.isArray(s) || (s = [s]);
  const i = [], o = () => {
    i.forEach((u) => u()), i.length = 0;
  }, r = (u, h, p, d) => (u.addEventListener(h, p, d), () => u.removeEventListener(h, p, d)), a = Me(
    () => [Ma(e), ze(n)],
    ([u, h]) => {
      o(), u && i.push(
        ...t.flatMap((p) => s.map((d) => r(u, p, d, h)))
      );
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    a(), o();
  };
  return pi(c), c;
}
function Oa(l) {
  return typeof l == "function" ? l : typeof l == "string" ? (e) => e.key === l : Array.isArray(l) ? (e) => l.includes(e.key) : () => !0;
}
function ft(...l) {
  let e, t, s = {};
  l.length === 3 ? (e = l[0], t = l[1], s = l[2]) : l.length === 2 ? typeof l[1] == "object" ? (e = !0, t = l[0], s = l[1]) : (e = l[0], t = l[1]) : (e = !0, t = l[0]);
  const {
    target: n = Pt,
    eventName: i = "keydown",
    passive: o = !1,
    dedupe: r = !1
  } = s, a = Oa(e);
  return de(n, i, (u) => {
    u.repeat && ze(r) || a(u) && t(u);
  }, o);
}
function La() {
  const l = G(!1);
  return Cn() && Ys(() => {
    l.value = !0;
  }), l;
}
function Pa(l) {
  const e = La();
  return Ne(() => (e.value, !!l()));
}
function Ra(l, e = {}) {
  const { window: t = Pt } = e, s = Pa(() => t && "matchMedia" in t && typeof t.matchMedia == "function");
  let n;
  const i = G(!1), o = () => {
    n && ("removeEventListener" in n ? n.removeEventListener("change", r) : n.removeListener(r));
  }, r = () => {
    s.value && (o(), n = t.matchMedia(Aa(l).value), i.value = !!(n != null && n.matches), n && ("addEventListener" in n ? n.addEventListener("change", r) : n.addListener(r)));
  };
  return at(r), pi(() => o()), i;
}
const xn = 1;
function Da(l, e = {}) {
  const {
    throttle: t = 0,
    idle: s = 200,
    onStop: n = ct,
    onScroll: i = ct,
    offset: o = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions: r = {
      capture: !1,
      passive: !0
    },
    behavior: a = "auto"
  } = e, c = G(0), u = G(0), h = Ne({
    get() {
      return c.value;
    },
    set(v) {
      d(v, void 0);
    }
  }), p = Ne({
    get() {
      return u.value;
    },
    set(v) {
      d(void 0, v);
    }
  });
  function d(v, w) {
    var _, y, L;
    const D = ze(l);
    D && ((L = D instanceof Document ? document.body : D) == null || L.scrollTo({
      top: (_ = ze(w)) != null ? _ : p.value,
      left: (y = ze(v)) != null ? y : h.value,
      behavior: ze(a)
    }));
  }
  const g = G(!1), m = cn({
    left: !0,
    right: !1,
    top: !0,
    bottom: !1
  }), T = cn({
    left: !1,
    right: !1,
    top: !1,
    bottom: !1
  }), x = (v) => {
    g.value && (g.value = !1, T.left = !1, T.right = !1, T.top = !1, T.bottom = !1, n(v));
  }, S = xa(x, t + s), E = (v) => {
    const w = v === window ? v.document.documentElement : v === document ? v.documentElement : v, { display: _, flexDirection: y } = getComputedStyle(w), L = w.scrollLeft;
    T.left = L < c.value, T.right = L > c.value;
    const D = Math.abs(L) <= 0 + (o.left || 0), R = Math.abs(L) + w.clientWidth >= w.scrollWidth - (o.right || 0) - xn;
    _ === "flex" && y === "row-reverse" ? (m.left = R, m.right = D) : (m.left = D, m.right = R), c.value = L;
    let k = w.scrollTop;
    v === document && !k && (k = document.body.scrollTop), T.top = k < u.value, T.bottom = k > u.value;
    const X = Math.abs(k) <= 0 + (o.top || 0), se = Math.abs(k) + w.clientHeight >= w.scrollHeight - (o.bottom || 0) - xn;
    _ === "flex" && y === "column-reverse" ? (m.top = se, m.bottom = X) : (m.top = X, m.bottom = se), u.value = k;
  }, f = (v) => {
    const w = v.target === document ? v.target.documentElement : v.target;
    E(w), g.value = !0, S(v), i(v);
  };
  return de(
    l,
    "scroll",
    t ? ba(f, t, !0, !1) : f,
    r
  ), de(
    l,
    "scrollend",
    x,
    r
  ), {
    x: h,
    y: p,
    isScrolling: g,
    arrivedState: m,
    directions: T,
    measure() {
      const v = ze(l);
      v && E(v);
    }
  };
}
const Ia = {
  page: (l) => [l.pageX, l.pageY],
  client: (l) => [l.clientX, l.clientY],
  screen: (l) => [l.screenX, l.screenY],
  movement: (l) => l instanceof Touch ? null : [l.movementX, l.movementY]
};
function Ca(l = {}) {
  const {
    type: e = "page",
    touch: t = !0,
    resetOnTouchEnds: s = !1,
    initialValue: n = { x: 0, y: 0 },
    window: i = Pt,
    target: o = i,
    eventFilter: r
  } = l, a = G(n.x), c = G(n.y), u = G(null), h = typeof e == "function" ? e : Ia[e], p = (x) => {
    const S = h(x);
    S && ([a.value, c.value] = S, u.value = "mouse");
  }, d = (x) => {
    if (x.touches.length > 0) {
      const S = h(x.touches[0]);
      S && ([a.value, c.value] = S, u.value = "touch");
    }
  }, g = () => {
    a.value = n.x, c.value = n.y;
  }, m = r ? (x) => r(() => p(x), {}) : (x) => p(x), T = r ? (x) => r(() => d(x), {}) : (x) => d(x);
  return o && (de(o, "mousemove", m, { passive: !0 }), de(o, "dragover", m, { passive: !0 }), t && e !== "movement" && (de(o, "touchstart", T, { passive: !0 }), de(o, "touchmove", T, { passive: !0 }), s && de(o, "touchend", g, { passive: !0 }))), {
    x: a,
    y: c,
    sourceType: u
  };
}
function ka({ window: l = Pt } = {}) {
  if (!l)
    return {
      x: G(0),
      y: G(0)
    };
  const e = G(l.scrollX), t = G(l.scrollY);
  return de(
    l,
    "scroll",
    () => {
      e.value = l.scrollX, t.value = l.scrollY;
    },
    {
      capture: !1,
      passive: !0
    }
  ), { x: e, y: t };
}
function fi(l = {}) {
  const {
    window: e = Pt,
    initialWidth: t = 1 / 0,
    initialHeight: s = 1 / 0,
    listenOrientation: n = !0,
    includeScrollbar: i = !0
  } = l, o = G(t), r = G(s), a = () => {
    e && (i ? (o.value = e.innerWidth, r.value = e.innerHeight) : (o.value = e.document.documentElement.clientWidth, r.value = e.document.documentElement.clientHeight));
  };
  if (a(), Sa(a), de("resize", a, { passive: !0 }), n) {
    const c = Ra("(orientation: portrait)");
    Me(c, () => a());
  }
  return { width: o, height: r };
}
const Yl = /* @__PURE__ */ te({
  __name: "MouseParallax",
  props: {
    disabled: { type: Boolean, default: !1 },
    factor: { default: 2.5 },
    ease: { default: 0.1 }
  },
  setup(l) {
    const e = l, { camera: t } = Le(), { disabled: s, factor: n, ease: i } = pe(e), { x: o, y: r } = Ca(), { width: a, height: c } = fi(), u = G(), h = Ne(() => (o.value / a.value - 0.5) * n.value), p = Ne(() => -(r.value / c.value - 0.5) * n.value), { onLoop: d } = Ce();
    return d(({ delta: g }) => {
      s.value || !u.value || (u.value.position.x += (h.value - u.value.position.x) * i.value * g, u.value.position.y += (p.value - u.value.position.y) * i.value * g);
    }), Me(
      () => u.value,
      (g) => {
        g == null || g.add(t.value);
      }
    ), (g, m) => (Q(), J("TresGroup", {
      ref_key: "cameraGroupRef",
      ref: u
    }, null, 512));
  }
});
let Jt = null;
function Fa(l, e) {
  return (t) => {
    e && e(t), l.draco && (Jt || (Jt = new ia()), Jt.setDecoderPath(l.decoderPath || "https://www.gstatic.com/draco/versioned/decoders/1.4.3/"), t.setDRACOLoader(Jt));
  };
}
async function Ua(l, e = {
  draco: !1
}, t) {
  return await Ks(qo, l, Fa(e, t));
}
const Xl = /* @__PURE__ */ te({
  __name: "component",
  props: {
    path: {},
    draco: { type: Boolean, default: !1 },
    decoderPath: { default: "https://www.gstatic.com/draco/versioned/decoders/1.4.1/" }
  },
  async setup(l, { expose: e }) {
    let t, s;
    const n = l, i = G();
    e({
      value: i
    });
    const { scene: o } = ([t, s] = ls(() => Ua(n.path, {
      draco: n.draco,
      decoderPath: n.decoderPath
    })), t = await t, s(), t);
    return (r, a) => {
      const c = Gs("primitive");
      return Q(), kn(c, Te({
        ref_key: "modelRef",
        ref: i,
        object: M(o)
      }, r.$attrs), null, 16, ["object"]);
    };
  }
});
async function Ba(l) {
  return await Ks(Nr, l);
}
const jl = /* @__PURE__ */ te({
  __name: "component",
  props: {
    path: {}
  },
  async setup(l, { expose: e }) {
    let t, s;
    const n = l, i = G();
    e({
      value: i
    });
    const o = ([t, s] = ls(() => Ba(n.path)), t = await t, s(), t);
    return (r, a) => {
      const c = Gs("primitive");
      return Q(), kn(c, Te({
        ref_key: "modelRef",
        ref: i,
        object: M(o)
      }, r.$attrs), null, 16, ["object"]);
    };
  }
}), bn = "[TresJS - Cientos ▲ ■ ♥] ";
function za() {
  function l(s, n) {
    console.error(`${bn} ${s}`, n || "");
  }
  function e(s) {
    console.warn(`${bn} ${s}`);
  }
  function t(s, n) {
  }
  return {
    logError: l,
    logWarning: e,
    logMessage: t
  };
}
let Ss = 0;
function Zl() {
  const l = G(!1), e = G(0), t = G([]), { logError: s } = za();
  return new Promise((n) => {
    Wt.onStart = () => {
      l.value = !1;
    }, Wt.onLoad = () => {
      l.value = !0;
    }, Wt.onProgress = (i, o, r) => {
      o === r && (Ss = r, l.value = !0, t.value.push(i)), e.value = Math.round((o - Ss) / (r - Ss) * 100 || 100, 2);
    }, Wt.onError = (i) => {
      s("Error loading assets", new Error(i)), l.value = !0;
    }, n({
      items: t,
      hasFinishLoading: l,
      progress: e
    });
  });
}
const Na = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "damping-factor", "enable-pan", "key-pan-speed", "keys", "max-azimuth-angle", "min-azimuth-angle", "max-polar-angle", "min-polar-angle", "min-distance", "max-distance", "min-zoom", "max-zoom", "touches", "enable-zoom", "zoom-speed", "enable-rotate", "rotate-speed", "args"], Kl = /* @__PURE__ */ te({
  __name: "OrbitControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    target: { default: () => [0, 0, 0] },
    enableDamping: { type: Boolean, default: !1 },
    dampingFactor: { default: 0.05 },
    autoRotate: { type: Boolean, default: !1 },
    autoRotateSpeed: { default: 2 },
    enablePan: { type: Boolean, default: !0 },
    keyPanSpeed: { default: 7 },
    keys: {},
    maxAzimuthAngle: { default: 1 / 0 },
    minAzimuthAngle: { default: -1 / 0 },
    maxPolarAngle: { default: Math.PI },
    minPolarAngle: { default: 0 },
    minDistance: { default: 0 },
    maxDistance: { default: 1 / 0 },
    minZoom: { default: 0 },
    maxZoom: { default: 1 / 0 },
    touches: { default: () => ({ ONE: Ye.ROTATE, TWO: Ye.DOLLY_PAN }) },
    enableZoom: { type: Boolean, default: !0 },
    zoomSpeed: { default: 1 },
    enableRotate: { type: Boolean, default: !0 },
    rotateSpeed: { default: 1 }
  },
  emits: ["change", "start", "end"],
  setup(l, { emit: e }) {
    const t = l, {
      makeDefault: s,
      autoRotate: n,
      autoRotateSpeed: i,
      enableDamping: o,
      dampingFactor: r,
      enablePan: a,
      keyPanSpeed: c,
      maxAzimuthAngle: u,
      minAzimuthAngle: h,
      maxPolarAngle: p,
      minPolarAngle: d,
      minDistance: g,
      maxDistance: m,
      minZoom: T,
      maxZoom: x,
      enableZoom: S,
      zoomSpeed: E,
      enableRotate: f,
      touches: v,
      rotateSpeed: w,
      target: _
    } = pe(t), { camera: y, renderer: L, extend: D, controls: R } = Le(), k = G(null);
    D({ OrbitControls: ii }), Me(k, (V) => {
      X(), V && s.value ? R.value = V : R.value = null;
    });
    function X() {
      de(k.value, "change", () => e("change", k.value)), de(k.value, "start", () => e("start", k.value)), de(k.value, "end", () => e("end", k.value));
    }
    const { onLoop: se } = Ce();
    return se(() => {
      k.value && (o.value || n.value) && k.value.update();
    }), Lt(() => {
      k.value && k.value.dispose();
    }), (V, ae) => {
      var j;
      return M(y) && M(L) ? (Q(), J("TresOrbitControls", {
        key: 0,
        ref_key: "controlsRef",
        ref: k,
        target: M(_),
        "auto-rotate": M(n),
        "auto-rotate-speed": M(i),
        "enable-damping": M(o),
        "damping-factor": M(r),
        "enable-pan": M(a),
        "key-pan-speed": M(c),
        keys: V.keys,
        "max-azimuth-angle": M(u),
        "min-azimuth-angle": M(h),
        "max-polar-angle": M(p),
        "min-polar-angle": M(d),
        "min-distance": M(g),
        "max-distance": M(m),
        "min-zoom": M(T),
        "max-zoom": M(x),
        touches: M(v),
        "enable-zoom": M(S),
        "zoom-speed": M(E),
        "enable-rotate": M(f),
        "rotate-speed": M(w),
        args: [M(y) || V.camera, ((j = M(L)) == null ? void 0 : j.domElement) || V.domElement]
      }, null, 8, Na)) : lt("", !0);
    };
  }
}), Ha = 5, Va = 6, Ga = 0.3, Ql = /* @__PURE__ */ te({
  __name: "KeyboardControls",
  props: {
    forward: { default: () => ["w", "W"] },
    back: { default: () => ["s", "S"] },
    left: { default: () => ["a", "A"] },
    right: { default: () => ["d", "D"] },
    jump: { default: () => [" "] },
    gravity: { default: 9.8 },
    moveSpeed: { default: 0.1 },
    headBobbing: { type: Boolean, default: !1 },
    is2D: { type: Boolean, default: !1 }
  },
  setup(l) {
    var D;
    const e = l, { forward: t, back: s, left: n, right: i, jump: o, gravity: r, moveSpeed: a, headBobbing: c, is2D: u } = pe(e), { camera: h, controls: p } = Le(), d = G(0), g = G(0), m = G(!1), T = G(!1), x = G(0), S = ue(), E = u.value ? "y" : "z";
    let f = ((D = h.value.position) == null ? void 0 : D.y) || 0;
    ft(
      t.value,
      () => {
        m.value = !0, g.value = a.value;
      },
      { eventName: "keydown" }
    ), ft(
      s.value,
      () => {
        m.value = !0, g.value = -a.value;
      },
      { eventName: "keydown" }
    ), ft(
      [...t.value, ...s.value],
      () => {
        m.value = !1, g.value = 0;
      },
      { eventName: "keyup" }
    ), ft(
      n.value,
      () => {
        m.value = !0, d.value = -a.value;
      },
      { eventName: "keydown" }
    ), ft(
      i.value,
      () => {
        m.value = !0, d.value = a.value;
      },
      { eventName: "keydown" }
    ), ft(
      [...n.value, ...i.value],
      () => {
        m.value = !1, d.value = 0;
      },
      { eventName: "keyup" }
    ), ft(o.value, () => {
      T.value || (x.value = Date.now()), T.value = !0;
    });
    const v = (R) => m.value ? Math.sin(R * Ha) * Ga + f : f, w = () => (Date.now() - x.value) / 1e3 * 3, _ = (R) => f + Va * R - 0.5 * r.value * Math.pow(R, 2), y = () => {
      if (T.value) {
        const R = _(w());
        return R <= f && (T.value = !1), R;
      }
      return 0;
    }, { onLoop: L } = Ce();
    return L(({ elapsed: R }) => {
      var k;
      p.value instanceof Ns && ((k = p.value) != null && k.isLocked) ? (p.value.moveForward(g.value), p.value.moveRight(d.value), h.value.position && (h.value.position.y = c.value ? v(R) : f, h.value.position.y += y())) : S.value.children.length > 0 && !(p.value instanceof Ns) && (S.value.position.x += d.value, S.value.position[E] += u.value ? g.value : -g.value);
    }), (R, k) => (Q(), J("TresGroup", {
      ref_key: "wrapperRef",
      ref: S
    }, [
      Ee(R.$slots, "default")
    ], 512));
  }
}), Ya = ["object", "args", "mode", "enabled", "axis", "translation-snap", "rotation-snap", "scale-snap", "space", "size", "show-x", "show-y", "show-z"], $l = /* @__PURE__ */ te({
  __name: "TransformControls",
  props: {
    object: {},
    mode: { default: "translate" },
    enabled: { type: Boolean, default: !0 },
    axis: { default: "XYZ" },
    translationSnap: {},
    rotationSnap: {},
    scaleSnap: {},
    space: { default: "world" },
    size: { default: 1 },
    showX: { type: Boolean, default: !0 },
    showY: { type: Boolean, default: !0 },
    showZ: { type: Boolean, default: !0 }
  },
  emits: ["dragging", "change", "mouseDown", "mouseUp", "objectChange"],
  setup(l, { emit: e }) {
    const t = l, { object: s, mode: n, enabled: i, axis: o, translationSnap: r, rotationSnap: a, scaleSnap: c, space: u, size: h, showX: p, showY: d, showZ: g } = pe(t), m = ue(), { controls: T, camera: x, renderer: S, extend: E } = Le();
    E({ TransformControls: Ho });
    const f = (w) => {
      T.value && (T.value.enabled = !w.value), e("dragging", w.value);
    };
    function v() {
      de(m.value, "change", () => e("change")), de(m.value, "dragging-changed", f), de(m.value, "mouseDown", () => e("mouseDown")), de(m.value, "mouseUp", () => e("mouseUp")), de(m.value, "objectChange", () => e("objectChange"));
    }
    return at(() => {
      m.value && v();
    }), Lt(() => {
      m.value && m.value.dispose();
    }), (w, _) => M(x) && M(S) ? (Q(), J("TresTransformControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: m,
      object: M(s),
      args: [M(x), M(S).domElement],
      mode: M(n),
      enabled: M(i),
      axis: M(o),
      "translation-snap": M(r),
      "rotation-snap": M(a),
      "scale-snap": M(c),
      space: M(u),
      size: M(h),
      "show-x": M(p),
      "show-y": M(d),
      "show-z": M(g),
      visible: !0
    }, null, 8, Ya)) : lt("", !0);
  }
}), Xa = ["args"], Wl = /* @__PURE__ */ te({
  __name: "PointerLockControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    selector: {}
  },
  emits: ["isLock"],
  setup(l, { expose: e, emit: t }) {
    const s = l, { camera: n, renderer: i, extend: o, controls: r } = Le(), a = G(null);
    let c;
    o({ PointerLockControls: Ns });
    const u = (h) => {
      t("isLock", h);
    };
    return Me(a, (h) => {
      h && s.makeDefault ? r.value = h : r.value = null;
      const p = document.getElementById(s.selector || "");
      c = p || i.value.domElement, de(c, "click", () => {
        var d, g, m;
        (d = r.value) == null || d.lock(), (g = r.value) == null || g.addEventListener("lock", () => u(!0)), (m = r.value) == null || m.addEventListener("unlock", () => u(!1));
      });
    }), Lt(() => {
      var h, p;
      (h = r.value) == null || h.removeEventListener("lock", () => u(!0)), (p = r.value) == null || p.removeEventListener("unlock", () => u(!1)), a.value && a.value.dispose();
    }), e({
      value: r
    }), (h, p) => {
      var d;
      return M(n) && M(i) ? (Q(), J("TresPointerLockControls", {
        key: 0,
        ref_key: "controlsRef",
        ref: a,
        args: [M(n) || h.camera, ((d = M(i)) == null ? void 0 : d.domElement) || h.domElement]
      }, null, 8, Xa)) : lt("", !0);
    };
  }
}), ja = ["args"], ql = /* @__PURE__ */ te({
  __name: "MapControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {}
  },
  setup(l) {
    const e = l, { camera: t, renderer: s, extend: n, controls: i } = Le(), o = G(null);
    return n({ MapControls: Wo }), Me(i, (r) => {
      r && e.makeDefault ? i.value = r : i.value = null;
    }), Lt(() => {
      o.value && o.value.dispose();
    }), (r, a) => {
      var c;
      return M(t) && M(s) ? (Q(), J("TresMapControls", {
        key: 0,
        ref_key: "controlsRef",
        ref: o,
        args: [M(t) || r.camera, ((c = M(s)) == null ? void 0 : c.domElement) || r.domElement]
      }, null, 8, ja)) : lt("", !0);
    };
  }
}), Jl = /* @__PURE__ */ te({
  __name: "ScrollControls",
  props: {
    pages: { default: 4 },
    distance: { default: 4 },
    smoothScroll: { default: 0.1 },
    horizontal: { type: Boolean, default: !1 },
    htmlScroll: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(l, { emit: e }) {
    const t = l, { logWarning: s } = wo();
    t.smoothScroll < 0 && s("SmoothControl must be greater than zero"), t.pages < 0 && s("Pages must be greater than zero");
    const { camera: n, controls: i, renderer: o } = Le(), r = ue(), a = document.createElement("div"), { y: c } = ka(), { x: u, y: h, isScrolling: p } = Da(a), { height: d, width: g } = fi();
    let m = 0;
    const T = G(!1), x = G(0), S = G(0), E = G(0), f = t.horizontal ? "x" : "y", v = Me(
      n,
      (_) => {
        if (T.value) {
          v();
          return;
        }
        m = t.horizontal ? (_ == null ? void 0 : _.position.x) || 0 : (_ == null ? void 0 : _.position.y) || 0, T.value = !0;
      },
      {
        immediate: !0
      }
    );
    Me(
      p,
      (_) => {
        i.value && (i.value.enabled = !_);
      },
      {
        immediate: !0
      }
    ), Me(c, (_) => {
      !p.value && !t.htmlScroll || (S.value = parseFloat((_ / d.value / (E.value / d.value - 1)).toFixed(2)), x.value = -1 * S.value, e("update:modelValue", S.value));
    }), Me(h, (_) => {
      S.value = parseFloat((_ / d.value / (E.value / d.value)).toFixed(2)), x.value = -1 * S.value, e("update:modelValue", S.value);
    }), Me(u, (_) => {
      S.value = parseFloat((_ / g.value / (E.value / g.value - 1)).toFixed(2)), x.value = +S.value, e("update:modelValue", S.value);
    }), Me(
      o,
      (_) => {
        var L, D;
        const y = _ == null ? void 0 : _.domElement;
        if (t.htmlScroll && (_ != null && _.domElement))
          y != null && y.style.width && (y != null && y.style.position) && (y != null && y.style.top) && (y != null && y.style.left) && (y.style.width = "100%", y.style.position = "fixed", y.style.zIndex = " -99999", y.style.top = "0", y.style.left = "0"), E.value = document.body.scrollHeight;
        else {
          const R = document.createElement("div"), k = document.createElement("div");
          a.style[t.horizontal ? "overflowX" : "overflowY"] = "auto", a.style[t.horizontal ? "overflowY" : "overflowX"] = "hidden", a.style.position = "absolute", a.style.width = "100%", a.style.height = " 100%", a.style.top = "0", a.style.left = "0", a.classList.add("scrollContainer"), R.style.position = "sticky", R.style.top = "0px", R.style.left = "0px", R.style.width = "100%", R.style.height = "100%", R.style.overflow = "hidden", a.appendChild(R), k.style.height = t.horizontal ? "100%" : `${d.value * t.pages}px`, k.style.width = t.horizontal ? `${g.value * t.pages}px` : "100vw", k.style.pointerEvents = "none", y.style.position = "fixed", y.style.zIndex = "0", y != null && y.style.width && (y.style.width = "100%"), a.appendChild(k), _.domElement.parentNode.style.position = "relative", (D = (L = _ == null ? void 0 : _.domElement) == null ? void 0 : L.parentNode) == null || D.appendChild(a), E.value = t.horizontal ? g.value * t.pages : d.value * t.pages;
        }
      },
      {
        immediate: !0
      }
    );
    const { onLoop: w } = Ce();
    return w(() => {
      var _;
      if ((_ = n.value) != null && _.position) {
        const y = (x.value * t.distance - n.value.position[f] + m) * t.smoothScroll;
        n.value.position[f] += y, r.value.children.length > 0 && (r.value.position[f] += y);
      }
    }), (_, y) => (Q(), J("TresGroup", {
      ref_key: "wrapperRef",
      ref: r
    }, [
      Ee(_.$slots, "default")
    ], 512));
  }
});
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const B = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
}, P = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
}), wt = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function mt(l) {
  return l.isPerspectiveCamera;
}
function tt(l) {
  return l.isOrthographicCamera;
}
const At = Math.PI * 2, Sn = Math.PI / 2, mi = 1e-5, It = Math.PI / 180;
function Ge(l, e, t) {
  return Math.max(e, Math.min(t, l));
}
function le(l, e = mi) {
  return Math.abs(l) < e;
}
function ie(l, e, t = mi) {
  return le(l - e, t);
}
function Mn(l, e) {
  return Math.round(l / e) * e;
}
function Ct(l) {
  return isFinite(l) ? l : l < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function kt(l) {
  return Math.abs(l) < Number.MAX_VALUE ? l : l * (1 / 0);
}
function es(l, e, t, s, n = 1 / 0, i) {
  s = Math.max(1e-4, s);
  const o = 2 / s, r = o * i, a = 1 / (1 + r + 0.48 * r * r + 0.235 * r * r * r);
  let c = l - e;
  const u = e, h = n * s;
  c = Ge(c, -h, h), e = l - c;
  const p = (t.value + o * c) * i;
  t.value = (t.value - o * p) * a;
  let d = e + (c + p) * a;
  return u - l > 0 == d > u && (d = u, t.value = (d - u) / i), d;
}
function On(l, e, t, s, n = 1 / 0, i, o) {
  s = Math.max(1e-4, s);
  const r = 2 / s, a = r * i, c = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let u = e.x, h = e.y, p = e.z, d = l.x - u, g = l.y - h, m = l.z - p;
  const T = u, x = h, S = p, E = n * s, f = E * E, v = d * d + g * g + m * m;
  if (v > f) {
    const V = Math.sqrt(v);
    d = d / V * E, g = g / V * E, m = m / V * E;
  }
  u = l.x - d, h = l.y - g, p = l.z - m;
  const w = (t.x + r * d) * i, _ = (t.y + r * g) * i, y = (t.z + r * m) * i;
  t.x = (t.x - r * w) * c, t.y = (t.y - r * _) * c, t.z = (t.z - r * y) * c, o.x = u + (d + w) * c, o.y = h + (g + _) * c, o.z = p + (m + y) * c;
  const L = T - l.x, D = x - l.y, R = S - l.z, k = o.x - T, X = o.y - x, se = o.z - S;
  return L * k + D * X + R * se > 0 && (o.x = T, o.y = x, o.z = S, t.x = (o.x - T) / i, t.y = (o.y - x) / i, t.z = (o.z - S) / i), o;
}
function Ms(l, e) {
  e.set(0, 0), l.forEach((t) => {
    e.x += t.clientX, e.y += t.clientY;
  }), e.x /= l.length, e.y /= l.length;
}
function Os(l, e) {
  return tt(l) ? (console.warn(`${e} is not supported in OrthographicCamera`), !0) : !1;
}
class Za {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    const s = this._listeners;
    s[e] === void 0 && (s[e] = []), s[e].indexOf(t) === -1 && s[e].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(e, t) {
    const s = this._listeners;
    return s[e] !== void 0 && s[e].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    const n = this._listeners[e];
    if (n !== void 0) {
      const i = n.indexOf(t);
      i !== -1 && n.splice(i, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(e) {
    if (!e) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(e) {
    const s = this._listeners[e.type];
    if (s !== void 0) {
      e.target = this;
      const n = s.slice(0);
      for (let i = 0, o = n.length; i < o; i++)
        n[i].call(this, e);
    }
  }
}
const Ka = "2.7.0", ts = 1 / 8, gi = typeof window < "u", Qa = gi && /Mac/.test(navigator.platform), $a = !(gi && "PointerEvent" in window);
let U, Ln, ss, Ls, Ae, H, ee, xt, Ft, He, Ve, gt, Pn, Rn, Re, Ut, bt, Dn, Ps, In, Rs, Ds, ns;
class Yt extends Za {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(e) {
    U = e.THREE, Ln = Object.freeze(new U.Vector3(0, 0, 0)), ss = Object.freeze(new U.Vector3(0, 1, 0)), Ls = Object.freeze(new U.Vector3(0, 0, 1)), Ae = new U.Vector2(), H = new U.Vector3(), ee = new U.Vector3(), xt = new U.Vector3(), Ft = new U.Vector3(), He = new U.Vector3(), Ve = new U.Vector3(), gt = new U.Vector3(), Pn = new U.Vector3(), Rn = new U.Vector3(), Re = new U.Spherical(), Ut = new U.Spherical(), bt = new U.Box3(), Dn = new U.Box3(), Ps = new U.Sphere(), In = new U.Quaternion(), Rs = new U.Quaternion(), Ds = new U.Matrix4(), ns = new U.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return P;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(e, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = P.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = wt.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new U.Vector3(), this._focalOffsetVelocity = new U.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (f, v, w) => {
      let _, y;
      if (mt(this._camera)) {
        const L = H.copy(this._camera.position).sub(this._target), D = this._camera.getEffectiveFOV() * It, R = L.length() * Math.tan(D * 0.5);
        _ = this.truckSpeed * f * R / this._elementRect.height, y = this.truckSpeed * v * R / this._elementRect.height;
      } else if (tt(this._camera)) {
        const L = this._camera;
        _ = f * (L.right - L.left) / L.zoom / this._elementRect.width, y = v * (L.top - L.bottom) / L.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (w ? this.setFocalOffset(this._focalOffsetEnd.x + _, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(_, 0, !0), this.forward(-y, !0)) : w ? this.setFocalOffset(this._focalOffsetEnd.x + _, this._focalOffsetEnd.y + y, this._focalOffsetEnd.z, !0) : this.truck(_, y, !0);
    }, this._rotateInternal = (f, v) => {
      const w = At * this.azimuthRotateSpeed * f / this._elementRect.height, _ = At * this.polarRotateSpeed * v / this._elementRect.height;
      this.rotate(w, _, !0);
    }, this._dollyInternal = (f, v, w) => {
      const _ = Math.pow(0.95, -f * this.dollySpeed), y = this._sphericalEnd.radius, L = this._sphericalEnd.radius * _, D = U.MathUtils.clamp(L, this.minDistance, this.maxDistance), R = D - L;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(L, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(R, !0), this._dollyToNoClamp(D, !0)) : this._dollyToNoClamp(D, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? L : D) - y, this._dollyControlCoord.set(v, w)), this._lastDollyDirection = Math.sign(-f);
    }, this._zoomInternal = (f, v, w) => {
      const _ = Math.pow(0.95, f * this.dollySpeed), y = this._zoom, L = this._zoom * _;
      this.zoomTo(L, !0), this.dollyToCursor && (this._changedZoom += L - y, this._dollyControlCoord.set(v, w));
    }, typeof U > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new U.Quaternion().setFromUnitVectors(this._camera.up, ss), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = P.NONE, this._target = new U.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new U.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new U.Spherical().setFromVector3(H.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new U.Vector3(),
      new U.Vector3(),
      new U.Vector3(),
      new U.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new U.Box3(new U.Vector3(-1 / 0, -1 / 0, -1 / 0), new U.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new U.Vector2(), this.mouseButtons = {
      left: P.ROTATE,
      middle: P.DOLLY,
      right: P.TRUCK,
      wheel: mt(this._camera) ? P.DOLLY : tt(this._camera) ? P.ZOOM : P.NONE
    }, this.touches = {
      one: P.TOUCH_ROTATE,
      two: mt(this._camera) ? P.TOUCH_DOLLY_TRUCK : tt(this._camera) ? P.TOUCH_ZOOM_TRUCK : P.NONE,
      three: P.TOUCH_TRUCK
    };
    const s = new U.Vector2(), n = new U.Vector2(), i = new U.Vector2(), o = (f) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const _ = this._domElement.getBoundingClientRect(), y = f.clientX / _.width, L = f.clientY / _.height;
        if (y < this._interactiveArea.left || y > this._interactiveArea.right || L < this._interactiveArea.top || L > this._interactiveArea.bottom)
          return;
      }
      const v = f.pointerType !== "mouse" ? null : (f.buttons & B.LEFT) === B.LEFT ? B.LEFT : (f.buttons & B.MIDDLE) === B.MIDDLE ? B.MIDDLE : (f.buttons & B.RIGHT) === B.RIGHT ? B.RIGHT : null;
      if (v !== null) {
        const _ = this._findPointerByMouseButton(v);
        _ && this._disposePointer(_);
      }
      if ((f.buttons & B.LEFT) === B.LEFT && this._lockedPointer)
        return;
      const w = {
        pointerId: f.pointerId,
        clientX: f.clientX,
        clientY: f.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: v
      };
      this._activePointers.push(w), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", u), this._isDragging = !0, m(f);
    }, r = (f) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const _ = this._domElement.getBoundingClientRect(), y = f.clientX / _.width, L = f.clientY / _.height;
        if (y < this._interactiveArea.left || y > this._interactiveArea.right || L < this._interactiveArea.top || L > this._interactiveArea.bottom)
          return;
      }
      const v = (f.buttons & B.LEFT) === B.LEFT ? B.LEFT : (f.buttons & B.MIDDLE) === B.MIDDLE ? B.MIDDLE : (f.buttons & B.RIGHT) === B.RIGHT ? B.RIGHT : null;
      if (v !== null) {
        const _ = this._findPointerByMouseButton(v);
        _ && this._disposePointer(_);
      }
      const w = {
        pointerId: 1,
        clientX: f.clientX,
        clientY: f.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (f.buttons & B.LEFT) === B.LEFT ? B.LEFT : (f.buttons & B.MIDDLE) === B.LEFT ? B.MIDDLE : (f.buttons & B.RIGHT) === B.LEFT ? B.RIGHT : null
      };
      this._activePointers.push(w), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", h), this._domElement.ownerDocument.addEventListener("mousemove", c), this._domElement.ownerDocument.addEventListener("mouseup", h), this._isDragging = !0, m(f);
    }, a = (f) => {
      f.cancelable && f.preventDefault();
      const v = f.pointerId, w = this._lockedPointer || this._findPointerById(v);
      if (w) {
        if (w.clientX = f.clientX, w.clientY = f.clientY, w.deltaX = f.movementX, w.deltaY = f.movementY, this._state = 0, f.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (f.buttons & B.LEFT) === B.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (f.buttons & B.MIDDLE) === B.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (f.buttons & B.RIGHT) === B.RIGHT && (this._state = this._state | this.mouseButtons.right);
        T();
      }
    }, c = (f) => {
      const v = this._lockedPointer || this._findPointerById(1);
      v && (v.clientX = f.clientX, v.clientY = f.clientY, v.deltaX = f.movementX, v.deltaY = f.movementY, this._state = 0, (this._lockedPointer || (f.buttons & B.LEFT) === B.LEFT) && (this._state = this._state | this.mouseButtons.left), (f.buttons & B.MIDDLE) === B.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (f.buttons & B.RIGHT) === B.RIGHT && (this._state = this._state | this.mouseButtons.right), T());
    }, u = (f) => {
      const v = this._findPointerById(f.pointerId);
      if (!(v && v === this._lockedPointer)) {
        if (v && this._disposePointer(v), f.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = P.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = P.NONE;
        x();
      }
    }, h = () => {
      const f = this._findPointerById(1);
      f && f === this._lockedPointer || (f && this._disposePointer(f), this._state = P.NONE, x());
    };
    let p = -1;
    const d = (f) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === P.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const L = this._domElement.getBoundingClientRect(), D = f.clientX / L.width, R = f.clientY / L.height;
        if (D < this._interactiveArea.left || D > this._interactiveArea.right || R < this._interactiveArea.top || R > this._interactiveArea.bottom)
          return;
      }
      if (f.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === P.ROTATE || this.mouseButtons.wheel === P.TRUCK) {
        const L = performance.now();
        p - L < 1e3 && this._getClientRect(this._elementRect), p = L;
      }
      const v = Qa ? -1 : -3, w = f.deltaMode === 1 ? f.deltaY / v : f.deltaY / (v * 10), _ = this.dollyToCursor ? (f.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, y = this.dollyToCursor ? (f.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case P.ROTATE: {
          this._rotateInternal(f.deltaX, f.deltaY), this._isUserControllingRotate = !0;
          break;
        }
        case P.TRUCK: {
          this._truckInternal(f.deltaX, f.deltaY, !1), this._isUserControllingTruck = !0;
          break;
        }
        case P.OFFSET: {
          this._truckInternal(f.deltaX, f.deltaY, !0), this._isUserControllingOffset = !0;
          break;
        }
        case P.DOLLY: {
          this._dollyInternal(-w, _, y), this._isUserControllingDolly = !0;
          break;
        }
        case P.ZOOM: {
          this._zoomInternal(-w, _, y), this._isUserControllingZoom = !0;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, g = (f) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === Yt.ACTION.NONE) {
          const v = f instanceof PointerEvent ? f.pointerId : (f instanceof MouseEvent, 0), w = this._findPointerById(v);
          w && this._disposePointer(w), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", h);
          return;
        }
        f.preventDefault();
      }
    }, m = (f) => {
      if (!this._enabled)
        return;
      if (Ms(this._activePointers, Ae), this._getClientRect(this._elementRect), s.copy(Ae), n.copy(Ae), this._activePointers.length >= 2) {
        const w = Ae.x - this._activePointers[1].clientX, _ = Ae.y - this._activePointers[1].clientY, y = Math.sqrt(w * w + _ * _);
        i.set(0, y);
        const L = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, D = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        n.set(L, D);
      }
      if (this._state = 0, !f)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in f && f.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (f.buttons & B.LEFT) === B.LEFT && (this._state = this._state | this.mouseButtons.left), (f.buttons & B.MIDDLE) === B.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (f.buttons & B.RIGHT) === B.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & P.ROTATE) === P.ROTATE || (this._state & P.TOUCH_ROTATE) === P.TOUCH_ROTATE || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & P.TRUCK) === P.TRUCK || (this._state & P.TOUCH_TRUCK) === P.TOUCH_TRUCK || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & P.DOLLY) === P.DOLLY || (this._state & P.TOUCH_DOLLY) === P.TOUCH_DOLLY || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & P.ZOOM) === P.ZOOM || (this._state & P.TOUCH_ZOOM) === P.TOUCH_ZOOM || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & P.OFFSET) === P.OFFSET || (this._state & P.TOUCH_OFFSET) === P.TOUCH_OFFSET || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, T = () => {
      if (!this._enabled)
        return;
      Ms(this._activePointers, Ae);
      const v = this._domElement && document.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, w = v ? -v.deltaX : n.x - Ae.x, _ = v ? -v.deltaY : n.y - Ae.y;
      if (n.copy(Ae), ((this._state & P.ROTATE) === P.ROTATE || (this._state & P.TOUCH_ROTATE) === P.TOUCH_ROTATE || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(w, _), this._isUserControllingRotate = !0), (this._state & P.DOLLY) === P.DOLLY || (this._state & P.ZOOM) === P.ZOOM) {
        const y = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, L = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, D = this.dollyDragInverted ? -1 : 1;
        (this._state & P.DOLLY) === P.DOLLY ? (this._dollyInternal(D * _ * ts, y, L), this._isUserControllingDolly = !0) : (this._zoomInternal(D * _ * ts, y, L), this._isUserControllingZoom = !0);
      }
      if ((this._state & P.TOUCH_DOLLY) === P.TOUCH_DOLLY || (this._state & P.TOUCH_ZOOM) === P.TOUCH_ZOOM || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) {
        const y = Ae.x - this._activePointers[1].clientX, L = Ae.y - this._activePointers[1].clientY, D = Math.sqrt(y * y + L * L), R = i.y - D;
        i.set(0, D);
        const k = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, X = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & P.TOUCH_DOLLY) === P.TOUCH_DOLLY || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(R * ts, k, X), this._isUserControllingDolly = !0) : (this._zoomInternal(R * ts, k, X), this._isUserControllingZoom = !0);
      }
      ((this._state & P.TRUCK) === P.TRUCK || (this._state & P.TOUCH_TRUCK) === P.TOUCH_TRUCK || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK) && (this._truckInternal(w, _, !1), this._isUserControllingTruck = !0), ((this._state & P.OFFSET) === P.OFFSET || (this._state & P.TOUCH_OFFSET) === P.TOUCH_OFFSET || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET) && (this._truckInternal(w, _, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
    }, x = () => {
      Ms(this._activePointers, Ae), n.copy(Ae), (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mouseup", h), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", S), this._domElement.ownerDocument.addEventListener("pointerlockerror", E), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", u), m());
    }, this.unlockPointer = () => {
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), document.exitPointerLock(), this.cancel(), this._domElement && (this._domElement.ownerDocument.removeEventListener("pointerlockchange", S), this._domElement.ownerDocument.removeEventListener("pointerlockerror", E));
    };
    const S = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, E = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (f) => {
      this._domElement = f, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", o), $a && this._domElement.addEventListener("mousedown", r), this._domElement.addEventListener("pointercancel", u), this._domElement.addEventListener("wheel", d, { passive: !1 }), this._domElement.addEventListener("contextmenu", g);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", o), this._domElement.removeEventListener("mousedown", r), this._domElement.removeEventListener("pointercancel", u), this._domElement.removeEventListener("wheel", d, { passive: !1 }), this._domElement.removeEventListener("contextmenu", g), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mouseup", h), this._domElement.ownerDocument.removeEventListener("pointerlockchange", S), this._domElement.ownerDocument.removeEventListener("pointerlockerror", E));
    }, this.cancel = () => {
      this._state !== P.NONE && (this._state = P.NONE, this._activePointers.length = 0, x());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(e) {
    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = !0);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(e) {
    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = !0);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(e) {
    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = !0);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(e) {
    this._boundaryEnclosesCamera = e, this._needsUpdate = !0;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(e) {
    this._interactiveArea.width = Ge(e.width, 0, 1), this._interactiveArea.height = Ge(e.height, 0, 1), this._interactiveArea.x = Ge(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Ge(e.x, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(e, t, s = !1) {
    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, s);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(e, t = !1) {
    return this.rotateTo(e, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(e, t = !1) {
    return this.rotateTo(this._sphericalEnd.theta, e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(e, t, s = !1) {
    this._isUserControllingRotate = !1;
    const n = Ge(e, this.minAzimuthAngle, this.maxAzimuthAngle), i = Ge(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = n, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, s || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const o = !s || ie(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ie(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(e, t = !1) {
    return this.dollyTo(this._sphericalEnd.radius - e, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(e, t = !1) {
    return this._isUserControllingDolly = !1, this._lastDollyDirection = wt.NONE, this._changedDolly = 0, this._dollyToNoClamp(Ge(e, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(e, t = !1) {
    const s = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const o = this._collisionTest(), r = ie(o, this._spherical.radius);
      if (!(s > e) && r)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(e, o);
    } else
      this._sphericalEnd.radius = e;
    this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius);
    const i = !t || ie(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(e, t = !1) {
    this._targetEnd.add(this._getCameraDirection(Ft).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
    const s = !t || ie(this._target.x, this._targetEnd.x, this.restThreshold) && ie(this._target.y, this._targetEnd.y, this.restThreshold) && ie(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(e, t = !1) {
    return this.zoomTo(this._zoomEnd + e, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(e, t = !1) {
    this._isUserControllingZoom = !1, this._zoomEnd = Ge(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
    const s = !t || ie(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(s);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(e, t, s = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(e, t, s);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(e, t, s = !1) {
    this._camera.updateMatrix(), He.setFromMatrixColumn(this._camera.matrix, 0), Ve.setFromMatrixColumn(this._camera.matrix, 1), He.multiplyScalar(e), Ve.multiplyScalar(-t);
    const n = H.copy(He).add(Ve), i = ee.copy(this._targetEnd).add(n);
    return this.moveTo(i.x, i.y, i.z, s);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(e, t = !1) {
    H.setFromMatrixColumn(this._camera.matrix, 0), H.crossVectors(this._camera.up, H), H.multiplyScalar(e);
    const s = ee.copy(this._targetEnd).add(H);
    return this.moveTo(s.x, s.y, s.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(e, t = !1) {
    return H.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + H.x, this._targetEnd.y + H.y, this._targetEnd.z + H.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(e, t, s, n = !1) {
    this._isUserControllingTruck = !1;
    const i = H.set(e, t, s).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, i, this.boundaryFriction), this._needsUpdate = !0, n || this._target.copy(this._targetEnd);
    const o = !n || ie(this._target.x, this._targetEnd.x, this.restThreshold) && ie(this._target.y, this._targetEnd.y, this.restThreshold) && ie(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(e, t, s, n = !1) {
    const r = H.set(e, t, s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(r.x, r.y, r.z, n);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(e, t, { cover: s = !1, paddingLeft: n = 0, paddingRight: i = 0, paddingBottom: o = 0, paddingTop: r = 0 } = {}) {
    const a = [], c = e.isBox3 ? bt.copy(e) : bt.setFromObject(e);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const u = Mn(this._sphericalEnd.theta, Sn), h = Mn(this._sphericalEnd.phi, Sn);
    a.push(this.rotateTo(u, h, t));
    const p = H.setFromSpherical(this._sphericalEnd).normalize(), d = In.setFromUnitVectors(p, Ls), g = ie(Math.abs(p.y), 1);
    g && d.multiply(Rs.setFromAxisAngle(ss, u)), d.multiply(this._yAxisUpSpaceInverse);
    const m = Dn.makeEmpty();
    ee.copy(c.min).applyQuaternion(d), m.expandByPoint(ee), ee.copy(c.min).setX(c.max.x).applyQuaternion(d), m.expandByPoint(ee), ee.copy(c.min).setY(c.max.y).applyQuaternion(d), m.expandByPoint(ee), ee.copy(c.max).setZ(c.min.z).applyQuaternion(d), m.expandByPoint(ee), ee.copy(c.min).setZ(c.max.z).applyQuaternion(d), m.expandByPoint(ee), ee.copy(c.max).setY(c.min.y).applyQuaternion(d), m.expandByPoint(ee), ee.copy(c.max).setX(c.min.x).applyQuaternion(d), m.expandByPoint(ee), ee.copy(c.max).applyQuaternion(d), m.expandByPoint(ee), m.min.x -= n, m.min.y -= o, m.max.x += i, m.max.y += r, d.setFromUnitVectors(Ls, p), g && d.premultiply(Rs.invert()), d.premultiply(this._yAxisUpSpace);
    const T = m.getSize(H), x = m.getCenter(ee).applyQuaternion(d);
    if (mt(this._camera)) {
      const S = this.getDistanceToFitBox(T.x, T.y, T.z, s);
      a.push(this.moveTo(x.x, x.y, x.z, t)), a.push(this.dollyTo(S, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    } else if (tt(this._camera)) {
      const S = this._camera, E = S.right - S.left, f = S.top - S.bottom, v = s ? Math.max(E / T.x, f / T.y) : Math.min(E / T.x, f / T.y);
      a.push(this.moveTo(x.x, x.y, x.z, t)), a.push(this.zoomTo(v, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(a);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(e, t) {
    const s = [], i = e instanceof U.Sphere ? Ps.copy(e) : Yt.createBoundingSphere(e, Ps);
    if (s.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), mt(this._camera)) {
      const o = this.getDistanceToFitSphere(i.radius);
      s.push(this.dollyTo(o, t));
    } else if (tt(this._camera)) {
      const o = this._camera.right - this._camera.left, r = this._camera.top - this._camera.bottom, a = 2 * i.radius, c = Math.min(o / a, r / a);
      s.push(this.zoomTo(c, t));
    }
    return s.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(s);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(e, t, s, n, i, o, r = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = wt.NONE, this._changedDolly = 0;
    const a = ee.set(n, i, o), c = H.set(e, t, s);
    this._targetEnd.copy(a), this._sphericalEnd.setFromVector3(c.sub(a).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, r || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const u = !r || ie(this._target.x, this._targetEnd.x, this.restThreshold) && ie(this._target.y, this._targetEnd.y, this.restThreshold) && ie(this._target.z, this._targetEnd.z, this.restThreshold) && ie(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ie(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ie(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(u);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(e, t, s, n, i, o, r, a, c, u, h, p, d, g = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = wt.NONE, this._changedDolly = 0;
    const m = H.set(n, i, o), T = ee.set(e, t, s);
    Re.setFromVector3(T.sub(m).applyQuaternion(this._yAxisUpSpace));
    const x = xt.set(u, h, p), S = ee.set(r, a, c);
    Ut.setFromVector3(S.sub(x).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(m.lerp(x, d));
    const E = Ut.theta - Re.theta, f = Ut.phi - Re.phi, v = Ut.radius - Re.radius;
    this._sphericalEnd.set(Re.radius + v * d, Re.phi + f * d, Re.theta + E * d), this.normalizeRotations(), this._needsUpdate = !0, g || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const w = !g || ie(this._target.x, this._targetEnd.x, this.restThreshold) && ie(this._target.y, this._targetEnd.y, this.restThreshold) && ie(this._target.z, this._targetEnd.z, this.restThreshold) && ie(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ie(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ie(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(w);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(e, t, s, n = !1) {
    return this.setLookAt(e, t, s, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, n);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(e, t, s, n = !1) {
    const i = this.getPosition(H), o = this.setLookAt(i.x, i.y, i.z, e, t, s, n);
    return this._sphericalEnd.phi = Ge(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), o;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(e, t, s, n = !1) {
    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(e, t, s), this._needsUpdate = !0, n || this._focalOffset.copy(this._focalOffsetEnd);
    const i = !n || ie(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && ie(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && ie(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(e, t, s) {
    this._camera.updateMatrixWorld(), He.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Ve.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), gt.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const n = H.set(e, t, s), i = n.distanceTo(this._camera.position), o = n.sub(this._camera.position);
    He.multiplyScalar(o.x), Ve.multiplyScalar(o.y), gt.multiplyScalar(o.z), H.copy(He).add(Ve).add(gt), H.z = H.z + i, this.dollyTo(i, !1), this.setFocalOffset(-H.x, H.y, -H.z, !1), this.moveTo(e, t, s, !1);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(e) {
    if (!e) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;
      return;
    }
    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(e, t, s, n) {
    if (e === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new U.Vector4(), typeof e == "number" ? this._viewport.set(e, t, s, n) : this._viewport.copy(e);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(e, t, s, n = !1) {
    if (Os(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const i = e / t, o = this._camera.getEffectiveFOV() * It, r = this._camera.aspect;
    return ((n ? i > r : i < r) ? t : e / r) * 0.5 / Math.tan(o * 0.5) + s * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(e) {
    if (Os(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * It, s = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, n = 1 < this._camera.aspect ? t : s;
    return e / Math.sin(n * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(e, t = !0) {
    return (e && e.isVector3 ? e : new U.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(e, t = !0) {
    return (e && e.isVector3 ? e : new U.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(e, t = !0) {
    return (e && e instanceof U.Spherical ? e : new U.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(e, t = !0) {
    return (e && e.isVector3 ? e : new U.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % At, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += At), this._spherical.theta += At * Math.round((this._sphericalEnd.theta - this._spherical.theta) / At);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(e = !1) {
    if (!ie(this._camera.up.x, this._cameraUp0.x) || !ie(this._camera.up.y, this._cameraUp0.y) || !ie(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const s = this.getPosition(H);
      this.updateCameraUp(), this.setPosition(s.x, s.y, s.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),
      this.zoomTo(this._zoom0, e)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, ss), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const e = H.subVectors(this._target, this._camera.position).normalize(), t = ee.crossVectors(e, this._camera.up);
    this._camera.up.crossVectors(t, e), this._camera.updateMatrixWorld();
    const s = this.getPosition(H);
    this.updateCameraUp(), this.setPosition(s.x, s.y, s.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(e) {
    const t = this._sphericalEnd.theta - this._spherical.theta, s = this._sphericalEnd.phi - this._spherical.phi, n = this._sphericalEnd.radius - this._spherical.radius, i = Pn.subVectors(this._targetEnd, this._target), o = Rn.subVectors(this._focalOffsetEnd, this._focalOffset), r = this._zoomEnd - this._zoom;
    if (le(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const h = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = es(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, h, 1 / 0, e), this._needsUpdate = !0;
    }
    if (le(s))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const h = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = es(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, h, 1 / 0, e), this._needsUpdate = !0;
    }
    if (le(n))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const h = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = es(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, h, this.maxSpeed, e), this._needsUpdate = !0;
    }
    if (le(i.x) && le(i.y) && le(i.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const h = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      On(this._target, this._targetEnd, this._targetVelocity, h, this.maxSpeed, e, this._target), this._needsUpdate = !0;
    }
    if (le(o.x) && le(o.y) && le(o.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const h = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      On(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, h, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0;
    }
    if (le(r))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const h = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = es(this._zoom, this._zoomEnd, this._zoomVelocity, h, 1 / 0, e);
    }
    if (this.dollyToCursor) {
      if (mt(this._camera) && this._changedDolly !== 0) {
        const h = this._spherical.radius - this._lastDistance, p = this._camera, d = this._getCameraDirection(Ft), g = H.copy(d).cross(p.up).normalize();
        g.lengthSq() === 0 && (g.x = 1);
        const m = ee.crossVectors(g, d), T = this._sphericalEnd.radius * Math.tan(p.getEffectiveFOV() * It * 0.5), S = (this._sphericalEnd.radius - h - this._sphericalEnd.radius) / this._sphericalEnd.radius, E = xt.copy(this._targetEnd).add(g.multiplyScalar(this._dollyControlCoord.x * T * p.aspect)).add(m.multiplyScalar(this._dollyControlCoord.y * T)), f = H.copy(this._targetEnd).lerp(E, S), v = this._lastDollyDirection === wt.IN && this._spherical.radius <= this.minDistance, w = this._lastDollyDirection === wt.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (v || w)) {
          this._sphericalEnd.radius -= h, this._spherical.radius -= h;
          const y = ee.copy(d).multiplyScalar(-h);
          f.add(y);
        }
        this._boundary.clampPoint(f, f);
        const _ = ee.subVectors(f, this._targetEnd);
        this._targetEnd.copy(f), this._target.add(_), this._changedDolly -= h, le(this._changedDolly) && (this._changedDolly = 0);
      } else if (tt(this._camera) && this._changedZoom !== 0) {
        const h = this._zoom - this._lastZoom, p = this._camera, d = H.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (p.near + p.far) / (p.near - p.far)).unproject(p), g = ee.set(0, 0, -1).applyQuaternion(p.quaternion), m = xt.copy(d).add(g.multiplyScalar(-d.dot(p.up))), x = -(this._zoom - h - this._zoom) / this._zoom, S = this._getCameraDirection(Ft), E = this._targetEnd.dot(S), f = H.copy(this._targetEnd).lerp(m, x), v = f.dot(S), w = S.multiplyScalar(v - E);
        f.sub(w), this._boundary.clampPoint(f, f);
        const _ = ee.subVectors(f, this._targetEnd);
        this._targetEnd.copy(f), this._target.add(_), this._changedZoom -= h, le(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0);
    const a = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, a), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!le(this._focalOffset.x) || !le(this._focalOffset.y) || !le(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), He.setFromMatrixColumn(this._camera.matrix, 0), Ve.setFromMatrixColumn(this._camera.matrix, 1), gt.setFromMatrixColumn(this._camera.matrix, 2), He.multiplyScalar(this._focalOffset.x), Ve.multiplyScalar(-this._focalOffset.y), gt.multiplyScalar(this._focalOffset.z), H.copy(He).add(Ve).add(gt), this._camera.position.add(H)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), H.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const u = this._needsUpdate;
    return u && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : u ? (this.dispatchEvent({ type: "update" }), le(t, this.restThreshold) && le(s, this.restThreshold) && le(n, this.restThreshold) && le(i.x, this.restThreshold) && le(i.y, this.restThreshold) && le(i.z, this.restThreshold) && le(o.x, this.restThreshold) && le(o.y, this.restThreshold) && le(o.z, this.restThreshold) && le(r, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !u && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = u, this._needsUpdate = !1, u;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: Ct(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: Ct(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: Ct(this.maxPolarAngle),
      minAzimuthAngle: Ct(this.minAzimuthAngle),
      maxAzimuthAngle: Ct(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: H.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(e, t = !1) {
    const s = JSON.parse(e);
    this.enabled = s.enabled, this.minDistance = s.minDistance, this.maxDistance = kt(s.maxDistance), this.minZoom = s.minZoom, this.maxZoom = kt(s.maxZoom), this.minPolarAngle = s.minPolarAngle, this.maxPolarAngle = kt(s.maxPolarAngle), this.minAzimuthAngle = kt(s.minAzimuthAngle), this.maxAzimuthAngle = kt(s.maxAzimuthAngle), this.smoothTime = s.smoothTime, this.draggingSmoothTime = s.draggingSmoothTime, this.dollySpeed = s.dollySpeed, this.truckSpeed = s.truckSpeed, this.dollyToCursor = s.dollyToCursor, this.verticalDragToForward = s.verticalDragToForward, this._target0.fromArray(s.target0), this._position0.fromArray(s.position0), this._zoom0 = s.zoom0, this._focalOffset0.fromArray(s.focalOffset0), this.moveTo(s.target[0], s.target[1], s.target[2], t), Re.setFromVector3(H.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(Re.theta, Re.phi, t), this.dollyTo(Re.radius, t), this.zoomTo(s.zoom, t), this.setFocalOffset(s.focalOffset[0], s.focalOffset[1], s.focalOffset[2], t), this._needsUpdate = !0;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(e) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    e.setAttribute("data-camera-controls-version", Ka), this._addAllEventListeners(e);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(e) {
    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(e) {
    return this._getTargetDirection(e).negate();
  }
  _findPointerById(e) {
    return this._activePointers.find((t) => t.pointerId === e);
  }
  _findPointerByMouseButton(e) {
    return this._activePointers.find((t) => t.mouseButton === e);
  }
  _disposePointer(e) {
    this._activePointers.splice(this._activePointers.indexOf(e), 1);
  }
  _encloseToBoundary(e, t, s) {
    const n = t.lengthSq();
    if (n === 0)
      return e;
    const i = ee.copy(t).add(e), r = this._boundary.clampPoint(i, xt).sub(i), a = r.lengthSq();
    if (a === 0)
      return e.add(t);
    if (a === n)
      return e;
    if (s === 0)
      return e.add(t).add(r);
    {
      const c = 1 + s * a / t.dot(r);
      return e.add(ee.copy(t).multiplyScalar(c)).add(r.multiplyScalar(1 - s));
    }
  }
  _updateNearPlaneCorners() {
    if (mt(this._camera)) {
      const e = this._camera, t = e.near, s = e.getEffectiveFOV() * It, n = Math.tan(s * 0.5) * t, i = n * e.aspect;
      this._nearPlaneCorners[0].set(-i, -n, 0), this._nearPlaneCorners[1].set(i, -n, 0), this._nearPlaneCorners[2].set(i, n, 0), this._nearPlaneCorners[3].set(-i, n, 0);
    } else if (tt(this._camera)) {
      const e = this._camera, t = 1 / e.zoom, s = e.left * t, n = e.right * t, i = e.top * t, o = e.bottom * t;
      this._nearPlaneCorners[0].set(s, i, 0), this._nearPlaneCorners[1].set(n, i, 0), this._nearPlaneCorners[2].set(n, o, 0), this._nearPlaneCorners[3].set(s, o, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let e = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Os(this._camera, "_collisionTest"))
      return e;
    const s = this._getTargetDirection(Ft);
    Ds.lookAt(Ln, s, this._camera.up);
    for (let n = 0; n < 4; n++) {
      const i = ee.copy(this._nearPlaneCorners[n]);
      i.applyMatrix4(Ds);
      const o = xt.addVectors(this._target, i);
      ns.set(o, s), ns.far = this._spherical.radius + 1;
      const r = ns.intersectObjects(this.colliderMeshes);
      r.length !== 0 && r[0].distance < e && (e = r[0].distance);
    }
    return e;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(e) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e;
  }
  _createOnRestPromise(e) {
    return e ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const s = () => {
        this.removeEventListener("rest", s), t();
      };
      this.addEventListener("rest", s);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(e) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(e) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(e) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(e, t = new U.Sphere()) {
    const s = t, n = s.center;
    bt.makeEmpty(), e.traverseVisible((o) => {
      o.isMesh && bt.expandByObject(o);
    }), bt.getCenter(n);
    let i = 0;
    return e.traverseVisible((o) => {
      if (!o.isMesh)
        return;
      const r = o, a = r.geometry.clone();
      a.applyMatrix4(r.matrixWorld);
      const u = a.attributes.position;
      for (let h = 0, p = u.count; h < p; h++)
        H.fromBufferAttribute(u, h), i = Math.max(i, n.distanceToSquared(H));
    }), s.radius = Math.sqrt(i), s;
  }
}
const Wa = ["min-polar-angle", "max-polar-angle", "min-azimuth-angle", "max-azimuth-angle", "min-distance", "max-distance", "infinity-dolly", "min-zoom", "max-zoom", "smooth-time", "dragging-smooth-time", "max-speed", "azimuth-rotate-speed", "polar-rotate-speed", "dolly-speed", "dolly-drag-inverted", "truck-speed", "dolly-to-cursor", "drag-to-offset", "vertical-drag-to-forward", "boundary-friction", "rest-threshold", "collider-meshes", "args"], ec = /* @__PURE__ */ te({
  __name: "CameraControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    minPolarAngle: { default: 0 },
    maxPolarAngle: { default: Math.PI },
    minAzimuthAngle: { default: -1 / 0 },
    maxAzimuthAngle: { default: 1 / 0 },
    minDistance: { default: Number.EPSILON },
    maxDistance: { default: 1 / 0 },
    infinityDolly: { type: Boolean, default: !1 },
    minZoom: { default: 0.01 },
    maxZoom: { default: 1 / 0 },
    smoothTime: { default: 0.25 },
    draggingSmoothTime: { default: 0.125 },
    maxSpeed: { default: 1 / 0 },
    azimuthRotateSpeed: { default: 1 },
    polarRotateSpeed: { default: 1 },
    dollySpeed: { default: 1 },
    dollyDragInverted: { type: Boolean, default: !1 },
    truckSpeed: { default: 2 },
    dollyToCursor: { type: Boolean, default: !1 },
    dragToOffset: { type: Boolean, default: !1 },
    verticalDragToForward: { type: Boolean, default: !1 },
    boundaryFriction: { default: 0 },
    restThreshold: { default: 0.01 },
    colliderMeshes: { default: () => [] },
    mouseButtons: {},
    touches: {}
  },
  emits: ["change", "start", "end"],
  setup(l, { expose: e, emit: t }) {
    const s = l, {
      makeDefault: n,
      minPolarAngle: i,
      maxPolarAngle: o,
      minAzimuthAngle: r,
      maxAzimuthAngle: a,
      minDistance: c,
      maxDistance: u,
      infinityDolly: h,
      minZoom: p,
      maxZoom: d,
      smoothTime: g,
      draggingSmoothTime: m,
      maxSpeed: T,
      azimuthRotateSpeed: x,
      polarRotateSpeed: S,
      dollySpeed: E,
      dollyDragInverted: f,
      truckSpeed: v,
      dollyToCursor: w,
      dragToOffset: _,
      verticalDragToForward: y,
      boundaryFriction: L,
      restThreshold: D,
      colliderMeshes: R
    } = pe(s), k = {
      Box3: Qn,
      MathUtils: {
        clamp: Oe.clamp
      },
      Matrix4: re,
      Quaternion: ce,
      Raycaster: Un,
      Sphere: $n,
      Spherical: os,
      Vector2: Se,
      Vector3: C,
      Vector4: Xt
    };
    Yt.install({ THREE: k });
    const { camera: X, renderer: se, extend: V, controls: ae } = Le(), j = G(null);
    V({ CameraControls: Yt }), at(() => {
      _e(), j.value && n.value ? ae.value = j.value : ae.value = null;
    });
    function _e() {
      de(j.value, "update", () => t("change", j.value)), de(j.value, "controlend", () => t("end", j.value)), de(j.value, "controlstart", () => t("start", j.value));
    }
    const { onLoop: fe } = Ce();
    return fe(({ delta: ne }) => {
      var $, W;
      ($ = j.value) != null && $.enabled && ((W = j.value) == null || W.update(ne));
    }), Lt(() => {
      j.value && j.value.disconnect();
    }), e({
      value: j
    }), (ne, $) => {
      var W;
      return M(X) && M(se) ? (Q(), J("TresCameraControls", {
        key: 0,
        ref_key: "controlsRef",
        ref: j,
        "min-polar-angle": M(i),
        "max-polar-angle": M(o),
        "min-azimuth-angle": M(r),
        "max-azimuth-angle": M(a),
        "min-distance": M(c),
        "max-distance": M(u),
        "infinity-dolly": M(h),
        "min-zoom": M(p),
        "max-zoom": M(d),
        "smooth-time": M(g),
        "dragging-smooth-time": M(m),
        "max-speed": M(T),
        "azimuth-rotate-speed": M(x),
        "polar-rotate-speed": M(S),
        "dolly-speed": M(E),
        "dolly-drag-inverted": M(f),
        "truck-speed": M(v),
        "dolly-to-cursor": M(w),
        "drag-to-offset": M(_),
        "vertical-drag-to-forward": M(y),
        "boundary-friction": M(L),
        "rest-threshold": M(D),
        "collider-meshes": M(R),
        args: [M(X) || ne.camera, ((W = M(se)) == null ? void 0 : W.domElement) || ne.domElement]
      }, null, 8, Wa)) : lt("", !0);
    };
  }
});
class qa extends Zs {
  constructor(t = {}) {
    super(t);
    ds(this, "_time");
    ds(this, "_factor");
    this.setValues(t), this._time = { value: 0 }, this._factor = { value: 1 };
  }
  onBeforeCompile(t) {
    t.uniforms || (t.uniforms = {}), t.uniforms.time = this._time, t.uniforms.factor = this._factor, t.vertexShader = `
        uniform float time;
        uniform float factor;
        ${t.vertexShader}
      `, t.vertexShader = t.vertexShader.replace(
      "#include <begin_vertex>",
      `float theta = sin( time + position.y ) / 2.0 * factor;
          float c = cos( theta );
          float s = sin( theta );
          mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
          vec3 transformed = vec3( position ) * m;
          vNormal = vNormal * m;`
    );
  }
  get time() {
    return this._time.value;
  }
  set time(t) {
    this._time.value = t;
  }
  get factor() {
    return this._factor.value;
  }
  set factor(t) {
    this._factor.value = t;
  }
}
const Ja = ["factor"], tc = /* @__PURE__ */ te({
  __name: "index",
  props: {
    speed: { default: 1 },
    factor: { default: 1 }
  },
  setup(l) {
    const e = l, t = ue(), { extend: s } = Le();
    s({ MeshWobbleMaterial: qa });
    const { onLoop: n } = Ce();
    return n(({ elapsed: i }) => {
      t.value && (t.value.time = i * (e == null ? void 0 : e.speed));
    }), (i, o) => (Q(), J("TresMeshWobbleMaterial", Te({
      ref_key: "materialRef",
      ref: t,
      factor: i.factor
    }, i.$attrs), null, 16, Ja));
  }
}), el = ["args"], tl = ["color"], sc = /* @__PURE__ */ te({
  __name: "Box",
  props: {
    args: { default: () => [1, 1, 1] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "boxRef",
      ref: i
    }, o.$attrs), [
      Y("TresBoxGeometry", { args: M(s) }, null, 8, el),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, tl)
      ])
    ], 16));
  }
}), sl = ["args"], nl = ["color"], nc = /* @__PURE__ */ te({
  __name: "Circle",
  props: {
    args: { default: () => [1, 32, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "circleRef",
      ref: i
    }, o.$attrs), [
      Y("TresCircleGeometry", { args: M(s) }, null, 8, sl),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, nl)
      ])
    ], 16));
  }
}), il = ["args"], ol = ["color"], ic = /* @__PURE__ */ te({
  __name: "Cone",
  props: {
    args: { default: () => [1, 1, 12, 12, !1, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "coneRef",
      ref: i
    }, o.$attrs), [
      Y("TresConeGeometry", { args: M(s) }, null, 8, il),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, ol)
      ])
    ], 16));
  }
}), rl = ["args"], al = ["color"], oc = /* @__PURE__ */ te({
  __name: "Dodecahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "dodecahedronRef",
      ref: i
    }, o.$attrs), [
      Y("TresDodecahedronGeometry", { args: M(s) }, null, 8, rl),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, al)
      ])
    ], 16));
  }
}), ll = ["args"], cl = ["color"], rc = /* @__PURE__ */ te({
  __name: "Icosahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "icosahedronRef",
      ref: i
    }, o.$attrs), [
      Y("TresIcosahedronGeometry", { args: M(s) }, null, 8, ll),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, cl)
      ])
    ], 16));
  }
}), hl = ["args"], ul = ["color"], ac = /* @__PURE__ */ te({
  __name: "Octahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "octahedronRef",
      ref: i
    }, o.$attrs), [
      Y("TresOctahedronGeometry", { args: M(s) }, null, 8, hl),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, ul)
      ])
    ], 16));
  }
}), pl = ["rotation"], dl = ["args"], fl = ["color"], lc = /* @__PURE__ */ te({
  __name: "Plane",
  props: {
    args: { default: () => [1, 1] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "planeRef",
      ref: i,
      rotation: [-Math.PI / 2, 0, 0]
    }, o.$attrs), [
      Y("TresPlaneGeometry", { args: M(s) }, null, 8, dl),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, fl)
      ])
    ], 16, pl));
  }
}), ml = ["args"], gl = ["color"], cc = /* @__PURE__ */ te({
  __name: "Ring",
  props: {
    args: { default: () => [0.5, 1, 32] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "ringRef",
      ref: i
    }, o.$attrs), [
      Y("TresRingGeometry", { args: M(s) }, null, 8, ml),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, gl)
      ])
    ], 16));
  }
}), _l = ["args"], yl = ["color"], hc = /* @__PURE__ */ te({
  __name: "Sphere",
  props: {
    args: { default: () => [2, 32, 16] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "sphereRef",
      ref: i
    }, o.$attrs), [
      Y("TresSphereGeometry", { args: M(s) }, null, 8, _l),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, yl)
      ])
    ], 16));
  }
}), vl = ["rotation"], Tl = ["args"], El = ["color"], uc = /* @__PURE__ */ te({
  __name: "Tetrahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "tetrahedronRef",
      ref: i,
      rotation: [-Math.PI / 2, 0, 0]
    }, o.$attrs), [
      Y("TresTetrahedronGeometry", { args: M(s) }, null, 8, Tl),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, El)
      ])
    ], 16, vl));
  }
}), wl = ["args"], Al = ["color"], pc = /* @__PURE__ */ te({
  __name: "Torus",
  props: {
    args: { default: () => [1, 1, 16, 80] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "torusRef",
      ref: i
    }, o.$attrs), [
      Y("TresTorusGeometry", { args: M(s) }, null, 8, wl),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, Al)
      ])
    ], 16));
  }
}), xl = ["args"], bl = ["color"], dc = /* @__PURE__ */ te({
  __name: "TorusKnot",
  props: {
    args: { default: () => [1, 0.4, 64, 8] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "torusKnotRef",
      ref: i
    }, o.$attrs), [
      Y("TresTorusKnotGeometry", { args: M(s) }, null, 8, xl),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, bl)
      ])
    ], 16));
  }
}), Sl = ["args"], Ml = ["color"], fc = /* @__PURE__ */ te({
  __name: "Tube",
  props: {
    args: { default: () => [
      new To(new C(-1, 0, 0), new C(0, 1, 0), new C(1, 0, 0)),
      20,
      0.2,
      8,
      !1
    ] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = pe(t), i = ue();
    return e({
      value: i
    }), (o, r) => (Q(), J("TresMesh", Te({
      ref_key: "tubeRef",
      ref: i
    }, o.$attrs), [
      Y("TresTubeGeometry", { args: M(s) }, null, 8, Sl),
      Ee(o.$slots, "default", {}, () => [
        Y("TresMeshBasicMaterial", { color: M(n) }, null, 8, Ml)
      ])
    ], 16));
  }
}), Ol = ["receive-shadow", "rotation"], Ll = ["args"], Pl = /* @__PURE__ */ Y("TresMeshStandardMaterial", {
  color: 8421504,
  side: 2
}, null, -1), mc = /* @__PURE__ */ te({
  __name: "Backdrop",
  props: {
    floor: { default: 0.25 },
    segments: { default: 20 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  setup(l) {
    const e = l, t = (r) => r === 0 ? 0 : Math.pow(2, 10 * r - 10), { floor: s, segments: n, receiveShadow: i } = pe(e), o = G(null);
    return Me(
      () => [n.value, s.value, o.value],
      ([r, a, c]) => {
        if (!c || r === null)
          return;
        let u = 0;
        const h = r / r / 2, p = c.attributes.position;
        for (let d = 0; d < r + 1; d++)
          for (let g = 0; g < r + 1; g++)
            p.setXYZ(
              u++,
              d / r - h + (d === 0 ? -a : 0),
              g / r - h,
              t(d / r)
            );
        p.needsUpdate = !0, c.computeVertexNormals();
      }
    ), (r, a) => (Q(), J("TresGroup", zi(Ni(r.$attrs)), [
      Y("TresMesh", {
        "receive-shadow": M(i),
        rotation: [-Math.PI / 2, 0, Math.PI / 2]
      }, [
        Y("TresPlaneGeometry", {
          ref_key: "planeRef",
          ref: o,
          args: [1, 1, M(n), M(n)]
        }, null, 8, Ll),
        Ee(r.$slots, "default", {}, () => [
          Pl
        ])
      ], 8, Ol)
    ], 16));
  }
});
let Be, is;
const gc = (l = "body") => {
  Be || (Be = new Ao({
    container: document.querySelector(l)
  }), Be.element.style.position = "absolute", Be.element.style.top = "1rem", Be.element.style.right = "1rem", Be.element.style.zIndex = "9999", Be.registerPlugin(xo), is = Be.addBlade({
    view: "fpsgraph",
    label: "fpsgraph"
  }));
  function e() {
    Be && Be.dispose();
  }
  return Ys(() => {
    const { onBeforeLoop: t, onAfterLoop: s, resume: n } = Ce();
    n(), t(() => is.begin()), s(() => is.end());
  }), Lt(() => {
    e();
  }), { pane: Be, fpsGraph: is, disposeTweakPane: e };
};
export {
  mc as Backdrop,
  sc as Box,
  ec as CameraControls,
  nc as Circle,
  ic as Cone,
  Gl as ContactShadows,
  oc as Dodecahedron,
  Bl as Environment,
  jl as FBXModel,
  Xl as GLTFModel,
  rc as Icosahedron,
  Ql as KeyboardControls,
  Vl as Levioso,
  ql as MapControls,
  tc as MeshWobbleMaterial,
  Yl as MouseParallax,
  ac as Octahedron,
  Kl as OrbitControls,
  lc as Plane,
  Wl as PointerLockControls,
  Nl as Precipitation,
  cc as Ring,
  Jl as ScrollControls,
  Hl as Smoke,
  hc as Sphere,
  zl as Stars,
  uc as Tetrahedron,
  Fl as Text3D,
  pc as Torus,
  dc as TorusKnot,
  $l as TransformControls,
  fc as Tube,
  Ul as useAnimations,
  aa as useEnvironment,
  Ba as useFBX,
  Ua as useGLTF,
  Zl as useProgress,
  gc as useTweakPane
};
