import { PerspectiveCamera, OrthographicCamera, Box3, Matrix4, Quaternion, Raycaster, Sphere, Spherical, Vector2, Vector3, Vector4, Object3D } from 'three';
export interface CameraControlsProps {
    /**
     * Whether to make this the default controls.
     *
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    makeDefault?: boolean;
    /**
     * The camera to control.
     *
     * @type {PerspectiveCamera | OrthographicCamera}
     * @memberof CameraControlsProps
     */
    camera?: PerspectiveCamera | OrthographicCamera;
    /**
     * The dom element to listen to.
     *
     * @type {HTMLElement}
     * @memberof CameraControlsProps
     */
    domElement?: HTMLElement;
    /**
     * Minimum vertical angle in radians.
     * The angle has to be between `0` and `.maxPolarAngle` inclusive.
     *
     * @default 0
     * @type {number}
     * @memberof CameraControlsProps
     */
    minPolarAngle?: number;
    /**
     * Maximum vertical angle in radians.
     * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.
     *
     * @default Math.PI
     * @type {number}
     * @memberof CameraControlsProps
     */
    maxPolarAngle?: number;
    /**
     * Minimum horizontal angle in radians.
     * The angle has to be less than `.maxAzimuthAngle`.
     *
     * @default -Infinity
     * @type {number}
     * @memberof CameraControlsProps
     */
    minAzimuthAngle?: number;
    /**
     * Maximum horizontal angle in radians.
     * The angle has to be greater than `.minAzimuthAngle`.
     *
     * @default Infinity
     * @type {number}
     * @memberof CameraControlsProps
     */
    maxAzimuthAngle?: number;
    /**
     * Minimum distance for dolly. The value must be higher than `0`.
     * PerspectiveCamera only.
     *
     * @default Number.EPSILON
     * @type {number}
     * @memberof CameraControlsProps
     */
    minDistance?: number;
    /**
     * Maximum distance for dolly. The value must be higher than `minDistance`.
     * PerspectiveCamera only.
     *
     * @default Infinity
     * @type {number}
     * @memberof CameraControlsProps
     */
    maxDistance?: number;
    /**
     * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`.
     * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`),
     * `infinityDolly` will keep the distance and pushes the target position instead.
     *
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    infinityDolly?: boolean;
    /**
     * Minimum camera zoom.
     *
     * @default 0.01
     * @type {number}
     * @memberof CameraControlsProps
     */
    minZoom?: number;
    /**
     * Maximum camera zoom.
     *
     * @default Infinity
     * @type {number}
     * @memberof CameraControlsProps
     */
    maxZoom?: number;
    /**
     * Approximate time in seconds to reach the target. A smaller value will reach the target faster.
     *
     * @default 0.25
     * @type {number}
     * @memberof CameraControlsProps
     */
    smoothTime?: number;
    /**
     * The smoothTime while dragging.
     *
     * @default 0.125
     * @type {number}
     * @memberof CameraControlsProps
     */
    draggingSmoothTime?: number;
    /**
     * Max transition speed in unit-per-seconds.
     *
     * @default Infinity
     * @type {number}
     * @memberof CameraControlsProps
     */
    maxSpeed?: number;
    /**
     * Speed of azimuth (horizontal) rotation.
     *
     * @default 1.0
     * @type {number}
     * @memberof CameraControlsProps
     */
    azimuthRotateSpeed?: number;
    /**
     * Speed of polar (vertical) rotation.
     *
     * @default 1.0
     * @type {number}
     * @memberof CameraControlsProps
     */
    polarRotateSpeed?: number;
    /**
     * Speed of mouse-wheel dollying.
     *
     * @default 1.0
     * @type {number}
     * @memberof CameraControlsProps
     */
    dollySpeed?: number;
    /**
     * `true` to invert direction when dollying or zooming via drag.
     *
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    dollyDragInverted?: boolean;
    /**
     * Speed of drag for truck and pedestal.
     *
     * @default 2.0
     * @type {number}
     * @memberof CameraControlsProps
     */
    truckSpeed?: number;
    /**
     * `true` to enable Dolly-in to the mouse cursor coords.
     *
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    dollyToCursor?: boolean;
    /**
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    dragToOffset?: boolean;
    /**
     * The same as `.screenSpacePanning` in three.js's OrbitControls.
     *
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    verticalDragToForward?: boolean;
    /**
     * Friction ratio of the boundary.
     *
     * @default 0.0
     * @type {number}
     * @memberof CameraControlsProps
     */
    boundaryFriction?: number;
    /**
     * Controls how soon the `rest` event fires as the camera slows.
     *
     * @default 0.01
     * @type {number}
     * @memberof CameraControlsProps
     */
    restThreshold?: number;
    /**
     * An array of Meshes to collide with the camera.
     * Be aware colliderMeshes may decrease performance.
     * The collision test uses 4 raycasters from the camera since the near plane has 4 corners.
     *
     * @default []
     * @type {Object3D[]}
     * @memberof CameraControlsProps
     */
    colliderMeshes?: Object3D[];
    /**
     * User's mouse input config.
     *
     * @default See description
     * @memberof CameraControlsProps
     */
    mouseButtons?: {
        left?: number;
        right?: number;
        wheel?: number;
        middle?: number;
    };
    /**
     * User's touch input config.
     *
     * @default See description
     * @memberof CameraControlsProps
     */
    touches?: {
        one?: number;
        two?: number;
        three?: number;
    };
}
declare const _default: import("vue").DefineComponent<{
    camera: {
        type: import("vue").PropType<OrthographicCamera | PerspectiveCamera>;
    };
    makeDefault: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    domElement: {
        type: import("vue").PropType<HTMLElement>;
    };
    minPolarAngle: {
        type: import("vue").PropType<number>;
        default: number;
    };
    maxPolarAngle: {
        type: import("vue").PropType<number>;
        default: number;
    };
    minAzimuthAngle: {
        type: import("vue").PropType<number>;
        default: number;
    };
    maxAzimuthAngle: {
        type: import("vue").PropType<number>;
        default: number;
    };
    minDistance: {
        type: import("vue").PropType<number>;
        default: number;
    };
    maxDistance: {
        type: import("vue").PropType<number>;
        default: number;
    };
    infinityDolly: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    minZoom: {
        type: import("vue").PropType<number>;
        default: number;
    };
    maxZoom: {
        type: import("vue").PropType<number>;
        default: number;
    };
    smoothTime: {
        type: import("vue").PropType<number>;
        default: number;
    };
    draggingSmoothTime: {
        type: import("vue").PropType<number>;
        default: number;
    };
    maxSpeed: {
        type: import("vue").PropType<number>;
        default: number;
    };
    azimuthRotateSpeed: {
        type: import("vue").PropType<number>;
        default: number;
    };
    polarRotateSpeed: {
        type: import("vue").PropType<number>;
        default: number;
    };
    dollySpeed: {
        type: import("vue").PropType<number>;
        default: number;
    };
    dollyDragInverted: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    truckSpeed: {
        type: import("vue").PropType<number>;
        default: number;
    };
    dollyToCursor: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    dragToOffset: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    verticalDragToForward: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    boundaryFriction: {
        type: import("vue").PropType<number>;
        default: number;
    };
    restThreshold: {
        type: import("vue").PropType<number>;
        default: number;
    };
    colliderMeshes: {
        type: import("vue").PropType<Object3D<import("three").Event>[]>;
        default: () => never[];
    };
    mouseButtons: {
        type: import("vue").PropType<{
            left?: number | undefined;
            right?: number | undefined;
            wheel?: number | undefined;
            middle?: number | undefined;
        }>;
    };
    touches: {
        type: import("vue").PropType<{
            one?: number | undefined;
            two?: number | undefined;
            three?: number | undefined;
        }>;
    };
}, {
    value: import("vue").Ref<{
        minPolarAngle: number;
        maxPolarAngle: number;
        minAzimuthAngle: number;
        maxAzimuthAngle: number;
        minDistance: number;
        maxDistance: number;
        infinityDolly: boolean;
        minZoom: number;
        maxZoom: number;
        smoothTime: number;
        draggingSmoothTime: number;
        maxSpeed: number;
        azimuthRotateSpeed: number;
        polarRotateSpeed: number;
        dollySpeed: number;
        dollyDragInverted: boolean;
        truckSpeed: number;
        dollyToCursor: boolean;
        dragToOffset: boolean;
        verticalDragToForward: boolean;
        boundaryFriction: number;
        restThreshold: number;
        colliderMeshes: {
            readonly isObject3D: true;
            readonly id: number;
            uuid: string;
            name: string;
            readonly type: string;
            parent: any | null;
            children: any[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                setFromColor: (color: import("three").Color) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                setFromColor: (color: import("three").Color) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import("three").EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                clone: () => import("three").Euler;
                copy: (euler: import("three").Euler) => import("three").Euler;
                setFromRotationMatrix: (m: Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                setFromQuaternion: (q: Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                setFromVector3: (v: Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
                equals: (euler: import("three").Euler) => boolean;
                fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                _onChange: (callback: () => void) => import("three").Euler;
                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => Quaternion;
                clone: () => Quaternion;
                copy: (q: Quaternion) => Quaternion;
                setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => Quaternion;
                setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
                setFromRotationMatrix: (m: Matrix4) => Quaternion;
                setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
                angleTo: (q: Quaternion) => number;
                rotateTowards: (q: Quaternion, step: number) => Quaternion;
                identity: () => Quaternion;
                invert: () => Quaternion;
                conjugate: () => Quaternion;
                dot: (v: Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => Quaternion;
                multiply: (q: Quaternion) => Quaternion;
                premultiply: (q: Quaternion) => Quaternion;
                multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                slerp: (qb: Quaternion, t: number) => Quaternion;
                slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                equals: (v: Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                toJSON: () => [number, number, number, number];
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Quaternion;
                _onChange: (callback: () => void) => Quaternion;
                _onChangeCallback: () => void;
                multiplyVector3: (v: any) => any;
                random: () => Quaternion;
                [Symbol.iterator]: () => Generator<number, void, unknown>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                setFromColor: (color: import("three").Color) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly modelViewMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            readonly normalMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                identity: () => import("three").Matrix3;
                clone: () => import("three").Matrix3;
                copy: (m: import("three").Matrix3) => import("three").Matrix3;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import("three").Matrix3;
                setFromMatrix4: (m: Matrix4) => import("three").Matrix3;
                multiplyScalar: (s: number) => import("three").Matrix3;
                determinant: () => number;
                invert: () => import("three").Matrix3;
                transpose: () => import("three").Matrix3;
                getNormalMatrix: (matrix4: Matrix4) => import("three").Matrix3;
                transposeIntoArray: (r: number[]) => import("three").Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                scale: (sx: number, sy: number) => import("three").Matrix3;
                makeTranslation: {
                    (v: Vector2): import("three").Matrix3;
                    (x: number, y: number): import("three").Matrix3;
                };
                makeRotation: {
                    (theta: number): import("three").Matrix3;
                    (theta: number): import("three").Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import("three").Matrix3;
                    (x: number, y: number): import("three").Matrix3;
                };
                rotate: (theta: number) => import("three").Matrix3;
                translate: (tx: number, ty: number) => import("three").Matrix3;
                equals: (matrix: import("three").Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                multiplyVector3: (vector: Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                    (matrix: import("three").Matrix): import("three").Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            matrixWorld: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: {
                mask: number;
                set: (layer: number) => void;
                enable: (layer: number) => void;
                enableAll: () => void;
                toggle: (layer: number) => void;
                disable: (layer: number) => void;
                disableAll: () => void;
                test: (layers: import("three").Layers) => boolean;
                isEnabled: (layer: number) => boolean;
            };
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import("three").InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
                    setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
                    getInterpolation: () => import("three").InterpolationModes;
                    createInterpolant: () => import("three").Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import("three").KeyframeTrack;
                    scale: (timeScale: number) => import("three").KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import("three").KeyframeTrack;
                    clone: () => import("three").KeyframeTrack;
                }[];
                blendMode: import("three").AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import("three").AnimationClip;
                trim: () => import("three").AnimationClip;
                validate: () => boolean;
                optimize: () => import("three").AnimationClip;
                clone: () => import("three").AnimationClip;
                toJSON: (clip: import("three").AnimationClip) => any;
            }[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial?: {
                alphaHash: boolean;
                alphaTest: number;
                alphaToCoverage: boolean;
                blendDst: import("three").BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import("three").BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import("three").Blending;
                blendSrc: 210 | import("three").BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: any;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import("three").DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import("three").StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import("three").StencilOp;
                stencilZFail: import("three").StencilOp;
                stencilZPass: import("three").StencilOp;
                readonly isMaterial: true;
                name: string;
                needsUpdate: boolean;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import("three").Side;
                shadowSide: import("three").Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: any;
                version: number;
                clone: () => import("three").Material;
                copy: (material: import("three").Material) => import("three").Material;
                dispose: () => void;
                onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import("three").MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            } | undefined;
            customDistanceMaterial?: {
                alphaHash: boolean;
                alphaTest: number;
                alphaToCoverage: boolean;
                blendDst: import("three").BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import("three").BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import("three").Blending;
                blendSrc: 210 | import("three").BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: any;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import("three").DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import("three").StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import("three").StencilOp;
                stencilZFail: import("three").StencilOp;
                stencilZPass: import("three").StencilOp;
                readonly isMaterial: true;
                name: string;
                needsUpdate: boolean;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import("three").Side;
                shadowSide: import("three").Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: any;
                version: number;
                clone: () => import("three").Material;
                copy: (material: import("three").Material) => import("three").Material;
                dispose: () => void;
                onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import("three").MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            } | undefined;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4: (matrix: Matrix4) => void;
            applyQuaternion: (quaternion: Quaternion) => Object3D<import("three").Event>;
            setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import("three").Euler) => void;
            setRotationFromMatrix: (m: Matrix4) => void;
            setRotationFromQuaternion: (q: Quaternion) => void;
            rotateOnAxis: (axis: Vector3, angle: number) => Object3D<import("three").Event>;
            rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<import("three").Event>;
            rotateX: (angle: number) => Object3D<import("three").Event>;
            rotateY: (angle: number) => Object3D<import("three").Event>;
            rotateZ: (angle: number) => Object3D<import("three").Event>;
            translateOnAxis: (axis: Vector3, distance: number) => Object3D<import("three").Event>;
            translateX: (distance: number) => Object3D<import("three").Event>;
            translateY: (distance: number) => Object3D<import("three").Event>;
            translateZ: (distance: number) => Object3D<import("three").Event>;
            localToWorld: (vector: Vector3) => Vector3;
            worldToLocal: (vector: Vector3) => Vector3;
            lookAt: {
                (vector: Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: Object3D<import("three").Event>[]) => Object3D<import("three").Event>;
            remove: (...object: Object3D<import("three").Event>[]) => Object3D<import("three").Event>;
            removeFromParent: () => Object3D<import("three").Event>;
            clear: () => Object3D<import("three").Event>;
            attach: (object: Object3D<import("three").Event>) => Object3D<import("three").Event>;
            getObjectById: (id: number) => Object3D<import("three").Event> | undefined;
            getObjectByName: (name: string) => Object3D<import("three").Event> | undefined;
            getObjectByProperty: (name: string, value: any) => Object3D<import("three").Event> | undefined;
            getObjectsByProperty: (name: string, value: any) => Object3D<import("three").Event>[];
            getWorldPosition: (target: Vector3) => Vector3;
            getWorldQuaternion: (target: Quaternion) => Quaternion;
            getWorldScale: (target: Vector3) => Vector3;
            getWorldDirection: (target: Vector3) => Vector3;
            raycast: (raycaster: Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]) => void;
            traverse: (callback: (object: Object3D<import("three").Event>) => any) => void;
            traverseVisible: (callback: (object: Object3D<import("three").Event>) => any) => void;
            traverseAncestors: (callback: (object: Object3D<import("three").Event>) => any) => void;
            updateMatrix: () => void;
            updateMatrixWorld: (force?: boolean | undefined) => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            } | undefined) => any;
            clone: (recursive?: boolean | undefined) => Object3D<import("three").Event>;
            copy: (source: Object3D<import("three").Event>, recursive?: boolean | undefined) => Object3D<import("three").Event>;
            addEventListener: <T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, Object3D<import("three").Event>>) => void;
            hasEventListener: <T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, Object3D<import("three").Event>>) => boolean;
            removeEventListener: <T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, Object3D<import("three").Event>>) => void;
            dispatchEvent: (event: import("three").Event) => void;
        }[];
        mouseButtons: {
            left: 0 | 2 | 1 | 4 | 8 | 16;
            middle: 0 | 2 | 1 | 4 | 8 | 16;
            right: 0 | 2 | 1 | 4 | 8 | 16;
            wheel: 0 | 2 | 1 | 4 | 8 | 16;
        };
        touches: {
            one: 0 | 8 | 16 | 32 | 64 | 128;
            two: 0 | 512 | 256 | 1024 | 32 | 64 | 128 | 4096 | 2048 | 32768 | 8192 | 16384;
            three: 0 | 512 | 256 | 1024 | 32 | 64 | 128 | 4096 | 2048 | 32768 | 8192 | 16384;
        };
        cancel: () => void;
        lockPointer: () => void;
        unlockPointer: () => void;
        camera: {
            readonly isOrthographicCamera: true;
            readonly type: string;
            zoom: number;
            view: {
                enabled: boolean;
                fullWidth: number;
                fullHeight: number;
                offsetX: number;
                offsetY: number;
                width: number;
                height: number;
            } | null;
            left: number;
            right: number;
            top: number;
            bottom: number;
            near: number;
            far: number;
            updateProjectionMatrix: () => void;
            setViewOffset: (fullWidth: number, fullHeight: number, offsetX: number, offsetY: number, width: number, height: number) => void;
            clearViewOffset: () => void;
            readonly isCamera: true;
            layers: {
                mask: number;
                set: (layer: number) => void;
                enable: (layer: number) => void;
                enableAll: () => void;
                toggle: (layer: number) => void;
                disable: (layer: number) => void;
                disableAll: () => void;
                test: (layers: import("three").Layers) => boolean;
                isEnabled: (layer: number) => boolean;
            };
            matrixWorldInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            projectionMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            projectionMatrixInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            coordinateSystem: import("three").CoordinateSystem;
            getWorldDirection: (target: Vector3) => Vector3;
            readonly isObject3D: true;
            readonly id: number;
            uuid: string;
            name: string;
            parent: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import("three").EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    clone: () => import("three").Euler;
                    copy: (euler: import("three").Euler) => import("three").Euler;
                    setFromRotationMatrix: (m: Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromQuaternion: (q: Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromVector3: (v: Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
                    equals: (euler: import("three").Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import("three").Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => Quaternion;
                    clone: () => Quaternion;
                    copy: (q: Quaternion) => Quaternion;
                    setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => Quaternion;
                    setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
                    setFromRotationMatrix: (m: Matrix4) => Quaternion;
                    setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
                    angleTo: (q: Quaternion) => number;
                    rotateTowards: (q: Quaternion, step: number) => Quaternion;
                    identity: () => Quaternion;
                    invert: () => Quaternion;
                    conjugate: () => Quaternion;
                    dot: (v: Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => Quaternion;
                    multiply: (q: Quaternion) => Quaternion;
                    premultiply: (q: Quaternion) => Quaternion;
                    multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                    slerp: (qb: Quaternion, t: number) => Quaternion;
                    slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                    equals: (v: Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Quaternion;
                    _onChange: (callback: () => void) => Quaternion;
                    _onChangeCallback: () => void;
                    multiplyVector3: (v: any) => any;
                    random: () => Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                    identity: () => import("three").Matrix3;
                    clone: () => import("three").Matrix3;
                    copy: (m: import("three").Matrix3) => import("three").Matrix3;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import("three").Matrix3;
                    setFromMatrix4: (m: Matrix4) => import("three").Matrix3;
                    multiplyScalar: (s: number) => import("three").Matrix3;
                    determinant: () => number;
                    invert: () => import("three").Matrix3;
                    transpose: () => import("three").Matrix3;
                    getNormalMatrix: (matrix4: Matrix4) => import("three").Matrix3;
                    transposeIntoArray: (r: number[]) => import("three").Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                    scale: (sx: number, sy: number) => import("three").Matrix3;
                    makeTranslation: {
                        (v: Vector2): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import("three").Matrix3;
                        (theta: number): import("three").Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    rotate: (theta: number) => import("three").Matrix3;
                    translate: (tx: number, ty: number) => import("three").Matrix3;
                    equals: (matrix: import("three").Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                    multiplyVector3: (vector: Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                        (matrix: import("three").Matrix): import("three").Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import("three").Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import("three").InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
                        setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
                        getInterpolation: () => import("three").InterpolationModes;
                        createInterpolant: () => import("three").Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import("three").KeyframeTrack;
                        scale: (timeScale: number) => import("three").KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import("three").KeyframeTrack;
                        clone: () => import("three").KeyframeTrack;
                    }[];
                    blendMode: import("three").AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import("three").AnimationClip;
                    trim: () => import("three").AnimationClip;
                    validate: () => boolean;
                    optimize: () => import("three").AnimationClip;
                    clone: () => import("three").AnimationClip;
                    toJSON: (clip: import("three").AnimationClip) => any;
                }[];
                userData: {
                    [key: string]: any;
                };
                customDepthMaterial?: {
                    alphaHash: boolean;
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: 210 | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                } | undefined;
                customDistanceMaterial?: {
                    alphaHash: boolean;
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: 210 | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                } | undefined;
                onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
                onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
                applyMatrix4: (matrix: Matrix4) => void;
                applyQuaternion: (quaternion: Quaternion) => Object3D<import("three").Event>;
                setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import("three").Euler) => void;
                setRotationFromMatrix: (m: Matrix4) => void;
                setRotationFromQuaternion: (q: Quaternion) => void;
                rotateOnAxis: (axis: Vector3, angle: number) => Object3D<import("three").Event>;
                rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<import("three").Event>;
                rotateX: (angle: number) => Object3D<import("three").Event>;
                rotateY: (angle: number) => Object3D<import("three").Event>;
                rotateZ: (angle: number) => Object3D<import("three").Event>;
                translateOnAxis: (axis: Vector3, distance: number) => Object3D<import("three").Event>;
                translateX: (distance: number) => Object3D<import("three").Event>;
                translateY: (distance: number) => Object3D<import("three").Event>;
                translateZ: (distance: number) => Object3D<import("three").Event>;
                localToWorld: (vector: Vector3) => Vector3;
                worldToLocal: (vector: Vector3) => Vector3;
                lookAt: {
                    (vector: Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: Object3D<import("three").Event>[]) => Object3D<import("three").Event>;
                remove: (...object: Object3D<import("three").Event>[]) => Object3D<import("three").Event>;
                removeFromParent: () => Object3D<import("three").Event>;
                clear: () => Object3D<import("three").Event>;
                attach: (object: Object3D<import("three").Event>) => Object3D<import("three").Event>;
                getObjectById: (id: number) => Object3D<import("three").Event> | undefined;
                getObjectByName: (name: string) => Object3D<import("three").Event> | undefined;
                getObjectByProperty: (name: string, value: any) => Object3D<import("three").Event> | undefined;
                getObjectsByProperty: (name: string, value: any) => Object3D<import("three").Event>[];
                getWorldPosition: (target: Vector3) => Vector3;
                getWorldQuaternion: (target: Quaternion) => Quaternion;
                getWorldScale: (target: Vector3) => Vector3;
                getWorldDirection: (target: Vector3) => Vector3;
                raycast: (raycaster: Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]) => void;
                traverse: (callback: (object: Object3D<import("three").Event>) => any) => void;
                traverseVisible: (callback: (object: Object3D<import("three").Event>) => any) => void;
                traverseAncestors: (callback: (object: Object3D<import("three").Event>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => Object3D<import("three").Event>;
                copy: (source: Object3D<import("three").Event>, recursive?: boolean | undefined) => Object3D<import("three").Event>;
                addEventListener: <T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, Object3D<import("three").Event>>) => void;
                hasEventListener: <T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, Object3D<import("three").Event>>) => boolean;
                removeEventListener: <T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, Object3D<import("three").Event>>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            } | null;
            children: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import("three").EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    clone: () => import("three").Euler;
                    copy: (euler: import("three").Euler) => import("three").Euler;
                    setFromRotationMatrix: (m: Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromQuaternion: (q: Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromVector3: (v: Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
                    equals: (euler: import("three").Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import("three").Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => Quaternion;
                    clone: () => Quaternion;
                    copy: (q: Quaternion) => Quaternion;
                    setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => Quaternion;
                    setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
                    setFromRotationMatrix: (m: Matrix4) => Quaternion;
                    setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
                    angleTo: (q: Quaternion) => number;
                    rotateTowards: (q: Quaternion, step: number) => Quaternion;
                    identity: () => Quaternion;
                    invert: () => Quaternion;
                    conjugate: () => Quaternion;
                    dot: (v: Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => Quaternion;
                    multiply: (q: Quaternion) => Quaternion;
                    premultiply: (q: Quaternion) => Quaternion;
                    multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                    slerp: (qb: Quaternion, t: number) => Quaternion;
                    slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                    equals: (v: Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Quaternion;
                    _onChange: (callback: () => void) => Quaternion;
                    _onChangeCallback: () => void;
                    multiplyVector3: (v: any) => any;
                    random: () => Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                    identity: () => import("three").Matrix3;
                    clone: () => import("three").Matrix3;
                    copy: (m: import("three").Matrix3) => import("three").Matrix3;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import("three").Matrix3;
                    setFromMatrix4: (m: Matrix4) => import("three").Matrix3;
                    multiplyScalar: (s: number) => import("three").Matrix3;
                    determinant: () => number;
                    invert: () => import("three").Matrix3;
                    transpose: () => import("three").Matrix3;
                    getNormalMatrix: (matrix4: Matrix4) => import("three").Matrix3;
                    transposeIntoArray: (r: number[]) => import("three").Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                    scale: (sx: number, sy: number) => import("three").Matrix3;
                    makeTranslation: {
                        (v: Vector2): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import("three").Matrix3;
                        (theta: number): import("three").Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    rotate: (theta: number) => import("three").Matrix3;
                    translate: (tx: number, ty: number) => import("three").Matrix3;
                    equals: (matrix: import("three").Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                    multiplyVector3: (vector: Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                        (matrix: import("three").Matrix): import("three").Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import("three").Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import("three").InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
                        setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
                        getInterpolation: () => import("three").InterpolationModes;
                        createInterpolant: () => import("three").Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import("three").KeyframeTrack;
                        scale: (timeScale: number) => import("three").KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import("three").KeyframeTrack;
                        clone: () => import("three").KeyframeTrack;
                    }[];
                    blendMode: import("three").AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import("three").AnimationClip;
                    trim: () => import("three").AnimationClip;
                    validate: () => boolean;
                    optimize: () => import("three").AnimationClip;
                    clone: () => import("three").AnimationClip;
                    toJSON: (clip: import("three").AnimationClip) => any;
                }[];
                userData: {
                    [key: string]: any;
                };
                customDepthMaterial?: {
                    alphaHash: boolean;
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: 210 | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                } | undefined;
                customDistanceMaterial?: {
                    alphaHash: boolean;
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: 210 | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                } | undefined;
                onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
                onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
                applyMatrix4: (matrix: Matrix4) => void;
                applyQuaternion: (quaternion: Quaternion) => Object3D<import("three").Event>;
                setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import("three").Euler) => void;
                setRotationFromMatrix: (m: Matrix4) => void;
                setRotationFromQuaternion: (q: Quaternion) => void;
                rotateOnAxis: (axis: Vector3, angle: number) => Object3D<import("three").Event>;
                rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<import("three").Event>;
                rotateX: (angle: number) => Object3D<import("three").Event>;
                rotateY: (angle: number) => Object3D<import("three").Event>;
                rotateZ: (angle: number) => Object3D<import("three").Event>;
                translateOnAxis: (axis: Vector3, distance: number) => Object3D<import("three").Event>;
                translateX: (distance: number) => Object3D<import("three").Event>;
                translateY: (distance: number) => Object3D<import("three").Event>;
                translateZ: (distance: number) => Object3D<import("three").Event>;
                localToWorld: (vector: Vector3) => Vector3;
                worldToLocal: (vector: Vector3) => Vector3;
                lookAt: {
                    (vector: Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: Object3D<import("three").Event>[]) => Object3D<import("three").Event>;
                remove: (...object: Object3D<import("three").Event>[]) => Object3D<import("three").Event>;
                removeFromParent: () => Object3D<import("three").Event>;
                clear: () => Object3D<import("three").Event>;
                attach: (object: Object3D<import("three").Event>) => Object3D<import("three").Event>;
                getObjectById: (id: number) => Object3D<import("three").Event> | undefined;
                getObjectByName: (name: string) => Object3D<import("three").Event> | undefined;
                getObjectByProperty: (name: string, value: any) => Object3D<import("three").Event> | undefined;
                getObjectsByProperty: (name: string, value: any) => Object3D<import("three").Event>[];
                getWorldPosition: (target: Vector3) => Vector3;
                getWorldQuaternion: (target: Quaternion) => Quaternion;
                getWorldScale: (target: Vector3) => Vector3;
                getWorldDirection: (target: Vector3) => Vector3;
                raycast: (raycaster: Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]) => void;
                traverse: (callback: (object: Object3D<import("three").Event>) => any) => void;
                traverseVisible: (callback: (object: Object3D<import("three").Event>) => any) => void;
                traverseAncestors: (callback: (object: Object3D<import("three").Event>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => Object3D<import("three").Event>;
                copy: (source: Object3D<import("three").Event>, recursive?: boolean | undefined) => Object3D<import("three").Event>;
                addEventListener: <T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, Object3D<import("three").Event>>) => void;
                hasEventListener: <T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, Object3D<import("three").Event>>) => boolean;
                removeEventListener: <T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, Object3D<import("three").Event>>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            }[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                setFromColor: (color: import("three").Color) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                setFromColor: (color: import("three").Color) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import("three").EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                clone: () => import("three").Euler;
                copy: (euler: import("three").Euler) => import("three").Euler;
                setFromRotationMatrix: (m: Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                setFromQuaternion: (q: Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                setFromVector3: (v: Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
                equals: (euler: import("three").Euler) => boolean;
                fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                _onChange: (callback: () => void) => import("three").Euler;
                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => Quaternion;
                clone: () => Quaternion;
                copy: (q: Quaternion) => Quaternion;
                setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => Quaternion;
                setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
                setFromRotationMatrix: (m: Matrix4) => Quaternion;
                setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
                angleTo: (q: Quaternion) => number;
                rotateTowards: (q: Quaternion, step: number) => Quaternion;
                identity: () => Quaternion;
                invert: () => Quaternion;
                conjugate: () => Quaternion;
                dot: (v: Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => Quaternion;
                multiply: (q: Quaternion) => Quaternion;
                premultiply: (q: Quaternion) => Quaternion;
                multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                slerp: (qb: Quaternion, t: number) => Quaternion;
                slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                equals: (v: Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                toJSON: () => [number, number, number, number];
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Quaternion;
                _onChange: (callback: () => void) => Quaternion;
                _onChangeCallback: () => void;
                multiplyVector3: (v: any) => any;
                random: () => Quaternion;
                [Symbol.iterator]: () => Generator<number, void, unknown>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                setFromColor: (color: import("three").Color) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly modelViewMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            readonly normalMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                identity: () => import("three").Matrix3;
                clone: () => import("three").Matrix3;
                copy: (m: import("three").Matrix3) => import("three").Matrix3;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import("three").Matrix3;
                setFromMatrix4: (m: Matrix4) => import("three").Matrix3;
                multiplyScalar: (s: number) => import("three").Matrix3;
                determinant: () => number;
                invert: () => import("three").Matrix3;
                transpose: () => import("three").Matrix3;
                getNormalMatrix: (matrix4: Matrix4) => import("three").Matrix3;
                transposeIntoArray: (r: number[]) => import("three").Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                scale: (sx: number, sy: number) => import("three").Matrix3;
                makeTranslation: {
                    (v: Vector2): import("three").Matrix3;
                    (x: number, y: number): import("three").Matrix3;
                };
                makeRotation: {
                    (theta: number): import("three").Matrix3;
                    (theta: number): import("three").Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import("three").Matrix3;
                    (x: number, y: number): import("three").Matrix3;
                };
                rotate: (theta: number) => import("three").Matrix3;
                translate: (tx: number, ty: number) => import("three").Matrix3;
                equals: (matrix: import("three").Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                multiplyVector3: (vector: Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                    (matrix: import("three").Matrix): import("three").Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            matrixWorld: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import("three").InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
                    setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
                    getInterpolation: () => import("three").InterpolationModes;
                    createInterpolant: () => import("three").Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import("three").KeyframeTrack;
                    scale: (timeScale: number) => import("three").KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import("three").KeyframeTrack;
                    clone: () => import("three").KeyframeTrack;
                }[];
                blendMode: import("three").AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import("three").AnimationClip;
                trim: () => import("three").AnimationClip;
                validate: () => boolean;
                optimize: () => import("three").AnimationClip;
                clone: () => import("three").AnimationClip;
                toJSON: (clip: import("three").AnimationClip) => any;
            }[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial?: {
                alphaHash: boolean;
                alphaTest: number;
                alphaToCoverage: boolean;
                blendDst: import("three").BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import("three").BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import("three").Blending;
                blendSrc: 210 | import("three").BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: any;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import("three").DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import("three").StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import("three").StencilOp;
                stencilZFail: import("three").StencilOp;
                stencilZPass: import("three").StencilOp;
                readonly isMaterial: true;
                name: string;
                needsUpdate: boolean;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import("three").Side;
                shadowSide: import("three").Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: any;
                version: number;
                clone: () => import("three").Material;
                copy: (material: import("three").Material) => import("three").Material;
                dispose: () => void;
                onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import("three").MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            } | undefined;
            customDistanceMaterial?: {
                alphaHash: boolean;
                alphaTest: number;
                alphaToCoverage: boolean;
                blendDst: import("three").BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import("three").BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import("three").Blending;
                blendSrc: 210 | import("three").BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: any;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import("three").DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import("three").StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import("three").StencilOp;
                stencilZFail: import("three").StencilOp;
                stencilZPass: import("three").StencilOp;
                readonly isMaterial: true;
                name: string;
                needsUpdate: boolean;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import("three").Side;
                shadowSide: import("three").Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: any;
                version: number;
                clone: () => import("three").Material;
                copy: (material: import("three").Material) => import("three").Material;
                dispose: () => void;
                onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import("three").MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            } | undefined;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4: (matrix: Matrix4) => void;
            applyQuaternion: (quaternion: Quaternion) => OrthographicCamera;
            setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import("three").Euler) => void;
            setRotationFromMatrix: (m: Matrix4) => void;
            setRotationFromQuaternion: (q: Quaternion) => void;
            rotateOnAxis: (axis: Vector3, angle: number) => OrthographicCamera;
            rotateOnWorldAxis: (axis: Vector3, angle: number) => OrthographicCamera;
            rotateX: (angle: number) => OrthographicCamera;
            rotateY: (angle: number) => OrthographicCamera;
            rotateZ: (angle: number) => OrthographicCamera;
            translateOnAxis: (axis: Vector3, distance: number) => OrthographicCamera;
            translateX: (distance: number) => OrthographicCamera;
            translateY: (distance: number) => OrthographicCamera;
            translateZ: (distance: number) => OrthographicCamera;
            localToWorld: (vector: Vector3) => Vector3;
            worldToLocal: (vector: Vector3) => Vector3;
            lookAt: {
                (vector: Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: Object3D<import("three").Event>[]) => OrthographicCamera;
            remove: (...object: Object3D<import("three").Event>[]) => OrthographicCamera;
            removeFromParent: () => OrthographicCamera;
            clear: () => OrthographicCamera;
            attach: (object: Object3D<import("three").Event>) => OrthographicCamera;
            getObjectById: (id: number) => Object3D<import("three").Event> | undefined;
            getObjectByName: (name: string) => Object3D<import("three").Event> | undefined;
            getObjectByProperty: (name: string, value: any) => Object3D<import("three").Event> | undefined;
            getObjectsByProperty: (name: string, value: any) => Object3D<import("three").Event>[];
            getWorldPosition: (target: Vector3) => Vector3;
            getWorldQuaternion: (target: Quaternion) => Quaternion;
            getWorldScale: (target: Vector3) => Vector3;
            raycast: (raycaster: Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]) => void;
            traverse: (callback: (object: Object3D<import("three").Event>) => any) => void;
            traverseVisible: (callback: (object: Object3D<import("three").Event>) => any) => void;
            traverseAncestors: (callback: (object: Object3D<import("three").Event>) => any) => void;
            updateMatrix: () => void;
            updateMatrixWorld: (force?: boolean | undefined) => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            } | undefined) => any;
            clone: (recursive?: boolean | undefined) => OrthographicCamera;
            copy: (source: OrthographicCamera, recursive?: boolean | undefined) => OrthographicCamera;
            addEventListener: <T_6 extends string>(type: T_6, listener: import("three").EventListener<import("three").Event, T_6, OrthographicCamera>) => void;
            hasEventListener: <T_7 extends string>(type: T_7, listener: import("three").EventListener<import("three").Event, T_7, OrthographicCamera>) => boolean;
            removeEventListener: <T_8 extends string>(type: T_8, listener: import("three").EventListener<import("three").Event, T_8, OrthographicCamera>) => void;
            dispatchEvent: (event: import("three").Event) => void;
        } | {
            readonly isPerspectiveCamera: true;
            readonly type: string;
            zoom: number;
            fov: number;
            aspect: number;
            near: number;
            far: number;
            focus: number;
            view: {
                enabled: boolean;
                fullWidth: number;
                fullHeight: number;
                offsetX: number;
                offsetY: number;
                width: number;
                height: number;
            } | null;
            filmGauge: number;
            filmOffset: number;
            getFocalLength: () => number;
            setFocalLength: (focalLength: number) => void;
            getEffectiveFOV: () => number;
            getFilmWidth: () => number;
            getFilmHeight: () => number;
            setViewOffset: (fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number) => void;
            clearViewOffset: () => void;
            updateProjectionMatrix: () => void;
            setLens: (focalLength: number, frameHeight?: number | undefined) => void;
            readonly isCamera: true;
            layers: {
                mask: number;
                set: (layer: number) => void;
                enable: (layer: number) => void;
                enableAll: () => void;
                toggle: (layer: number) => void;
                disable: (layer: number) => void;
                disableAll: () => void;
                test: (layers: import("three").Layers) => boolean;
                isEnabled: (layer: number) => boolean;
            };
            matrixWorldInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            projectionMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            projectionMatrixInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            coordinateSystem: import("three").CoordinateSystem;
            getWorldDirection: (target: Vector3) => Vector3;
            readonly isObject3D: true;
            readonly id: number;
            uuid: string;
            name: string;
            parent: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import("three").EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    clone: () => import("three").Euler;
                    copy: (euler: import("three").Euler) => import("three").Euler;
                    setFromRotationMatrix: (m: Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromQuaternion: (q: Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromVector3: (v: Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
                    equals: (euler: import("three").Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import("three").Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => Quaternion;
                    clone: () => Quaternion;
                    copy: (q: Quaternion) => Quaternion;
                    setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => Quaternion;
                    setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
                    setFromRotationMatrix: (m: Matrix4) => Quaternion;
                    setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
                    angleTo: (q: Quaternion) => number;
                    rotateTowards: (q: Quaternion, step: number) => Quaternion;
                    identity: () => Quaternion;
                    invert: () => Quaternion;
                    conjugate: () => Quaternion;
                    dot: (v: Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => Quaternion;
                    multiply: (q: Quaternion) => Quaternion;
                    premultiply: (q: Quaternion) => Quaternion;
                    multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                    slerp: (qb: Quaternion, t: number) => Quaternion;
                    slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                    equals: (v: Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Quaternion;
                    _onChange: (callback: () => void) => Quaternion;
                    _onChangeCallback: () => void;
                    multiplyVector3: (v: any) => any;
                    random: () => Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                    identity: () => import("three").Matrix3;
                    clone: () => import("three").Matrix3;
                    copy: (m: import("three").Matrix3) => import("three").Matrix3;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import("three").Matrix3;
                    setFromMatrix4: (m: Matrix4) => import("three").Matrix3;
                    multiplyScalar: (s: number) => import("three").Matrix3;
                    determinant: () => number;
                    invert: () => import("three").Matrix3;
                    transpose: () => import("three").Matrix3;
                    getNormalMatrix: (matrix4: Matrix4) => import("three").Matrix3;
                    transposeIntoArray: (r: number[]) => import("three").Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                    scale: (sx: number, sy: number) => import("three").Matrix3;
                    makeTranslation: {
                        (v: Vector2): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import("three").Matrix3;
                        (theta: number): import("three").Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    rotate: (theta: number) => import("three").Matrix3;
                    translate: (tx: number, ty: number) => import("three").Matrix3;
                    equals: (matrix: import("three").Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                    multiplyVector3: (vector: Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                        (matrix: import("three").Matrix): import("three").Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import("three").Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import("three").InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
                        setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
                        getInterpolation: () => import("three").InterpolationModes;
                        createInterpolant: () => import("three").Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import("three").KeyframeTrack;
                        scale: (timeScale: number) => import("three").KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import("three").KeyframeTrack;
                        clone: () => import("three").KeyframeTrack;
                    }[];
                    blendMode: import("three").AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import("three").AnimationClip;
                    trim: () => import("three").AnimationClip;
                    validate: () => boolean;
                    optimize: () => import("three").AnimationClip;
                    clone: () => import("three").AnimationClip;
                    toJSON: (clip: import("three").AnimationClip) => any;
                }[];
                userData: {
                    [key: string]: any;
                };
                customDepthMaterial?: {
                    alphaHash: boolean;
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: 210 | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                } | undefined;
                customDistanceMaterial?: {
                    alphaHash: boolean;
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: 210 | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                } | undefined;
                onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
                onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
                applyMatrix4: (matrix: Matrix4) => void;
                applyQuaternion: (quaternion: Quaternion) => Object3D<import("three").Event>;
                setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import("three").Euler) => void;
                setRotationFromMatrix: (m: Matrix4) => void;
                setRotationFromQuaternion: (q: Quaternion) => void;
                rotateOnAxis: (axis: Vector3, angle: number) => Object3D<import("three").Event>;
                rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<import("three").Event>;
                rotateX: (angle: number) => Object3D<import("three").Event>;
                rotateY: (angle: number) => Object3D<import("three").Event>;
                rotateZ: (angle: number) => Object3D<import("three").Event>;
                translateOnAxis: (axis: Vector3, distance: number) => Object3D<import("three").Event>;
                translateX: (distance: number) => Object3D<import("three").Event>;
                translateY: (distance: number) => Object3D<import("three").Event>;
                translateZ: (distance: number) => Object3D<import("three").Event>;
                localToWorld: (vector: Vector3) => Vector3;
                worldToLocal: (vector: Vector3) => Vector3;
                lookAt: {
                    (vector: Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: Object3D<import("three").Event>[]) => Object3D<import("three").Event>;
                remove: (...object: Object3D<import("three").Event>[]) => Object3D<import("three").Event>;
                removeFromParent: () => Object3D<import("three").Event>;
                clear: () => Object3D<import("three").Event>;
                attach: (object: Object3D<import("three").Event>) => Object3D<import("three").Event>;
                getObjectById: (id: number) => Object3D<import("three").Event> | undefined;
                getObjectByName: (name: string) => Object3D<import("three").Event> | undefined;
                getObjectByProperty: (name: string, value: any) => Object3D<import("three").Event> | undefined;
                getObjectsByProperty: (name: string, value: any) => Object3D<import("three").Event>[];
                getWorldPosition: (target: Vector3) => Vector3;
                getWorldQuaternion: (target: Quaternion) => Quaternion;
                getWorldScale: (target: Vector3) => Vector3;
                getWorldDirection: (target: Vector3) => Vector3;
                raycast: (raycaster: Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]) => void;
                traverse: (callback: (object: Object3D<import("three").Event>) => any) => void;
                traverseVisible: (callback: (object: Object3D<import("three").Event>) => any) => void;
                traverseAncestors: (callback: (object: Object3D<import("three").Event>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => Object3D<import("three").Event>;
                copy: (source: Object3D<import("three").Event>, recursive?: boolean | undefined) => Object3D<import("three").Event>;
                addEventListener: <T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, Object3D<import("three").Event>>) => void;
                hasEventListener: <T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, Object3D<import("three").Event>>) => boolean;
                removeEventListener: <T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, Object3D<import("three").Event>>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            } | null;
            children: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import("three").EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    clone: () => import("three").Euler;
                    copy: (euler: import("three").Euler) => import("three").Euler;
                    setFromRotationMatrix: (m: Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromQuaternion: (q: Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromVector3: (v: Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
                    equals: (euler: import("three").Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import("three").Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => Quaternion;
                    clone: () => Quaternion;
                    copy: (q: Quaternion) => Quaternion;
                    setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => Quaternion;
                    setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
                    setFromRotationMatrix: (m: Matrix4) => Quaternion;
                    setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
                    angleTo: (q: Quaternion) => number;
                    rotateTowards: (q: Quaternion, step: number) => Quaternion;
                    identity: () => Quaternion;
                    invert: () => Quaternion;
                    conjugate: () => Quaternion;
                    dot: (v: Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => Quaternion;
                    multiply: (q: Quaternion) => Quaternion;
                    premultiply: (q: Quaternion) => Quaternion;
                    multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                    slerp: (qb: Quaternion, t: number) => Quaternion;
                    slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                    equals: (v: Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Quaternion;
                    _onChange: (callback: () => void) => Quaternion;
                    _onChangeCallback: () => void;
                    multiplyVector3: (v: any) => any;
                    random: () => Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    setFromColor: (color: import("three").Color) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: Vector3) => Vector3;
                    add: (v: Vector3) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    addVectors: (a: Vector3, b: Vector3) => Vector3;
                    sub: (a: Vector3) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: Vector3, b: Vector3) => Vector3;
                    multiply: (v: Vector3) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                    applyEuler: (euler: import("three").Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: Quaternion) => Vector3;
                    project: (camera: import("three").Camera) => Vector3;
                    unproject: (camera: import("three").Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: Vector3) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: Vector3) => Vector3;
                    max: (v: Vector3) => Vector3;
                    clamp: (min: Vector3, max: Vector3) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: Vector3) => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: Vector3, alpha: number) => Vector3;
                    lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                    cross: (a: Vector3) => Vector3;
                    crossVectors: (a: Vector3, b: Vector3) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: Vector3) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: Vector3) => number;
                    distanceToSquared: (v: Vector3) => number;
                    distanceToManhattan: (v: Vector3) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import("three").Euler) => Vector3;
                    equals: (v: Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                    identity: () => import("three").Matrix3;
                    clone: () => import("three").Matrix3;
                    copy: (m: import("three").Matrix3) => import("three").Matrix3;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import("three").Matrix3;
                    setFromMatrix4: (m: Matrix4) => import("three").Matrix3;
                    multiplyScalar: (s: number) => import("three").Matrix3;
                    determinant: () => number;
                    invert: () => import("three").Matrix3;
                    transpose: () => import("three").Matrix3;
                    getNormalMatrix: (matrix4: Matrix4) => import("three").Matrix3;
                    transposeIntoArray: (r: number[]) => import("three").Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                    scale: (sx: number, sy: number) => import("three").Matrix3;
                    makeTranslation: {
                        (v: Vector2): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import("three").Matrix3;
                        (theta: number): import("three").Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    rotate: (theta: number) => import("three").Matrix3;
                    translate: (tx: number, ty: number) => import("three").Matrix3;
                    equals: (matrix: import("three").Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                    multiplyVector3: (vector: Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                        (matrix: import("three").Matrix): import("three").Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import("three").Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import("three").InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
                        setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
                        getInterpolation: () => import("three").InterpolationModes;
                        createInterpolant: () => import("three").Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import("three").KeyframeTrack;
                        scale: (timeScale: number) => import("three").KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import("three").KeyframeTrack;
                        clone: () => import("three").KeyframeTrack;
                    }[];
                    blendMode: import("three").AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import("three").AnimationClip;
                    trim: () => import("three").AnimationClip;
                    validate: () => boolean;
                    optimize: () => import("three").AnimationClip;
                    clone: () => import("three").AnimationClip;
                    toJSON: (clip: import("three").AnimationClip) => any;
                }[];
                userData: {
                    [key: string]: any;
                };
                customDepthMaterial?: {
                    alphaHash: boolean;
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: 210 | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                } | undefined;
                customDistanceMaterial?: {
                    alphaHash: boolean;
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: 210 | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                } | undefined;
                onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
                onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
                applyMatrix4: (matrix: Matrix4) => void;
                applyQuaternion: (quaternion: Quaternion) => Object3D<import("three").Event>;
                setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import("three").Euler) => void;
                setRotationFromMatrix: (m: Matrix4) => void;
                setRotationFromQuaternion: (q: Quaternion) => void;
                rotateOnAxis: (axis: Vector3, angle: number) => Object3D<import("three").Event>;
                rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<import("three").Event>;
                rotateX: (angle: number) => Object3D<import("three").Event>;
                rotateY: (angle: number) => Object3D<import("three").Event>;
                rotateZ: (angle: number) => Object3D<import("three").Event>;
                translateOnAxis: (axis: Vector3, distance: number) => Object3D<import("three").Event>;
                translateX: (distance: number) => Object3D<import("three").Event>;
                translateY: (distance: number) => Object3D<import("three").Event>;
                translateZ: (distance: number) => Object3D<import("three").Event>;
                localToWorld: (vector: Vector3) => Vector3;
                worldToLocal: (vector: Vector3) => Vector3;
                lookAt: {
                    (vector: Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: Object3D<import("three").Event>[]) => Object3D<import("three").Event>;
                remove: (...object: Object3D<import("three").Event>[]) => Object3D<import("three").Event>;
                removeFromParent: () => Object3D<import("three").Event>;
                clear: () => Object3D<import("three").Event>;
                attach: (object: Object3D<import("three").Event>) => Object3D<import("three").Event>;
                getObjectById: (id: number) => Object3D<import("three").Event> | undefined;
                getObjectByName: (name: string) => Object3D<import("three").Event> | undefined;
                getObjectByProperty: (name: string, value: any) => Object3D<import("three").Event> | undefined;
                getObjectsByProperty: (name: string, value: any) => Object3D<import("three").Event>[];
                getWorldPosition: (target: Vector3) => Vector3;
                getWorldQuaternion: (target: Quaternion) => Quaternion;
                getWorldScale: (target: Vector3) => Vector3;
                getWorldDirection: (target: Vector3) => Vector3;
                raycast: (raycaster: Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]) => void;
                traverse: (callback: (object: Object3D<import("three").Event>) => any) => void;
                traverseVisible: (callback: (object: Object3D<import("three").Event>) => any) => void;
                traverseAncestors: (callback: (object: Object3D<import("three").Event>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => Object3D<import("three").Event>;
                copy: (source: Object3D<import("three").Event>, recursive?: boolean | undefined) => Object3D<import("three").Event>;
                addEventListener: <T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, Object3D<import("three").Event>>) => void;
                hasEventListener: <T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, Object3D<import("three").Event>>) => boolean;
                removeEventListener: <T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, Object3D<import("three").Event>>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            }[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                setFromColor: (color: import("three").Color) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                setFromColor: (color: import("three").Color) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import("three").EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                clone: () => import("three").Euler;
                copy: (euler: import("three").Euler) => import("three").Euler;
                setFromRotationMatrix: (m: Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                setFromQuaternion: (q: Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                setFromVector3: (v: Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
                equals: (euler: import("three").Euler) => boolean;
                fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                _onChange: (callback: () => void) => import("three").Euler;
                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => Quaternion;
                clone: () => Quaternion;
                copy: (q: Quaternion) => Quaternion;
                setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => Quaternion;
                setFromAxisAngle: (axis: Vector3, angle: number) => Quaternion;
                setFromRotationMatrix: (m: Matrix4) => Quaternion;
                setFromUnitVectors: (vFrom: Vector3, vTo: Vector3) => Quaternion;
                angleTo: (q: Quaternion) => number;
                rotateTowards: (q: Quaternion, step: number) => Quaternion;
                identity: () => Quaternion;
                invert: () => Quaternion;
                conjugate: () => Quaternion;
                dot: (v: Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => Quaternion;
                multiply: (q: Quaternion) => Quaternion;
                premultiply: (q: Quaternion) => Quaternion;
                multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                slerp: (qb: Quaternion, t: number) => Quaternion;
                slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                equals: (v: Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                toJSON: () => [number, number, number, number];
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Quaternion;
                _onChange: (callback: () => void) => Quaternion;
                _onChangeCallback: () => void;
                multiplyVector3: (v: any) => any;
                random: () => Quaternion;
                [Symbol.iterator]: () => Generator<number, void, unknown>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                setFromColor: (color: import("three").Color) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly modelViewMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            readonly normalMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                identity: () => import("three").Matrix3;
                clone: () => import("three").Matrix3;
                copy: (m: import("three").Matrix3) => import("three").Matrix3;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import("three").Matrix3;
                setFromMatrix4: (m: Matrix4) => import("three").Matrix3;
                multiplyScalar: (s: number) => import("three").Matrix3;
                determinant: () => number;
                invert: () => import("three").Matrix3;
                transpose: () => import("three").Matrix3;
                getNormalMatrix: (matrix4: Matrix4) => import("three").Matrix3;
                transposeIntoArray: (r: number[]) => import("three").Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                scale: (sx: number, sy: number) => import("three").Matrix3;
                makeTranslation: {
                    (v: Vector2): import("three").Matrix3;
                    (x: number, y: number): import("three").Matrix3;
                };
                makeRotation: {
                    (theta: number): import("three").Matrix3;
                    (theta: number): import("three").Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import("three").Matrix3;
                    (x: number, y: number): import("three").Matrix3;
                };
                rotate: (theta: number) => import("three").Matrix3;
                translate: (tx: number, ty: number) => import("three").Matrix3;
                equals: (matrix: import("three").Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                multiplyVector3: (vector: Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                    (matrix: import("three").Matrix): import("three").Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            matrixWorld: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: (v: number | Vector3, y?: number | undefined, z?: number | undefined) => Matrix4;
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import("three").CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import("three").InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
                    setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
                    getInterpolation: () => import("three").InterpolationModes;
                    createInterpolant: () => import("three").Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import("three").KeyframeTrack;
                    scale: (timeScale: number) => import("three").KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import("three").KeyframeTrack;
                    clone: () => import("three").KeyframeTrack;
                }[];
                blendMode: import("three").AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import("three").AnimationClip;
                trim: () => import("three").AnimationClip;
                validate: () => boolean;
                optimize: () => import("three").AnimationClip;
                clone: () => import("three").AnimationClip;
                toJSON: (clip: import("three").AnimationClip) => any;
            }[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial?: {
                alphaHash: boolean;
                alphaTest: number;
                alphaToCoverage: boolean;
                blendDst: import("three").BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import("three").BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import("three").Blending;
                blendSrc: 210 | import("three").BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: any;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import("three").DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import("three").StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import("three").StencilOp;
                stencilZFail: import("three").StencilOp;
                stencilZPass: import("three").StencilOp;
                readonly isMaterial: true;
                name: string;
                needsUpdate: boolean;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import("three").Side;
                shadowSide: import("three").Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: any;
                version: number;
                clone: () => import("three").Material;
                copy: (material: import("three").Material) => import("three").Material;
                dispose: () => void;
                onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import("three").MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            } | undefined;
            customDistanceMaterial?: {
                alphaHash: boolean;
                alphaTest: number;
                alphaToCoverage: boolean;
                blendDst: import("three").BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import("three").BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import("three").Blending;
                blendSrc: 210 | import("three").BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: any;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import("three").DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import("three").StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import("three").StencilOp;
                stencilZFail: import("three").StencilOp;
                stencilZPass: import("three").StencilOp;
                readonly isMaterial: true;
                name: string;
                needsUpdate: boolean;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import("three").Side;
                shadowSide: import("three").Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: any;
                version: number;
                clone: () => import("three").Material;
                copy: (material: import("three").Material) => import("three").Material;
                dispose: () => void;
                onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import("three").MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            } | undefined;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: import("three").Camera, geometry: import("three").BufferGeometry<import("three").NormalBufferAttributes>, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4: (matrix: Matrix4) => void;
            applyQuaternion: (quaternion: Quaternion) => PerspectiveCamera;
            setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import("three").Euler) => void;
            setRotationFromMatrix: (m: Matrix4) => void;
            setRotationFromQuaternion: (q: Quaternion) => void;
            rotateOnAxis: (axis: Vector3, angle: number) => PerspectiveCamera;
            rotateOnWorldAxis: (axis: Vector3, angle: number) => PerspectiveCamera;
            rotateX: (angle: number) => PerspectiveCamera;
            rotateY: (angle: number) => PerspectiveCamera;
            rotateZ: (angle: number) => PerspectiveCamera;
            translateOnAxis: (axis: Vector3, distance: number) => PerspectiveCamera;
            translateX: (distance: number) => PerspectiveCamera;
            translateY: (distance: number) => PerspectiveCamera;
            translateZ: (distance: number) => PerspectiveCamera;
            localToWorld: (vector: Vector3) => Vector3;
            worldToLocal: (vector: Vector3) => Vector3;
            lookAt: {
                (vector: Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: Object3D<import("three").Event>[]) => PerspectiveCamera;
            remove: (...object: Object3D<import("three").Event>[]) => PerspectiveCamera;
            removeFromParent: () => PerspectiveCamera;
            clear: () => PerspectiveCamera;
            attach: (object: Object3D<import("three").Event>) => PerspectiveCamera;
            getObjectById: (id: number) => Object3D<import("three").Event> | undefined;
            getObjectByName: (name: string) => Object3D<import("three").Event> | undefined;
            getObjectByProperty: (name: string, value: any) => Object3D<import("three").Event> | undefined;
            getObjectsByProperty: (name: string, value: any) => Object3D<import("three").Event>[];
            getWorldPosition: (target: Vector3) => Vector3;
            getWorldQuaternion: (target: Quaternion) => Quaternion;
            getWorldScale: (target: Vector3) => Vector3;
            raycast: (raycaster: Raycaster, intersects: import("three").Intersection<Object3D<import("three").Event>>[]) => void;
            traverse: (callback: (object: Object3D<import("three").Event>) => any) => void;
            traverseVisible: (callback: (object: Object3D<import("three").Event>) => any) => void;
            traverseAncestors: (callback: (object: Object3D<import("three").Event>) => any) => void;
            updateMatrix: () => void;
            updateMatrixWorld: (force?: boolean | undefined) => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            } | undefined) => any;
            clone: (recursive?: boolean | undefined) => PerspectiveCamera;
            copy: (source: PerspectiveCamera, recursive?: boolean | undefined) => PerspectiveCamera;
            addEventListener: <T_9 extends string>(type: T_9, listener: import("three").EventListener<import("three").Event, T_9, PerspectiveCamera>) => void;
            hasEventListener: <T_10 extends string>(type: T_10, listener: import("three").EventListener<import("three").Event, T_10, PerspectiveCamera>) => boolean;
            removeEventListener: <T_11 extends string>(type: T_11, listener: import("three").EventListener<import("three").Event, T_11, PerspectiveCamera>) => void;
            dispatchEvent: (event: import("three").Event) => void;
        };
        enabled: boolean;
        readonly active: boolean;
        readonly currentAction: number;
        distance: number;
        azimuthAngle: number;
        polarAngle: number;
        boundaryEnclosesCamera: boolean;
        interactiveArea: {
            height: number;
            width: number;
            x: number;
            y: number;
            readonly bottom: number;
            readonly left: number;
            readonly right: number;
            readonly top: number;
            toJSON: () => any;
        } | {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        addEventListener: <K extends keyof import("camera-controls/dist/types").CameraControlsEventMap>(type: K, listener: (event: import("camera-controls/dist/types").CameraControlsEventMap[K]) => any) => void;
        removeEventListener: <K_1 extends keyof import("camera-controls/dist/types").CameraControlsEventMap>(type: K_1, listener: (event: import("camera-controls/dist/types").CameraControlsEventMap[K_1]) => any) => void;
        rotate: (azimuthAngle: number, polarAngle: number, enableTransition?: boolean | undefined) => Promise<void>;
        rotateAzimuthTo: (azimuthAngle: number, enableTransition?: boolean | undefined) => Promise<void>;
        rotatePolarTo: (polarAngle: number, enableTransition?: boolean | undefined) => Promise<void>;
        rotateTo: (azimuthAngle: number, polarAngle: number, enableTransition?: boolean | undefined) => Promise<void>;
        dolly: (distance: number, enableTransition?: boolean | undefined) => Promise<void>;
        dollyTo: (distance: number, enableTransition?: boolean | undefined) => Promise<void>;
        dollyInFixed: (distance: number, enableTransition?: boolean | undefined) => Promise<void>;
        zoom: (zoomStep: number, enableTransition?: boolean | undefined) => Promise<void>;
        zoomTo: (zoom: number, enableTransition?: boolean | undefined) => Promise<void>;
        pan: (x: number, y: number, enableTransition?: boolean | undefined) => Promise<void>;
        truck: (x: number, y: number, enableTransition?: boolean | undefined) => Promise<void>;
        forward: (distance: number, enableTransition?: boolean | undefined) => Promise<void>;
        elevate: (height: number, enableTransition?: boolean | undefined) => Promise<void>;
        moveTo: (x: number, y: number, z: number, enableTransition?: boolean | undefined) => Promise<void>;
        lookInDirectionOf: (x: number, y: number, z: number, enableTransition?: boolean | undefined) => Promise<void>;
        fitToBox: (box3OrObject: Object3D<import("three").Event> | Box3, enableTransition: boolean, { cover, paddingLeft, paddingRight, paddingBottom, paddingTop }?: Partial<import("camera-controls/dist/types").FitToOptions> | undefined) => Promise<void[]>;
        fitToSphere: (sphereOrMesh: Object3D<import("three").Event> | Sphere, enableTransition: boolean) => Promise<void[]>;
        setLookAt: (positionX: number, positionY: number, positionZ: number, targetX: number, targetY: number, targetZ: number, enableTransition?: boolean | undefined) => Promise<void>;
        lerpLookAt: (positionAX: number, positionAY: number, positionAZ: number, targetAX: number, targetAY: number, targetAZ: number, positionBX: number, positionBY: number, positionBZ: number, targetBX: number, targetBY: number, targetBZ: number, t: number, enableTransition?: boolean | undefined) => Promise<void>;
        setPosition: (positionX: number, positionY: number, positionZ: number, enableTransition?: boolean | undefined) => Promise<void>;
        setTarget: (targetX: number, targetY: number, targetZ: number, enableTransition?: boolean | undefined) => Promise<void>;
        setFocalOffset: (x: number, y: number, z: number, enableTransition?: boolean | undefined) => Promise<void>;
        setOrbitPoint: (targetX: number, targetY: number, targetZ: number) => void;
        setBoundary: (box3?: Box3 | undefined) => void;
        setViewport: (viewportOrX: number | Vector4 | null, y: number, width: number, height: number) => void;
        getDistanceToFitBox: (width: number, height: number, depth: number, cover?: boolean | undefined) => number;
        getDistanceToFitSphere: (radius: number) => number;
        getTarget: (out: Vector3, receiveEndValue?: boolean | undefined) => Vector3;
        getPosition: (out: Vector3, receiveEndValue?: boolean | undefined) => Vector3;
        getSpherical: (out: Spherical, receiveEndValue?: boolean | undefined) => Spherical;
        getFocalOffset: (out: Vector3, receiveEndValue?: boolean | undefined) => Vector3;
        normalizeRotations: () => void;
        reset: (enableTransition?: boolean | undefined) => Promise<void[]>;
        saveState: () => void;
        updateCameraUp: () => void;
        applyCameraUp: () => void;
        update: (delta: number) => boolean;
        toJSON: () => string;
        fromJSON: (json: string, enableTransition?: boolean | undefined) => void;
        connect: (domElement: HTMLElement) => void;
        disconnect: () => void;
        dispose: () => void;
        dampingFactor: number;
        draggingDampingFactor: number;
        hasEventListener: (type: string, listener: import("camera-controls/dist/EventDispatcher").Listener) => boolean;
        removeAllEventListeners: (type?: string | undefined) => void;
        dispatchEvent: (event: import("camera-controls/dist/EventDispatcher").DispatcherEvent) => void;
    } | null>;
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, ("start" | "change" | "end")[], "start" | "change" | "end", import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<import("vue").ExtractPropTypes<{
    camera: {
        type: import("vue").PropType<OrthographicCamera | PerspectiveCamera>;
    };
    makeDefault: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    domElement: {
        type: import("vue").PropType<HTMLElement>;
    };
    minPolarAngle: {
        type: import("vue").PropType<number>;
        default: number;
    };
    maxPolarAngle: {
        type: import("vue").PropType<number>;
        default: number;
    };
    minAzimuthAngle: {
        type: import("vue").PropType<number>;
        default: number;
    };
    maxAzimuthAngle: {
        type: import("vue").PropType<number>;
        default: number;
    };
    minDistance: {
        type: import("vue").PropType<number>;
        default: number;
    };
    maxDistance: {
        type: import("vue").PropType<number>;
        default: number;
    };
    infinityDolly: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    minZoom: {
        type: import("vue").PropType<number>;
        default: number;
    };
    maxZoom: {
        type: import("vue").PropType<number>;
        default: number;
    };
    smoothTime: {
        type: import("vue").PropType<number>;
        default: number;
    };
    draggingSmoothTime: {
        type: import("vue").PropType<number>;
        default: number;
    };
    maxSpeed: {
        type: import("vue").PropType<number>;
        default: number;
    };
    azimuthRotateSpeed: {
        type: import("vue").PropType<number>;
        default: number;
    };
    polarRotateSpeed: {
        type: import("vue").PropType<number>;
        default: number;
    };
    dollySpeed: {
        type: import("vue").PropType<number>;
        default: number;
    };
    dollyDragInverted: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    truckSpeed: {
        type: import("vue").PropType<number>;
        default: number;
    };
    dollyToCursor: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    dragToOffset: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    verticalDragToForward: {
        type: import("vue").PropType<boolean>;
        default: boolean;
    };
    boundaryFriction: {
        type: import("vue").PropType<number>;
        default: number;
    };
    restThreshold: {
        type: import("vue").PropType<number>;
        default: number;
    };
    colliderMeshes: {
        type: import("vue").PropType<Object3D<import("three").Event>[]>;
        default: () => never[];
    };
    mouseButtons: {
        type: import("vue").PropType<{
            left?: number | undefined;
            right?: number | undefined;
            wheel?: number | undefined;
            middle?: number | undefined;
        }>;
    };
    touches: {
        type: import("vue").PropType<{
            one?: number | undefined;
            two?: number | undefined;
            three?: number | undefined;
        }>;
    };
}>> & {
    onStart?: ((...args: any[]) => any) | undefined;
    onChange?: ((...args: any[]) => any) | undefined;
    onEnd?: ((...args: any[]) => any) | undefined;
}, {
    makeDefault: boolean;
    minPolarAngle: number;
    maxPolarAngle: number;
    minAzimuthAngle: number;
    maxAzimuthAngle: number;
    minDistance: number;
    maxDistance: number;
    infinityDolly: boolean;
    minZoom: number;
    maxZoom: number;
    smoothTime: number;
    draggingSmoothTime: number;
    maxSpeed: number;
    azimuthRotateSpeed: number;
    polarRotateSpeed: number;
    dollySpeed: number;
    dollyDragInverted: boolean;
    truckSpeed: number;
    dollyToCursor: boolean;
    dragToOffset: boolean;
    verticalDragToForward: boolean;
    boundaryFriction: number;
    restThreshold: number;
    colliderMeshes: Object3D<import("three").Event>[];
}, {}>;
export default _default;
